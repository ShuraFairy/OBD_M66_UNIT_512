/* 
 * File:   test_EP_C30.c
 * Author: Alexander Rykovskov
 *
 * Created on 14 декабря 2014 г., 20:08
 */

//#define SELFPROGR
//#define LIN_SLAVE
//#define LIN_MASTER

//# define K_LINE
//# define LIN //9
//# define WBUS

//# define MAZDA_LOCK

#define FCY 20000000UL
#include <xc.h>
#include "ecan1_config.h"
//#include "ecan1_drv.h"
#include "ecan2_config.h"
//#include "ecan2_drv.h"
#include "common.h"

//#include <p33EP256MU806.h>
/*old uC in Element.*/
//#define dsPIC33EP512GP806 
#define dsPIC33EP256MU806

#ifdef dsPIC33EP256MU806
#include <p33EP256MU806.h>
#endif
#ifdef dsPIC33EP512GP806
#include <p33EP512GP806.h>
#endif


#include <libpic30.h>
//#include "p33Exxxx.h"
//#include <stdio.h>
#include <stdlib.h>
#include <libq.h>
#include <math.h>
//#include <uart.h>
#include <string.h>
//#include "ecan.h"
//#include "ecan.h"
//#include "ECAN1Config.h"
//#include "ECAN1Drv.h"
//#include "ECAN2Config.h"
//#include "ECAN2Drv.h"
//# define WBUS
# if defined (WBUS)
#include "wbus.h"
# endif

#define FOR_TRUCK
#include "variables.h"
//#include "cancommon.h"

// CONFIG
//_FGS     (GWRP_OFF & GSS_ON & GSSK_ON);
//_FOSCSEL (FNOSC_FRC & IESO_OFF); //FNOSC_PRIPLL
//_FOSC	 (POSCMD_XT & OSCIOFNC_OFF & IOL1WAY_OFF & FCKSM_CSECMD); //POSCMD_HS
//_FWDT	 (WDTPOST_PS16384 & WDTPRE_PR32 & PLLKEN_ON & WINDIS_OFF & FWDTEN_OFF);
//_FPOR	 (FPWRT_PWR128 & BOREN_ON & ALTI2C1_OFF);
//_FICD	 (ICS_PGD1 & RSTPRI_AF & JTAGEN_OFF);
//_FAS	 (AWRP_OFF & APL_OFF & APLK_OFF);

#pragma config GWRP = OFF           // General Segment Write-Protect bit (General Segment may be written)
#pragma config GSS = ON            // General Segment Code-Protect bit (General Segment Code protect is disabled)
#pragma config GSSK = ON           // General Segment Key bits (General Segment Write Protection and Code Protection is Disabled)

// FOSCSEL
#pragma config FNOSC = FRC          // Initial Oscillator Source Selection Bits (Internal Fast RC (FRC))
#pragma config IESO = OFF           // Two-speed Oscillator Start-up Enable bit (Start up with user-selected oscillator source)

// FOSC
#pragma config POSCMD = XT          // Primary Oscillator Mode Select bits (XT Crystal Oscillator Mode)
#pragma config OSCIOFNC = OFF       // OSC2 Pin Function bit (OSC2 is clock output)
#pragma config IOL1WAY = OFF        // Peripheral pin select configuration (Allow multiple reconfigurations)
#pragma config FCKSM = CSECMD       // Clock Switching Mode bits (Clock switching is enabled,Fail-safe Clock Monitor is disabled)

// FWDT
#pragma config WDTPOST = PS16384    // Watchdog Timer Postscaler Bits (1:32,768)
#pragma config WDTPRE = PR32       // Watchdog Timer Prescaler bit (1:128)
#pragma config PLLKEN = ON          // PLL Lock Wait Enable bit (Clock switch to PLL source will wait until the PLL lock signal is valid.)
#pragma config WINDIS = OFF         // Watchdog Timer Window Enable bit (Watchdog Timer in Non-Window mode)
#pragma config FWDTEN = OFF         // Watchdog Time  r Enable bit (Watchdog timer enabled/disabled by user software)

// FPOR
#pragma config FPWRT = PWR128       // Power-on Reset Timer Value Select bits (128ms)
#pragma config BOREN = ON           // Brown-out Reset (BOR) Detection Enable bit (BOR is enabled)
#pragma config ALTI2C1 = OFF        // Alternate I2C pins for I2C1 (SDA1/SCK1 pins are selected as the I/O pins for I2C1)
//#pragma config ALTI2C2 = OFF        // Alternate I2C pins for I2C2 (SDA2/SCK2 pins are selected as the I/O pins for I2C2)

// FICD
#pragma config ICS = PGD1           // ICD Communication Channel Select bits (Communicate on PGEC1 and PGED1)
#pragma config RSTPRI = PF          // Reset Target Vector Select bit (Device will obtain reset instruction from Primary flash)
#pragma config JTAGEN = OFF         // JTAG Enable bit (JTAG is disabled)

// FAS
#pragma config AWRP = OFF           // Auxiliary Segment Write-protect bit (Auxiliary program memory is not write-protected)
#pragma config APL = OFF            // Auxiliary Segment Code-protect bit (Aux Flash Code protect is disabled)
#pragma config APLK = OFF           // Auxiliary Segment Key bits (Aux Flash Write Protection and Code Protection is Disabled)

unsigned int CRC16(void * buff, unsigned int byte_count);
char FM25_read_1 (unsigned int address);
int hex_2_bin (unsigned char nibble);
unsigned long unit_transp_generator (unsigned long temp);
unsigned int get_rund_puls_duration ( char *ptr );
unsigned int get_runp_puls_duration ( char *ptr );
char get_fw_nibble (char *ptr);
int generate_content_of_message ( unsigned char name, unsigned char type );
unsigned long long get_dataflags_by_name (unsigned char name);
int save_dataflags_by_name (unsigned char name, char *ptr );
int generate_content_of_ack_free_message ( unsigned char name, unsigned char type );
unsigned long get_sequence_number (void);
unsigned long long FM25_read_8 (unsigned int address);
int save_settings_by_name (unsigned char name, char *ptr );
long long convert_str_to_hex ( char *ptr, unsigned char len );
unsigned long FM25_read_4 (unsigned int address);
long FM25_read_4_signed (unsigned int address);
unsigned int convert_hex_to_hexstr ( char *ptr );
int check_sms_enable_by_name ( char name );
char Si4461_temperature_mesuare ( char sleep_on );
char Si4461_temperature_mesuare_during_sleep ( char sleep_on );
unsigned char get_bitmask_from_number ( unsigned char num );
unsigned char LIN_CRC_calc( unsigned char *array_crc, unsigned char length, unsigned char inv );
unsigned char read_inputs ( unsigned char input );
void load_content_event_by_sms ( char name, char *navi_ptr, char *destination_buf_ptr );
int save_lock_control_settings ( unsigned char *ptr, unsigned char command_type );
unsigned char get_input_status_MCP23S08 ( unsigned char input );
unsigned char get_number_of_input ( unsigned char function );
unsigned char read_MCP23S08 (unsigned char addr );
int generate_canbus_sleep_message ( unsigned char source );

/* МОДЕМЫ */
//# define UC15

//# define DIRECTTX

/* ВЫХОДЫ БЛОКА */
# define FISICAL_LOCK // 1
# define ONE_WIRE_FISICAL_LOCK // 2
# define WIRED_ENJINE_BLOKING // 3
# define ENJINE_STATUS_OUT // 4
# define DATALINK // 5
# define SOBR // 6
# define PANDORA // 7
# define FUNCONTRL // 8


/* АВТОМОБИЛИ */
//# define VESTA         //1
//# define FREELANDER2   //2
//# define INFINITY_FX35 //3
//# define INFINITY_FX37 //4
//# define MAZDA_CX5     //5
//# define X_RAY         //6
//# define LEXUS_CT200H
//# define AUDI_A6
//# define NISSAN
//# define HYUDAI_I40
//# define BMW_X3
//# define VOLVO_XC70D     //0x12
//# define LIFAN_280
//# define BMW_X6
//# define PORSHE_CAENE          //0x10 
//# define JAGUAR
//# define BMW_3_F30
//# define AUDI_A5        //0x14 
//# define KIA_RIO          //0x15        
//# define TOYOTA_HIGHLANDER_2014  //0x16
//# define HYUNDAI_SANTAFE_2014 // 0x17
//# define MERS_A_2016 // 0x18
//# define FORD_FOCUS3_TREND_SPORT // 0x19
//# define VW_JETTA_2017 // 0x1A
//# define HYUNDAI_SANTAFE_2012 // 0x1B
//# define HYUNDAI_GENESIS_COUPE_2012 // 0x1C
//# define PORSHE_PANAMERA_2010 // 0x1D
//# define LEXUS_LS600h // 0x1E
//# define TLC200_2012_2015 // 0x1F
//# define NISSAN_MICRA_2005 // 0x20
//# define NISSAN_QASHKAI_XTRAIL_2016 // 0x21
//# define TOYOTA_CAMRY_2016 // 0x22
//# define TOUAREG_2016_WEBASTO
//# define VW_Tiguan_2017 // 2C
//# define VOLVO_XC70D_WEBASTO
//# define VW_MMULTIVAN_T6_2017_WEBASTO
//# define VW_MMULTIVAN_T6_2017_OTOPITEL
//# define VOLVO_XC60_WEBASTO
/**/
//# define FUEL_RECALC
# define ODO_FIX
/**/
//# define K_LINE
# define LIN //9

# define RUN_O
#ifdef RUN_O
#define startstop_button_1() if (OUTFUNCbits.pin9 == 0x12) AUTO_START = 1; if (OUTFUNCbits.pin10 == 0x12) OUT2 = 1; if (OUTFUNCbits.pin15 == 0x12) L_OUT = 1; //
#define ignition_1()         if (OUTFUNCbits.pin9 == 0x10) AUTO_START = 1; if (OUTFUNCbits.pin10 == 0x10) OUT2 = 1; if (OUTFUNCbits.pin15 == 0x10) L_OUT = 1; //
#define brakepedal_1()       if (OUTFUNCbits.pin9 == 0x11) AUTO_START = 1; if (OUTFUNCbits.pin10 == 0x11) OUT2 = 1; if (OUTFUNCbits.pin15 == 0x11) L_OUT = 1; //
#define startstop_button_0() if (OUTFUNCbits.pin9 == 0x12) AUTO_START = 0; if (OUTFUNCbits.pin10 == 0x12) OUT2 = 0; if (OUTFUNCbits.pin15 == 0x12) L_OUT = 0; //
#define ignition_0()         if (OUTFUNCbits.pin9 == 0x10) AUTO_START = 0; if (OUTFUNCbits.pin10 == 0x10) OUT2 = 0; if (OUTFUNCbits.pin15 == 0x10) L_OUT = 0; //
#define brakepedal_0()       if (OUTFUNCbits.pin9 == 0x11) AUTO_START = 0; if (OUTFUNCbits.pin10 == 0x11) OUT2 = 0; if (OUTFUNCbits.pin15 == 0x11) L_OUT = 0; //
#endif

/*ТИП ПАМЯТИ*/
/*
 * функция save_page_to_flash (void) для SST26
 * Если  flash_ptr_W нечетное и second_page_flag == 0, то из цикла while (save_to_flash_ptr_R != save_to_flash_ptr_W)
 * не выйдет никогда. Такое может произойти если сбросится когда записалась только одна страница из пары.
 * 
 * Для решеания проверять при загрузке flash_ptr_W на четность - если нечетный, инкрементировать.
 */ 
# define SST26
//# define SST25
/**/
//# define MCP23S08
/**/
# define KL3333
/**/
//# define L76_L
/**/
//# define TEST
/**/
/**/
//# define PRODUCTION_MODE
/**/

# define GNSSLED_green  _LATB6
# define CS_FM25        _LATB1
# define PWRkey         _LATF3
# define MODEMVBATT_out _LATD9
# define MODEMSTATUS    _RG3
# define POWERSTATUS    _RG2
# define GSM_LED        _LATB7


# if defined (MCP23S08) 
    # define CS_23S08     _LATB0
    # define IO_INTERRUPT _RB11
    # define GPS_IO_RESET _LATB9
    # define LIN_KEY      _LATE7
# else
    # define AUTO_START  _LATB0
    # define INPUT1      _RB11
    # define GPS_RST     _TRISB9
    # define L_OUT       _LATE7
# endif

# define MODEM_SLEEP    _LATD10

# define CS_at45        _LATG9
# define CS_SPI1        _LATE0
# define CS_SI4461      _LATC13
# define SDN_SI4461     _LATD0

# define OUT2           _LATB10
# define CHARGE_ONOFF   _LATB8

# define BUZZ           _LATD8
# define BUTTON         _RG2
# define CAN1_STB       _LATB13
# define CAN2_STB       _LATB12


# define UART1_Rx_buf_SIZE 1024
//# define UART1_Tx_buf_SIZE 1030
# define WAITOFF 0
# define WAITON 1

# define FWEN 0
# define FWDIS 0x1C

# define GPS_ON 0
# define GPS_OFF 1
# define MODEM_ON 1
# define MODEM_OFF 2
# define MODEM_RESTART 0
# define MODEM_EMERG_RST 3

# define QIOPENIDLE        0
# define QIOPENSTART       1
# define QIOPENRUNNING     2
# define WAITINGCONNECT    3
# define CONNECTOK         4
# define ALREADYCONNECT    5
# define QIOPENERROR      -1
# define QIOPENTIMEOUT    -2
# define CONNECTFAIL      -3
# define CONNECTERROR     -4
# define CONNECTTIMEOUT   -5
# define CONNECTEXCEPTION -6


# define qiopenidle     0b0000000000000000
# define qiopenstart    0b0000000000000001 // start
# define qiopenok       0b0000000000000010 // qiopen_ok
# define qiopenerror    0b0000000000000100 // qiopen_error
# define qiopentimeout  0b0000000000001000 // qiopen_timeout
# define connectok      0b0000000000010010 // qiopen_ok && connect_ok
# define connectfail    0b0000000001000010 // qiopen_ok && connect_fail
# define connecterror   0b0000000010000010 //
# define alreadyconnect 0b0000000000100100 // already_connect && qiopen_error
# define waitingconnect 0b0000001000000010 // qiopen_ok && waiting_connection
# define connecttimeout 0b0000000100000010 // qiopen_ok && connect_timeout


# define qicloseidle     0x0000
# define qiclosestart    0x0001
# define qicloseok       0x0002
# define qicloseerror    0x0004
# define qiclosetimeout  0x0008
# define QICLOSEIDLE        0
# define QICLOSESTART       1
# define QICLOSERUNNING     2
# define QICLOSEOK          3
# define QICLOSEERROR      -1
# define QICLOSETIMEOUT    -2
# define QICLOSEEXCEPTION  -3

# define cmgsidle             0b0000000000000000
# define cmgsstart            0b0000000000000001 // start == 1
# define cmgsrunning          0b0000000000000010 // at_cmgs == 1
//# define cntrlzrunning        0b0000000000001100 // cntrlz == 1 и waiting_cmgs_result == 1
# define smssending           0b0000000000001100 // waiting_cmgs_result && cntrlz
# define smssentok            0b0000000000111100 // plus_cmgs && cmgs_ok && cntrlz && waiting_cmgs_result
# define cmserror             0b0000000001001100 // cms_error && cntrlz && waiting_cmgs_result
# define cmeerror             0b0000000010001100 // cme_error && cntrlz && waiting_cmgs_result
# define smssendtimeout       0b0000000100001100 // cmgs_result_timeout && cntrlz && waiting_cmgs_result
# define atcmgstimeout        0b0000001000000010 // at_cmgs_timeout
    
# define SMSSENDIDLE       0
# define CMGSWAITING       1
# define CMGSRUNNING       2
# define SMSSENDING        3    
# define SMSSENDSUCCESS    4
# define CMSERROR         -1
# define CMEERROR         -2
# define SMSSENDTIMEOUT   -3    
# define ATCMGSTIMEOUT    -4
# define SMSSENDEXCEPTION -5    


# define cmgridle        0b0000000000000000
# define cmgrwaiting     0b0000000000000001
# define cmgrrunning     0b0000000000000010
# define cmgrok          0b0000000000000110     
# define cmgrcmserror    0b0000000000001010
# define cmgrcmeerror    0b0000000000010010
# define cmgrtimeout     0b0000000000100010
    
# define CMGRIDLE        0
# define CMGRWAITING     1
# define CMGRRUNNING     2
# define CMGROK          3     
# define CMGRCMSERROR   -1
# define CMGRCMEERROR   -2
# define CMGRTIMEOUT    -3
# define CMGREXCEPTION  -4

# define SMSDELIDLE       0
# define SMSDELWAITING    1
# define SMSDELRUNNING    2
# define SMSDELOK         3
# define SMSDELERROR     -1
# define SMSDELCMSERROR  -2
# define SMSDELTIMEOUT   -3
# define SMSDELEXCEPTION -4

# define GPRSSENDIDLE       0
# define GPRSSENDWAITING    1
# define QISENDRUNNING      2
# define WAITINGSENDOK      3    
# define WAITINGACK         4
# define GPRSSENDSUCCESS    5
# define SENDERROR         -1     
# define SENDFAILE         -2
# define QISENDTIMEOUT     -3
# define GPRSACKTIMEOUT    -4 
# define GPRSSENDEXCEPTION -5 

# define C1 0x1010101;
# define TX_to_READY     0x30
# define TX_to_RX        0x80
# define TX_to_SPIACTIVE 0x20

# define SLEEP           0x01
# define SPI_ACTIVE      0x02
# define READY           0x03
# define TX_STATE        0x07
# define RX_STATE        0x08


#if defined(__dsPIC33E__)
__eds__ ECAN1MSGBUF ecan1msgBuf __attribute__((eds,space(dma),aligned(ECAN1_MSG_BUF_LENGTH*32)));
__eds__ ECAN2MSGBUF ecan2msgBuf __attribute__((eds,space(dma),aligned(ECAN2_MSG_BUF_LENGTH*32)));
#else
ECAN1MSGBUF ecan1msgBuf __attribute__((space(dma),aligned(ECAN1_MSG_BUF_LENGTH*32)));
ECAN2MSGBUF ecan2msgBuf __attribute__((space(dma),aligned(ECAN2_MSG_BUF_LENGTH*32)));
#endif
//#endif

//unsigned char can1_byte;

const unsigned char ok [3]     = "ok\0";
const unsigned char error [6]  = "error\0";

const unsigned char OK []     = "\r\nOK\r\n\0";
const unsigned char rnOK []     = "\r\n\r\nOK\r\n\0";
const unsigned char ERROR [] = "\r\nERROR\r\n\0";

/*########################## AT КОМАНДЫ #####################################*/

const unsigned char AT_QPOWD[12]       = "AT+QPOWD=1\r\0";
      unsigned char AT_CMGS[30]        = "AT+CMGS=\"+79032559788\"\r\0"; //5277
      unsigned char AT_CMGS_CMGF[]     = "AT+CMGF=1;+cscs=\"IRA\";+CMGS=\"+79032559788\"\r\0"; //5277
const unsigned char AT_CSDH[11]        = "AT+CSDH=1\r\0";
const unsigned char AT_CMGD[9]         = "AT+CMGD=\0";
const unsigned char AT_QMGDA_READ[]    = "AT+QMGDA=\"DEL READ\"\r\0";
const unsigned char AT_QMGDA_ALL[]     = "AT+QMGDA=\"DEL ALL\"\r\0";
const unsigned char AT_CMGR[12]        = "AT+CMGR=02\r\0";
const unsigned char AT_CMGR_CMGF[]     = "AT+CMGF=1;+cscs=\"IRA\";+CMGR=02\r\0";
const unsigned char AT_QMGDA_INBOX[20] = "AT+QMGDA=DEL INBOX\r\0";
const unsigned char SET_CREG[11]       = "AT+CREG=1\r\0";
const unsigned char GET_CREG[10]       = "AT+CREG?\r\0";
const unsigned char GET_CGREG[]        = "AT+CGREG?;+CREG?;+CSQ;\r\0"; //11
const unsigned char GET_IMSI[]         = "AT+CPIN?;+CIMI;\r\0"; //11
const unsigned char AT[4]              = "AT\r\0";

# if defined (UC15)
    unsigned char AT_QISEND_LEN[]  = "AT+QISEND=0,0000\r\0";
# else
      unsigned char AT_QISEND_LEN[16]  = "AT+QISEND=0000\r\0";
# endif
const unsigned char AT_QISEND[11]      = "AT+QISEND\r\0";
const unsigned char AT_QISHOWRA[15]    = "AT+QISHOWRA=1\r\0";
const unsigned char AT_QICLOSE[]       = "AT+QICLOSE\r\0";
const unsigned char AT_QIDEACT[12]     = "AT+QIDEACT\r\0";
const unsigned char ATW[6]             = "AT&W\r\0";
const unsigned char ATZ[6]             = "AT&Z\r\0";
const unsigned char AT_QISTAT[11]      = "AT+QISTAT\r\0";
const unsigned char ATI[5]             = "ATI\r\0";

const unsigned char CONF[5]         = "CONF\0";
const unsigned char PHONE[]         = "PHONET\0";
const unsigned char AT_QSCLK[11]    = "AT+QSCLK=1\0";
const unsigned char AT_CCLK[10]     = "\r\nAT+CCLK\0";

const unsigned char ENTER[3]        = "\r\n\0";
const unsigned char RDY[8]          = "\r\nRDY\r\n\0"; // >=7
const unsigned char CFUN[10]        = "\r\n+CFUN: \0"; // >=
const unsigned char CPIN[10]        = "\r\n+CPIN: \0"; // >=

const unsigned char CALLREADY[15]   = "\r\nCall Ready\r\n\0"; // >=14
const unsigned char PBDONE[]   = "\r\n+QIND: PB DONE\r\n"; 

const unsigned char MODEM_OK[7]           = "\r\nOK\r\n\0"; // >=6
const unsigned char MODEM_ERROR[10]       = "\r\nERROR\r\n\0";
const unsigned char SEND_OK[12]           = "\r\nSEND OK\r\n\0";
const unsigned char SEND_FAIL[14]         = "\r\nSEND FAIL\r\n\0";
const unsigned char ACK[4]                = "ACK\0";
const unsigned char CLOSE_OK[13]          = "\r\nCLOSE OK\r\n\0";
const unsigned char DEACT_OK[13]          = "\r\nDEACT OK\r\n\0";
# if defined (UC15)
const unsigned char CONNECT_OK[]        = "\r\n+QIOPEN: ";
# else
const unsigned char CONNECT_OK[15]        = "\r\nCONNECT OK\r\n\0";
# endif

const unsigned char CONNECT_FAIL[17]      = "\r\nCONNECT FAIL\r\n\0";
const unsigned char ALREADY_CONNECT[]     = "\r\nALREADY CONNECT\r\n\0"; // 20
const unsigned char CLOSED[11]            = "\r\nCLOSED\r\n\0";
const unsigned char NORMAL_POWER_DOWN[23] = "\r\nNORMAL POWER DOWN \r\n\0";
const unsigned char RING[]               = "RING\r\n\0";
const unsigned char CMTI_SM[15]           = "\r\n+CMTI: \"SM\",\0";
const unsigned char CMTI_ME[15]           = "\r\n+CMTI: \"ME\",\0";
const unsigned char RECV_FROM[13]         = "\r\nRECV FROM:\0";
const unsigned char CNTRLZ[5]             = "\r\n> \0";
const unsigned char OK_STATE[]            = "\r\nOK\r\n\r\nSTATE\r\n\0";

const unsigned char PDP_DEACT[15]         = "\r\n+PDP DEACT\r\n\0";
const unsigned char NO_CARRIER[15]        = "\r\nNO CARRIER\r\n\0";
const unsigned char CMGS[]                = "\r\n+CMGS: \0";
const unsigned char CMGR[10]              = "\r\n+CMGR: \0";
const unsigned char CMS_ERROR[13]         = "\r\n+CMS ERROR\0";
const unsigned char CME_ERROR[13]         = "\r\n+CME ERROR\0";
const unsigned char CREG[9]               = "\r\n+CREG:\0";
const unsigned char CGREG[10]             = "\r\n+CGREG:\0";
const unsigned char CCLK[10]              = "\r\n+CCLK: \0";
const unsigned char CSQ[8]                = "\r\n+CSQ:\0";

const unsigned char AT_QIFGCNT[14]        = "AT+QIFGCNT=0\r\0";

// Команды и запросы
const unsigned char SET_GET_PARAMETER[]   = "at$";
const unsigned char APN_PARAM[]           = "apn";
const unsigned char SERVER_PARAM[]        = "server";
const unsigned char SMS_SEND[]            = "smssnd=";
const unsigned char GPRS_SEND[]            = "gsnd;";
const unsigned char AT_TO_MODEM[]         = "at>";
const unsigned char AT_NAVI[]             = "navi";
const unsigned char IGNTT[]               = "igntt";
const unsigned char IGNFT[]               = "ignft";
const unsigned char IGNVT[]               = "ignvt";
const unsigned char ACEL[]                = "acel";
const unsigned char DCEL[]                = "dcel";
const unsigned char LALL[]                = "lall";
const unsigned char SMSEN[]               = "smsen";
const unsigned char CALRST[]              = "calrst";
const unsigned char RUN[]                 = "run=";
const unsigned char RUNS[]                = "runs=";
const unsigned char RUND[]                = "rund=";
const unsigned char RUNP[]                = "runp";
#ifdef RUN_O
const unsigned char RUNO[]                = "runo";
const unsigned char ROST[]                = "rost";
#endif
const unsigned char SRV[]                 = "srv";
const unsigned char DLU[]                 = "dlu";
const unsigned char DLLU[]                = "dllu";
const unsigned char BTLU[]                = "btlu";
const unsigned char CDAT[]                = "cdat";
const unsigned char CSET[]                = "cset";
const unsigned char UNRST[]               = "unrst;";
const unsigned char QGSN[]                = "+QGSN";
const unsigned char DRST[]                = "drst;";
const unsigned char DVRQ[]                = "dvrq;";
#if defined (WBUS)
const unsigned char DRSTW[]                = "drstw;"; //clear webasto errors through WBUS
const unsigned char DVRQW[]                = "dvrqw;"; //request webasto errors through WBUS
#endif
const unsigned char FW[]                  = "fw=";
const unsigned char FWRS[]                = "fwrs=";
const unsigned char FWRNW[]               = "fwrnw";
const unsigned char RSET[]                = "rset=";
const unsigned char RBLK[]                = "rblk=";
const unsigned char OBLK[]                = "oblk=";
const unsigned char RLRN[]                = "rlrn;";
const unsigned char TLRN[]                = "tlrn;";
const unsigned char TDEL[]                = "tdel=";
const unsigned char TDIS[]                = "tdis=";
const unsigned char HFEN[]                = "hfen=";
const unsigned char REN[]                 = "ren=";
const unsigned char ARMEN[]               = "armen";
const unsigned char ALCEN[]               = "alcen";
const unsigned char MDAT[]                = "mdat";
const unsigned char MSET[]                = "mset";
const unsigned char SMSG[]                = "smsg";
const unsigned char CRSH[]                = "crsh;";
const unsigned char WBST[]                = "wbst";
const unsigned char WBSW[]                = "wbsw";
const unsigned char PHNS[]                = "phns";
const unsigned char TMSG[]                = "tmsg";
const unsigned char SMSD[]                = "smsd;";
const unsigned char SSQN[]                = "ssqn;";
const unsigned char DDIS[]                = "ddis";
const unsigned char CRQSET[]              = "crqset";
const unsigned char CRQDAT[]              = "crqdat";
const unsigned char GODO[]                = "godo";
const unsigned char INSET[]               = "inset";
const unsigned char IVFL[]                = "ivfl";
const unsigned char USLP[]                = "uslp;";
const unsigned char PSLP[]                = "pslp=";
const unsigned char SETSLP[]              = "setslp";
const unsigned char CCFG[]                = "ccfg";
const unsigned char CRTYP[]               = "crtyp";
const unsigned char LSET[]                = "lset";
const unsigned char FEQ[]                 = "feq";
const unsigned char WBSF[]                = "wbsf";
const unsigned char LLDAT[]               = "lldat";
const unsigned char LBDAT[]               = "lbdat";
const unsigned char OFUN[]                = "ofun";
const unsigned char WSET[]                = "wset";
const unsigned char LBEN[]                = "lben";
const unsigned char LBLRN[]               = "lblrn";
const unsigned char LNDAT[]               = "lndat";
const unsigned char MRLEN[]               = "mrlen";
const unsigned char LSNF[]                = "lsnf";
const unsigned char LSNFB[]               = "lsnfb";
const unsigned char TSET[]                = "tset";
const unsigned char BCHRG[]               = "bchrg";
const unsigned char RPTR[]                = "rptr";
const unsigned char LMDS[]                = "lmds";
const unsigned char RRFEN[]               = "rrfen";
const unsigned char MMSG[]                = "mmsg";
const unsigned char FLEN[]                = "flen";
const unsigned char SEVT[]                = "sevt";
const unsigned char WBSA[]                = "wbsa";
const unsigned char INPOL[]               = "inpol";
const unsigned char OPOL[]                = "opol";
const unsigned char IMSI[]                = "imsi";
const unsigned char ASOP[]                = "asop";
const unsigned char CLBR[]                = "clbr";
const unsigned char TLTMR[]               = "tltmr";
const unsigned char DSET[]                = "dset";
const unsigned char IFUN[]                = "ifun";
const unsigned char DFLT[]                = "dflt;";
const unsigned char DSIG[]                = "dsig";
//const unsigned char WBSW[]                = "wbsw";
const unsigned char OPLS[]                = "opls";
const unsigned char IORST[]               = "iorst";
const unsigned char FRTR[]                = "frtr;";
const unsigned char TLST[]                = "tlst;";
const unsigned char TEN[]                 = "ten";
const unsigned char ORQEN[]               = "orqen";
const unsigned char CCOF[]                = "ccof";
const unsigned char CFRQ[]                = "cfrq";
const unsigned char DULU[]                = "dulu";
const unsigned char SRVR[]                = "srvr";
const unsigned char TLTR[]                = "tltr;";
const unsigned char SLPT[]                = "slpt";
const unsigned char RUNC[]                = "runc";
const unsigned char SSET[]                = "sset";
const unsigned char WSSWT[]               = "wsswt";
const unsigned char DDUN[]                = "ddun";
const unsigned char SAEN[]                = "saen";
const unsigned char CSNF[]                = "csnf";
const unsigned char RPRD[]                = "rprd;";
const unsigned char SPRD[]                = "sprd;";
const unsigned char FDOTP[]               = "fdotp";
# if defined (DIRECTTX)
const unsigned char DTRNS[]               = "dtrns";
# endif
unsigned char fw_req_buf[20]              = "at$fwrq=00000,00000\0";

//unsigned char APN[30];
unsigned char PROTOCOL[3];
unsigned char PORT[3];
//unsigned char PHONE_NUMBER[16]            = "\"+79032559788\"\0";//+79165076059 +79032559788
//unsigned char TEST_TEXT[]                 = "test04062015\0";
/**/ 

unsigned char IMEI_str [16]                 = "865733020391181";
unsigned char TYPE0 [11]                   = { 0x26, 0x86, 0x57, 0x33, 0x02, 0x03, 0x91, 0x18, 0x10, 0x00, 0x00 };
//unsigned char IMEI_str []                 = "865733024040149";
//unsigned char TYPE0 [9]                   = { 0x26, 0x86, 0x57, 0x33, 0x02, 0x40, 0x40, 0x14, 0x90 };
//unsigned char IMEI_str []                 = "865733022130140";
//unsigned char TYPE0 [9]                   = { 0x26, 0x86, 0x57, 0x33, 0x02, 0x21, 0x30, 0x14, 0x00 };

//unsigned char IMEI_str []                 = "865733022131536";
//unsigned char TYPE0 [9]                   = { 0x26, 0x86, 0x57, 0x33, 0x02, 0x21, 0x31, 0x53, 0x60 };

//unsigned char IMEI_str []                 = "865733022131551";
//unsigned char TYPE0 [9]                   = { 0x26, 0x86, 0x57, 0x33, 0x02, 0x21, 0x31, 0x55, 0x10 };

//unsigned char IMEI_str []                 = "359231030091720";
//unsigned char TYPE0 [9]                   = { 0x26, 0x35, 0x92, 0x31, 0x03, 0x00, 0x91, 0x72, 0x00 };

//unsigned char IMEI_str []                 = "865733020391496";
//unsigned char TYPE0 [9]                   = { 0x26, 0x86, 0x57, 0x33, 0x02, 0x03, 0x91, 0x49, 0x60 };
/**/

// Обычная SIM
//unsigned char AT_CNT_SGP[70]      = "AT+QIFGCNT=0;+QICSGP=1,\"internet.beeline.ru\",\"beeline\",\"beeline\"\r\0";
//Megafon
//unsigned char AT_CNT_SGP[78]      = "AT+QIFGCNT=0;+QICSGP=1,\"internet\",\"gdata\",\"gdata\"\r\0";

# if defined (UC15)
    unsigned char AT_CNT_SGP[78]      = "AT+QICSGP=1,1,\"m2m.msk\",\"mts\",\"mts\",0\r\0";
# else
    unsigned char AT_CNT_SGP[78]      = "AT+QIFGCNT=0;+QICSGP=1,\"m2m.msk\",\"mts\",\"mts\"\r\0";
# endif

/**/
// M2M SIM
//const unsigned char AT_QICSGP[55]      = "AT+QICSGP=1,\"m2m.beeline.ru\",\"beeline\",\"beeline\"\r\0";
//unsigned char AT_CNT_SGP[100]     = "AT+QIFGCNT=0;+QICSGP=1,\"m2m.beeline.ru\",\"beeline\",\"beeline\"\r\0"; //61
/* KPN SIM*/
//unsigned char AT_CNT_SGP[]     = "AT+QIFGCNT=0;+QICSGP=1,\"cc0498.m2m\"\r\0";

// Яндекс
//const unsigned char AT_QIOPEN[33] = "AT+QIOPEN=\"TCP\",\"77.88.21.3\",80\r\0";
// Мой комп TCP
//const unsigned char AT_QIOPEN[40] = "AT+QIOPEN=\"TCP\",\"95.143.222.142\",50000\r\0";
/* Мой комп UDP*/
//unsigned char AT_QIOPEN[60]       = "AT+QIDNSIP=0;+QIOPEN=\"UDP\",\"95.143.222.142\",50000\r\0";
/*Руслан UDP*/
//unsigned char AT_QIOPEN[60] = "AT+QIDNSIP=0;+QIOPEN=\"UDP\",\"176.9.61.196\",232\r\0";
//Пример строки
//&359231030091720|v3|210115|140001|5554.4023N|03732.9917E|3800.1|62.3|183.2|3|10000011||H
/* Рабочий комп UDP*/
//unsigned char AT_QIOPEN[60]       = "AT+QIDNSIP=0;+QIOPEN=\"UDP\",\"93.91.14.131\",5566\r\0";

/*############################################################################*/
/* Владов сервер UDP*/
//unsigned char AT_QIOPEN[60]       = "AT+QIDNSIP=0;+QIOPEN=\"UDP\",\"77.246.239.22\",8051\r\0";//"UDP","sdlcloud.cloudapp.net",8051
//unsigned char AT_QIOPEN[60]       = "AT+QIDNSIP=0;+QIOPEN=\"UDP\",\"95.143.118.74\",8051\r\0"; // тестовый
//unsigned char AT_QIOPEN[60]       = "AT+QIDNSIP=1;+QIOPEN=\"UDP\",\"sdlcloud.cloudapp.net\",8051\r\0";
# if defined (UC15)    
    unsigned char AT_QIOPEN[70]       = "AT+QIACT=1;+QIOPEN=1,0,\"UDP\",\"52.232.38.248\",8051,0,1\r\0";//"AT+QIACT=1;+QIOPEN=1,0\"UDP\",\"receiver.smartdriving.io\",8051,0,0\r\0""AT+QIACT=1\r\0"
# else    //at>"AT+QIOPEN=1,1\"UDP\",\"receiver.smartdriving.io\",8051,0,0,0\r\0"
    unsigned char AT_QIOPEN[70]       = "AT+QIDNSIP=1;+QIOPEN=\"UDP\",\"receiver.smartdriving.io\",8051\r\0";
# endif

const unsigned char STARTING_WORK[] = "\r\nstarting work\0";

//const unsigned char Navi_str_last_known_const[] = "150013.0,110715,5543.15470,N,03727.35080,E,158.0M,000.0,000.0,V,N,1,N,00,00";

//int i, z;

volatile int rxmsg1;
volatile unsigned int CAN1AUX_R_ptr, CAN1AUX_W_ptr;
unsigned long ID;
volatile unsigned int CAN1_fault;
unsigned char __attribute__ ((far)) CAN1_DATA_buf [8];
unsigned char __attribute__ ((far)) CANOBD_DATA_buf1 [8];
unsigned char __attribute__ ((far)) CANOBD_DATA_buf2 [8];
unsigned char __attribute__ ((far)) CANOBD_DATA_buf3 [8];
volatile unsigned char __attribute__ ((far)) CAN1AUX_DATA_buf[25][8];
volatile unsigned long __attribute__ ((far)) CAN1AUX_ID_buf[25][1];
unsigned char BRPVAL1;
unsigned int bitrate1, Fp1;
union __attribute__ ((far))  {
    unsigned int CAN1SETTINGS;
   struct 
    {
		unsigned char on:1;
        unsigned char ide:1;
        unsigned int  bitrate:10;
        unsigned int :4;
    };
} CAN1SETTINGSbits;
union __attribute__ ((far))  {
    unsigned long CAN1CFG;
   struct 
    {
		unsigned char   sjw:2;
        unsigned char  seg1:3;
        unsigned char  seg2:3;
        unsigned char prseg:3;
        unsigned char   sam:1;
        unsigned char      :4;
        
		unsigned char   sjw_slp:2;
        unsigned char  seg1_slp:3;
        unsigned char  seg2_slp:3;
        unsigned char prseg_slp:3;
        unsigned char   sam_slp:1;
        unsigned char      :4;        
    };
} CAN1CFGbits;

volatile int rxmsg2;
volatile unsigned int CAN2AUX_R_ptr, CAN2AUX_W_ptr;
unsigned long ID2;
volatile unsigned int CAN2_fault;
unsigned int Fp2;
unsigned char __attribute__ ((far)) CAN2_DATA_buf [8];
volatile unsigned char __attribute__ ((far)) CAN2AUX_DATA_buf[25][8];
volatile unsigned long __attribute__ ((far)) CAN2AUX_ID_buf[25][1];
union __attribute__ ((far))  {
    unsigned int CAN2SETTINGS;
   struct 
    {
		unsigned char on:1;
        unsigned char ide:1;
        unsigned int  bitrate:10;
        unsigned int :4;
    };
} CAN2SETTINGSbits;
union __attribute__ ((far))  {
    unsigned long CAN2CFG;
   struct 
    {
		unsigned char   sjw:2;
        unsigned char  seg1:3;
        unsigned char  seg2:3;
        unsigned char prseg:3;
        unsigned char   sam:1;
        unsigned char      :4;
        
		unsigned char   sjw_slp:2;
        unsigned char  seg1_slp:3;
        unsigned char  seg2_slp:3;
        unsigned char prseg_slp:3;
        unsigned char   sam_slp:1;
        unsigned char          :4;        
    };
} CAN2CFGbits;

//##############################################################################

volatile unsigned char __attribute__ ((far)) UART1_Rx_buf[UART1_Rx_buf_SIZE];
volatile unsigned char __attribute__ ((far)) UART_Rx_copy_buf[UART1_Rx_buf_SIZE];
//unsigned char __attribute__ ((far)) UART_Rx_copy_buf_gnss[1024];
unsigned char __attribute__ ((far)) UART1_Tx_buf[528];//1024
unsigned char __attribute__ ((far)) UART2_buf[1024];
unsigned char __attribute__ ((far)) UART3_Rx_buf[100];
# if defined (K_LINE)
unsigned char __attribute__ ((far)) UART3_Rx_copy_buf[10][15];
# endif
# if defined (LIN)
unsigned char __attribute__ ((far)) LIN_Rx_copy_buf[40];
# endif
#if defined (WBUS)
unsigned char __attribute__ ((far)) WBUS_Rx_copy_buf[40];
#endif
//unsigned char __attribute__ ((far)) UART2_copy_buf[1025];
unsigned char __attribute__ ((far)) UART2_Tx_buf[80];
unsigned char __attribute__ ((far)) UART4_Rx_buf[100];
unsigned char __attribute__ ((far)) UART4_Tx_buf[528]; //1024
unsigned char __attribute__ ((far)) command_temp_buf[528];
//unsigned char __attribute__ ((far)) telit_buf[92];
unsigned char __attribute__ ((far)) flash_sector_buf[32]; //1024
unsigned char __attribute__ ((far)) fw_sector_buf[4096]; //4096
unsigned char __attribute__ ((far)) fw_page_buf[512]; //4096
//unsigned char __attribute__ ((far)) config_buf[1024];

unsigned char __attribute__ ((far)) save_to_flash_buf0 [130];
unsigned char __attribute__ ((far)) save_to_flash_buf1 [130];
unsigned char __attribute__ ((far)) save_to_flash_buf2 [130];
unsigned char __attribute__ ((far)) save_to_flash_buf3 [130];
unsigned int  __attribute__ ((far)) save_to_flash_ptrs_buf [4];
unsigned int  __attribute__ ((far)) ACK_ptrs_buf [5];
unsigned char __attribute__ ((far)) save_to_flash2_buf [4][130];

unsigned char __attribute__ ((far)) GPRS_to_send_buf0 [130]; //504
unsigned char __attribute__ ((far)) GPRS_to_send_buf1 [130];
unsigned char __attribute__ ((far)) GPRS_to_send_buf2 [130];
unsigned char __attribute__ ((far)) GPRS_to_send_buf3 [130];
unsigned char __attribute__ ((far)) GPRS_to_send_buf4 [130];
unsigned int  __attribute__ ((far)) GPRS_nums_to_send_buf [5];
         
unsigned char __attribute__ ((far)) SMS_to_send_buf0 [165];
unsigned char __attribute__ ((far)) SMS_to_send_buf1 [165];
unsigned char __attribute__ ((far)) SMS_to_send_buf2 [165];
unsigned char __attribute__ ((far)) SMS_to_send_buf3 [165];
unsigned char __attribute__ ((far)) SMS_to_send_buf4 [165];
unsigned int  __attribute__ ((far)) SMS_to_send_ptrs_buf [5];
unsigned int  __attribute__ ((far)) SMS_nums_to_read_buf [10];
unsigned char __attribute__ ((far)) SMS_temp_buf[250];
unsigned int  __attribute__ ((far)) SMS_parts_ptrs_buf[8];

unsigned char  __attribute__ ((far)) PHONES_buf[6][15];
unsigned char  __attribute__ ((far)) PHONE_to_send_buf[18];
unsigned char  __attribute__ ((far)) sms_temp_buf1[65];
unsigned char  __attribute__ ((far)) sms_temp_buf2[65];

//unsigned char  __attribute__ ((far)) temp_text_buf[504];
unsigned char  __attribute__ ((far)) bin_2_bcd_buf[9];
unsigned char  __attribute__ ((far)) GPRS_header_buf[12];

unsigned char __attribute__ ((far)) Navi_str [76];
unsigned char __attribute__ ((far)) Navi_str_last_known [76];
unsigned char __attribute__ ((far)) Navi_bin [76];

//int __attribute__ ((far)) gamma1_res [12];
//int __attribute__ ((far)) gamma2_res [12];
//int __attribute__ ((far)) gamma2_buf [90];
//int __attribute__ ((far)) gamma2_buf2 [180];
int __attribute__ ((far)) gamma2_buf10 [36];
int __attribute__ ((far)) gamma2_buf1 [360];
int __attribute__ ((far)) gamma2_buf_tmp [180];
//int __attribute__ ((far)) gamma2_buf_tmp4 [360];
int __attribute__ ((far)) gamma2_buf_tmp10 [180];
int __attribute__ ((far)) gamma2_diff [90];
unsigned char __attribute__ ((far)) UART3_Tx_buf[32];
int __attribute__ ((far)) Gxi_buf0_b [33];
int __attribute__ ((far)) Gxi_buf1_b [33];
int __attribute__ ((far)) Gyi_buf0_b [33];
int __attribute__ ((far)) Gyi_buf1_b [33];
int __attribute__ ((far)) Gzi_buf0_b [33];
int __attribute__ ((far)) Gzi_buf1_b [33];
char __attribute__ ((far)) Gxp_buf [120];
char __attribute__ ((far)) Gyp_buf [120];
int __attribute__ ((far)) Gxi_buf2 [17];
int __attribute__ ((far)) Gyi_buf2 [17];
int __attribute__ ((far)) Gzi_buf2 [17];

unsigned long __attribute__ ((far)) CRASH_ACC_buf [1][600];
unsigned char __attribute__ ((far)) CRASH_TREK_buf [20][22];

char __attribute__ ((far)) SST26_buf [256];
unsigned int __attribute__ ((far)) WBSTR_TIME_buf [8];
unsigned char __attribute__ ((far)) LOCK_BYTES_buf [8];
unsigned char __attribute__ ((far)) LOCK_BYTES_buf_tmp1[8], LOCK_BYTES_buf_tmp2[8];
unsigned char __attribute__ ((far)) IMSI_buf [16] = {0x30,030,030,030,030,030,030,030,030,030,030,030,030,030,030,0};
unsigned char __attribute__ ((far)) TOYOTAKEYbuf[3][8];
unsigned char __attribute__ ((far)) TOYOTAKEYTMPbuf[8];
//unsigned char __attribute__ ((far)) CAN1_DATA_buf_tmp [8];
//unsigned char __attribute__ ((far)) CAN2_DATA_buf_tmp [8];
//volatile unsigned long __attribute__ ((far)) CAN1AUX_ID_buf_tmp[25][1], CAN2AUX_ID_buf_tmp[25][1];
//unsigned char __attribute__ ((far)) CAN1_DATA_buf [8];

# define PHONENUMPTR SMS_parts_ptrs_buf[2]
# define SMSTEXTPTR  SMS_parts_ptrs_buf[6]

unsigned char TOYOTA_W_ptr, TOYOTA_R_ptr;
volatile unsigned int U1_num_W, U1_num_W_tmp, U1_num_R;
volatile unsigned int U3_num_W, U3_num_W_tmp, U3_Rx_copy_buf_W, U3_Rx_num_of_pages, U3_Rx_timeout;
volatile unsigned char uart1_timeout_counter, Start_accumulation1, Rx1_DataAvailable;
volatile unsigned char uart2_timeout_counter, uart2_busy_flag, Start_accumulation;
volatile unsigned char  uart3_busy_flag, Start_accumulation3, Rx3_DataAvailable;//uart3_timeout_counter,
volatile unsigned int uart3_timeout_counter;
volatile unsigned char Rx2_DataAvailable, Rx4_DataAvailable, Tx2_DataAvailable;
volatile unsigned char Tx4_DataAvailable, Tx1_DataAvailable;
volatile unsigned char periodic_flag;
volatile unsigned int num_of_bytes, num_of_bytes_tmp, num_of_bytes4, num_of_bytes_tmp4;
volatile unsigned int moden_off_puls_counter, modem_UART_check_counter;
volatile unsigned int modem_UART_check_flag, modem_UART_dead_flag;
volatile unsigned int modem_on_off_counter, modem_restart_counter;
volatile unsigned int modem_on_off_puls_duration, modem_busy_max_value;
volatile unsigned int modem_on_off_type, modem_on_off_finished_flag;
volatile unsigned int GSM_status_timer, sim_presence_timer, creg_check_timer;
volatile unsigned int gsm_creg_check_flag, gsm_task_busy_timer;
volatile unsigned int gprs_start_timer;
volatile unsigned int gsm_task_busy_max_value, modem_tasck_timeout_flag;
unsigned int ACK_timer, SMS_ACK_timer, SEND_OK_timer, server_connection_timer_tmp;
unsigned char SMS_ptr_R, SMS_ptr_W, SMS_read_ptr_R, SMS_read_ptr_W, GPRS_send_ptr_R, GPRS_send_ptr_W;
unsigned char save_to_flash_ptr_R, save_to_flash_ptr_W, save_to_flash2_ptr_R, save_to_flash2_ptr_W, ACK_ptr_R, ACK_ptr_W;
unsigned int flash_ptr_R, flash_ptr_W, flash2_ptr_R, flash2_ptr_W;
unsigned long number_of_event;
unsigned int SMS_sending_time;
unsigned int nav_trigger, ACK_number;
volatile unsigned int ignition, ignition_tmp, ignition_by_pulse, power, sleep_counter, periodic_10ms_flag, power_counter;
unsigned char idle;
char flash_1_byte;
int flash_2_bytes;
long flash_3_bytes, flash_4_bytes;
unsigned char max_speed, max_speed_to_send;
unsigned long GPS_odometer;

unsigned int ign_level_trh, ign_frq_trh, freq_average_to_send, sleep_timer;

volatile unsigned int UART1_Rx_data_len, U1_Tx_length;

//unsigned char Lat_str [9];
//unsigned char Long_str [10];
//unsigned char Alt_str [8];
unsigned char Time_str [7];
//unsigned char Date_str [7];
//unsigned char Speed_str [6];
//unsigned char Course_str [6];
//unsigned char GP_sat_number_str[3];
//unsigned char GL_sat_number_str[3];

//unsigned char lcd_buf [4];
unsigned char Navigation_sistem;
unsigned char Navigation_mode_ind;
unsigned char Mode_of_operation;
unsigned char Lat_hemisphere;
unsigned char Long_hemisphere;

float Speed;
float Lat1, Lat2, Long1, Long2, distance, fix_to_fix_mileage;
unsigned long time1, time2;
unsigned int course1, course2;
unsigned char speed1, speed2;

unsigned char navistrout_ON, navistrtype, gsmdebug_ON;

unsigned int  frequency, frequency_counter, frequency_ready;
unsigned char ign_on_time, ign_off_time;
unsigned int  ign_frq_trh_min, ign_frq_trh;
unsigned int  ign_volt_trh_min, ign_volt_trh; 

unsigned char swt;

char start_frq_calibr;

unsigned int number_of_acc_logs, number_of_pages, log_address, last_page_of_log;
unsigned int acc_log_counter, acc_page_flag, matrix_number;
long res4;
int Gx, Gy, Gz, gamma1, gamma2;
int Gx_400, Gy_400, Gz_400;
int Gx_test, Gy_test, Gz_test;
int  start, stop;
float fi1, fi2, fi, fi1deg, fi2deg, fideg, gamma, gammadeg;
float sina, sinb, cosa, cosb, alfa, beta, alfa_deg, beta_deg, sing, cosg, cosfi, sinfi;
int Gx, Gy, Gz, Gxyz, Gx0, Gy0, Gz0, Gx0filt, Gy0filt, Gz0filt, Gxyz0, Gxyz0_trh, Gxyz4_trh;
float m11, m12, m13, m21, m22, m23, m31, m32, m33, i1, i2, i3, i4, i5, j1, j2, j3, j4, j5, k1, k2, k3, eps;
float fi1, fi2, fi, fi1deg, fi2deg, fideg, gamma, gammadeg;
float m11t, m12t, m13t, m21t, m22t, m23t, m31t, m32t, m33t;
float mod_g, mod_g_xy, Gxy, Gxy_max;
float sina, sinb, cosa, cosb, alfa, beta, alfa_deg, beta_deg, sing, cosg, cosfi, sinfi;
float Gxf0, Gxf1, Gxf2, Gxf3, Gxf4, Gyf0, Gyf1, Gyf2, Gyf3, Gyf4, Gzf0, Gzf1, Gzf2, Gzf3, Gzf4, Gxout;
int Gxi, Gyi, Gzi, Gxyi, Gxyzi;
int Gxp, Gyp, Gxyp, gamma_p;
volatile int U3_Tx_length, Tx3_DataAvailable;
float Gxf0b, Gxf1b, Gyf0b, Gyf1b, Gzf0b, Gzf1b;
int Gxif0b, Gxif1b, Gyif0b, Gyif1b, Gzif0b, Gzif1b;
int Gxif2, Gyif2, Gzif2;
int max_of_gist, direction_counter;
unsigned char invertion_flag; 
unsigned char speed_from_memory, car_voltage, car_voltage_fall, battery_voltage; 
unsigned int fuel_level;
unsigned long calibration_duration;

unsigned char CRASH_TREK_W_ptr, acc_data_redy_flag;
unsigned int CRASH_ACC_W_ptr, CRASH_ACC_point_ptr, CRASH_TREK_point_ptr, crash_trigger;
unsigned int crash_to_send_ptr, save_crash_to_flash_ptr_W, curent_acc_ack = 20000, number_of_crash;

volatile unsigned int flash_write_end_flag, flash_write_monitor_flag, flash_data_length;
volatile unsigned long flash_data_start_addr;
volatile unsigned char *ptr_to_save;

unsigned long Unit_num, transp_flags_to_save;
unsigned long transp1_num, transp2_num, transp3_num, transp4_num, transp5_num, transp6_num;
unsigned long K0, K1, K2, K3, K4, K5, K6, K7;
volatile unsigned long N1, N2, tempNN2, N2_eeprom, tempN1, tempN2, N3, status_out, S, omega0, omega1, omega, omega_0, omega_1;
volatile unsigned long N1_freezed, N2_freezed;
unsigned int timer1_freezed, timer2_freezed, timer3_freezed;
unsigned long long N, NN, tempN;
volatile unsigned int nIRQ, receive_timeout, length, RF_DataAvailable, fire_relay_flag;
unsigned int SS, RF_WDT, GPRS_SEND_WDT;
volatile unsigned int rel_timeout_counter, rel_timeout_flag, rel_transaction_flag, fire_rel_transaction_flag, wired_block;
unsigned int periodic_relay_transaction_counter;
volatile unsigned int rf_reset_monitor_flag, rf_reset_counter;

unsigned char lock_status, lock_status_tmp, boot_lock_status, boot_lock_status_tmp, alarm2_status, alarm2_status_tmp, dtc_reset_start, dvrq_start, hands_free_enable, relay_enable, arm_enable;
unsigned char dtc_reset_K_fast_start;
unsigned char gearbox2_status, gearbox2_status_tmp;
unsigned char webasto_status, webasto_status_tmp, mil_status, mil_status_tmp;
unsigned char obd_fuel_level;
unsigned long FW_version, Num_of_strings, Num_of_pages;
unsigned int current_num_of_page, save_fw_to_flash_ptr_W, fwversion_message_flag, fw_dowloaded_flag, fw_request_flag, type0_send_flag;
unsigned int generate_panic_flag, serv_off_by_speed_flag;
unsigned int blink_arm_event_flag, blink_disarm_event_flag;

volatile unsigned int transp_presence_counter, power_presence_counter;
unsigned int gsm_data_link_wdt;
unsigned long first_IMEI_digits;
unsigned char kdtc_W_ptr, type_of_K_line, type_of_K_line_request;

unsigned char lock_close_autorun_enable, status_mesage_flag;

unsigned long GPS_odometer_to_send, sequence_number;
int ptr_to_data_portion, phone_num_check_result;
unsigned char W_ptr;
unsigned char generate_crash_flag;
unsigned int dd_intrusion_off_timer, dd_intrusion_off_setting, start_engine_success_flag;
unsigned char ign_on_off_counter, crash_detection_type;
unsigned int RF_freezed_monitor_flag, RF_freezed_monitor_run_flag, F_freezed_monitor_run_counter;

unsigned int doors_status, doors_status_tmp, doors_counter = 0;
unsigned int boot_status, boot_status_tmp, fisical_boot_counter = 0;
unsigned int crash_trh_switch_timer = 0, xy_trh, xyz_trh, duration;
unsigned int navi_wait_timer, fisical_input_enable, fisical_ignition_counter;
int boot_lock_unlock_flag;
volatile unsigned int num_of_lin_transmittions, lin_transmitting_flag;
volatile unsigned int lin_sleep, lin_wake_transmitting, lin_sleep_counter;
unsigned char LIN_LOCK_CRC, LIN_UNLOCK_CRC, LIN_LOCK_LENGTH, LIN_UNLOCK_LENGTH, LIN_TRANSMITTION_LENGTH;
unsigned char LIN_LOCK_CRC2, LIN_UNLOCK_CRC2, LIN_LOCK_LENGTH2, LIN_UNLOCK_LENGTH2, LIN_TRANSMITTION_LENGTH2;
unsigned char LIN_BOOT_UNLOCK_CRC, LIN_BOOT_UNLOCK_LENGTH, LIN_BOOT_UNLOCK_TRANSMITTION_ATTEMPTS, LIN_BOOT_UNLOCK_ADDR, LIN_BOOT_TRANSMITTION_LENGTH;

unsigned char LIN_LOCK_ADDR, LIN_UNLOCK_ADDR, LIN_LOCK_TRANSMITTION_ATTEMPTS, LIN_UNLOCK_TRANSMITTION_ATTEMPTS;
unsigned char LIN_LOCK_ADDR2, LIN_UNLOCK_ADDR2, LIN_LOCK_TRANSMITTION_ATTEMPTS2, LIN_UNLOCK_TRANSMITTION_ATTEMPTS2;
unsigned int check_status_duration, lin_boot_unlock_start;
unsigned char lockbytes_enable, lockbytes_learned, delayed_beep_start, lockbytes_learn_param, sms_during_sleep_flag, mil_req_len;
volatile unsigned int LIN_switch_counter = 0, LIN_transmitting_flag = 0;
volatile int temperatura;
char temperaturaC, temperaturaC_in_sleep;
unsigned char lin_lock_flag_tmp = 0, lin_lock_flag_tmp2 = 0, lin_lock_flag = 0, lin_snif_enable, battery_charge_type;
unsigned char lin_counter = 0, fuel_sensor_enable, start_engine_volt_trh;
unsigned int unlock_message_off_timer, unlock_message_off_counter;
unsigned int rf_reset_counter1, rf_reset_flag1;
unsigned char second_attempt, second_attempt_done, lin_status_byte;
volatile unsigned char rf_reset_enable;
unsigned int fuel_level_lin, RF_turn_on_start, lock_status_changed, lock_status_changed_lin, key_unlock_ign_on_timer;
extern unsigned int Fp1, Fp2;
unsigned char intrusion_off_by_input_flag;
unsigned int fast_init_start_flag = 0;
unsigned long tilt_off_timer = 0, temperatura_correct_timer;
unsigned char tilt_off_timer_setting, temperatura_correct_timer_setting;
unsigned char tllights_status = 0, tllights_status_tmp = 0, trlights_status = 0, trlights_status_tmp = 0, t_lights_off_timeout = 0;
unsigned char doors_intr_autorun_flag, door_open_autorun_flag = 0, sim_status_in_sleep = 0;
unsigned long short_period_of_reports_counter = 162000, fuel_consumption;
unsigned int fuel_consumption_quantum;
unsigned int tilt_overage_counter = 0;//, beep_after_test_flag = 0;
unsigned char fuel_consumption_counter_tmp = 0, test_message_after_wake = 0;
unsigned char doors_status_changed, dflt_flag, fake_serv_flag, io_reset_flag, gps_reset_flag;
unsigned char periodic_break_flag, periodic_10ms_break_flag, sent_transponed_list_flag, transp_in_zone_counter, filt_crash_first_entrance, crash_filt_cutoff_frq;
unsigned char number_of_samples, acc_sampling_frequency;
volatile unsigned long ID_tmp, ID2_tmp;
unsigned char mazda_lock_start_flag, mazda_lock_type;
unsigned char srvr_flag;
unsigned char brake_status, RPM_status; 
unsigned int engine_rpm, tilt_delay_counter;
unsigned char hw_version, engine_status, wbst_startenginecan_switch, disarm_by_doors_unlock_enable, timed_period;
unsigned char can_button, disarmed_by_button_flag, button_pressed_flag, fake_doors_open_type, message_during_ignition_off_flag;
unsigned int wbus_err_crc = 0;
//unsigned long ID_to_sniff;


//volatile unsigned int CAN1AUX_R_ptr_tmp, CAN1AUX_W_ptr_tmp, CAN2AUX_R_ptr_tmp, CAN2AUX_W_ptr_tmp;

# if defined (SELFPROGR)
unsigned int fw_refresh_counter, fw_refresh_flag;
# endif

# if defined ( PRODUCTION_MODE )                
unsigned char can1_test_ok, can2_test_ok;
unsigned int beep_after_test_flag = 0;
# endif 


//# if defined (SST26)
//    hw_version = hw_version | 0b00000001;
//# endif
//# if defined (SST25)
//    HW_VERSION = HW_VERSION | 0b00000000;
//# endif
//# if defined (L76_L)
//    HW_VERSION = HW_VERSION | 0b00000010;
//# endif
    
const float Coeff_0_b [17] = {
/*
Filter Type        : Parks-McClellan:  Lowpass
Sampling Frequency : 100.00000 Hz
Number of Taps     : 33
Coefficient Mode   : 32 bit quantized
Min Taps           : Yes
Ripple             : 0.130 dB
Attenuation        : 40.000 dB
Passband Upper     : 23.00000 Hz
Stopband Lower     : 30.00000 Hz
*/
    
//Coefficients
 0.004570483230, 0.000387738924,-0.007683156058, 0.003189279698, 0.010267945938,
-0.006370739080,-0.015669804998, 0.014655919746, 0.019762882032,-0.026809442788,
-0.024630393833, 0.049369797576, 0.027950799558,-0.096763198264,-0.030590412673,
 0.315246369224, 0.531206748448

};
const float Coeff_1_b [17] = {
/*
Filter Type        : Parks-McClellan:  Lowpass
Sampling Frequency : 50.00000 Hz
Number of Taps     : 33
Coefficient Mode   : 32 bit quantized
Min Taps           : Yes
Ripple             : 0.150 dB
Attenuation        : 38.000 dB
Passband Upper     : 3.80000 Hz
Stopband Lower     : 7.00000 Hz
*/

//Coefficients
-0.007232092321,-0.004319110885,-0.001038236544, 0.005394543055, 0.012334985659,
 0.015468494035, 0.010847646277,-0.002541392110,-0.020891158842,-0.035771631636,
-0.036704374477,-0.015553900972, 0.029211476911, 0.090387534816, 0.153325188439,
 0.200582218356, 0.218122284394

};
//const float Coeff_2 [13] = {
//
////Filter Type        : Parks-McClellan:  Lowpass
////Sampling Frequency : 100.00000 Hz
////Number of Taps     : 25
////Coefficient Mode   : 32 bit quantized
////Min Taps           : Yes
////Ripple             : 0.215 dB
////Attenuation        : 42.000 dB
////Passband Upper     : 3.00000 Hz
////Stopband Lower     : 11.50000 Hz
//
//
////Coefficients
//-0.006506366655,-0.009100964759,-0.012454573996,-0.013310107868,-0.009575376753,
// 0.000474181492, 0.017579246778, 0.041037308518, 0.068567824084, 0.096567522734,
// 0.120802217629, 0.137255326845, 0.143082626164
// 
//};

const float Coeff_37Hz [9] = {
//Label: Value
/*    
Chip Type          : QF1D512
Filter Type        : Parks-McClellan:  Lowpass
Sampling Frequency : 100.00000 Hz
Number of Taps     : 17
Coefficient Mode   : 32 bit quantized
Min Taps           : Yes
Ripple             : 0.200 dB
Attenuation        : 40.000 dB
Passband Upper     : 33.00000 Hz
Stopband Lower     : 45.00000 Hz
*/

//Coefficients
 0.007056541741,
-0.020535341930,
 0.022074948065,
-0.012728771660,
-0.023474288639,
 0.080278820824,
-0.146353502758,
 0.198859784752,
 0.780812520999


};
const float Coeff_25Hz [9] = {
/*
//Label: Value
Chip Type          : QF1D512
Filter Type        : Parks-McClellan:  Lowpass
Sampling Frequency : 100.00000 Hz
Number of Taps     : 17
Coefficient Mode   : 32 bit quantized
Min Taps           : Yes
Ripple             : 0.200 dB
Attenuation        : 40.000 dB
Passband Upper     : 20.00000 Hz
Stopband Lower     : 33.00000 Hz
*/
    
//Coefficients
 0.004929644521,
-0.013628751040,
-0.013801640365,
 0.033599247225,
 0.021106089000,
-0.085327307228,
-0.027489072643,
 0.310827224515,
 0.529873059131

};
const float Coeff_15Hz [9] = {
/*
//Label: Value
Chip Type          : QF1D512
Filter Type        : Parks-McClellan:  Lowpass
Sampling Frequency : 100.00000 Hz
Number of Taps     : 17
Coefficient Mode   : 32 bit quantized
Min Taps           : Yes
Ripple             : 0.200 dB
Attenuation        : 40.000 dB
Passband Upper     : 11.00000 Hz
Stopband Lower     : 23.00000 Hz

*/

//Coefficients
 0.008226092439,
 0.018279036973,
 0.000923458487,
-0.033207880799,
-0.054207264911,
-0.003565459047,
 0.126511895098,
 0.273400423117,
 0.337781481445


    
};
const float Coeff_8Hz [9] = {
/*    
//Label: Value
Chip Type          : QF1D512
Filter Type        : Parks-McClellan:  Lowpass
Sampling Frequency : 100.00000 Hz
Number of Taps     : 17
Coefficient Mode   : 32 bit quantized
Min Taps           : Yes
Ripple             : 0.150 dB
Attenuation        : 40.000 dB
Passband Upper     : 4.00000 Hz
Stopband Lower     : 16.00000 Hz
*/

//Coefficients
-0.012121469248,
-0.017604634631,
-0.017392969690,
-0.001450085081,
 0.034462195821,
 0.086642908398,
 0.142913110089,
 0.186500675511,
 0.202928641811
  
};


unsigned char __attribute__ ((far)) Transp_in_zone[13] = { '0', ',', '0', ',', '0', ',', '0', ',', '0', ',', '0', '0', 0 };
unsigned char __attribute__ ((far)) Transp_nums[7];
unsigned char __attribute__ ((far)) Transp_flags[7];
unsigned char __attribute__ ((far)) Transp_flags_to_learn[7];
         char __attribute__ ((far)) Transp_flags_lrn[7];
unsigned char __attribute__ ((far)) IN_Transp_flags[7];
unsigned char __attribute__ ((far)) IN_Transp_new_flags[7];
unsigned char __attribute__ ((far)) OUT_Transp_flags[7];
unsigned char __attribute__ ((far)) Free_transp_nums [7];
unsigned char __attribute__ ((far)) Free_transp_flags [7];
unsigned char __attribute__ ((far)) check_kr[5];
unsigned char __attribute__ ((far)) rx_buf[8];

unsigned char __attribute__ ((far)) VIN[18];
unsigned char __attribute__ ((far)) VIN_TMP[18];
unsigned char __attribute__ ((far)) DTC_buf [93];
unsigned char __attribute__ ((far)) DTC_buf_tmp[93];

# if defined (K_LINE)
unsigned char __attribute__ ((far)) KVIN[18];
unsigned char __attribute__ ((far)) KVIN_TMP[18];
unsigned char __attribute__ ((far)) KDTC_buf [93];
unsigned char __attribute__ ((far)) KDTC_buf_tmp[93];
# endif

unsigned int SW2_receive1        = 0x50; // 0x05 synchronize word 3 for receive1
unsigned int const SW2_receive1_transp = 0x50; // 0x50 synchronize word 3 for receive1
unsigned int const SW2_receive1_relay  = 0x60; // 0x60 synchronize word 3 for receive1
unsigned int const SW2_receive  = 0x30; // synchronize word 3 for receive
unsigned int const SW2_lrn_rel = 0xF0; // synchronize word 2 for learn
unsigned int const SW1_lrn_rel = 0x00; // synchronize word 1 for learn
unsigned int const SW0_lrn_rel = 0x00; // synchronize word 0

unsigned int const SW2_lrn_trnsp = 0x90; // synchronize word 2 for learn
unsigned int const SW1_lrn_trnsp = 0x00; // synchronize word 1 for learn
unsigned int const SW0_lrn_trnsp = 0x00; // synchronize word 0

unsigned int const SW2_lrn_mstr = 0x00; // synchronize word 2 for learn
unsigned int const SW1_lrn_mstr = 0xFF; // synchronize word 1 for learn
unsigned int const SW0_lrn_mstr = 0x00; // synchronize word 0
unsigned int SW2;   // = 0x2D; // synchronize word 2
unsigned int SW1;   // = 0xD4; // synchronize word 1
unsigned int SW0;   // = 0x55; // synchronize word 0
unsigned char const sw0[16] = {3,11,4,2,12,10,9,13,0,7,14,8,1,5,6,15};
unsigned char const sw1[16] = {1,3,10,14,12,7,5,0,2,15,11,8,6,13,9,4};
unsigned char const sw2[16] = {14,10,8,4,3,11,9,2,0,1,7,13,5,12,6,15};
unsigned char const sw3[16] = {3,4,10,9,12,2,11,0,8,15,1,14,5,13,7,6};
unsigned char const sw4[16] = {13,8,5,10,15,0,6,4,14,7,2,1,3,9,11,12};
unsigned char const sw5[16] = {11,2,10,1,5,8,6,7,0,14,9,13,4,12,15,3};
unsigned char const sw0_learn[5] = {0,0x0A,0x0B,0x0C,0x0D};

unsigned char H0[16] = {3,0,15,14,6,11,4,13,5,12,10,9,8,7,2,1};
unsigned char H1[16] = {11,6,2,4,3,9,14,1,12,7,8,13,0,15,10,5};
unsigned char H2[16] = {9,13,5,3,7,4,1,10,8,0,15,2,11,6,12,14};
unsigned char H3[16] = {4,0,15,9,11,8,10,12,1,3,5,6,7,14,13,2};
unsigned char H4[16] = {12,4,0,15,2,6,1,10,11,3,8,5,9,13,14,7};
unsigned char H5[16] = {10,14,6,3,15,13,5,8,4,9,12,7,11,2,0,1};
unsigned char H6[16] = {6,3,2,11,13,5,7,12,14,4,9,8,1,10,0,15};
unsigned char H7[16] = {2,8,13,6,7,3,5,12,9,4,14,1,11,0,10,15};


unsigned char Si4461_buf [16];
//unsigned char const RF_POWER_UP[7] = {0x02, 0x01, 0x00, 0x01, 0xC9, 0xC3, 0x80};
unsigned char const  NOP[1] = {0x00};  //No Operation command. revB1B 
unsigned char const  PART_INFO[1] = {0x01};  //Reports basic information about the device. revB1B
//unsigned char const  FUNC_INFO = 0x10;   //Returns the Function revision information of the device. revB1B 
//unsigned char const  SET_PROPERTY = 0x11;   //Sets the value of one or more properties. revB1B 
//unsigned char const  GET_PROPERTY = 0x12;   //Retrieves the value of one or more properties revB1B 
//unsigned char const  GPIO_PIN_CFG[8] = {0x13, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60};   //Configures the GPIO pins. revB1B 
//unsigned char const  FIFO_INFO = 0x15;   //Access the current byte counts in the TX and RX FIFOs, and provide for resetting the FIFOs. revB1B 
unsigned char const  GET_INT_STATUS[4] = {0x20, 0x00, 0x00, 0x00};   //Returns the interrupt status of ALL the possible interrupt events (both STATUS and PENDING). Optionally, it may be used to clear latched (PENDING) interrupt events. revB1B 
//unsigned char const  REQUEST_DEVICE_STATE = 0x33;   //Request current device state and channel. revB1B 
//unsigned char const  CHANGE_STATE = 0x34;   //Manually switch the chip to a desired operating state. revB1B 
unsigned char const  READ_CMD_BUFF[1] = {0x44};   //Used to read CTS and the command response. revB1B 
//unsigned char const  FRR_A_READ = 0x50;   //Reads the fast response registers (FRR) starting with FRR_A. revB1B 
//unsigned char const  FRR_B_READ = 0x51;   //Reads the fast response registers (FRR) starting with FRR_B. revB1B 
//unsigned char const  FRR_C_READ = 0x53;   //Reads the fast response registers (FRR) starting with FRR_C. revB1B 
//unsigned char const  FRR_D_READ = 0x57;   //Reads the fast response registers (FRR) starting with FRR_D. revB1B 

unsigned char const  POWER_UP[7]                   			= { 0x02, 0x01, 0x00, 0x01, 0xC9, 0xC3, 0x80 };
# if defined (DIRECTTX)
unsigned char const  GPIO_PIN_CFG[8]               			= { 0x13, 0x44, 0x08, 0x20, 0x21, 0x27, 0x00, 0x00 };
# else
unsigned char const  GPIO_PIN_CFG[8]               			= { 0x13, 0x07, 0x08, 0x20, 0x21, 0x27, 0x00, 0x00 };
# endif
unsigned char const  GLOBAL_XO_TUNE_1[5]           			= { 0x11, 0x00, 0x01, 0x00, 0x52 };
unsigned char const  GLOBAL_CLK_CFG_1[5]           			= { 0x11, 0x00, 0x01, 0x01, 0x68 };
unsigned char const  GLOBAL_CONFIG_1[5]            			= { 0x11, 0x00, 0x01, 0x03, 0x60 };
unsigned char const  INT_CTL_ENABLE_3[8]           			= { 0x11, 0x01, 0x04, 0x00, 0x03, 0x30, 0x01, 0x00 };
unsigned char        INT_SW_DETECT_ENABLE[5]     			= { 0x11, 0x01, 0x01, 0x02, 0x00 };
unsigned char const  FRR_CTL_A_MODE_4[8]           			= { 0x11, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00 };
unsigned char        START_TX[5]                 			= { 0x31, 0x00, 0x00, 0x00, 0x03 };
unsigned char        START_RX[8]                 			= { 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
unsigned char        CHANGE_STATE[2]                        = { 0x34, 0x00 }; 
unsigned char const  PREAMBLE_TX_LENGTH_9[13]      			= { 0x11, 0x10, 0x09, 0x00, 0x05, 0x14, 0x00, 0x0F, 0x31, 0x00, 0x00, 0x00, 0x00 };
unsigned char const  SYNC_CONFIG[5]              			= { 0x11, 0x11, 0x01, 0x00, 0x02 };
unsigned char        SYNC_BITS[8]                			= { 0x11, 0x11, 0x04, 0x01, 0xC0, 0xBD, 0x7C, 0xC8 };
unsigned char        SYNC_BITS_SW2[5]              			= { 0x11, 0x11, 0x01, 0x01, 0x00 };
unsigned char        GET_SYNC_BITS[5]              			= { 0x12, 0x11, 0x01, 0x04, 0x01 };
unsigned char const  PKT_CRC_CONFIG_1[5]           			= { 0x11, 0x12, 0x01, 0x00, 0x80 };
unsigned char const  PKT_WHT_SEED_15_8_4[8]        			= { 0x11, 0x12, 0x04, 0x03, 0xFF, 0xFF, 0x00, 0x02 };         //0x08
unsigned char const  PKT_LEN_12[16]                			= { 0x11, 0x12, 0x0C, 0x08, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00 };
unsigned char 	     PKT_LENTH[5]                			= { 0x11, 0x12, 0x01, 0x0E, 0x00 };
unsigned char const  PH_RX_DIS[5]                			= { 0x11, 0x12, 0x01, 0x06, 0x40 };
unsigned char const  PKT_FIELD_2_CRC_CONFIG_12[16] 			= { 0x11, 0x12, 0x0C, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
unsigned char const  PKT_FIELD_5_CRC_CONFIG_1[5]   			= { 0x11, 0x12, 0x01, 0x20, 0x00 };
# if defined (DIRECTTX)
unsigned char const  MODEM_MOD_TYPE_12[16]         			= { 0x11, 0x20, 0x0C, 0x00, 0x89, 0x00, 0x07, 0x2D, 0xC6, 0xC0, 0x01, 0xC9, 0xC3, 0x80, 0x00, 0x14 };
#else
unsigned char const  MODEM_MOD_TYPE_12[16]         			= { 0x11, 0x20, 0x0C, 0x00, 0x02, 0x00, 0x07, 0x2D, 0xC6, 0xC0, 0x01, 0xC9, 0xC3, 0x80, 0x00, 0x14 };
#endif
unsigned char const  MODEM_FREQ_DEV_0_1[5]         			= { 0x11, 0x20, 0x01, 0x0C, 0x7B };
unsigned char const  MODEM_TX_RAMP_DELAY_8[12]     			= { 0x11, 0x20, 0x08, 0x18, 0x01, 0x00, 0x08, 0x03, 0xC0, 0x00, 0x00, 0x30 };
unsigned char const  MODEM_BCR_OSR_1_9[13]         			= { 0x11, 0x20, 0x09, 0x22, 0x00, 0x64, 0x05, 0x1E, 0xB8, 0x05, 0x1F, 0x02, 0x00 };
unsigned char const  MODEM_AFC_GEAR_7[11]          			= { 0x11, 0x20, 0x07, 0x2C, 0x00, 0x23, 0xCA, 0x3D, 0x00, 0xCD, 0xE0 };
unsigned char const  MODEM_AGC_CONTROL_1[5]        			= { 0x11, 0x20, 0x01, 0x35, 0xE2 };
unsigned char const  MODEM_AGC_WINDOW_SIZE_9[13]   			= { 0x11, 0x20, 0x09, 0x38, 0x22, 0x0B, 0x0B, 0x00, 0x02, 0x40, 0x00, 0x00, 0x28 };
unsigned char const  MODEM_OOK_CNT1_11[15]        			= { 0x11, 0x20, 0x0B, 0x42, 0xA4, 0x03, 0xD6, 0x03, 0x01, 0x3F, 0x01, 0x80, 0xFF, 0x0C, 0x00 };
unsigned char const  MODEM_RSSI_COMP_1[5]          			= { 0x11, 0x20, 0x01, 0x4E, 0x40 };
unsigned char const  MODEM_CLKGEN_BAND_1[5]                 = { 0x11, 0x20, 0x01, 0x51, 0x08 };
unsigned char const  MODEM_CHFLT_RX1_CHFLT_COE13_7_0_12[16] = { 0x11, 0x21, 0x0C, 0x00, 0x7E, 0x64, 0x1B, 0xBA, 0x58, 0x0B, 0xDD, 0xCE, 0xD6, 0xE6, 0xF6, 0x00 };
unsigned char const  MODEM_CHFLT_RX1_CHFLT_COE1_7_0_12[16]  = { 0x11, 0x21, 0x0C, 0x0C, 0x03, 0x03, 0x15, 0xF0, 0x3F, 0x00, 0x7E, 0x64, 0x1B, 0xBA, 0x58, 0x0B };
unsigned char const  MODEM_CHFLT_RX2_CHFLT_COE7_7_0_12[16]  = { 0x11, 0x21, 0x0C, 0x18, 0xDD, 0xCE, 0xD6, 0xE6, 0xF6, 0x00, 0x03, 0x03, 0x15, 0xF0, 0x3F, 0x00 };
unsigned char const  PA_MODE_4[8]                           = { 0x11, 0x22, 0x04, 0x00, 0x20, 0x14, 0x32, 0x5D }; //{ 0x11, 0x22, 0x04, 0x00, 0x20, 0x14, 0x32, 0x5D };
unsigned char const  SYNTH_PFDCP_CPFF_7[11]                 = { 0x11, 0x23, 0x07, 0x00, 0x01, 0x05, 0x0B, 0x05, 0x02, 0x00, 0x03 };
unsigned char const  MATCH_VALUE_1_12[16]                   = { 0x11, 0x30, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
unsigned char const  FREQ_CONTROL_INTE_8[12]                = { 0x11, 0x40, 0x08, 0x00, 0x38, 0x0E, 0xFC, 0x96, 0x22, 0x22, 0x20, 0xFF };

//mID canTxMessage;
//mID canRxMessage;
//
///* Define ECAN Message Buffers */
//ECAN1MSGBUF ecan1msgBuf __attribute__((space(dma),aligned(ECAN1_MSG_BUF_LENGTH*16)));

union {
   unsigned int GSMSINGLALLEVEL;
   struct
    {
        unsigned char rssi:8;
        unsigned char ber:8;

    };
} GSMSINGLALLEVELbits;

union {
   volatile unsigned int NETWORKSTATUS;
   struct
    {
        unsigned char creg:3;
        unsigned char cgreg:3;
        unsigned int :10;
    };
} NETWORKSTATUSbits;

union {
   volatile unsigned int CONNECTIONCLS;
   struct
    {
        unsigned char start:1;
//        unsigned char qiclose:1;
        unsigned char close_ok:1;
        unsigned char close_error:1;
        unsigned char close_timeout:1;
        unsigned int :12;
    };
} CONNECTIONCLSbits;

union {
   volatile unsigned int GSMSTATUS;
   struct
    {
        unsigned char power:1;
        unsigned char unexpected_off:1;
        unsigned char normal_on:1;
        unsigned char normal_off:1;
        unsigned char normal_pw_dwn:1;
        unsigned char rdy:1;
        unsigned char cfun:3;
        unsigned char cpin:2;
        unsigned char callready:1;
//        unsigned char creg:3;
        unsigned char :1;
    };
} GSMSTATUSbits;
union {
   volatile unsigned int GETIMEI;
   struct
    {
        unsigned char start:1;
        unsigned char done:1;
    };
} GEIMEIbits;
union {
   volatile unsigned int GETIMSI;
   struct
    {
        unsigned char start:1;
        unsigned char done:1;
        unsigned char timeout:1;
        unsigned char ok:1;
        unsigned char error:1;
        unsigned char cms_cme_error:1;
        unsigned char sours_of_command:2;
        unsigned char tasck_timeout:8;
    };
} GETIMSIbits;
union {
   volatile unsigned long MODEMTASCKS;
   struct
    {
        unsigned char onoff:1;
        unsigned char modem_UART_check:1;
        unsigned char creg_check:1;
        unsigned char set_cnt_sgp:1; //set_cnt
        unsigned char set_sgp:1;
        unsigned char qiopen:1;
        unsigned char qiclose:1;
        unsigned char pdp_deact:1;
        unsigned char cgreg_check:1;
        unsigned char data_sending:1;
        unsigned char at_to_modem:1;
        unsigned char sms_sending:1;
        unsigned char sms_reading:1;
        unsigned char sms_deleting:1; 
        unsigned char get_imsi:1;
        unsigned long :17;
    };
} MODEMTASCKSbits;

union {
   volatile unsigned int CONTEXTSTATUS;
   struct
    {
        unsigned char start:1;
        unsigned char cnt_sgp:1;
        unsigned char context_ok:1;
        unsigned char context_error:1;
        unsigned char context_timeout:1;

    };
} CONTEXTSTATUSbits;

union {
   volatile unsigned int GPRSSTATUS;
   struct
    {
        unsigned char start:1;
//        unsigned char cgreg:4;
        unsigned char qiopen_ok:1;
        unsigned char qiopen_error:1;
        unsigned char qiopen_timeout:1;
        unsigned char connect_ok:1;
        unsigned char already_connect:1;
        unsigned char connect_fail:1;
        unsigned char connect_error:1;
        unsigned char connect_timeout:1;
        unsigned char waiting_connection:1;
        
        unsigned char :2;
    };
} GPRSSTATUSbits;

union {
   volatile unsigned int GPRSSEND;
   struct
    {
        unsigned char start_sending:1;
        unsigned char at_qisend:1;
        unsigned char cntrlz:1;
        unsigned char waiting_send_ok:1;
        unsigned char received_ACK:1;        
        unsigned char send_ok:1;
        unsigned char send_fail:1;
        unsigned char send_error:1;
        unsigned char qisend_timeout:1;
        unsigned char ACK_timeout_flag:1;

        unsigned char :5;
    };
} GPRSSENDbits;

union {
   volatile unsigned long FLASHDATASEND;
   struct
    {
       unsigned char waiting_ACK:1;
       unsigned char ACK:1;
       unsigned int  received_ACK:16;

        unsigned int :14;
    };
} FLASHDATASENDbits;
union {
   volatile unsigned long ACCDATASEND;
   struct
    {
       unsigned char waiting_ACK:1;
       unsigned char ACK:1;
       unsigned int  received_ACK:16;

        unsigned int :14;
    };
} ACCDATASENDbits;
union {
   volatile unsigned long TYPE0SEND;
   struct
    {
       unsigned char waiting_ACK:1;
       unsigned char ACK:1;
       unsigned int  received_ACK:16;

        unsigned int :14;
    };
} TYPE0SENDbits;

union {
   volatile unsigned int GSMPARAMTASCK;
   struct
    {
        unsigned char change_apn:1;
        unsigned char change_server:1;
        

        unsigned int :6;
    };
} GSMPARAMTASCKbits;

union {
   volatile unsigned long UARTATMODEM;
   struct
    {
        unsigned char start:1;
        unsigned char at_timeout:1;
        unsigned int  at_ptr:16;
        unsigned int :14;
    };
} UARTATMODEMbits;

union {
   volatile unsigned long SMSSEND;
   struct
    {
        unsigned char start_sending:1;
        unsigned char at_cmgs:1;
        unsigned char cntrlz:1;
        unsigned char waiting_cmgs_result:1;
        unsigned char plus_cmgs:1;        
        unsigned char cmgs_ok:1;
        unsigned char cms_error:1;
        unsigned char cme_error:1;
        unsigned char sms_send_timeout:1;
        unsigned char at_cmgs_timeout:1;
        unsigned int :6;
        
        unsigned int  result_code:16;
    };
} SMSSENDbits;

union {
   volatile unsigned long SMSREAD;
   struct
    {
        unsigned char start_reading:1;
        unsigned char at_cmgr:1;
        unsigned char at_cmgr_ok:1;
        unsigned char cms_error:1;
        unsigned char cme_error:1;
        unsigned char at_cmgr_timeout:1;
        unsigned int :10;
        
        unsigned int result_code:16;
    };
} SMSREADbits;

union {
   volatile unsigned long SMSDELETE;
   struct
    {
        unsigned char start_deleting:1;
        unsigned char at_qmgda:1;
        unsigned char at_qmgda_ok:1;
        unsigned char at_qmgda_error:1;
        unsigned char cms_error:1;
        unsigned char at_qmgda_timeout:1;
        unsigned int :10;
        
        unsigned int result_code:16;
    };
} SMSDELETEbits;
 
union {
   unsigned char AV;
   struct
    {
        unsigned char PLN:2;
        unsigned char DIM:2;
        unsigned char NEAD:3;
        unsigned char S:1;
    };
} AVbits;

union {
   unsigned char NSAT;
   struct
    {
        unsigned char GL:2;
        unsigned char GPGL:2;
    };
} NSATbits;

union {
   unsigned char FIXFLAGS;
   struct
    {
       unsigned char ready:1;
       unsigned char time:1;
       unsigned char distance:1;
       unsigned char course:1;
       unsigned char idlestart:1;
       unsigned char idleend:1;
       unsigned char speed:1;
    };
} FIXFLAGSbits;

union {
   unsigned char IGNEVENTSFLAGS;
   struct
    {
       unsigned char event_on_flag:1;
       unsigned char event_off_flag:1;
       unsigned char trigg_on:1;
       unsigned char trigg_off:1;
       unsigned char :4;
    };
} IGNEVENTSFLAGSbits;

union {
   unsigned char PWREVENTSFLAGS;
   struct
    {
       unsigned char event_on_flag:1;
       unsigned char event_off_flag:1;
       unsigned char trigg_on:1;
       unsigned char trigg_off:1;
       unsigned char :4;
    };
} PWREVENTSFLAGSbits;

union {
   unsigned char IDLEEVENTSFLAGS;
   struct
    {
       unsigned char event_on_flag:1;
       unsigned char event_off_flag:1;
       unsigned char trigg_on:1;
       unsigned char trigg_off:1;
       unsigned char :4;
    };
} IDLEEVENTSFLAGSbits;

union {
   unsigned int GPSSPEED;
   struct
    {
        unsigned char V:8;
        unsigned char V0:8;
    };
} GPSSPEEDbits;

union {
   unsigned char AUTOCAL;
   struct
    {
        unsigned char staticcal:1;
        unsigned char orientation:1;
        unsigned char direction:1;
        
    };
} AUTOCALbits;
union {
   unsigned char AUTOCALSTATUS;
   struct
    {
        unsigned char staticcal:1;
        unsigned char orientation:1;
        unsigned char direction:1;
        unsigned char finished:1;
    };
} AUTOCALSTATUSbits;

union {
   unsigned long long DECELEVENT;
   struct
    {
        unsigned char flag1:1;
        unsigned char flag2:1;
        unsigned char flag3:1;
        unsigned char flag4:1;
        unsigned char :4;
        unsigned char duration1:8;
        unsigned char duration2:8;
        unsigned char duration3:8;
        unsigned char duration4:8;
        unsigned char max_decel:8;
        unsigned char :8;
        unsigned char :8;        
    };
} DECELEVENTbits;
union {
   unsigned long long ACCELEVENT;
   struct
    {
        unsigned char flag1:1;
        unsigned char flag2:1;
        unsigned char flag3:1;
        unsigned char flag4:1;
        unsigned char :4;
        unsigned char duration1:8;
        unsigned char duration2:8;
        unsigned char duration3:8;
        unsigned char duration4:8;
        unsigned char max_accel:8;
        unsigned char :8;
        unsigned char :8;        
    };
} ACCELEVENTbits;
union {
   unsigned long long LALREVENT;
   struct
    {
        unsigned char flag1:1;
        unsigned char flag2:1;
        unsigned char flag3:1;
        unsigned char flag4:1;
        unsigned char :4;
        unsigned char duration1:8;
        unsigned char duration2:8;
        unsigned char duration3:8;
        unsigned char duration4:8;
        unsigned char max_decel:8;
        unsigned char :8;
        unsigned char :8;        
    };
} LALREVENTbits;
union {
   unsigned long long LALLEVENT;
   struct
    {
        unsigned char flag1:1;
        unsigned char flag2:1;
        unsigned char flag3:1;
        unsigned char flag4:1;
        unsigned char :4;
        unsigned char duration1:8;
        unsigned char duration2:8;
        unsigned char duration3:8;
        unsigned char duration4:8;
        unsigned char max_accel:8;
        unsigned char :8;
        unsigned char :8;        
    };
} LALLEVENTbits;

union {
   unsigned int FLASHBUSY;
   struct
    {
        unsigned char page_saving:1;
        unsigned char page2_saving:1;
        unsigned char acc_saving:1;
        unsigned char fw_saving:1;
        unsigned char page_sector_erasing:1;
        unsigned char page2_sector_erasing:1;
        unsigned char acc_sector_erasing:1;
        unsigned char fw_sector_erasing:1;
        unsigned char :8;
    };
} FLASHBUSYbits;


union {
   unsigned long long ACEL;
   struct
    {
        char trh1:8;
        char dur1:8;
        char trh2:8;
        char dur2:8;
        char trh3:8;
        char dur3:8;
        char trh4:8;
        char dur4:8;
    };
} ACELbits;
union {
   unsigned long long DCEL;
   struct
    {
        char trh1:8;
        char dur1:8;
        char trh2:8;
        char dur2:8;
        char trh3:8;
        char dur3:8;
        char trh4:8;
        char dur4:8;
    };
} DCELbits;
union {
   unsigned long long LALR;
   struct
    {
        char trh1:8;
        char dur1:8;
        char trh2:8;
        char dur2:8;
        char trh3:8;
        char dur3:8;
        char trh4:8;
        char dur4:8;
    };
} LALRbits;
union {
   unsigned long long LALL;
   struct
    {
        char trh1:8;
        char dur1:8;
        char trh2:8;
        char dur2:8;
        char trh3:8;
        char dur3:8;
        char trh4:8;
        char dur4:8;
    };
} LALLbits;

union {
   unsigned long SMSEN;
   struct
    {

        unsigned char pwr_on:1;
        unsigned char pwr_off:1;
        unsigned char ign_on:1;
        unsigned char ign_off:1;
        unsigned char static_compl:1;
        unsigned char clbr_compl:1;
        unsigned char acel:1;
        unsigned char dcel:1;
        unsigned char lal:1;

    };
} SMSENbits;

union {
   unsigned long BEEPFLAGS;
   struct
    {

        unsigned char start:1;
        unsigned char running:1;        
        unsigned int  pulse:13;
        unsigned int  pause:13;
        unsigned char   num:4;        
        
    };
} BEEPFLAGSbits;
union {
   unsigned long long OUTPLSTASCK;
   struct
    {
        unsigned char start:1;
        unsigned char running:1;
        unsigned char output_number:4;
        unsigned char stop:2;
        unsigned char num:8;        
        unsigned int  pulse:16;
        unsigned int  pause:16;
        unsigned int :16;        
        
    };
} OUTPLSTASCKbits;

/**/
//MCP23S17
union {
   unsigned char EXT_LATB;
   struct
    {
        unsigned char B0:1;
        unsigned char B1:1;        
        unsigned char B2:1;
        unsigned char B3:1;
        unsigned char B4:1;
        unsigned char B5:1;        
        unsigned char B6:1;
        unsigned char B7:1;
       
        
    };
} EXT_LATBbits;

union {
    unsigned long LFSR;
   struct 
    {
		unsigned char b1:1;
		unsigned char b2:1;
		unsigned char b3:1;
		unsigned char :1;
		unsigned char b5:1;
		unsigned char :1;
		unsigned char b7:1;
		unsigned long :24;
		unsigned char b32:1;
    };
} LFSRbits;
//union {
//    unsigned long LFSRSW;
//   struct 
//    {
//		unsigned long :19;
//		unsigned char b20:1;
//		unsigned char b21:1;
//		unsigned char :1;
//		unsigned char b23:1;
//		unsigned char b24:1;
//		unsigned char :8;
//    };
//} LFSRSWbits;
union {
    unsigned long LFSRSW;
   struct 
    {
		unsigned char b1:1;
		unsigned char :1;
		unsigned char b3:1;
		unsigned char b4:1;
		unsigned long :19;        
		unsigned char b24:1;
		unsigned char :8;
    };
} LFSRSWbits;
//union {
//    unsigned long LFSRT;
//   struct 
//    {
//		unsigned char b1:1;
//		unsigned char :1;
//		unsigned char b3:1;
//		unsigned char b4:1;
//		unsigned long :19;
//		unsigned char b24:1;
//		unsigned char :8;
//    };
//} LFSRTbits;
union {
    unsigned long LFSRT;
   struct 
    {
		unsigned char b1:1;
		unsigned char :2;        
		unsigned char b4:1;
		unsigned char :1;        
		unsigned char b6:1;        
		unsigned int :14;
		unsigned char b20:1;
		unsigned int :11;
    };
} LFSRTbits;
union {
    unsigned long SW;
    struct 
    {
		unsigned char nibble0:4;
		unsigned char nibble1:4;
		unsigned char nibble2:4;
		unsigned char nibble3:4;
		unsigned char nibble4:4;
		unsigned char nibble5:4;
		unsigned char :8;
    };
} SWbits;
union {
    unsigned long OUT;
   struct 
    {
		unsigned long unit_num:24;
		unsigned char power_status:1;
		unsigned char :1;
		unsigned char arm_flag:1;
		unsigned char rf_protect_flag:1;
		unsigned char serv_flag:1;
//		unsigned char :1;
		unsigned char transp_num:3;
    };
} OUTbits;
union {
    unsigned long RELOUT;
   struct 
    {
		unsigned int  counter:16;
        unsigned char command:3;
        unsigned char param_value:4;        
		unsigned char arm_flag:1;
		unsigned char serv_flag:1;
		unsigned char block_flag:1;        
		unsigned char autorun_flag:1;
		unsigned char :5;        
    };
} RELOUTbits;
union {
    unsigned long OUTTMP;
   struct 
    {
		unsigned long unit_num:24;
		unsigned char power_status:1;
		unsigned char :1;
		unsigned char arm_flag:1;
		unsigned char rf_protect_flag:1;
		unsigned char serv_flag:1;
//		unsigned char :1;
		unsigned char transp_num:3;
    };
} OUTTMPbits;
union {
    unsigned long RELOUTTMP;
   struct 
    {
		unsigned int  counter:16;
        unsigned char command:3;
        unsigned char param_value:4;        
		unsigned char arm_flag:1;
		unsigned char serv_flag:1;
		unsigned char block_flag:1;        
		unsigned char autorun_flag:1;
		unsigned char :5;        
    };
} RELOUTTMPbits;

union {
    unsigned long temp;
    struct 
    {
		unsigned char nibble0:4;
		unsigned char nibble1:4;
		unsigned char nibble2:4;
		unsigned char nibble3:4;
		unsigned char nibble4:4;
		unsigned char nibble5:4;
		unsigned char nibble6:4;
		unsigned char nibble7:4;
    };
} value;
union {
    unsigned char IN;
   struct 
    {
//		unsigned char :1;
		unsigned char transp_num:3;
		unsigned char disarm_flag:1;
		unsigned char panic:1;
		unsigned char rf_protectOFF_flag:1;
		unsigned char servON_flag:1;
		unsigned char servOFF_flag:1;

//		unsigned char beep_flag:1;
    };
} INbits;
union {
    unsigned long IN_TMP;
   struct 
    {
		unsigned long transp_number:24;
//		unsigned char :1;
		unsigned char transp_num:3;
		unsigned char disarm_flag:1;
		unsigned char panic:1;
		unsigned char battery_voltage_flag:1;
		unsigned char servON_flag:1;
		unsigned char servOFF_flag:1;
    };
} IN_TMPbits;
union {
    unsigned long RIN2_TMP;
   struct 
    {
		unsigned int  counter:16;
        unsigned char command:3;
        unsigned char param_value:4;        
		unsigned char arm_flag:1;
		unsigned char serv_flag:1;
		unsigned char block_flag:1;        
		unsigned char transp_num:3;
		unsigned char ignition_flag:1;        
		unsigned char confirmation:1;
		unsigned char :1;
    };
} RIN2_TMPbits;
union {
    unsigned long RIN3_TMP;
   struct 
    {
		unsigned int  counter:16;
        unsigned char command:3;
        unsigned char param_value:4;        
		unsigned char arm_flag:1;
		unsigned char serv_flag:1;
		unsigned char block_flag:1;        
		unsigned char rel_out:1; 
		unsigned char ignition_flag:1; 
		unsigned char autorun_flag:1;        
		unsigned char confirmation:1;
		unsigned char :2;        
    };
} RIN3_TMPbits;
union {
    unsigned long RLIN_TMP;
   struct 
    {
		unsigned long transp_number:24;
		unsigned char transp_num:3;
		unsigned char confirmation:1;
		unsigned char :4;        
    };
} RLIN_TMPbits;

union {
    unsigned long OUT_TLEARN;
   struct 
    {
		unsigned long number:24;
		unsigned char comand:4;
		unsigned char transp_num:4;
    };
} OUT_TLEARNbits;

union {
    unsigned long IN_TLEARN;
   struct 
    {
		unsigned long number:24;
		unsigned char comand:4;
		unsigned char transp_num:4;
    };
} IN_TLEARNbits;

union {
    unsigned int RFSTATE;
   struct 
    {
		unsigned char waiting_inquiry:1;
        unsigned char transmitting:1;
		unsigned char receiving:3;

    };
} RFSTATEbits;
union {
    unsigned long ARMFLAGS; // было int
   struct 
    {
		unsigned char arm_status:1;
		unsigned char arm_on_event:1;
        unsigned char arm_on_event_sent:1;
		unsigned char arm_off_event:1;
        unsigned char arm_off_event_sent:1;
		unsigned char intr_event:1;
        unsigned int arm_timer:10;
        
		unsigned char intr_event_trigg:1; 
        unsigned char intr_event_sent:1;        
        unsigned char :4;
        unsigned int intrusion_timer:10;

    };
} ARMFLAGSbits;
union {
    unsigned int INTRUSIONFLAGS;
   struct 
    {
		unsigned char intr_trigg:1;
        unsigned char intr_alarm:1;
        unsigned int intr_timer:10;
    };
} INTRUSIONFLAGSbits;
union {
    unsigned char INTRREASON;
   struct 
    {
       unsigned char ign:1;
       unsigned char dd:1;
       unsigned char fpd:1;
       unsigned char lrd:1;
       unsigned char rrd:1;
       unsigned char bn:1;
       unsigned char bt:1;
       unsigned char all_doors:1;
    };
} INTRREASONbits;
union {
    unsigned char SERVFLAGS;
   struct 
    {
		unsigned char serv_status:1;
        unsigned char serv_on_event:1;
        unsigned char serv_on_event_sent:1;
		unsigned char serv_off_event:1;
        unsigned char serv_off_event_sent:1;
        unsigned char :3;
    };
} SERVFLAGSbits;
union {
    unsigned int ROBBFLAGS;
   struct 
    {
		unsigned char robb_status:1;
        unsigned char robb_on_event:1;
        unsigned char robb_on_event_sent:1;
//        unsigned char :3;
		unsigned int robb_timer:13;
    };
} ROBBFLAGSbits;
union {
    unsigned long TILTFLAGS;
   struct 
    {
        unsigned char tilt_on_event:1;
        unsigned char tilt_on_event_sent:1;
		unsigned int tilt_timer:4;
		unsigned int tilt_delay_timer:13;        
    };
} TILTFLAGSbits;
union {
    unsigned long RFWDT;
   struct 
    {
		unsigned int tx_state_wdt:11;
        unsigned int rx_state_wdt:10;
        unsigned int irq_state_wdt:10;
    };
} RFWDTbits;
union {
    unsigned char RFRESET;
   struct 
    {
		unsigned char start:1;
        unsigned char sdn:1;
        unsigned char power_up:1;
        unsigned char init:1;
    };
} RFRESETbits;
union {
    unsigned int RELTASKS;
   struct 
    {
		unsigned char state:3;
        unsigned char complete:1;
        unsigned char timeout_counter:4;
        unsigned int :8;
    };
} RELTASKSbits;
union {
    unsigned int RLEARNTASKS;
   struct 
    {
		unsigned char start:1;
        unsigned char complete:1;
        unsigned int timeout_counter:10;
        unsigned char :4;
    };
} RLEARNTASKSbits;
union {
    unsigned long TLEARNTASKS;
   struct 
    {
		unsigned char start:1;
        unsigned char running:1;
        unsigned char running1:1;        
        unsigned char complete:1;
        unsigned char temp_tr_num:3;
        unsigned  int timeout_counter:10;
        unsigned int :15;
    };
} TLEARNTASKSbits;
union {
    unsigned int TFINISHTASKS;
   struct 
    {
		unsigned char start:1;
        unsigned char running:1;
        unsigned char complete:1;
        unsigned char temp_tr_num:3;
        unsigned  int timeout_counter:10;

    };
} TFINISHTASKSbits;
union {
    unsigned long STARTENGINE;
   struct 
    {
		unsigned int start:1;
        unsigned int source_of_command:2;
        unsigned int pulse_duration:7;
        unsigned int wait_duration:12;
        unsigned int running_duration:10;
    };
} STARTENGINEbits;
union {
    unsigned long long STARTENGINES;
   struct 
    {
		unsigned int start:1;
        unsigned int start_success:1;
        unsigned int source_of_command:2;
        unsigned int pulse_duration:16;
        unsigned int wait_duration:16;
        unsigned int running_duration:10;
        unsigned long :18;
    };
} STARTENGINESbits;
union {
    unsigned long STARTENGINEDL;
   struct 
    {
		unsigned char start:1;
        unsigned char success_message_generated:1;       
        unsigned char source_of_command:2;
        unsigned int  run_duration:15;
        unsigned int  pulse_delay:7;
        unsigned int  pulse_duration:6;
//        unsigned int  wait_duration:12;
//        unsigned int  running_duration:10;

//        unsigned char :5;
    };
} STARTENGINEDLbits;
union {
    unsigned long STARTENGINEP;
   struct 
    {
		unsigned char start:1;
        unsigned char success_message_generated:1;       
        unsigned char source_of_command:2;
        unsigned int  run_duration:15;
        unsigned int  start_pulse_duration:7;
        unsigned int  stop_pulse_duration:6;

    };
} STARTENGINEPbits;
#ifdef RUN_O
union {
    unsigned long long STARTENGINEO;
   struct 
    {
		unsigned char  start:1;
        unsigned char  stop:1;
        unsigned int   run_duration:15;  //at$runo input in sec
        unsigned char  pulse_delay:6;    //msec
        unsigned char  pulse_duration:6; //msec
        unsigned char  pulse_count:3;    //
        unsigned char  stage:4;          //stages for timer inside start_engine_runo() func
        unsigned char  attempts_cnt:3;   //number of start attempts
        unsigned char  success:1;
        unsigned long :25;
    };
} STARTENGINEObits;
union {
    unsigned long long STARTENGINEO1;
   struct 
    {
		unsigned char  start:1;
        unsigned char  stop:1;
        unsigned int   run_duration:15;  //at$runo input in sec
        unsigned char  pulse_delay:6;    //msec
        unsigned char  pulse_duration:6; //msec
        unsigned char  pulse_count:3;    //
        unsigned char  stage:4;          //stages for timer inside start_engine_runo() func
        unsigned char  attempts_cnt:3;   //number of start attempts
        unsigned char  success:1;        //flag for msg server generation only 1time
        unsigned long :24;
    };
} STARTENGINEO1bits;
union {
    unsigned long STARTENGINEOSET;
   struct 
    {
		unsigned char  alg_type:2;
        unsigned char      dur4:6;
        unsigned int       dur2:12;
        unsigned int       dur3:12;
    };
} STARTENGINEOSETbits;
#endif
union {
    unsigned long long STARTENGINEC;
   struct 
    {
		unsigned char start_tasck:1;
        unsigned char stop_tasck:1;
        unsigned char start:1;
        unsigned char stop:1;
        unsigned char success_message_generated:1;       
        unsigned char source_of_command:2;
        unsigned char :1;
        unsigned long  run_duration:32;
        unsigned int  :16; 
        unsigned char :8;
    };
} STARTENGINECbits;
union {
    unsigned long FUNCONTROL;
   struct 
    {
		unsigned char start:1;
        unsigned char success_message_generated:1;       
        unsigned char source_of_command:2;
        unsigned int  run_duration:16;
        unsigned int  start_pulse_duration:6;
        unsigned int  stop_pulse_duration:6;

    };
} FUNCONTROLbits;
union {
    unsigned int LOCKUNLOCK;
   struct 
    {
		unsigned char start:1;
        unsigned char lock:1;
        unsigned char unlock:1;
        unsigned char counter:4;
        unsigned int :9;
    };
} LOCKUNLOCKbits;
union {
    unsigned int DOOROPEN;
   struct 
    {
		unsigned char start:1;
        unsigned char lock:1;
        unsigned char unlock:1;
        unsigned char counter:4;
        unsigned int :9;
    };
} DOOROPENbits;
union {
    unsigned int DOOROPEN2;
   struct 
    {
		unsigned char start:1;
        unsigned char lock:1;
        unsigned char unlock:1;
        unsigned char counter:4;
        unsigned int :9;
    };
} DOOROPEN2bits;

union {
    unsigned int LINLOCKUNLOCK;
   struct 
    {
		unsigned char start:1;
        unsigned char running:1;
        unsigned char wake_sent:1;
        unsigned char lock:1;
        unsigned char unlock:1;
        unsigned char command:4;
        unsigned int  :8;
    };
} LINLOCKUNLOCKbits;
union {
    unsigned long long LINLOCKDATA;
   struct 
    {
		unsigned char byte0:8;
        unsigned char byte1:8;
        unsigned char byte2:8;
        unsigned char byte3:8;
        unsigned char byte4:8;
        unsigned char byte5:8;
        unsigned char byte6:8;
        unsigned char byte7:8;
    };
} LINLOCKDATAbits;
union {
    unsigned long long LINUNLOCKDATA;
   struct 
    {
		unsigned char byte0:8;
        unsigned char byte1:8;
        unsigned char byte2:8;
        unsigned char byte3:8;
        unsigned char byte4:8;
        unsigned char byte5:8;
        unsigned char byte6:8;
        unsigned char byte7:8;
    };
} LINUNLOCKDATAbits;
union {
    unsigned long long LINLOCKDATA2;
   struct 
    {
		unsigned char byte0:8;
        unsigned char byte1:8;
        unsigned char byte2:8;
        unsigned char byte3:8;
        unsigned char byte4:8;
        unsigned char byte5:8;
        unsigned char byte6:8;
        unsigned char byte7:8;
    };
} LINLOCKDATA2bits;
union {
    unsigned long long LINUNLOCKDATA2;
   struct 
    {
		unsigned char byte0:8;
        unsigned char byte1:8;
        unsigned char byte2:8;
        unsigned char byte3:8;
        unsigned char byte4:8;
        unsigned char byte5:8;
        unsigned char byte6:8;
        unsigned char byte7:8;
    };
} LINUNLOCKDATA2bits;

union {
    unsigned int LINBOOTUNLOCK;
   struct 
    {
		unsigned char start:1;
        unsigned char running:1;
        unsigned char wake_sent:1;
        unsigned char lock:1;
        unsigned char unlock:1;
        unsigned char command:4;
        unsigned int  :8;
    };
} LINBOOTUNLOCKbits;
union {
    unsigned long long LINBOOTUNLOCKDATA;
   struct 
    {
		unsigned char byte0:8;
        unsigned char byte1:8;
        unsigned char byte2:8;
        unsigned char byte3:8;
        unsigned char byte4:8;
        unsigned char byte5:8;
        unsigned char byte6:8;
        unsigned char byte7:8;
    };
} LINBOOTUNLOCKDATAbits;


//union {
//    unsigned int LINSTATUS;
//   struct 
//    {
//		unsigned char sleep:1;
//        unsigned char wake_transmitting:1;
//        unsigned int :6;        
//        unsigned char sleep_counter:8;
//
//    };
//} LINSTATUSbits;

union {
    unsigned long WEBASTO;
   struct 
    {
		unsigned char task_start:1;
        unsigned char start:1;
        unsigned char stop:1;
        unsigned char start_done:1;
        unsigned char stop_done:1;
        unsigned char :3;
        unsigned long counter:18;
        unsigned int :6;
    };
} WEBASTObits;

union {
    unsigned long LOCKAUTORUN;
   struct 
    {
		unsigned char start:1;
        unsigned int counter:16;
        unsigned char delay_counter:8;
        unsigned char :3;

    };
} LOCKAUTORUNbits;
union {
    unsigned int IGNINTROFFAUTORUN;
   struct 
    {
		unsigned char start:1;
        unsigned int counter:15;
    };
} IGNINTROFFAUTORUNbits;
union {
    unsigned long DOORAUTORUN;
   struct 
    {
		unsigned char start:1;
        unsigned int counter:16;
        unsigned char delay_counter:8;
        unsigned char engine_start_fail:1;
        unsigned char :2;

    };
} DOORAUTORUNbits;
union {
    unsigned long DOORAUTORUNO;
   struct 
    {
		unsigned char start:1;
        unsigned int counter:16;
        unsigned char delay_counter:8;
        unsigned char engine_start_fail:1;
        unsigned char :2;

    };
} DOORAUTORUNObits;

union {
    unsigned long ACCSAMPLS;
   struct 
    {
		int Gx:10;
		int Gy:10;
		int Gz:10;
		unsigned char crash_point:2;
    };
} ACCSAMPLSbits;

union {
    unsigned long long FWDTASCK;
   struct 
    {
        unsigned char start:1;
        unsigned char waiting_page:1;
        unsigned char page_received:1;
        unsigned char sector_downloaded:1;
        unsigned char download_complete:1;
        unsigned int  page_counter:14;
        unsigned char sector_counter:7;
        unsigned int  timeout_counter:12;
        unsigned long :26;

    };
} FWDTASCKbits;

union __attribute__ ((far))  {
    unsigned long KINITTASKS;
   struct 
    {
		unsigned char start:1;
        unsigned char sync:1;
        unsigned char kw1:1;
        unsigned char kw2:1;        
        unsigned char ini:1;
        unsigned char done:1;
        unsigned char waiting_response:1;
        unsigned char tasck_complete:1;
        unsigned char length:4;
        unsigned char num_of_:4;
        unsigned int type:2;
        
        unsigned int :14;
    };
} KINITTASKSbits;
union __attribute__ ((far))  {
    unsigned int KTASCKS;
   struct 
    {
        unsigned char start:1;
        unsigned char mode3_running:1;
        unsigned char mode3_done:1;
        unsigned char mode7_running:1;
        unsigned char mode7_done:1;
        unsigned char modeA_running:1;
        unsigned char modeA_done:1;
        unsigned char vin_running:1;
        unsigned char vin_done:1;        
        unsigned char :5;
    };
} KTASCKSbits;

union __attribute__ ((far))  {
    unsigned int KFASTINITTASKS;
   struct 
    {
		unsigned char start:1;
        unsigned char ini:1;
        unsigned char done:1;
        unsigned char waiting_response:1;        
        unsigned char tasck_complete:1;
        unsigned char length:4;
        unsigned char num_of_:4;
        unsigned char  type:2;
        
        unsigned char :1;
    };
} KFASTINITTASKSbits;
union __attribute__ ((far))  {
    unsigned int KFASTTASCKS;
   struct 
    {
        unsigned char start:1;
        unsigned char mode3_running:1;
        unsigned char mode3_done:1;
        unsigned char mode7_running:1;
        unsigned char mode7_done:1;
        unsigned char modeA_running:1;
        unsigned char modeA_done:1;
        unsigned char vin_running:1;
        unsigned char vin_done:1;        
        unsigned char :5;
    };
} KFASTTASCKSbits;

union __attribute__ ((far))  {
    unsigned char KFASTDTCRESETTASK;
   struct 
    {
		unsigned char start:1;
        unsigned char ini:1;
        unsigned char ini_running:1;
        unsigned char done:1;
        unsigned char waiting_response:1;        
        unsigned char :3;
    };
} KFASTDTCRESETTASKbits;

union __attribute__ ((far))  {
    unsigned long KFASTMILTASK;
   struct 
    {
		unsigned char start:1;
        unsigned char ini:1;
        unsigned char ini_running:1;
        unsigned char done:1;
        unsigned char waiting_response:1;        
        unsigned char :3;
        unsigned int request_timer:16;
        unsigned char :8;
    };
} KFASTMILTASKbits;

union __attribute__ ((far))  {
    unsigned char STATUSFLAGS1;
   struct 
    {
		unsigned char transponder_battery_flag:1;
        unsigned char transp_num:3;
        unsigned char transp_present:1;
        unsigned char ignition:1;
        unsigned char engine_running:1;
        unsigned char power_stable:1;
    };
} STATUSFLAGS1bits;//

union __attribute__ ((far))  {
    unsigned long long CAN1DATA;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;

    };
} CAN1DATAbits;
union __attribute__ ((far))  {
    unsigned long CANODO;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;
        unsigned char :8;

    };
} CANODObits;
union __attribute__ ((far))  {
    unsigned char CANDOORS;
   struct 
    {
		unsigned char dd:1;
        unsigned char fpd:1;
        unsigned char lrd:1;
        unsigned char rrd:1;
        unsigned char bn:1;
        unsigned char bt:1;
        unsigned char belt:1;
        unsigned char all_doors:1;        
    };
} CANDOORSbits;
union __attribute__ ((far))  {
    unsigned char CANDOORSTMP;
   struct 
    {
		unsigned char dd:1;
        unsigned char fpd:1;
        unsigned char lrd:1;
        unsigned char rrd:1;
        unsigned char bn:1;
        unsigned char bt:1;
        unsigned char belt:1;        
    };
} CANDOORSTMPbits;

union __attribute__ ((far))  {
    unsigned long long CANIGNPRMS;
   struct 
    {
		unsigned char can_number:2;
        unsigned char inv:1;
        unsigned char :5;        
        unsigned char filt_number:4;
        unsigned char byte:4;
        unsigned char bit_mask:8;
        unsigned long id:29;        
        unsigned int :11;
    };
} CANIGNPRMSbits;
union  {
    unsigned long long CANIGNPRMS2;
    struct 
    {
        
        unsigned long id:29;
        unsigned char byte:3;        
		unsigned char can_number:2;
        unsigned char :2;
        unsigned char filt_number:4;
        unsigned char bit_mask:8;        
        unsigned char value1:8;
        unsigned char value2:8;

    };
} CANIGNPRMS2bits;
union __attribute__ ((far))  {
    unsigned long long ENJSTATUSPRMS2;
   struct 
    {
		unsigned char can_number:2;
        unsigned char filt_number:4;
        unsigned char byte:3;        
        unsigned char bit_mask:8;        
        unsigned char value1:8;
        unsigned char value2:8;
        unsigned long id:29;
    };
} ENJSTATUSPRMS2bits;

union __attribute__ ((far))  {
    unsigned long long CANDDPRMS;
   struct 
    {
		unsigned char can_number:2;
        unsigned char inv:1;
        unsigned char :5;        
        unsigned char filt_number:4;
        unsigned char byte:4;
        unsigned char bit_mask:8;
        unsigned long id:29;        
        unsigned int :11;
    };
} CANDDPRMSbits;  // Дверь водителя
union __attribute__ ((far))  {
    unsigned long long CANFPDPRMS;
   struct 
    {
		unsigned char can_number:2;
        unsigned char inv:1;
        unsigned char :5;        
        unsigned char filt_number:4;
        unsigned char byte:4;
        unsigned char bit_mask:8;
        unsigned long id:29;        
        unsigned int :11;
    };
} CANFPDPRMSbits; // Передняя пассажирская дверь 
union __attribute__ ((far))  {
    unsigned long long CANBRPPRMS;
   struct 
    {
		unsigned char can_number:2;
        unsigned char inv:1;
        unsigned char :5;        
        unsigned char filt_number:4;
        unsigned char byte:4;
        unsigned char bit_mask:8;
        unsigned long id:29;        
        unsigned int :11;
    };
} CANBRPPRMSbits; // Педаль тормоза 
union __attribute__ ((far))  {
    unsigned long long CANRLDPRMS;
   struct 
    {
		unsigned char can_number:2;
        unsigned char inv:1;
        unsigned char :5;        
        unsigned char filt_number:4;
        unsigned char byte:4;
        unsigned char bit_mask:8;
        unsigned long id:29;        
        unsigned int :11;
    };
} CANRLDPRMSbits; // Левая задняя дверь
union __attribute__ ((far))  {
    unsigned long long CANRRDPRMS;
   struct 
    {
		unsigned char can_number:2;
        unsigned char inv:1;
        unsigned char :5;        
        unsigned char filt_number:4;
        unsigned char byte:4;
        unsigned char bit_mask:8;
        unsigned long id:29;        
        unsigned int :11;
    };
} CANRRDPRMSbits; // Правая задняя дверь
union __attribute__ ((far))  {
    unsigned long long CANBNPRMS;
   struct 
    {
		unsigned char can_number:2;
        unsigned char inv:1;
        unsigned char :5;        
        unsigned char filt_number:4;
        unsigned char byte:4;
        unsigned char bit_mask:8;
        unsigned long id:29;        
        unsigned int :11;
    };
} CANBNPRMSbits;// Багажник
union __attribute__ ((far))  {
    unsigned long long CANBTPRMS;
   struct 
    {
		unsigned char can_number:2;
        unsigned char inv:1;
        unsigned char :5;        
        unsigned char filt_number:4;
        unsigned char byte:4;
        unsigned char bit_mask:8;
        unsigned long id:29;        
        unsigned int :11;
    };
} CANBTPRMSbits;// Капот
union __attribute__ ((far))  {
    unsigned long long CANODOPRMS;
   struct 
    {
		unsigned char can_number:2;
        unsigned char filt_number:4;
        unsigned int :2;
        unsigned char byte0:8;
        unsigned char byte1:8;
        unsigned char byte2:8;
        unsigned long id:29;        
        unsigned int :3;
    };
} CANODOPRMSbits;//
union __attribute__ ((far))  {
    unsigned long long CANODOCHECKBYTES;
   struct 
    {
		unsigned char num1:4;
        unsigned char num2:4;
        unsigned char num3:4;
        unsigned char :4;
        unsigned char byte1:8;
        unsigned char byte2:8;
        unsigned char byte3:8;
        unsigned long :24;
    };
} CANODOCHECKBYTESbits;//
union __attribute__ ((far))  {
    unsigned long long CANFLPRMS;
   struct 
    {
		unsigned char can_number:2;
        unsigned char filt_number:4;
        unsigned long :2;
        unsigned char byte0:8;
        unsigned long id:29;
        unsigned char cntrl_byte_number:8;
        unsigned char cntrl_byte:8;
        unsigned char :3;

    };
} CANFLPRMSbits;//
union __attribute__ ((far))  {
    unsigned long long CANFL2PRMS;
   struct 
    {
		unsigned char can_number:2;
        unsigned char filt_number:4;
        unsigned long :2;
        unsigned char byte0:8;
        unsigned char byte1:8;
        unsigned long id:29;        
        unsigned long :11;

    };
} CANFL2PRMSbits;//
union __attribute__ ((far))  {
    unsigned long long RPMPRMS;
   struct 
    {
		unsigned char can_number:2;
        unsigned char filt_number:4;
        unsigned long :2;
        unsigned char byte0:8;
        unsigned char byte1:8;
        unsigned long id:29;        
        unsigned long :11;

    };
} RPMPRMSbits;//
union __attribute__ ((far))  {
    unsigned long long TOYOTAKEYDAT;
   struct 
    {
		unsigned char can_number:2;
        unsigned char filt_number:4;
        unsigned long :2;
        unsigned char :8;
        unsigned char :8;
        unsigned long id:29;        
        unsigned long :11;

    };
} TOYOTAKEYDATbits;//

union __attribute__ ((far))  {
    unsigned long long CANFL3PRMS;
   struct 
    {
		unsigned char can_number:2;
        unsigned char filt_number:4;
        unsigned long :2;
        unsigned char byte0:8;
        unsigned char byte1:8;
        unsigned long id:29;        
        unsigned long :11;

    };
} CANFL3PRMSbits;//
union __attribute__ ((far))  {
    unsigned long long CANFLCNPNPRMS;
   struct 
    {
		unsigned char can_number:2;
        unsigned char filt_number:4;
        unsigned long :2;
        unsigned char byte0:8;
        unsigned long id:29;        
        unsigned long :19;

    };
} CANFLCNPNPRMSbits;//
union __attribute__ ((far))  {
    unsigned long long CANBELTPRMS;
   struct 
    {
		unsigned char can_number:2;
        unsigned char inv:1;
        unsigned char :5;        
        unsigned char filt_number:4;
        unsigned char byte:4;
        unsigned char bit_mask:8;
        unsigned long id:29;        
        unsigned int :11;
    };
} CANBELTPRMSbits;//
union __attribute__ ((far))  {
    unsigned long long LOCKSTATPRMS;
   struct 
    {
		unsigned char can_number:2;
        unsigned char inv:1;
        unsigned char :5;        
        unsigned char filt_number:4;
        unsigned char byte:4;
        unsigned char bit_mask:8;
        unsigned long id:29;        
        unsigned int :11;
    };
} LOCKSTATPRMSbits;
union __attribute__ ((far))  {
    unsigned long long BOOTLOCKSTATPRMS;
   struct 
    {
		unsigned char can_number:2;
        unsigned char inv:1;
        unsigned char :5;        
        unsigned char filt_number:4;
        unsigned char byte:4;
        unsigned char bit_mask:8;
        unsigned long id:29;        
        unsigned int :11;
    };
} BOOTLOCKSTATPRMSbits;
union __attribute__ ((far))  {
    unsigned long long LOCKSTATPRMS2;
   struct 
    {
		unsigned char can_number:2;
        unsigned char filt_number:4;
        unsigned char byte:3;        
        unsigned char bit_mask:8;        
        unsigned char value1:8;
        unsigned char value2:8;
        unsigned long id:29;        
    };
} LOCKSTATPRMS2bits;//
union __attribute__ ((far))  {
    unsigned long long LOCKSTATPRMS3;
   struct 
    {
        unsigned long id:29;
        unsigned char byte:3;        
		unsigned char can_number:2;
        unsigned char :2;
        unsigned char filt_number:4;
        unsigned char bit_mask:8;        
        unsigned char value1:8;
        unsigned char value2:8;        
    };
} LOCKSTATPRMS3bits;//
union __attribute__ ((far))  {
    unsigned char CANRESET;
   struct 
    {
		unsigned char start:1;
        unsigned char counter:7;
    };
} CANRESETbits;//
union __attribute__ ((far))  {
    unsigned int CANODOEXIST;
   struct 
    {
		unsigned char exist_mes1:1;
        unsigned char exist_mes2:1;
        unsigned char exist_mes3:1;
        unsigned char      :5;
    };
} CANODOEXISTbits;
union __attribute__ ((far))  {
    unsigned long long WEBASTOSTATPRMS;
   struct 
    {
		unsigned char can_number:2;
        unsigned char inv:1;
        unsigned char :5;        
        unsigned char filt_number:4;
        unsigned char byte:4;
        unsigned char bit_mask:8;
        unsigned long id:29;        
        unsigned int :11;
    };
} WEBASTOSTATPRMSbits;
union __attribute__ ((far))  {
    unsigned long long ALARMSTATPRMS2;
   struct 
    {
		unsigned char can_number:2;
        unsigned char filt_number:4;
        unsigned char byte:3;        
        unsigned char bit_mask:8;        
        unsigned char value1:8;
        unsigned char value2:8;
        unsigned long id:29;        
    };
} ALARMSTATPRMS2bits;//
union __attribute__ ((far))  {
    unsigned long long GEARBOXSTATPRMS2;
   struct 
    {
		unsigned char can_number:2;
        unsigned char filt_number:4;
        unsigned char byte:3;        
        unsigned char bit_mask:8;        
        unsigned char value1:8;
        unsigned char value2:8;
        unsigned long id:29;        
    };
} GEARBOXSTATPRMS2bits;//
union __attribute__ ((far))  {
    unsigned long long CANLOCKBYTESPRMS;
   struct 
    {
		unsigned char can_number:2;
        unsigned char filt_number:4;
        unsigned int :2;
        unsigned char byte0:8;
        unsigned char byte1:8;
        unsigned char byte2:8;
        unsigned long id:29;        
        unsigned int :3;
    };
} CANLOCKBYTESPRMSbits;//
union __attribute__ ((far))  {
    unsigned int CANLOCKBYTESPRMS2;
   struct 
    {
        unsigned char byte3:8;
        unsigned char byte4:8;
    };
} CANLOCKBYTESPRMS2bits;
union __attribute__ ((far))  {
    unsigned long long CANLOCKCHECKBYTES;
   struct 
    {
        unsigned char num0:8;
        unsigned char num1:8;
        unsigned char num2:8;       
        unsigned char byte0:8;
        unsigned char byte1:8;
        unsigned char byte2:8;
        unsigned int :16;
    };
} CANLOCKCHECKBYTESbits;
union __attribute__ ((far))  {
    unsigned long long CANLIGHTSPRMS;
   struct 
    {
		unsigned char can_number:2;
        unsigned char inv:1;
        unsigned char :5;        
        unsigned char filt_number:4;
        unsigned char byte:4;
        unsigned char bit_mask:8;
        unsigned long id:29;        
        unsigned int :11;
    };
} CANLIGHTSPRMSbits;  // Ближний свет
union __attribute__ ((far))  {
    unsigned long long CANTLLIGHTSPRMS;
   struct 
    {
		unsigned char can_number:2;
        unsigned char inv:1;
        unsigned char :5;        
        unsigned char filt_number:4;
        unsigned char byte:4;
        unsigned char bit_mask:8;
        unsigned long id:29;        
        unsigned int :11;
    };
} CANTLLIGHTSPRMSbits;  // Поворотники
union __attribute__ ((far))  {
    unsigned long long CANTRLIGHTSPRMS;
   struct 
    {
		unsigned char can_number:2;
        unsigned char inv:1;
        unsigned char :5;        
        unsigned char filt_number:4;
        unsigned char byte:4;
        unsigned char bit_mask:8;
        unsigned long id:29;        
        unsigned int :11;
    };
} CANTRLIGHTSPRMSbits;  // Поворотники

union __attribute__ ((far))  {
    unsigned long OBDTASCKS;
   struct 
    {
		unsigned char ECM_mode1_00:1;// поддерживаемые пиды 01-1f
        unsigned char ECM_mode1_01:1;// MIL, DTC count
        unsigned char mode3:1;   // DTCs
        unsigned char mode4:1;   // стереть ошибки, погасить чек энджайн
        unsigned char mode7:1;   // pending DTCs
        unsigned char ECM_mode9_02:1;// VIN
        unsigned char modeA:1;   // permanent DTCs

        unsigned char TCM_mode1_00:1; // поддерживаемые пиды 01-1f
        unsigned char TCM_mode1_01:1; // MIL, DTC count
        unsigned char TCM_mode1_05:1; // температура охлаждающей жидкости
        unsigned char TCM_mode1_0C:1; // обороты двигателя
        unsigned char TCM_mode1_0D:1; // скорость автомобиля
        unsigned char TCM_mode3:1;    // DTCs
        unsigned char TCM_mode4:1;    // стереть ошибки, погасить чек энджайн
        unsigned char TCM_mode7:1;    // стереть ошибки, погасить чек энджайн
        
        unsigned char ABS_mode4:1;    // стереть ошибки, погасить чек энджайн
        unsigned char ABS_mode7:1;    // DTCs
        
        unsigned char      :5;
    };
} OBDTASCKSbits;
union __attribute__ ((far))  {
    unsigned long OBDTIMER;
   struct 
    {
		unsigned char start:1;
        unsigned char timeout:1;
        unsigned int timer:16;
        unsigned int request_timeout:16;
    };
} OBDTIMERbits;
union __attribute__ ((far))  {
    unsigned char GETVIN;
   struct 
    {
		unsigned char start:1;
        unsigned char message_counter:4;
        unsigned char :3;
    };
} GETVINbits;
union __attribute__ ((far))  {
    unsigned char GETMIL;
   struct 
    {
		unsigned char start:1;
        unsigned char message_counter:4;
        unsigned char :3;
    };
} GETMILbits;
union __attribute__ ((far))  {
    unsigned long ECMPIDS1;
   struct 
    {
		unsigned char_01:1;
        unsigned char message_counter:4;
        unsigned char :3;
    };
} ECMPIDS1bits;
union __attribute__ ((far))  {
    unsigned int FUELTASCKS;
   struct 
    {
		unsigned char running:1;
        unsigned char data_ready:1;
        unsigned char data_not_exist:1;
        unsigned char :5;
    };
} FUELTASCKSbits;

union __attribute__ ((far))  {
    unsigned long OBDRPMREQ;
   struct 
    {
		unsigned char   start:1;
        unsigned char    stop:1;
        unsigned char        :6;
        unsigned long counter:24;

    };
} OBDRPMREQbits;

union __attribute__ ((far))  {
    unsigned long long MODE3;
   struct 
    {
		unsigned char start:1;
        unsigned char :3;
        unsigned char message_counter1:4;
        unsigned char message_counter2:4;
        unsigned char message_counter3:4;
        unsigned char message_num:8;
        unsigned char dtc_num_bytes1:8;
        unsigned char dtc_num_bytes2:8;
        unsigned char dtc_num_bytes3:8;
        unsigned int :16;
    };
} MODE3bits;
union __attribute__ ((far))  {
    unsigned char MODE7;
   struct 
    {
		unsigned char start:1;
        unsigned char message_counter:7;
//        unsigned char :3;
    };
} MODE7bits;
union __attribute__ ((far))  {
    unsigned char MODEA;
   struct 
    {
		unsigned char start:1;
        unsigned char message_counter:7;
//        unsigned char :3;
    };
} MODEAbits;

union __attribute__ ((far))  {
    unsigned int CRASHTASK;
   struct 
    {
		unsigned char crash_trigger:1;
        unsigned char crash_record_done:1;
        unsigned char trek_record_done:1;
        unsigned int post_acc_counter:9;
        unsigned int post_trek_counter:4;

    };
} CRASHTASKbits;
union __attribute__ ((far))  {
    unsigned char CRASHSAVETASK;
   struct 
    {
		unsigned char samples_saving:1;
        unsigned char trek_saving:1;
        unsigned char verification:1;
		unsigned char samples_saving_done:1;
        unsigned char trek_saving_done:1;        
        unsigned char :2;//!!!!!!
    };
} CRASHSAVETASKbits;
union __attribute__ ((far))  {
    unsigned char FWSAVETASK;
   struct 
    {
		unsigned char fw_saving:1;
        unsigned char verification:1;
		unsigned char fw_saving_done:1;
        
        unsigned char :5;//!!!!!!
    };
} FWSAVETASKbits;

union __attribute__ ((far))  {
    unsigned int RESETREASON;
   struct 
    {
		unsigned char reset_flag:1;
		unsigned char TRAPR:1;
		unsigned char IOPUWR:1;
		unsigned char EXTR:1; 
		unsigned char SWR:1; 
		unsigned char WDTO:1; 
		unsigned char BOR:1; 
		unsigned char POR:1;
        
        unsigned char :8;//!!!!!!
    };
} RESETREASONbits;
union __attribute__ ((far))  {
    unsigned int MEMRESFLAGS;
   struct 
    {
		unsigned char can_set:1;
		unsigned char can_dat:1;
		unsigned char flash1:1;
		unsigned char flash2:1; 
		unsigned char flash_acc:1;
        unsigned char modem_init:1;
        unsigned int :9;
        unsigned char flash_fw:1;
    };
} MEMRESFLAGSbits;


union __attribute__ ((far))  {
    unsigned char TIMEDDAT;

    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;
    };    
} TIMEDDATbits; //1
union __attribute__ ((far))  {
    unsigned char TIMEDWBSTDAT;

    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;
    };    
} TIMEDWBSTDATbits; //82
union __attribute__ ((far))  {
    unsigned long long DISTDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };   
} DISTDATbits; //2
union __attribute__ ((far))  {
    unsigned long long HEADINGDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };    
} HEADINGDATbits; //3
union __attribute__ ((far))  {
    unsigned char IGNONDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };
    
} IGNONDATbits; //4
union __attribute__ ((far))  {
    unsigned long long IGNOFFDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;
;
    };
} IGNOFFDATbits; //5
union __attribute__ ((far))  {
    unsigned long long POWERONDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };    
} POWERONDATbits; //6
union __attribute__ ((far))  {
    unsigned long long POWEROFFDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} POWEROFFDATbits; //7
union __attribute__ ((far))  {
    unsigned long long IDLESTARTDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} IDLESTARTDATbits; //8
union __attribute__ ((far))  {
    unsigned long long IDLEENDDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} IDLEENDDATbits; //9
union __attribute__ ((far))  {
    unsigned long long DINAMICCALDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} DINAMICCALDATbits; //26
union __attribute__ ((far))  {
    unsigned long long ARMDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} ARMDATbits; //27
union __attribute__ ((far))  {
    unsigned long long DISARMDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} DISARMDATbits; //28
union __attribute__ ((far))  {
    unsigned long long INTRUSIONDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} INTRUSIONDATbits; //29
union __attribute__ ((far))  {
    unsigned long long SERVONDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} SERVONDATbits; //30
union __attribute__ ((far))  {
    unsigned long long SERVOFFDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} SERVOFFDATbits; //31
union __attribute__ ((far))  {
    unsigned long long SERVAUTOOFFDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };    
} SERVAUTOOFFDATbits; //32
union __attribute__ ((far))  {
    unsigned long long STARTUNSUCCESSDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} STARTUNSUCCESSDATbits; //33
union __attribute__ ((far))  {
    unsigned long long STARTSUCCESSDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} STARTSUCCESSDATbits; //34
union __attribute__ ((far))  {
    unsigned long long LOCKOPENDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} LOCKOPENDATbits; //35
union __attribute__ ((far))  {
    unsigned long long LOCKCLOSEDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} LOCKCLOSEDATbits; //36
union __attribute__ ((far))  {
    unsigned long long AUTORUNCOMMANDDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} AUTORUNCOMMANDDATbits; //37
union __attribute__ ((far))  {
    unsigned long long ROBBERYDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} ROBBERYDATbits; //39
union __attribute__ ((far))  {
    unsigned long long TILTDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };    
} TILTDATbits; //40
union __attribute__ ((far))  {
    unsigned long long FWRNWDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} FWRNWDATbits; //41
union __attribute__ ((far))  {
    unsigned long long FWDLDDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} FWDLDDATbits; //42
union __attribute__ ((far))  {
    unsigned long long LOCKCOMMANDDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} LOCKCOMMANDDATbits; //43
union __attribute__ ((far))  {
    unsigned long long UNLOCKCOMMANDDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };    
} UNLOCKCOMMANDDATbits; //44
union __attribute__ ((far))  {
    unsigned long long TNUMSDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} TNUMSDATbits; //45
union __attribute__ ((far))  {
    unsigned long long PANICDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} PANICDATbits;  //46
union __attribute__ ((far))  {
    unsigned long long STATICCALDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} STATICCALDATbits; //47
union __attribute__ ((far))  {
    unsigned long long UNITSTATUSDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} UNITSTATUSDATbits; //49
union __attribute__ ((far))  {
    unsigned long long CRASHDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} CRASHDATbits; //49
union __attribute__ ((far))  {
    unsigned long long ACCDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} ACCDATbits; //10 - 25
union __attribute__ ((far))  {
    unsigned long long ACCCHARTSDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} ACCCHARTSDATbits; //10 - 25 тип2
union __attribute__ ((far))  {
    unsigned long long VINDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} VINDATbits; //38, 48
union __attribute__ ((far))  {
    unsigned long long DTCDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} DTCDATbits; //26, 27 тип2
union __attribute__ ((far))  {
    unsigned char DTCWBUSDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} DTCWBUSDATbits; //26, 27 тип2
union __attribute__ ((far))  {
    unsigned char WEBASTOONDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} WEBASTOONDATbits; //51 тип 1
union __attribute__ ((far))  {
    unsigned char WEBASTOOFFDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} WEBASTOOFFDATbits; //52 тип 1
union __attribute__ ((far))  {
    unsigned char REPORTDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} REPORTDATbits; //53 тип 1
union __attribute__ ((far))  {
    unsigned char ALARMDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} ALARMDATbits; //55 тип 1
union __attribute__ ((far))  {
    unsigned char PWOFFMSGDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} PWOFFMSGDATbits; //56 тип 1
union __attribute__ ((far))  {
    unsigned char MILMSGDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} MILMSGDATbits; //56 тип 1
union __attribute__ ((far))  {
    unsigned char GEARBOXDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} GEARBOXDATbits; //56 тип 1
union __attribute__ ((far))  {
    unsigned char BATLOWDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} BATLOWDATbits; //56 тип 1
union __attribute__ ((far))  {
    unsigned long long BOOTLOCKOPENDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} BOOTLOCKOPENDATbits; //61
union __attribute__ ((far))  {
    unsigned long long BOOTLOCKCLOSEDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} BOOTLOCKCLOSEDATbits; //62
union __attribute__ ((far))  {
    unsigned char SPEEDDAT;

    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;
    };    
} SPEEDDATbits; //63
union __attribute__ ((far))  {
    unsigned int SPEEDSET;

    struct
    {
		unsigned char speed:8;
		unsigned char time:8;

    };    
} SPEEDSETbits; //63
union __attribute__ ((far))  {
    unsigned char BLINKRPTRDAT;

    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;
    };    
} BLINKRPTRDATbits; //63

union __attribute__ ((far))  {
    unsigned long CRASHSET;
    struct
    {
        unsigned char  duration:6;
		unsigned int gxy:13;
        unsigned int gxyz:13;
    };     
} CRASHSETbits; //50 тип 1
union __attribute__ ((far))  {
    unsigned long CRASHSETIGNOFF;
    struct
    {
        unsigned char  duration:6;
		unsigned int gxy:13;
        unsigned int gxyz:13;
    };     
} CRASHSETIGNOFFbits; //50 тип 1
union __attribute__ ((far))  {
    unsigned long ROBBERYSET;
    struct
    {
        unsigned int  duration:16;
        unsigned char speed:8;
        unsigned char :8;
    };     
} ROBBERYSETbits; //39 тип 1
union __attribute__ ((far))  {
    unsigned int TILTSET;
    struct
    {
        unsigned char duration:6;
        unsigned int  treshold:10;
    };     
} TILTSETbits; //40 тип 1
union __attribute__ ((far))  {
    unsigned long REPORTSET;
    struct
    {
        unsigned long  period:32;
    };     
} REPORTSETbits; //40 тип 1
union __attribute__ ((far))  {
    unsigned long TESTMSGSET;
    struct
    {
        unsigned char start:1;
        unsigned char mem:2;
        unsigned int period:12;
        unsigned int number_of_attempts:16;
        unsigned char :1;
    };     
} TESTMSGSETbits; //40 тип 1
union __attribute__ ((far))  {
    unsigned long PWOFFMSGSET;
    struct
    {
        unsigned long  period:32;
    };     
} PWOFFMSGSETbits; //40 тип 1
union __attribute__ ((far))  {
    unsigned long BATLOWSET;
   struct 
    {
            unsigned char on_treshold:8;
            unsigned char off_treshold:8;
            unsigned int delay:15;            
            unsigned char triggered:1;

        };
    } BATLOWSETbits;
union __attribute__ ((far))  {
    unsigned long IGNPULSVFALLTSET;
   struct 
    {
            unsigned char enable:8;
            unsigned char voltage_treshold:8;
            unsigned int timer_value:16;            
        };
    } IGNPULSVFALLTSETbits;
union __attribute__ ((far))  {
    unsigned long IGNPULSVFALLTASCK;
   struct 
    {
        unsigned char start:8;
        unsigned int  timer:16;            
    };
    } IGNPULSVFALLTASCKbits;    
    
union __attribute__ ((far))  {
    unsigned long long CANREQ1SET;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} CANREQ1SETbits;    
union __attribute__ ((far))  {
    unsigned long long CANREQ1DAT;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} CANREQ1DATbits;
union __attribute__ ((far))  {
    unsigned long long CANREQ2SET;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} CANREQ2SETbits;    
union __attribute__ ((far))  {
    unsigned long long CANREQ2DAT;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} CANREQ2DATbits;
union __attribute__ ((far))  {
    unsigned long long CANREQ3SET;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} CANREQ3SETbits;    
union __attribute__ ((far))  {
    unsigned long long CANREQ3DAT;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} CANREQ3DATbits;

union __attribute__ ((far))  {
    unsigned long long DOPENSET1;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} DOPENSET1bits;    
union __attribute__ ((far))  {
    unsigned long long DOPENDAT1;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} DOPENDAT1bits;
union __attribute__ ((far))  {
    unsigned long DOPENTIME1;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;
        unsigned char B3:8;        
    };
} DOPENTIME1bits;

union __attribute__ ((far))  {
    unsigned long long CLOCKSET1;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} CLOCKSET1bits;    
union __attribute__ ((far))  {
    unsigned long long CLOCKDAT1;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} CLOCKDAT1bits;
union __attribute__ ((far))  {
    unsigned long long CLOCKTIME1;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} CLOCKTIME1bits;

union __attribute__ ((far))  {
    unsigned long long CLOCKSET2;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} CLOCKSET2bits;    
union __attribute__ ((far))  {
    unsigned long long CLOCKDAT2;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} CLOCKDAT2bits;
union __attribute__ ((far))  {
    unsigned long long CLOCKTIME2;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} CLOCKTIME2bits;

union __attribute__ ((far))  {
    unsigned long long CLOCKSET3;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} CLOCKSET3bits;    
union __attribute__ ((far))  {
    unsigned long long CLOCKDAT3;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} CLOCKDAT3bits;
union __attribute__ ((far))  {
    unsigned long long CLOCKTIME3;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} CLOCKTIME3bits;

union __attribute__ ((far))  {
    unsigned long long CUNLOCKSET1;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} CUNLOCKSET1bits;    
union __attribute__ ((far))  {
    unsigned long long CUNLOCKDAT1;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} CUNLOCKDAT1bits;

union __attribute__ ((far))  {
    unsigned long long CUNLOCKSET2;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} CUNLOCKSET2bits;    
union __attribute__ ((far))  {
    unsigned long long CUNLOCKDAT2;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} CUNLOCKDAT2bits;

union __attribute__ ((far))  {
    unsigned long long CUNLOCKSET3;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} CUNLOCKSET3bits;    
union __attribute__ ((far))  {
    unsigned long long CUNLOCKDAT3;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} CUNLOCKDAT3bits;


union __attribute__ ((far))  {
    unsigned long long CBTUNLOCKSET1;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} CBTUNLOCKSET1bits;    
union __attribute__ ((far))  {
    unsigned long long CBTUNLOCKDAT1;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} CBTUNLOCKDAT1bits;
union __attribute__ ((far))  {
    unsigned long long CBTUNLOCKTIME1;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} CBTUNLOCKTIME1bits;

union __attribute__ ((far))  {
    unsigned long long CBTUNLOCKSET2;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} CBTUNLOCKSET2bits;    
union __attribute__ ((far))  {
    unsigned long long CBTUNLOCKDAT2;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} CBTUNLOCKDAT2bits;
union __attribute__ ((far))  {
    unsigned long long CBTUNLOCKTIME2;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} CBTUNLOCKTIME2bits;

union __attribute__ ((far))  {
    unsigned long long CBTUNLOCKSET3;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} CBTUNLOCKSET3bits;    
union __attribute__ ((far))  {
    unsigned long long CBTUNLOCKDAT3;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} CBTUNLOCKDAT3bits;
union __attribute__ ((far))  {
    unsigned long long CBTUNLOCKTIME3;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} CBTUNLOCKTIME3bits;

//STARTENGINEC
union __attribute__ ((far))  {
    unsigned long long STRTENGCSTARTSET1;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} STRTENGCSTARTSET1bits;    
union __attribute__ ((far))  {
    unsigned long long STRTENGCSTARTDAT1;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} STRTENGCSTARTDAT1bits;
union __attribute__ ((far))  {
    unsigned long long STRTENGCSTARTTIME1;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} STRTENGCSTARTTIME1bits;

union __attribute__ ((far))  {
    unsigned long long STRTENGCSTARTSET2;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} STRTENGCSTARTSET2bits;    
union __attribute__ ((far))  {
    unsigned long long STRTENGCSTARTDAT2;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} STRTENGCSTARTDAT2bits;
union __attribute__ ((far))  {
    unsigned long long STRTENGCSTARTTIME2;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} STRTENGCSTARTTIME2bits;

union __attribute__ ((far))  {
    unsigned long long STRTENGCSTARTSET3;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} STRTENGCSTARTSET3bits;    
union __attribute__ ((far))  {
    unsigned long long STRTENGCSTARTDAT3;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} STRTENGCSTARTDAT3bits;
union __attribute__ ((far))  {
    unsigned long long STRTENGCSTARTTIME3;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} STRTENGCSTARTTIME3bits;

union __attribute__ ((far))  {
    unsigned long long STRTENGCSTARTSET4;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} STRTENGCSTARTSET4bits;    
union __attribute__ ((far))  {
    unsigned long long STRTENGCSTARTDAT4;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} STRTENGCSTARTDAT4bits;
union __attribute__ ((far))  {
    unsigned long long STRTENGCSTARTTIME4;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} STRTENGCSTARTTIME4bits;

union __attribute__ ((far))  {
    unsigned long long STRTENGCSTARTSET5;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} STRTENGCSTARTSET5bits;    
union __attribute__ ((far))  {
    unsigned long long STRTENGCSTARTDAT5;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} STRTENGCSTARTDAT5bits;
union __attribute__ ((far))  {
    unsigned long long STRTENGCSTARTTIME5;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} STRTENGCSTARTTIME5bits;
//STRTENGC
union __attribute__ ((far))  {
    unsigned long long STRTENGCSTOPSET1;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} STRTENGCSTOPSET1bits;   
union __attribute__ ((far))  {
    unsigned long long STRTENGCSTOPDAT1;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} STRTENGCSTOPDAT1bits;
union __attribute__ ((far))  {
    unsigned long long STRTENGCSTOPTIME1;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} STRTENGCSTOPTIME1bits;

union __attribute__ ((far))  {
    unsigned long long STRTENGCSTOPSET2;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} STRTENGCSTOPSET2bits;    
union __attribute__ ((far))  {
    unsigned long long STRTENGCSTOPDAT2;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} STRTENGCSTOPDAT2bits;
union __attribute__ ((far))  {
    unsigned long long STRTENGCSTOPTIME2;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} STRTENGCSTOPTIME2bits;

union __attribute__ ((far))  {
    unsigned long long STRTENGCSTOPSET3;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} STRTENGCSTOPSET3bits;    
union __attribute__ ((far))  {
    unsigned long long STRTENGCSTOPDAT3;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} STRTENGCSTOPDAT3bits;
union __attribute__ ((far))  {
    unsigned long long STRTENGCSTOPTIME3;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} STRTENGCSTOPTIME3bits;

union __attribute__ ((far))  {
    unsigned long long STRTENGCSTOPSET4;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} STRTENGCSTOPSET4bits;    
union __attribute__ ((far))  {
    unsigned long long STRTENGCSTOPDAT4;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} STRTENGCSTOPDAT4bits;
union __attribute__ ((far))  {
    unsigned long long STRTENGCSTOPTIME4;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} STRTENGCSTOPTIME4bits;

union __attribute__ ((far))  {
    unsigned long long STRTENGCSTOPSET5;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} STRTENGCSTOPSET5bits;    
union __attribute__ ((far))  {
    unsigned long long STRTENGCSTOPDAT5;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} STRTENGCSTOPDAT5bits;
union __attribute__ ((far))  {
    unsigned long long STRTENGCSTOPTIME5;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} STRTENGCSTOPTIME5bits;


/**/

union __attribute__ ((far))  {
    unsigned long long WBSTSTARTSET1;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} WBSTSTARTSET1bits;    
union __attribute__ ((far))  {
    unsigned long long WBSTSTARTDAT1;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} WBSTSTARTDAT1bits;
union __attribute__ ((far))  {
    unsigned long long WBSTSTARTTIME1;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} WBSTSTARTTIME1bits;

union __attribute__ ((far))  {
    unsigned long long WBSTSTARTSET2;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} WBSTSTARTSET2bits;    
union __attribute__ ((far))  {
    unsigned long long WBSTSTARTDAT2;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} WBSTSTARTDAT2bits;
union __attribute__ ((far))  {
    unsigned long long WBSTSTARTTIME2;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} WBSTSTARTTIME2bits;

union __attribute__ ((far))  {
    unsigned long long WBSTSTARTSET3;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} WBSTSTARTSET3bits;    
union __attribute__ ((far))  {
    unsigned long long WBSTSTARTDAT3;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} WBSTSTARTDAT3bits;
union __attribute__ ((far))  {
    unsigned long long WBSTSTARTTIME3;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} WBSTSTARTTIME3bits;

union __attribute__ ((far))  {
    unsigned long long WBSTSTARTSET4;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} WBSTSTARTSET4bits;    
union __attribute__ ((far))  {
    unsigned long long WBSTSTARTDAT4;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} WBSTSTARTDAT4bits;
union __attribute__ ((far))  {
    unsigned long long WBSTSTARTTIME4;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} WBSTSTARTTIME4bits;

union __attribute__ ((far))  {
    unsigned long long WBSTSTARTSET5;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} WBSTSTARTSET5bits;    
union __attribute__ ((far))  {
    unsigned long long WBSTSTARTDAT5;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} WBSTSTARTDAT5bits;
union __attribute__ ((far))  {
    unsigned long long WBSTSTARTTIME5;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} WBSTSTARTTIME5bits;

union __attribute__ ((far))  {
    unsigned long long WBSTSTARTSET6;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} WBSTSTARTSET6bits;    
union __attribute__ ((far))  {
    unsigned long long WBSTSTARTDAT6;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} WBSTSTARTDAT6bits;
union __attribute__ ((far))  {
    unsigned long long WBSTSTARTTIME6;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} WBSTSTARTTIME6bits;
/*
union __attribute__ ((far))  {
    unsigned long long WBSTSTARTSET7;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} WBSTSTARTSET7bits;    
union __attribute__ ((far))  {
    unsigned long long WBSTSTARTDAT7;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} WBSTSTARTDAT7bits;
union __attribute__ ((far))  {
    unsigned long long WBSTSTARTTIME7;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} WBSTSTARTTIME7bits;
*/
union __attribute__ ((far))  {
    unsigned long long WBSTSTOPSET1;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} WBSTSTOPSET1bits;   
union __attribute__ ((far))  {
    unsigned long long WBSTSTOPDAT1;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} WBSTSTOPDAT1bits;
union __attribute__ ((far))  {
    unsigned long long WBSTSTOPTIME1;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} WBSTSTOPTIME1bits;

union __attribute__ ((far))  {
    unsigned long long WBSTSTOPSET2;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} WBSTSTOPSET2bits;    
union __attribute__ ((far))  {
    unsigned long long WBSTSTOPDAT2;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} WBSTSTOPDAT2bits;
union __attribute__ ((far))  {
    unsigned long long WBSTSTOPTIME2;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} WBSTSTOPTIME2bits;

union __attribute__ ((far))  {
    unsigned long long WBSTSTOPSET3;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} WBSTSTOPSET3bits;    
union __attribute__ ((far))  {
    unsigned long long WBSTSTOPDAT3;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} WBSTSTOPDAT3bits;
union __attribute__ ((far))  {
    unsigned long long WBSTSTOPTIME3;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} WBSTSTOPTIME3bits;

union __attribute__ ((far))  {
    unsigned long long WBSTSTOPSET4;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} WBSTSTOPSET4bits;    
union __attribute__ ((far))  {
    unsigned long long WBSTSTOPDAT4;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} WBSTSTOPDAT4bits;
union __attribute__ ((far))  {
    unsigned long long WBSTSTOPTIME4;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} WBSTSTOPTIME4bits;

union __attribute__ ((far))  {
    unsigned long long WBSTSTOPSET5;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} WBSTSTOPSET5bits;    
union __attribute__ ((far))  {
    unsigned long long WBSTSTOPDAT5;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} WBSTSTOPDAT5bits;
union __attribute__ ((far))  {
    unsigned long long WBSTSTOPTIME5;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} WBSTSTOPTIME5bits;

union __attribute__ ((far))  {
    unsigned long long WBSTSTOPSET6;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} WBSTSTOPSET6bits;    
union __attribute__ ((far))  {
    unsigned long long WBSTSTOPDAT6;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} WBSTSTOPDAT6bits;
union __attribute__ ((far))  {
    unsigned long long WBSTSTOPTIME6;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} WBSTSTOPTIME6bits;
/*
union __attribute__ ((far))  {
    unsigned long long WBSTSTOPSET7;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} WBSTSTOPSET7bits;    
union __attribute__ ((far))  {
    unsigned long long WBSTSTOPDAT7;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} WBSTSTOPDAT7bits;
union __attribute__ ((far))  {
    unsigned long long WBSTSTOPTIME7;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} WBSTSTOPTIME7bits;
*/
union __attribute__ ((far))  {
    unsigned long long WBSTRSET1;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} WBSTRSET1bits;    
union __attribute__ ((far))  {
    unsigned long long WBSTRDAT1;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} WBSTRDAT1bits;
union __attribute__ ((far))  {
    unsigned long long WBSTRTIME1;
   struct 
    {
		unsigned char B0:8;
        unsigned char B1:8;
        unsigned char B2:8;        
        unsigned char B3:8;
        unsigned char B4:8;
        unsigned char B5:8;
        unsigned char B6:8;
        unsigned char B7:8;
    };
} WBSTRTIME1bits;
union __attribute__ ((far))  {
    unsigned long long WBSTCANWAKETIME;
   struct 
    {
		unsigned int      period:16;
        unsigned int after_delay:16;
        unsigned long           :32;
    };
} WBSTCANWAKETIMEbits;

union __attribute__ ((far))  {
    unsigned long long WBSTCANWAKESET;
   struct 
    {
		unsigned char can_number:2;
        unsigned char len:6;
        unsigned long id:29;        
        unsigned long :27;
    };
} WBSTCANWAKESETbits;    
union __attribute__ ((far))  {
    unsigned long long WBSTCANWAKESTARTDAT;
   struct 
    {
		unsigned char B7:8;
        unsigned char B6:8;
        unsigned char B5:8;        
        unsigned char B4:8;
        unsigned char B3:8;
        unsigned char B2:8;
        unsigned char B1:8;
        unsigned char B0:8;
    };
} WBSTCANWAKESTARTDATbits;

union __attribute__ ((far))  {
    unsigned char LIGTSDAT;

    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;
    };    
} LIGTSDATbits; //74
union __attribute__ ((far))  {
    unsigned char TRLIGTSDAT;

    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;
    };    
} TRTLLIGTSDATbits; //76


union __attribute__ ((far))  {
    unsigned int PERIFSLEEPSET;
   struct 
    {
		unsigned char modem:1;
        unsigned char rf:1;
        unsigned char can1:1;        
        unsigned char can2:1;
        unsigned char acc:1;
        unsigned char modem_sleep_off:1;
        unsigned char :1;
        unsigned char low_freq:1;
        unsigned char :8;
    };
} PERIFSLEEPSETbits;

//extern union __attribute__ ((far))  {
//    unsigned long CAN1CFG;
//   struct 
//    {
//		unsigned char   sjw:2;
//        unsigned char  seg1:3;
//        unsigned char  seg2:3;
//        unsigned char prseg:3;
//        unsigned char   sam:1;
//        unsigned char      :4;
//        
//		unsigned char   sjw_slp:2;
//        unsigned char  seg1_slp:3;
//        unsigned char  seg2_slp:3;
//        unsigned char prseg_slp:3;
//        unsigned char   sam_slp:1;
//        unsigned char      :4;        
//    };
//} CAN1CFGbits;
//extern union __attribute__ ((far))  {
//    unsigned long CAN2CFG;
//   struct 
//    {
//		unsigned char   sjw:2;
//        unsigned char  seg1:3;
//        unsigned char  seg2:3;
//        unsigned char prseg:3;
//        unsigned char   sam:1;
//        unsigned char      :4;
//        
//		unsigned char   sjw_slp:2;
//        unsigned char  seg1_slp:3;
//        unsigned char  seg2_slp:3;
//        unsigned char prseg_slp:3;
//        unsigned char   sam_slp:1;
//        unsigned char      :4;        
//    };
//} CAN2CFGbits;
union __attribute__ ((far))  {
    unsigned long long FEQU;
   struct 
    {
		unsigned int  a:16;
        unsigned int  b:16;
                 int  c:16;

        unsigned int   :16;        
    };
} FEQUbits;
union __attribute__ ((far))  {
    unsigned long long OUTFUNC;
   struct 
    {
		unsigned char  pin1:8;
        unsigned char  pin2:8;
        unsigned char  pin8:8;
        unsigned char  pin9:8;
        unsigned char  pin10:8;
        unsigned char  pin12:8;
        unsigned char  pin13:8;
        unsigned char  pin15:8;
    };
} OUTFUNCbits;
union __attribute__ ((far))  {
    unsigned long long INFUNC;
   struct 
    {
		unsigned char  pin1:8;
        unsigned char  pin2:8;
        unsigned char  pin8:8;
        unsigned char  pin9:8;
        unsigned char  pin10:8;
        unsigned char  pin12:8;
        unsigned char  pin13:8;
        unsigned char  pin15:8;
    };
} INFUNCbits;

union {
    unsigned int LOCKBYTESTASCK;
   struct 
    {
		unsigned char start:1;
        unsigned char preliminary:1;
        unsigned char preliminary_done:1;
        unsigned char accomplished:1;
        unsigned char accomplished_done:1;
        unsigned char counter:3;
        unsigned int  timer:8;
    };
} LOCKBYTESTASCKbits;

union __attribute__ ((far))  {
    unsigned long LINLOCKPSTATPRMS;
   struct 
    {
        unsigned char byte:4; 
        unsigned char param:4;
 		unsigned char enable:1;
        unsigned char inv:1;
        unsigned char len:6;       
        unsigned char bit_mask:8;
        unsigned char addr:8;
    };
} LINLOCKPSTATPRMSbits;  // Дверь водителя
union __attribute__ ((far))  {
    unsigned long LINCOMMANDSTATPRMS;
   struct 
    {
        unsigned char byte_lock:4; 
        unsigned char bit_lock:4;
        unsigned char byte_unlock:4; 
        unsigned char bit_unlock:4;        
 		unsigned char enable:1;
        unsigned char len:6;       
        unsigned char :1;
        unsigned char addr:8;
    };
} LINCOMMANDSTATPRMSbits;  // Дверь водителя

union __attribute__ ((far))  {
    unsigned int GPRSCHECK;
   struct 
    {
		unsigned char  start:1;
        unsigned int counter:15;
       
    };
} GPRSCHECKbits;

union __attribute__ ((far))  {
    unsigned long LINSNIFBYTES;
   struct 
    {
		unsigned char  byte0:1;
        unsigned char  byte1:1;
        unsigned char  byte2:1;
        unsigned char  byte3:1;
    };
} LINSNIFBYTESbits;
union __attribute__ ((far))  {
    unsigned int TEMPERATURESET;
   struct 
    {
		unsigned char  enable:1;
        unsigned char  delta1:7;
        unsigned char  delta2:8;
    };
} TEMPERATURESETbits;
union __attribute__ ((far))  {
    unsigned char BATTCHRGTASK;
   struct 
    {
		unsigned char  low_trh_trigg:1;
        unsigned char  hihg_trh_trigg:1;
        unsigned char  :6;
    };
} BATTCHRGTASKbits;
union __attribute__ ((far))  {
    unsigned int BLINKRPTRTASK;
   struct 
    {
		unsigned char  start:1;
        unsigned char   type:1;
        unsigned int   timer:14;
    };
} BLINKRPTRTASKbits;
//switch_output_during_unlock
union __attribute__ ((far))  {
    unsigned int SWITCHOUTUNLTASK;
   struct 
    {
		unsigned char  start:1;
        unsigned char  unlock_start:1;
        unsigned int   timer:14;
    };
} SWITCHOUTUNLTASKbits;


union __attribute__ ((far))  {
    unsigned int SPEEDTRHSET1;
   struct 
    {
		unsigned char    treshold:8;
        unsigned char  histeresis:4;
        unsigned char            :4;
    };
} SPEEDTRHSET1bits;
union __attribute__ ((far))  {
    unsigned int SPEEDTRHSET2;
   struct 
    {
		unsigned char    treshold:8;
        unsigned char  histeresis:4;
        unsigned char            :4;
    };
} SPEEDTRHSET2bits;
union __attribute__ ((far))  {
    unsigned int SPEEDTRHSET3;
   struct 
    {
		unsigned char    treshold:8;
        unsigned char  histeresis:4;
        unsigned char            :4;
    };
} SPEEDTRHSET3bits;
union __attribute__ ((far))  {
    unsigned char SPEEDTRHDAT;

    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;
    };    
} SPEEDTRHDATbits; //63
union __attribute__ ((far))  {
    unsigned char SPEEDTRHTASK;

    struct
    {
		unsigned char trh1_trigg:1;
        unsigned char trh2_trigg:1;
        unsigned char trh3_trigg:1;

		unsigned char :5;

    };    
} SPEEDTRHTASKbits; //63
union __attribute__ ((far))  {
    unsigned long GETMEMMSGTASK;

    struct
    {
		unsigned char start:1;
        unsigned int addr:15;

    };    
} GETMEMMSGTASKbits; //63
union __attribute__ ((far))  {
    unsigned char TRANSPPRESSLPDAT;

    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;
    };    
} TRANSPPRESSLPDATbits; //71
union __attribute__ ((far))  {
    unsigned long WBSATASK;

    struct
    {
		unsigned char start:1;
        unsigned char stop:1;
		unsigned long counter:30;
    };    
} WBSATASKbits; //71
//#if defined (WBUS)
union __attribute__ ((far))  {
    unsigned long WBSWTASK;

    struct
    {
		unsigned char start:1;
        unsigned char stop:1;
        unsigned char start_ack:1;
        unsigned char break_start:1;
        unsigned char break_done:1;
        unsigned char wbus_busy:1;
		unsigned long counter:30;
    };    
} WBSWTASKbits; 
union __attribute__ ((far))  {
    unsigned long DRSTWTASK;

    struct
    {
		unsigned char start:1;
        unsigned char stop:1;
        unsigned char counter:8;
    };    
} DRSTWTASKbits; 
union __attribute__ ((far))  {
    unsigned long DVRQWTASK;

    struct
    {
		unsigned char start:1;
        unsigned char stop:1;
        unsigned char counter:8;
    };    
} DVRQWTASKbits; 
union __attribute__ ((far))  {
    unsigned long WEBASTOSTATUS;

    struct
    {
		unsigned char FD:1;      //Flame detector   
        unsigned char CAF:1;     //Combustion Air Fan (CAF)
        unsigned char ST:1;      //Glowplug / Spark transmitter (ST)
        unsigned char FP:1;      //Fuel Pump (FP)
        unsigned char CP:1;      //Circulation Pump (CP)
        unsigned char VFR:1;     //Vehicle Fan Relay (VFR)
        unsigned char NSH:1;     //Nozzle stock heating (NSH)
        unsigned char FI:1;      //Flame indicator (FI)
        signed char   TEMP:8;    //Webasto temperature
    };    
} WEBASTOSTATUSbits; 
//#endif
union __attribute__ ((far))  {
    unsigned long long WBSATASK2;

    struct
    {
		unsigned char start:1;
        unsigned char stop:1;
        unsigned int      :14;
		unsigned int  start_puls:16;
		unsigned int  stop_pulse:16;        
		unsigned int  counter:16;
    };    
} WBSATASK2bits; //71

union __attribute__ ((far))  {
    unsigned char INPPOL;

    struct
    {
		unsigned char in1_p1:1;
        unsigned char in2_p8:1;
		unsigned char in3_p13:1;
        unsigned char in4_p12:1;        
        unsigned int  :4;

    };    
} INPPOLbits;
union __attribute__ ((far))  {
    unsigned char OUTPOL;

    struct
    {
		unsigned char out1_p9:1;
        unsigned char out2_p10:1;
		unsigned char out3_p15:1;
        unsigned char out4_p12:1;
        unsigned char out5_p13:1;
        unsigned int  :3;

    };    
} OUTPOLbits;
union __attribute__ ((far))  {
    unsigned long long IMSIDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} IMSIDATbits; //34

union __attribute__ ((far))  {
    unsigned int PULSAFTERAUOTORUNTASK;

    struct
    {
		unsigned char start:1;
        unsigned char delay:1;
        unsigned char puls_duration:1;

    };    
} PULSAFTERAUOTORUNTASKbits;
union __attribute__ ((far))  {
    unsigned int PULSAFTERAUOTORUNPRMS;

    struct
    {
        unsigned int delay:10;
        unsigned char puls_duration:6;
    };    
} PULSAFTERAUOTORUNPRMSbits;

union __attribute__ ((far))  {
    unsigned int MODEMRESINSLEEP;

    struct
    {
        unsigned char start:1;
        unsigned int counter:15;
    };    
} MODEMRESINSLEEPbits;

union __attribute__ ((far))  {
    unsigned int MODEMRESINSLPMSGTASCK;

    struct
    {
        unsigned char start:1;
        unsigned int counter:15;
    };    
} MODEMRESINSLPMSGTASCKbits;

union __attribute__ ((far))  {
    unsigned long long BELTCHANGEDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} BELTCHANGEDATbits; //80, 81

union __attribute__ ((far))  {
    unsigned char INPUT;
    struct
    {
		unsigned char in1_p1:1;
		unsigned char in2_p8:1;
        unsigned char in3_p13:1;
        unsigned char in4_p12:1;
		unsigned char in_out:4;
    };     
} INPUTbits; //
union __attribute__ ((far))  {
    unsigned char OUTPUT;
    struct
    {
		unsigned char b0:1; 
        unsigned char b1:1;
        unsigned char b2:1;
        unsigned char b3:1;
		unsigned char out1_p9:1;
		unsigned char out3_p15:1;
        unsigned char out4_p12:1;
        unsigned char out5_p13:1;
    };     
} OUTPUTbits; //
union __attribute__ ((far))  {
    unsigned long DIAGNSIGNALS;
    struct
    {
		unsigned char transp_ok:1;        
		unsigned char rel_periodic:1;
		unsigned char rel_arm:1;
        unsigned char rel_disarm:1;        
		unsigned char rel_serv_on:1;
        unsigned char rel_serv_off:1;
		unsigned char rel_serv_fake:1;
        unsigned char rel_block:1;
        unsigned char rel_unblock:1;
        unsigned char rel_itself:1;
        unsigned char rel_learn:1;
        unsigned char reset_rf1:1;
        unsigned char lnk_not_compl:1;
        unsigned char messsage_corr:1;
        unsigned char not_valid_transp:1;
        unsigned char vis_transp:1;
        unsigned char keys_restored:1;
        unsigned char tr_flag_restored:1;
        unsigned char rel_only_serv:1;
        unsigned char rel_disarm_by_button:1;
        unsigned long :12;

    };     
} DIAGNSIGNALSbits; //
union __attribute__ ((far))  {
    unsigned int RELTRANSFLGS;
    struct
    {
		unsigned char rel_periodic:1;
		unsigned char rel_arm:1;
        unsigned char rel_disarm:1;        
		unsigned char rel_serv_on:1;
        unsigned char rel_serv_off:1;
		unsigned char rel_serv_fake:1;
        unsigned char rel_block:1;
        unsigned char rel_unblock:1;
        unsigned char rel_learn:1;
        unsigned char rel_only_serv_on:1;
        unsigned char rel_only_serv_off:1;
        unsigned char rel_disarm_by_button:1;
        unsigned char :4;
    };     
} RELTRANSFLGSbits; //

union __attribute__ ((far))  {
    unsigned char OBDREQEN;
    struct
    {
		unsigned char mil_req:1;
		unsigned char vin_req:1;
        unsigned char dtc3_req:1;        
		unsigned char dtc7_req:1;
        unsigned char dtca_req:1;
		unsigned char fuel_req:1;
        unsigned char rpm_req:1;
        unsigned char :1;
    };     
} OBDREQENbits; //
union __attribute__ ((far))  {
    unsigned long long RBLKDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} RBLKDATbits;

union __attribute__ ((far))  {
    unsigned int HANDSFREETASCK2;
    struct
    {
		unsigned char start:4;
        unsigned char transp_trigger_flag:1;
		unsigned char open_done:1;
		unsigned char close_done:1; 
        
		unsigned int  timer:9;

    };     
} HANDSFREETASCK2bits;
union __attribute__ ((far))  {
    unsigned long long HF2DAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} HF2DATbits;
union __attribute__ ((far))  {
    unsigned char SECONDAUTHORDAT;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} SECONDAUTHORDATbits;
union __attribute__ ((far))  {
    unsigned char SECONDAUTHORDATFAIL;
    struct
    {
		unsigned char queue:4;
		unsigned char sms_en:1;
		unsigned char enaible_in_serv:1; 
		unsigned char :1;
        unsigned char :1;

    };     
} SECONDAUTHORDATFAILbits;

union __attribute__ ((far))  {
    unsigned long long CANBUTTONPRMS;
   struct 
    {
		unsigned char can_number:2;
        unsigned char :2;
        unsigned char filt_number:4;
        unsigned char bit_mask:8;        
        unsigned char value1:8;
        unsigned char value2:8;
        unsigned long id:29;
        unsigned char byte:3;        
    };
} CANBUTTONPRMSbits;
union __attribute__ ((far))  {
    unsigned char SECONDAUTHOR;
   struct 
    {
		unsigned char on:1;
        unsigned char type:1;
        unsigned char num:2;
        unsigned char :2;
    };
} SECONDAUTHORbits;
volatile union __attribute__ ((far))  {
    unsigned char PRODERRORS;
   struct 
    {
		unsigned char autostart:1;
        unsigned char out2:1;
        unsigned char lout:1;
        unsigned char lin:1;
        unsigned char can1:1;
        unsigned char can2:1;
        unsigned char gsm:1;
        unsigned char batt:1;
    };
} PRODERRORSbits;


//###########################  INTERRUPTS  #################################

#define _trapISR __attribute__((interrupt,no_auto_psv))

/* ****************************************************************
* Standard Exception Vector handlers if ALTIVT (INTCON2<15>) = 0  *
*                                                                 *
* Not required for labs but good to always include                *
******************************************************************/
void _trapISR _OscillatorFail(void)
{
    int i;
    i = 0;
        INTCON1bits.OSCFAIL = 0;
        while(i == 0) {
//            GNSSLED_green = 1;
            Nop(); Nop(); Nop();
        }
}

void _trapISR _AddressError(void)
{
    int i;
    i = 0;
        INTCON1bits.ADDRERR = 0;
        while(i == 0) {
            Nop(); Nop(); Nop();
            if ( i == 0 )asm volatile ( "reset" );
        }
}

void _trapISR _StackError(void)
{
    int i;
    i = 0;
        INTCON1bits.STKERR = 0;
        while(i == 0) {
            Nop(); Nop(); Nop();
            asm volatile ( "reset" );
        }
}

void _trapISR _MathError(void)
{
    int i;
    i = 0;
        INTCON1bits.MATHERR = 0;
        while(i == 0) {
            Nop(); Nop(); Nop();
        }
}

void __attribute__((__interrupt__,no_auto_psv)) _DMACError(void){
    static unsigned int ErrorLocation;
    // Peripheral Write Collision Error Location
    if(DMAPWC & 0x0001){ 
        ErrorLocation = DMA0STAL;
    }
    // DMA RAM Write Collision Error Location
    if(DMARQC & 0x0002){
        ErrorLocation = DMA1STAL;
    }

INTCON1bits.DMACERR = 0;//Clear Trap Flag
}
//void __attribute__((__interrupt__,no_auto_psv)) _C1Event(void){
//
//    if (C1INTFbits.IVRIF == 1) {
//       C1INTFbits.IVRIF = 0;
//       if ()
//       
//    }
//    
//}
//void __attribute__((__interrupt__,no_auto_psv)) _C2Event(void){
//
//}

/********************* UART interrupts  *******************/
void __attribute__ ((__interrupt__, no_auto_psv)) _U1RXInterrupt(void) {

    IFS0bits.U1RXIF = 0;
    uart1_timeout_counter = 0;
    
    if (U1STAbits.OERR == 1) {
//        Nop();Nop();Nop();
        U1STAbits.OERR = 0;
    }

// Read the receive buffer till atleast one or more character can be read
    while( U1STAbits.URXDA == 1 )	{//DataRdyUART1()
	Start_accumulation1 = 1;
//	UART1_Rx_buf[U1_num_W] = ReadUART1();
        UART1_Rx_buf[U1_num_W] = U1RXREG;
// Проверяем, заполнен ли буфер, инкрементируем счетчик        
	if ((U1_num_W + 1) % UART1_Rx_buf_SIZE != U1_num_R) U1_num_W ++; 
	U1_num_W %= UART1_Rx_buf_SIZE; // Циклический возврат на начало буфера

    } //while( DataRdyUART1())

}
void __attribute__ ((__interrupt__, no_auto_psv)) _U1TXInterrupt(void) {
   static unsigned int Tx1_num = 0;
//   U2TX_Clear_Intr_Status_Bit;
   IFS0bits.U1TXIF = 0;

   if(Tx1_num < U1_Tx_length) {
//      WriteUART1((unsigned int)UART1_Tx_buf[Tx1_num++]);
      U1TXREG = (unsigned int)UART1_Tx_buf[Tx1_num++];
    }
    else {
      IEC0bits.U1TXIE = 0; 
//      DisableIntU1TX;
      Tx1_num = 0;
      Tx1_DataAvailable = 1;
    }

//   IFS0bits.U1TXIF = 0;
//   if(UART1_Tx_buf[Tx1_num]!= '\0') {
//      WriteUART1((unsigned int)UART1_Tx_buf[Tx1_num++]);
//    }
//    else {
//      DisableIntU1TX;
//      Tx1_num = 0;
//      Tx1_DataAvailable = 1;
//    }

//U1_Tx_length
}

void __attribute__ ((__interrupt__, no_auto_psv)) _U2RXInterrupt(void) {

IFS1bits.U2RXIF = 0;
uart2_timeout_counter = 0;
static unsigned int uart2_temp = 0;

    if (U2STAbits.OERR == 1) {
//        Nop();Nop();Nop();
        U2STAbits.OERR = 0;
    }

// Read the receive buffer till atleast one or more character can be read
uart2_busy_flag = 1;
    while( U2STAbits.URXDA == 1 )	{
	if (Start_accumulation == 0)	{
//	uart2_temp = ReadUART2();
    uart2_temp = U2RXREG;
		if ( uart2_temp == '$') { // GGA
                    Rx2_DataAvailable = 0;
                    Start_accumulation = 1;
                    uart2_temp = 0;
                    UART2_buf[0] = '$';
//                    UART2_buf[0] = '$';UART2_buf[1] = 'G';
//                    UART2_buf[2] = 'N';UART2_buf[3] = 'G';
//                    UART2_buf[4] = 'G';UART2_buf[5] = 'A';
                    num_of_bytes = 0;
                    num_of_bytes ++;
                    uart2_temp = 0;
		}
//        uart2_temp = uart2_temp << 8;
	} else 
          {
//               UART2_buf[num_of_bytes] = ReadUART2();
               UART2_buf[num_of_bytes] = U2RXREG;
               if (num_of_bytes < 1023) {num_of_bytes ++;}
               else Start_accumulation = 0; 
//        	   if (num_of_bytes == 1023) Start_accumulation = 0;
//        	   num_of_bytes ++;
		  }
    } //while( DataRdyUART1())
/*
uart2_busy_flag = 1;
    while(DataRdyUART2())	{
	if (Start_accumulation == 0)	{
	uart2_temp = uart2_temp + ReadUART2();
		if ( (uart2_temp & 0x00FFFFFF) == 0x00474741) { // GGA
                    Rx2_DataAvailable = 0;
                    Start_accumulation = 1;
                    uart2_temp = 0;
                    UART2_buf[0] = '$';UART2_buf[1] = 'G';
                    UART2_buf[2] = 'N';UART2_buf[3] = 'G';
                    UART2_buf[4] = 'G';UART2_buf[5] = 'A';
                    num_of_bytes = 6;
                    uart2_temp = 0;
		}
        uart2_temp = uart2_temp << 8;
	} else 
          {
               UART2_buf[num_of_bytes] = ReadUART2();
               if (num_of_bytes < 1023) {num_of_bytes ++;}
               else Start_accumulation = 0; 
//        	   if (num_of_bytes == 1023) Start_accumulation = 0;
//        	   num_of_bytes ++;
		  }
    } //while( DataRdyUART1())
*/

}
void __attribute__ ((__interrupt__, no_auto_psv)) _U2TXInterrupt(void) {
   static unsigned int Tx2_num = 0;
//   U2TX_Clear_Intr_Status_Bit;
   IFS1bits.U2TXIF = 0;
   if(UART2_Tx_buf[Tx2_num]!= '\0') {
//      WriteUART2((unsigned int)UART2_Tx_buf[Tx2_num++]);
      U2TXREG = (unsigned int)UART2_Tx_buf[Tx2_num++];
    }
    else {
       IEC1bits.U2TXIE = 0;
//      DisableIntU2TX;
      Tx2_num = 0;
      Tx2_DataAvailable = 1;
    }
}


void __attribute__ ((__interrupt__, no_auto_psv)) _U3RXInterrupt(void) {
    
//    static unsigned char lock_status;
    
IFS5bits.U3RXIF = 0;
// Read the receive buffer till atleast one or more character can be read
    IFS5bits.U3RXIF = 0;
    
    
    if (U3STAbits.OERR == 1) {
        Nop();Nop();Nop();
        U3STAbits.OERR = 0;
    }
    if (U3STAbits.FERR == 1) {
        Nop();Nop();Nop();

    }
IFS5bits.U3EIF = 0;

    while(  U3STAbits.URXDA == 1 )	{//DataRdyUART3()
        Start_accumulation3 = 1;
        uart3_timeout_counter = 0;
# if defined (LIN)
    uart3_timeout_counter = 0;
# endif        
//        UART3_Rx_buf[U3_num_W] = ReadUART3();
        UART3_Rx_buf[U3_num_W] = U3RXREG;
/*        WriteUART4(UART3_Rx_buf[U3_num_W]); */
    // Проверяем, заполнен ли буфер, инкрементируем счетчик
# if defined (LIN)
    if ( UART3_Rx_buf[0] == 0 && UART3_Rx_buf[1] == 0x55 && UART3_Rx_buf[2] != 0 && U3_num_W == 2 ) { // 

        if ((UART3_Rx_buf[2] == LIN_LOCK_ADDR             || UART3_Rx_buf[2] == LIN_UNLOCK_ADDR ||
             UART3_Rx_buf[2] == LINLOCKPSTATPRMSbits.addr || UART3_Rx_buf[2] == LIN_BOOT_UNLOCK_ADDR ||
             UART3_Rx_buf[2] == LIN_LOCK_ADDR2            || UART3_Rx_buf[2] == LIN_UNLOCK_ADDR2 ) 
             && lin_wake_transmitting == 0) {
            lin_sleep = 0;
            lin_sleep_counter = 0;
            
            if (LINLOCKUNLOCKbits.running == 1 || LINBOOTUNLOCKbits.running == 1) { //&& lin_transmitting_flag == 0

                    if (num_of_lin_transmittions > 0 ) {
                        num_of_lin_transmittions --;
                        
                            if (lin_transmitting_flag == 0) {
                                if (OUTFUNCbits.pin10 == 9) OUT2 = 1;                        
                                UART3_Rx_buf[2] = 0xFF;
                                lin_transmitting_flag = 1;
                                start_UART3_LIN_transmission ( LIN_TRANSMITTION_LENGTH );
                            }

                    }

            }
        }
    }   
# endif        
        if (U3_num_W <= 99) U3_num_W ++; 

    } //while( DataRdyUART4())

}
void __attribute__ ((__interrupt__, no_auto_psv)) _U3TXInterrupt(void) {
   static unsigned int Tx3_num = 0;//, Tx3_num_tmp = 0;
//   U2TX_Clear_Intr_Status_Bit;
   IFS5bits.U3TXIF = 0;
   

   if(Tx3_num < U3_Tx_length) {
        LIN_switch_counter = 0;
//        WriteUART3((unsigned int)UART3_Tx_buf[Tx3_num++]);//UART3_Tx_buf[ Tx3_num_tmp ])
        U3TXREG = (unsigned int)UART3_Tx_buf[Tx3_num++];
    }
    else {
       IEC5bits.U3TXIE = 0;
//      DisableIntU3TX;
# if defined (LIN) 
//      if (OUTFUNCbits.pin10 == 9) {
//      OUT2 = 0;
//      }
//      lin_transmitting_flag = 0; 
      if (lin_wake_transmitting == 1) {
          lin_wake_transmitting = 0;
      }

# endif
      Nop();Nop();Nop();
      

      Tx3_num = 0;
      Tx3_DataAvailable = 1;
    }

}
void __attribute__ ((__interrupt__, no_auto_psv)) _U3ErrInterrupt(void) {
    unsigned char temp;
    
IFS5bits.U3EIF = 0;

    if (U3STAbits.OERR == 1) {
        Nop();Nop();Nop();
        U3STAbits.OERR = 0;
    }
    if (U3STAbits.FERR == 1) {
        Nop();Nop();Nop();
        temp = U3STAbits.FERR;

    }    

    
}

void __attribute__ ((__interrupt__, no_auto_psv)) _U4RXInterrupt(void) {
IFS5bits.U4RXIF = 0;
// Read the receive buffer till atleast one or more character can be read
    IFS5bits.U4RXIF = 0;
    
    if (U4STAbits.OERR == 1) {
//        Nop();Nop();Nop();
        U4STAbits.OERR = 0;
    }
    
    while(  U4STAbits.URXDA == 1 )	{// DataRdyUART4() 
//    UART4_Rx_buf[num_of_bytes4 ++] = ReadUART4();
    UART4_Rx_buf[num_of_bytes4 ++] = U4RXREG;
        if (UART4_Rx_buf[num_of_bytes4 - 1] == 0x0A)	{
            UART4_Rx_buf[num_of_bytes4] = 0;
            num_of_bytes4 ++;
            num_of_bytes_tmp4 = num_of_bytes4;
            num_of_bytes4 = 0;
            Rx4_DataAvailable = 1;
            break;
        }
    } //while( DataRdyUART4())
}
void __attribute__ ((__interrupt__, no_auto_psv)) _U4TXInterrupt(void) {
   static unsigned int Tx4_num = 0;
   IFS5bits.U4TXIF = 0;
   if(UART4_Tx_buf[Tx4_num]!= '\0') {
//      WriteUART4((unsigned int)UART4_Tx_buf[Tx4_num++]);
      U4TXREG = (unsigned int)UART4_Tx_buf[Tx4_num++];
    }
    else {
       IEC5bits.U4TXIE = 0;
//      DisableIntU4TX;
      Tx4_num = 0;
      Tx4_DataAvailable = 1;
    }
}

/**************************  TIMER interrupt  *******************************/
void __attribute__ ((__interrupt__, no_auto_psv)) _CM1Interrupt(void) {

    
IFS1bits.CMIF = 0;    
Nop();Nop();Nop();
    if (CMSTATbits.C3EVT == 1) {
        Nop();Nop();Nop();
        frequency ++;
        CM3CONbits.CEVT = 0;
    }

Nop();Nop();Nop();

//_LATB5 = !_LATB5;
} // _ISR

/**************************  TIMER interrupt  *******************************/
void __attribute__ ((__interrupt__, no_auto_psv)) _T6Interrupt(void) {
IFS2bits.T6IF = 0;

static unsigned int mesuare_counter = 0;

   if (mesuare_counter < 500) { 
       mesuare_counter ++;
       IEC1bits.CMIE = 1;

   }
   else {
    IEC1bits.CMIE = 0;   
    frequency_ready = 1;
    mesuare_counter = 0;
    IEC2bits.T6IE = 0;

   }

} // _ISR
void __attribute__ ((__interrupt__, no_auto_psv)) _T3Interrupt(void) {
//    static unsigned int K_fast_counter = 0;
IFS0bits.T3IF = 0;

// UART2 receiving timeout
	if (Start_accumulation == 1) {
            uart2_timeout_counter ++;
                if (uart2_timeout_counter > 10) { //100 для 115200
                    uart2_timeout_counter = 0; 
                    Start_accumulation = 0;
                    uart2_busy_flag=0; 
//                    UART2_buf[num_of_bytes]=0;
                    num_of_bytes_tmp = num_of_bytes;
                    num_of_bytes = 0;
                    Rx2_DataAvailable=1;
                }
	} else uart2_timeout_counter = 0;

// UART1 receiving timeout
        if (Start_accumulation1 == 1) {
            uart1_timeout_counter ++;
		if (uart1_timeout_counter > 1) { //12
                    Rx1_DataAvailable = 1;
                    Start_accumulation1 = 0;
                    uart1_timeout_counter = 0;
                    U1_num_W_tmp = U1_num_W;
		}
	}
	else uart1_timeout_counter = 0;

// UART3 receiving timeout
    if (Start_accumulation3 == 1) {
            uart3_timeout_counter ++;
		if (uart3_timeout_counter > U3_Rx_timeout) { //3; 25 U3_Rx_timeout
//            if (KFASTDTCRESETTASKbits.ini_running == 1 && UART3_Rx_buf[0] == 0x83) {
//                Nop();Nop();Nop();
//            }
                    Rx3_DataAvailable = 1;
                    Start_accumulation3 = 0;
                    uart3_timeout_counter = 0;
                    U3_num_W_tmp = U3_num_W;
                    U3_num_W = 0;
# if defined (WBUS)
                    char l;
                    for (l = 0; l < U3_num_W_tmp; l ++) {
                        WBUS_Rx_copy_buf[l] = UART3_Rx_buf[l];
                        UART3_Rx_buf[l] = 0;
                    }
#endif                    
# if defined (LIN)
                    char l;
                    for (l = 0; l < 41; l ++) {
                        LIN_Rx_copy_buf[l] = UART3_Rx_buf[l];
                        UART3_Rx_buf[l] = 0;
                    }
#endif                    
                    
		}
	}
	else uart3_timeout_counter = 0;

// Таймер завершения цикла общения с реле
    if (rel_timeout_counter > 0) {
        rel_timeout_counter --;
        if (rel_timeout_counter == 0) rel_timeout_flag = 1;
    }

# if defined (LIN) 
    if ( lin_transmitting_flag == 1 ) {
        if (LIN_switch_counter < 4) LIN_switch_counter ++; //4
        else {
            LIN_switch_counter = 0;
            lin_transmitting_flag = 0;
# if defined (MCP23S08)
            if ( OUTFUNCbits.pin10 == 9 ) LIN_KEY = 0;
# else            
            if ( OUTFUNCbits.pin10 == 9 ) OUT2 = 0;
# endif
        }
    }
# endif

# if defined (K_LINE) 
if ( fast_init_start_flag == 1 ) {
    
    if ( K_fast_counter < 51 ) {
        _TRISD3 = 0;
        _LATD3 = 0;
# if defined (MCP23S08)

# else        
        if (OUTFUNCbits.pin15 == 15) L_OUT = 1;
# endif        
        K_fast_counter ++; 
    }
    else {
        _LATD3 = 1;
        _TRISD3 = 1;
# if defined (MCP23S08)

# else        
        if (OUTFUNCbits.pin15 == 15) L_OUT = 0;
# endif        
        K_fast_counter = 0;
        fast_init_start_flag = 0;
    }
    
} else K_fast_counter = 0;
# endif
#if defined (WBUS)
static unsigned char wbus_timer = 0; //1step - 500uS , 50steps - 25mS
if ((WBSWTASKbits.break_start == 1) && (WBSWTASKbits.break_done == 0)) {
    
    if (wbus_timer == 0) {
        // disable UART on pin and wait for LOW level break
        _TRISD3 = 0;
        switch_on_off_u3tx_output ( 0 );
        _LATD3 = 0;
        Nop();Nop();Nop();
    }
    wbus_timer++; //timer increment
    if (wbus_timer == 100) { // enable UART on pin and wait for HIGH level break after 25mS
        _TRISD3 = 1;
        switch_on_off_u3tx_output ( 1 );
        Nop();Nop();Nop();
    }
    if (wbus_timer == 200) {
    wbus_timer = 0; //reset timer after 50ms cycle    
    WBSWTASKbits.break_done = 1; // set break_done flag for wbus_task()
    //WBSWTASKbits.break_start= 0; //reset FL in global while(1)
    }
}
#endif

#if defined (MAZDA_LOCK)
static unsigned int mazda_counter = 0;
if ( mazda_lock_start_flag != 0 ) {
    if ( mazda_counter < 93 ) mazda_counter ++;
    else {
        mazda_counter = 0;
        mazda_lock_start_flag = 0;
    }

    switch (mazda_counter) {

        case 1:
            UART3_Tx_buf[0] = 0x0C;
            U3_Tx_length = 1;
            Tx3_DataAvailable = 0;
            IEC5bits.U3TXIE = 1;
            IFS5bits.U3TXIF = 1;        
        break;

        case 13:
            if ( mazda_lock_type == 0 ) {
                UART3_Tx_buf[0] = 0x8B;
                U3_Tx_length = 1;
                Tx3_DataAvailable = 0;
                IEC5bits.U3TXIE = 1;
                IFS5bits.U3TXIF = 1;
            }
        break;

        case 80:
            if ( mazda_lock_start_flag == 1 ) {// open
                UART3_Tx_buf[0] = 0x54; UART3_Tx_buf[1] = 0x4B; UART3_Tx_buf[2] = 0xDA;
                UART3_Tx_buf[3] = 0xF2; UART3_Tx_buf[4] = 0x7A; UART3_Tx_buf[5] = 0x17; 
            } else { // close
                UART3_Tx_buf[0] = 0x54; UART3_Tx_buf[1] = 0xA4; UART3_Tx_buf[2] = 0xE8;
                UART3_Tx_buf[3] = 0xE0; UART3_Tx_buf[4] = 0x68; UART3_Tx_buf[5] = 0xB4;                
            }
            U3_Tx_length = 6;
            Tx3_DataAvailable = 0;
            IEC5bits.U3TXIE = 1;
            IFS5bits.U3TXIF = 1;     
        break; 

        case 92:
            if ( mazda_lock_type == 0 ) {
                UART3_Tx_buf[0] = 0xDA; UART3_Tx_buf[1] = 0x17; UART3_Tx_buf[2] = 0x8E;
                U3_Tx_length = 3;
                Tx3_DataAvailable = 0;
                IEC5bits.U3TXIE = 1;
                IFS5bits.U3TXIF = 1;
            }
        break;

        default:        
            break;
    }
}
#endif


}
void __attribute__ ((__interrupt__, no_auto_psv)) _T4Interrupt(void) {
    
static unsigned int periodic_counter;//, ignition_counter = 0;// power_counter = 0;    
IFS1bits.T4IF = 0;
//OUT2 = !OUT2;
// Обработка питания
    if ( POWERSTATUS == 0 ) {
            if (power_counter < 1000) {
                power_counter ++;
                if (power_counter >= 1000) {
                    power = 1;
                }
            }
    }
    else {
        if (power_counter > 0) {
            power_counter --;
            if (power_counter == 0) {
                power = 0;
            }
		}
    }


// Обработка зажигания 
/*
if (IGN == 1) {
	if (ignition_counter < 20) {
	ignition_counter ++;
		if (ignition_counter == 20) {
            ignition = 1;
//		Ignition_ON = 1;
//		Ignition_OFF = 0;
		}
	}
} else {
		if (ignition_counter > 0) {
		ignition_counter --;
			if (ignition_counter == 0) {
                ignition = 0;
//			Ignition_OFF = 1;
//			Ignition_ON = 0;
			}
		}
}
*/

// Включение/выключение модема
    if (modem_on_off_counter != 0) {
        // Включение
        if (modem_on_off_type == MODEM_ON) {
            MODEMVBATT_out = 0; // Включение напряжения питания модема
            // Импульс включения с задержкой 100мс длительностью 1100 мс
            if ((modem_on_off_counter > 10) && (modem_on_off_counter < 120)) {
                PWRkey = 0;
            } else  PWRkey = 1;
        }
        // Выключение
        if (modem_on_off_type == MODEM_OFF) {
            if (modem_on_off_counter <= 85) {PWRkey = 0;}
            else PWRkey = 1;
        }
        if (modem_on_off_type == MODEM_EMERG_RST) {
            // Выключение напряжения питания модема на 2 секунды
            if (modem_on_off_counter < 200) { MODEMVBATT_out = 1; }
            else MODEMVBATT_out = 0;
            
            // Импульс включения с задержкой 100мс длительностью 1100 мс
            if ((modem_on_off_counter > 210) && (modem_on_off_counter < 320)) {
                PWRkey = 0;
            } else  PWRkey = 1;
        }

        // Рестарт модема
        if (modem_on_off_type == MODEM_RESTART) {

            if (modem_on_off_counter <= 85) {PWRkey = 0;} // Выключение
            else {
                PWRkey = 1;
                //Импульс броса питания
                if ((modem_on_off_counter >= 1300)&&(modem_on_off_counter <= 1500)) {
                    MODEMVBATT_out = 1;
                } else MODEMVBATT_out = 0;
                //Импульс включения
                if ((modem_on_off_counter > 1740)&&(modem_on_off_counter < 1950)) {
                    PWRkey = 0;
                } else PWRkey = 1;

            }

        }
        
        if (modem_on_off_counter <= modem_busy_max_value) {modem_on_off_counter ++;}
        else {
            modem_on_off_finished_flag = 1;
            modem_on_off_counter = 0;
            MODEMTASCKSbits.onoff = 0;
            gsm_task_busy_timer = 0;
//            _LATB3 = 0;
//            if (modem_on_off_type != MODEM_OFF) {
//                GSMSTATUSbits.normal_on = 1;
//            } else {GSMSTATUSbits.normal_on = 0;}
        }
    }

// Тамер периодических задач
if (periodic_counter < 9) {periodic_counter ++;}
else {periodic_counter = 0; periodic_flag = 1;}

// Таймер занятости задачи
if (gsm_task_busy_timer > 0) {
    if (gsm_task_busy_timer <= gsm_task_busy_max_value) gsm_task_busy_timer ++;
    else {
        gsm_task_busy_timer = 0;
        modem_tasck_timeout_flag = 1;
//        _LATB3 = 0;
    }
}

periodic_10ms_flag = 1;
flash_write_monitor_flag = 1;
//_LATB4 = !_LATB4;
}
void __attribute__ ((__interrupt__, no_auto_psv)) _T5Interrupt(void) {
IFS1bits.T5IF = 0;

    BUZZ = ! BUZZ;

} // _ISR
void __attribute__ ((__interrupt__, no_auto_psv)) _T7Interrupt(void) {
// Сохранение во флеш память массива данных и стирание сектора.
//static unsigned int byte_counter = 0;
//int temp;

IFS3bits.T7IF = 0;

# if defined (SST25)
    if ( byte_counter < flash_data_length ) {
        CS_at45 = 0; 
            SPI2BUF = 0x06; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда разрешения записи
        CS_at45 = 1;
        Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
        Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
        Nop();Nop();Nop();Nop();Nop();Nop();
        CS_at45 = 0;    
            SPI2BUF = 0x02; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда записи одного байта
            SPI2BUF = (unsigned char) ( flash_data_start_addr >> 16); while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;   
            SPI2BUF = (unsigned char) ( flash_data_start_addr >> 8);  while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
            SPI2BUF = (unsigned char)   flash_data_start_addr;        while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
            SPI2BUF = (int) *ptr_to_save; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
        CS_at45 = 1;
        Nop();Nop();Nop();
        flash_data_start_addr ++;
        ptr_to_save ++;
        byte_counter ++;
        TMR7 = 0;
    }
    else {
//        SLEEP_LED = 0;
        T7CONbits.TON = 0;
        IEC3bits.T7IE = 0;
        IFS3bits.T7IF = 0;
        TMR7 = 0;
        byte_counter = 0;
        flash_write_end_flag = 1;
    }
# endif

} // _ISR
void __attribute__ ((__interrupt__, no_auto_psv)) _T2Interrupt(void) {

//    L_OUT = 0;
    T2CONbits.TON = 0;
    TMR2 = 0;
    RFSTATEbits.receiving = 5; // Не поступило ответа от метки
    RF_DataAvailable = 1; 
    
IFS0bits.T2IF = 0;

}
void __attribute__ ((__interrupt__, no_auto_psv)) _T8Interrupt(void) {
    static int Gx_L, Gx_H, Gy_L, Gy_H, Gz_L, Gz_H, W_ptr = 0;
    static long Gx_tmp = 0, Gy_tmp = 0, Gz_tmp = 0;

//    L_OUT = !L_OUT;
	asm ("nop");asm ("nop");asm ("nop");asm ("nop");asm ("nop");
	asm ("nop");asm ("nop");asm ("nop");asm ("nop");asm ("nop");
	asm ("nop");asm ("nop");asm ("nop");asm ("nop");asm ("nop");
	asm ("nop");asm ("nop");asm ("nop");asm ("nop");asm ("nop");    
	CS_SPI1 = 0;  
        writeSPI1(0x80 | 0x40 | 0x28);
        Gx_L = writeSPI1(0x00);
        Gx_H = (writeSPI1(0x00) << 8);
        Gy_L = writeSPI1(0x00);
        Gy_H = (writeSPI1(0x00) << 8);
        Gz_L = writeSPI1(0x00);
        Gz_H = (writeSPI1(0x00) << 8);
	CS_SPI1 = 1;
    
    if ( W_ptr < (number_of_samples - 1) ) {
        Gx_tmp = Gx_tmp + (long)(Gx_H + Gx_L);
        Gy_tmp = Gy_tmp + (long)(Gy_H + Gy_L);
        Gz_tmp = Gz_tmp + (long)(Gz_H + Gz_L);
        W_ptr ++;
    } else {
        Gx_tmp = Gx_tmp + (Gx_H + Gx_L);
        Gy_tmp = Gy_tmp + (Gy_H + Gy_L);
        Gz_tmp = Gz_tmp + (Gz_H + Gz_L);
        Gx_400 = (int) (Gx_tmp/number_of_samples); 
        Gy_400 = (int) (Gy_tmp/number_of_samples); 
        Gz_400 = (int) (Gz_tmp/number_of_samples);
        acc_data_redy_flag = 1;
        W_ptr = 0;
        Gx_tmp = 0, Gy_tmp = 0, Gz_tmp = 0;
//        L_OUT = !L_OUT;
    }
//L_OUT = !L_OUT;   
IFS3bits.T8IF = 0;
}

/********************  Change notification interrupt  ***********************/
void __attribute__((__interrupt__,no_auto_psv)) _CNInterrupt(void) {

    GSMSTATUSbits.power = ! MODEMSTATUS;

    if ( GSMSTATUSbits.normal_on && ! MODEMTASCKSbits.onoff && MODEMSTATUS ) { //
        GSMSTATUSbits.unexpected_off = 1;
    }
    
    if ( POWERSTATUS == 1 ) {
        STATUSFLAGS1bits.power_stable = 0;
        power_presence_counter = 0;
    }

IFS1bits.CNIF = 0;
}


/*********  Обработка прерывания от Si4461 ***************/
void __attribute__ ((__interrupt__, no_auto_psv)) _T1Interrupt(void) {
IFS0bits.T1IF = 0;

    if ( RFSTATEbits.transmitting == 1 ) {
        RFSTATEbits.transmitting = 0;
        RFSTATEbits.receiving = 1;
        T1CONbits.TON = 0;
        TMR1 = 0; PR1 = 210;
        T1CONbits.TON = 1;
        
        if (length != 0) {
            CS_SI4461 = 0;
                writeSPI3 (0x66);	// WRITE_TX_FIFO CMD
                writeSPI3 (N1); writeSPI3 (N1 >> 8); writeSPI3 (N1 >> 16); writeSPI3 (N1 >> 24);
                writeSPI3 (N2); writeSPI3 (N2 >> 8); writeSPI3 (N2 >> 16); writeSPI3 (N2 >> 24);
            CS_SI4461 = 1;
        }
unsigned int i;
for ( i = 0; i < 120; i++ ) {

}
            
        START_TX[2] = TX_to_READY; //TX_to_READY
        START_TX[4] = length;
        Si4461_CMD_stream ( START_TX, 5 );
        Si4461_CMD_stream ( GET_INT_STATUS, 1 ); //Si4461_interrupt_reset ();
//        while (Si4461_get_reply_stream ( READ_CMD_BUFF, 0 ) != 0xFF); //wait_ready ();
        if ( rel_transaction_flag == 1 ){
            Nop();Nop();Nop();
        }        
    } else {

        if ( RFSTATEbits.receiving == 1 ) {
            Nop(); Nop(); Nop();
//            L_OUT = 1;
            RFSTATEbits.receiving = 2;
            T1CONbits.TON = 0;
            TMR1 = 0; 
            if ( rel_transaction_flag == 1 ) PR1 = 375; // 600 Таймаут ответа реле
            else  PR1 = 98; // 98 Таймаут ответа метки
            T1CONbits.TON = 1;

            PKT_LENTH[4]= 8; Si4461_CMD_stream ( PKT_LENTH, 5 );// Длина пакета 8 байт
            while (Si4461_get_reply_stream ( READ_CMD_BUFF, 0 ) != 0xFF); //wait_ready ();            
            Si4461_CMD_stream ( GET_INT_STATUS, 1 ); //Si4461_interrupt_reset ();            
            while (Si4461_get_reply_stream ( READ_CMD_BUFF, 0 ) != 0xFF); //wait_ready ();
            Si4461_CMD_stream ( START_RX, 3 );// Запуск приема пакета из восьми байт данных
            while (Si4461_get_reply_stream ( READ_CMD_BUFF, 0 ) != 0xFF); //wait_ready (); 
            
        } 
        else {
            if ( RFSTATEbits.receiving == 2 ) {
//                Nop(); Nop(); Nop();
//                    int k;
//                    CS_SI4461 = 0;
//                        writeSPI3(0x77); // READ Rx buffer command
//                        for (k=0; k<8; k++)	{
//                            rx_buf[k] = writeSPI3 (0);
//                        }
//                    CS_SI4461 = 1;                
//                RFSTATEbits.receiving = 5; // Не поступило ответа от метки
//                RF_DataAvailable = 1;
            }
        }

    }

    if (fire_relay_flag == 1) {
        Nop(); Nop(); Nop();
//        L_OUT = 0;
        fire_relay_flag = 0;
        Si4461_start_receiving ();
    }

} // _ISR
void __attribute__ ((__interrupt__, no_auto_psv)) _INT1Interrupt(void) {

	nIRQ = 1;

    if ( RFSTATEbits.waiting_inquiry == 1 && fire_relay_flag == 0)  {
        
        T2CONbits.TON = 1;
//        L_OUT = 1;
        
        rf_reset_monitor_flag = 1;
        RFSTATEbits.waiting_inquiry = 0;
        RFSTATEbits.transmitting = 1;
        length = 8;
        
        TMR1 = 0; PR1 = 20;
        T1CONbits.TON = 1;
        
        CHANGE_STATE[1] = READY;
        Si4461_CMD_stream ( CHANGE_STATE, 2 );
        while (Si4461_get_reply_stream ( READ_CMD_BUFF, 0 ) != 0xFF); //wait_ready ();
        
        if ( rel_transaction_flag == 0 ) SYNC_BITS_SW2 [4] = SW2_receive | SW2; // для общения с меткой SW2_receive1!!!!!!!!!!!!!!!!?????????????????????
        if ( rel_transaction_flag == 1 ) SYNC_BITS_SW2 [4] = SW2_receive1_relay | SW2; // для общения с реле
        if ( RLEARNTASKSbits.start == 1) { SYNC_BITS_SW2 [4] = SW2_lrn_rel; }
        if ( TLEARNTASKSbits.start == 1) { SYNC_BITS_SW2 [4] = SW2_lrn_trnsp; }
        if (TFINISHTASKSbits.start == 1) { SYNC_BITS_SW2 [4] = SW2_lrn_trnsp; }
        
        Si4461_CMD_stream ( SYNC_BITS_SW2, 5 );
        while (Si4461_get_reply_stream ( READ_CMD_BUFF, 0 ) != 0xFF); //wait_ready ();        
    }
    
    if ( fire_relay_flag == 0 ) {
        if ( RFSTATEbits.receiving >= 2 ) {
//            TMR2 = 0; 
            if ( RFSTATEbits.receiving == 2 ) {
                RFSTATEbits.receiving = 3;
                Si4461_CMD_stream ( GET_INT_STATUS, 1 ); //Si4461_interrupt_reset ();
                wait_ready ();
            }
            else {
                if ( RFSTATEbits.receiving == 3 ) {
                    Nop(); Nop(); Nop();
                    T2CONbits.TON = 0; TMR2 = 0;// L_OUT = 0;
                    T1CONbits.TON = 0; TMR1 = 0;
                    RFSTATEbits.receiving = 4;

                    int k;
                    CS_SI4461 = 0;
                        writeSPI3(0x77); // READ Rx buffer command
                        for (k=0; k<8; k++)	{ rx_buf[k] = writeSPI3 (0); }
                    CS_SI4461 = 1;
                    RF_DataAvailable = 1;
                    Nop(); Nop(); Nop();
                }
            }

        } 
    }

IFS1bits.INT1IF = 0;
} //T2Interrupt



void pll_ON (void) {
// Configure PLL prescaler, PLL postscaler, PLL divisor
                                  //((16/2)*20)/4 = 40 MHz
    PLLFBDbits.PLLDIV  = 78;      // 18 => M = 20 (16MHz); 78 => M = 80 (4MHz) 
    CLKDIVbits.PLLPOST = 0b01;    // N2 = 4
    CLKDIVbits.PLLPRE  = 0b00000; // N1 = 2
// Initiate Clock Switch to Primary Oscillator with PLL (NOSC=0b011)
    __builtin_write_OSCCONH(0x03);
    __builtin_write_OSCCONL(OSCCON | 0x01);
    while (OSCCONbits.COSC!= 0b011); // Wait for Clock switch to occur
    while (OSCCONbits.LOCK!= 1);     // Wait for PLL to lock

}
void pll_switch_to_10MHz (void) {
// Configure PLL prescaler, PLL postscaler, PLL divisor
                                  //((16/2)*20)/4 = 40 MHz
//    PLLFBDbits.PLLDIV  = 78;      // 18 => M = 20 (16MHz); 78 => M = 80 (4MHz) 
    if (Fp1 == 10) {CLKDIVbits.PLLPOST = 0b11;}    // N2 = 4
    else {CLKDIVbits.PLLPOST = 0b01;}
//    CLKDIVbits.PLLPRE  = 0b00000; // N1 = 4
// Initiate Clock Switch to Primary Oscillator with PLL (NOSC=0b011)
//    __builtin_write_OSCCONH(0x03);
//    __builtin_write_OSCCONL(OSCCON | 0x01);
//    while (OSCCONbits.COSC!= 0b011); // Wait for Clock switch to occur
//    while (OSCCONbits.LOCK!= 1);     // Wait for PLL to lock

}
void switch_off_unused_periferals (void) {
    
    PMD1bits.AD1MD  = 0;
    PMD1bits.C1MD   = 0;
    PMD1bits.C2MD   = 0;
    PMD1bits.DCIMD  = 1;
    PMD1bits.I2C1MD = 1;
# if defined (dsPIC33EP256MU806)    
    PMD1bits.PWMMD  = 1;
    PMD1bits.QEI1MD = 1;
# endif    
    PMD1bits.SPI1MD = 0;
    PMD1bits.SPI2MD = 0;
    PMD1bits.T1MD   = 0;
    PMD1bits.T2MD   = 0;
    PMD1bits.T3MD   = 0;
    PMD1bits.T4MD   = 0;
    PMD1bits.T5MD   = 1;
    PMD1bits.U1MD   = 0;
    PMD1bits.U2MD   = 0;

    PMD2bits.OC1MD = 0;
    PMD2bits.OC2MD = 1;
    PMD2bits.OC3MD = 1;
    PMD2bits.OC4MD = 1;
    PMD2bits.OC5MD = 1;
    PMD2bits.OC6MD = 1;
    PMD2bits.OC7MD = 1;
    PMD2bits.OC8MD = 1;
    PMD2bits.IC1MD = 1;
    PMD2bits.IC2MD = 1;
    PMD2bits.IC3MD = 1;
    PMD2bits.IC4MD = 1;
    PMD2bits.IC5MD = 1;
    PMD2bits.IC6MD = 1;
    PMD2bits.IC7MD = 1;
    PMD2bits.IC8MD = 1;

    PMD3bits.AD2MD  = 1;
    PMD3bits.I2C2MD = 1;
    PMD3bits.U3MD   = 0;
# if defined (dsPIC33EP256MU806)    
    PMD3bits.QEI2MD = 1;
# endif    
    PMD3bits.DAC1MD = 1;
    PMD3bits.CRCMD  = 1;
    PMD3bits.PMPMD  = 1;
    PMD3bits.RTCCMD = 1;
    PMD3bits.CMPMD  = 0;
    PMD3bits.T6MD   = 0;
    PMD3bits.T7MD   = 0;
    PMD3bits.T8MD   = 0;
    PMD3bits.T9MD   = 1;
# if defined (dsPIC33EP256MU806)
    PMD4bits.USB1MD = 1;
# endif    
    PMD4bits.REFOMD = 1;
    PMD4bits.U4MD   = 0;

    PMD5bits.OC9MD  = 1;
    PMD5bits.OC10MD = 1;
    PMD5bits.OC11MD = 1;
    PMD5bits.OC12MD = 1;
    PMD5bits.OC13MD = 1;
    PMD5bits.OC14MD = 1;
    PMD5bits.OC15MD = 1;
    PMD5bits.OC16MD = 1;
    PMD5bits.IC9MD  = 1;
    PMD5bits.IC10MD = 1;
    PMD5bits.IC11MD = 1;
    PMD5bits.IC12MD = 1;
    PMD5bits.IC13MD = 1;
    PMD5bits.IC14MD = 1;
    PMD5bits.IC15MD = 1;
    PMD5bits.IC16MD = 1;

    PMD6bits.SPI3MD = 0;
    PMD6bits.SPI4MD = 1;
# if defined (dsPIC33EP256MU806)    
    PMD6bits.PWM1MD = 1;
    PMD6bits.PWM2MD = 1;
    PMD6bits.PWM3MD = 1;
    PMD6bits.PWM4MD = 1;
# endif
    PMD7bits.DMA0MD  = 0;
    PMD7bits.DMA4MD  = 1;//!!!!
    PMD7bits.DMA8MD  = 1;
    PMD7bits.DMA12MD = 1;
    PMD7bits.DMA1MD  = 0;
    PMD7bits.DMA5MD  = 1;//!!!!
    PMD7bits.DMA9MD  = 1;
    PMD7bits.DMA13MD = 1;
    PMD7bits.DMA2MD  = 0;
    PMD7bits.DMA6MD  = 1;
    PMD7bits.DMA10MD = 1;
    PMD7bits.DMA14MD = 1;
    PMD7bits.DMA3MD  = 0;
    PMD7bits.DMA7MD  = 1;
    PMD7bits.DMA11MD = 1;
    
}
void init_analog (void) {
    AD1CON1 = 0;
    AD2CON1 = 0;
    CM1CON = 0;
    CM2CON = 0;
    CM3CON = 0;
    ANSELB = 0b0000010000001100;
    ANSELC = 0;
    ANSELD = 0b0000000011000000;
    ANSELE = 0b0000000000000000;
    ANSELG = 0b0000000000000000;
    
    CVRCON = 0x00E7;
    CM3CON = 0x4140; //8250
//    IEC1bits.CMIE = 1;
    CM3CONbits.CON = 1;
}
void init_ADC1(void) {
/* Initialize ADC module */
AD1CON1bits.ADSIDL = 0;// Стоп в idle
AD1CON1bits.AD12B  = 0;// 10bit
AD1CON1bits.FORM   = 0;// Стоп в idle
AD1CON1bits.SSRC   = 7;// Auto convert
AD1CON1bits.SSRCG  = 0;// 
AD1CON1bits.SIMSAM = 0;//
AD1CON1bits.ASAM   = 0;// Ручной запуск

AD1CON2bits.VCFG  = 0b100;// AVDD, AVSS
AD1CON2bits.CSCNA = 0;// does not scan inputs
AD1CON2bits.CHPS  = 0b01;//0 converts CH0
AD1CON2bits.SMPI  = 0;// Generates interrupt after completion of every sample/conversion operation
AD1CON2bits.BUFM  = 0;// Always starts filling the buffer from the Start address.
AD1CON2bits.ALTS  = 0;// Always uses channel input selects for Sample A

AD1CON3bits.ADRC  = 0;// System clock
AD1CON3bits.SAMC  = 1;// Auto-Sample Time 1Tad
AD1CON3bits.ADCS  = 0b11111111;//ADC Conversion Clock 256TCY = TAD
AD1CON4           = 0;// No DMA

AD1CSSH = 0x0000;
AD1CSSL = 0x0000;

AD1CHS123 = 0;
AD1CHS0bits.CH0NA   = 0;
AD1CHS0bits.CH0NB   = 0;
AD1CHS0bits.CH0SA   = 2; //2
/* Enable ADC module and provide ADC stabilization delay */
AD1CON1bits.ADON = 1;
}
void init_IO (void) {
    ODCD  = 0b0000011000000000;
    ODCF  = 0b0000000000001000;
    ODCG  = 0b0000000000000000;

    
    LATC  = 0b0010000000000000;
    LATD  = 0b0000011000101000;    
    LATE  = 0b0000000000000001; // LATE7 в единицу для управления расширителем портов
    LATF  = 0b0000000000111000;
    LATG  = 0b0000001000000000;

# if defined (MCP23S08)
    LATB  = 0b0000000111000011;//0b0000000100000010;
    TRISB = 0b1100100000111100;    
# else
    LATB  = 0b0000000111000010;//0b0000000100000010;
    TRISB = 0b1100101000111100;
# endif    
    
    TRISC = 0b0100000000000000;
    TRISD = 0b0000100011101110;
    TRISE = 0b0000000001111110; // LATE7 в единицу для откл управления расширителем портов
    TRISF = 0b0000000000110011;   
    TRISG = 0b0000000010001100;
    
    MODEM_SLEEP = 0;
    
}
void configure_RP_RPI (void) {

    // Unlock Registers
    asm volatile (
                "MOV #OSCCON, w1 \n"
                "MOV #0x46, w2 \n"
                "MOV #0x57, w3 \n"
                "MOV.b w2, [w1] \n"
                "MOV.b w3, [w1] \n"
                "BCLR OSCCON,#6");

    // Configure Input Functions
          RPINR18bits.U1RXR = 81; // Assign U1RX To Pin RPI81
          RPINR19bits.U2RXR = 86; // Assign U2RX To Pin RPI86
          RPINR28bits.U4RXR = 83; // Assign U4RX To Pin RPI83
          RPINR27bits.U3RXR = 36; // Assign U4RX To Pin RPI83
          RPINR20bits.SDI1R = 37; // Assign SDI1 To Pin RP10
          RPINR29bits.SDI3R = 62; // Assign SDI3 To Pin RPI62
          RPINR0bits.INT1R  = 75; // Assign INT1 To Pin RPI75
          
          RPINR26bits.C1RXR = 47; // Assign CAN1 To Pin RPI47
          RPINR26bits.C2RXR = 46; // Assign CAN2 To Pin RPI46
          
    //Configure Output Functions
          RPOR5bits.RP82R = 1;    // Assign U1TX To Pin RP82
          RPOR6bits.RP85R = 3;    // Assign U2TX To Pin RP85
          RPOR1bits.RP67R = 27;   // Assign U3TX To Pin RP67          
          RPOR5bits.RP84R = 29;   // Assign U4TX To Pin RP85
          RPOR2bits.RP68R = 16;   // Assign OC1  To Pin RP68
//          RPOR2bits.RP68R = 17;   // Assign OC2  To Pin RP68          
          RPOR2bits.RP69R = 26;   // Assign C3OUT  To Pin RP69
          RPOR7bits.RP96R = 5;    // Assign SDO1 To Pin RP96
          RPOR7bits.RP97R = 6;    // Assign SCK1 To Pin RP97
          RPOR0bits.RP65R = 31;   // Assign SDO3 To Pin RP65    
          RPOR1bits.RP66R = 32;   // Assign SCK3 To Pin RP66
          
          RPOR9bits.RP101R = 14;   // Assign C1Tx To Pin RP101
          RPOR9bits.RP100R = 15;   // Assign C2Tx To Pin RP100
          
    // Lock Registers
    asm volatile (
                "MOV #OSCCON, w1 \n"
                "MOV #0x46, w2 \n"
                "MOV #0x57, w3 \n"
                "MOV.b w2, [w1] \n"
                "MOV.b w3, [w1] \n"
                "BSET OSCCON, #6");
 }
void init_CNI () {
    IPC4bits.CNIP = 4;
//    CNENBbits.CNIEB15 = 1; // Enable RB15 pin for interrupt detection
//    CNENBbits.CNIEB14 = 1; // Enable RB15 pin for interrupt detection
    CNENGbits.CNIEG2 = 1;
    CNENGbits.CNIEG3 = 1; // Enable RB15 pin for interrupt detection    
    IEC1bits.CNIE = 1; // Enable CN interrupts
    IFS1bits.CNIF = 0; // Reset CN interrupt
}
void init_INT1(void) {
    
    INTCON2bits.INT1EP = 1;
    IPC5bits.INT1IP1 = 5;
    IFS1bits.INT1IF = 0;
    IEC1bits.INT1IE = 1;
    
}

void init_OC1 (void) {
    OC1CON1 = 0; /* It is a good practice to clear off the control bits initially */
    OC1CON2 = 0;
    OC1CON1bits.OCTSEL = 0x07; /* This selects the peripheral clock as the clock 
                                  input to the OC module */
    OC1R = 800; /* This is just a typical number, user must calculate based on 
                    the waveform requirements and the system clock */
    OC1RS = 2000; /* Determines the Period */
    OC1CON2bits.SYNCSEL = 0x1F; /* This selects the synchronization source as itself */
    OC1CON1bits.OCM = 6; /* This selects and starts the Edge Aligned PWM mode*/
}

void init_SPI (void) {
	SPI2CON1 = 0x013B;//0x013B
	SPI2STAT = 0x8000;

	SPI1CON1 = 0x013B;//0x013B
	SPI1STAT = 0x8000;

	SPI3CON1 = 0x013B;//0x013B
	SPI3STAT = 0x8000;
    
}
void init_UART (void) {
/*
	U1BRG = 207; // ???????? 9600
	U1MODE = 0;
	U1MODEbits.BRGH = 1;
	U1MODEbits.UARTEN = 0;
        asm ("nop");
	asm ("nop");
	U1STA = 0;
	U1STAbits.UTXINV = 0;
	U1STAbits.UTXEN = 1;
	U1STAbits.URXISEL1 = 0;
	U1STAbits.URXISEL0 = 0;
        IPC2bits.U1RXIP2 = 1; //Set Uart RX Interrupt Priority = 4
	IPC2bits.U1RXIP1 = 0;
	IPC2bits.U1RXIP0 = 0;
	IEC0bits.U1RXIE  = 1; //Enable Receive Interrupt
*/

	U1BRG =  42; // 520 - 9600@20MHz
	U1MODE = 0;
	U1MODEbits.BRGH = 1;
	U1MODEbits.UARTEN = 1;
	asm ("nop");
	asm ("nop");
	U1STA = 0;
	U1STAbits.UTXINV = 0;
	U1STAbits.UTXEN = 1;
	U1STAbits.URXISEL1 = 0;
	U1STAbits.URXISEL0 = 0;
	IPC2bits.U1RXIP2 = 0; //Set Uart RX Interrupt Priority = 3
	IPC2bits.U1RXIP1 = 1;
	IPC2bits.U1RXIP0 = 1;
	IEC0bits.U1RXIE  = 1; //Enable Receive Interrupt
        U1STAbits.UTXISEL0 = 1;
        U1STAbits.UTXISEL1 = 0;
	IPC3bits.U1TXIP2 = 0; //Set Uart RX Interrupt Priority = 3
	IPC3bits.U1TXIP1 = 1;
	IPC3bits.U1TXIP0 = 1;
	IEC0bits.U1TXIE  = 0; //Enable Transmit Interrupt


	U2BRG =  520; // 42 -> 115200
	U2MODE = 0;
	U2MODEbits.BRGH = 1;
	U2MODEbits.UARTEN = 1;
	asm ("nop");
	asm ("nop");
	U2STA = 0;
	U2STAbits.UTXINV = 0;
	U2STAbits.UTXEN = 1;
	U2STAbits.URXISEL1 = 0;
	U2STAbits.URXISEL0 = 0;
	IPC7bits.U2RXIP2 = 1; //Set Uart RX Interrupt Priority = 4
	IPC7bits.U2RXIP1 = 0;
	IPC7bits.U2RXIP0 = 0;
	IEC1bits.U2RXIE  = 1; //Enable Receive Interrupt
	IPC7bits.U2TXIP2 = 1; //Set Uart RX Interrupt Priority = 4
	IPC7bits.U2TXIP1 = 0;
	IPC7bits.U2TXIP0 = 0;
	IEC1bits.U2TXIE  = 0; //Enable Transmit Interrupt

# if defined (WBUS)
    U3BRG = 520; //2400 baud WBUS 
    U3MODE = 0;
    U3MODEbits.PDSEL = 0b01; //Even parity WBUS
	U3MODEbits.BRGH = 0;
	U3MODEbits.UARTEN = 1;
	asm ("nop");
	asm ("nop");
	U3STA = 0;
	U3STAbits.UTXINV = 0;
	U3STAbits.UTXEN = 1;
	U3STAbits.URXISEL1 = 0;
	U3STAbits.URXISEL0 = 0;
	IPC20bits.U3RXIP2 = 0; //Set Uart RX Interrupt Priority = 3
	IPC20bits.U3RXIP1 = 1;
	IPC20bits.U3RXIP0 = 1;
	IEC5bits.U3RXIE  = 1; //Enable Receive Interrupt
        U3STAbits.UTXISEL0 = 1;
        U3STAbits.UTXISEL1 = 0;
	IPC20bits.U3TXIP2 = 0; //Set Uart RX Interrupt Priority = 3
	IPC20bits.U3TXIP1 = 1;
	IPC20bits.U3TXIP0 = 1;
	IEC5bits.U3TXIE  = 0; //Enable Transmit Interrupt 
#endif
# if defined (K_LINE)    
	U3BRG =  119; // 
	U3MODE = 0;
	U3MODEbits.BRGH = 0;
	U3MODEbits.UARTEN = 1;
	asm ("nop");
	asm ("nop");
	U3STA = 0;
	U3STAbits.UTXINV = 0;
	U3STAbits.UTXEN = 1;
	U3STAbits.URXISEL1 = 0;
	U3STAbits.URXISEL0 = 0;
	IPC20bits.U3RXIP2 = 0; //Set Uart RX Interrupt Priority = 3
	IPC20bits.U3RXIP1 = 1;
	IPC20bits.U3RXIP0 = 1;
	IEC5bits.U3RXIE  = 1; //Enable Receive Interrupt
        U3STAbits.UTXISEL0 = 1;
        U3STAbits.UTXISEL1 = 0;
	IPC20bits.U3TXIP2 = 0; //Set Uart RX Interrupt Priority = 3
	IPC20bits.U3TXIP1 = 1;
	IPC20bits.U3TXIP0 = 1;
	IEC5bits.U3TXIE  = 0; //Enable Transmit Interrupt    
# endif
# if defined (LIN)    
	U3BRG =  129; // 9600 
	U3MODE = 0;
	U3MODEbits.BRGH = 0;
	U3MODEbits.UARTEN = 1;
//    U3MODEbits.WAKE = 1;
//    U3MODEbits.ABAUD = 1;
	asm ("nop");
	asm ("nop");
	U3STA = 0;
	U3STAbits.UTXINV = 0;
	U3STAbits.UTXEN = 1;
	U3STAbits.URXISEL1 = 0;
	U3STAbits.URXISEL0 = 0;
//	IPC20bits.U3RXIP2 = 0; //Set Uart RX Interrupt Priority = 3
//	IPC20bits.U3RXIP1 = 1;
//	IPC20bits.U3RXIP0 = 1;
        IPC20bits.U3RXIP = 4; //UART2 RX Interrupt Priority, mid-range
        IPC20bits.U3TXIP = 4; //UART2 TX Interrupt Priority, mid-range
        IPC20bits.U3EIP = 5; //UART2 Error Interrupt Priority set higher 
        IEC5bits.U3EIE = 1;
        IEC5bits.U3RXIE  = 1; //Enable Receive Interrupt
        U3STAbits.UTXISEL0 = 1;
        U3STAbits.UTXISEL1 = 0;
//	IPC20bits.U3TXIP2 = 0; //Set Uart RX Interrupt Priority = 3
//	IPC20bits.U3TXIP1 = 1;
//	IPC20bits.U3TXIP0 = 1;
	IEC5bits.U3TXIE  = 0; //Enable Transmit Interrupt    
# endif
# if defined (MAZDA_LOCK)    
	U3BRG =  86; // 14400 
	U3MODE = 0;
	U3MODEbits.BRGH = 0;
	U3MODEbits.UARTEN = 1;
//    U3MODEbits.WAKE = 1;
//    U3MODEbits.ABAUD = 1;
	asm ("nop");
	asm ("nop");
	U3STA = 0;
	U3STAbits.UTXINV = 0;
	U3STAbits.UTXEN = 1;
	U3STAbits.URXISEL1 = 0;
	U3STAbits.URXISEL0 = 0;
//	IPC20bits.U3RXIP2 = 0; //Set Uart RX Interrupt Priority = 3
//	IPC20bits.U3RXIP1 = 1;
//	IPC20bits.U3RXIP0 = 1;
        IPC20bits.U3RXIP = 4; //UART2 RX Interrupt Priority, mid-range
        IPC20bits.U3TXIP = 4; //UART2 TX Interrupt Priority, mid-range
        IPC20bits.U3EIP = 5; //UART2 Error Interrupt Priority set higher 
        IEC5bits.U3EIE = 1;
        IEC5bits.U3RXIE  = 1; //Enable Receive Interrupt
        U3STAbits.UTXISEL0 = 1;
        U3STAbits.UTXISEL1 = 0;
//	IPC20bits.U3TXIP2 = 0; //Set Uart RX Interrupt Priority = 3
//	IPC20bits.U3TXIP1 = 1;
//	IPC20bits.U3TXIP0 = 1;
	IEC5bits.U3TXIE  = 0; //Enable Transmit Interrupt    
# endif
    
    U4BRG =  42; // 16 (8MHz) 115200
	U4MODE = 0;
	U4MODEbits.BRGH = 1;
	U4MODEbits.UARTEN = 1;
	asm ("nop");
	asm ("nop");
	U4STA = 0;
	U4STAbits.UTXINV = 0;
	U4STAbits.UTXEN = 1;
	U4STAbits.URXISEL1 = 0;
	U4STAbits.URXISEL0 = 0;
	IPC22bits.U4RXIP2 = 1; //Set Uart RX Interrupt Priority = 5
	IPC22bits.U4RXIP1 = 0;
	IPC22bits.U4RXIP0 = 1;
    
	IEC5bits.U4RXIE  = 1; //Enable Receive Interrupt
        U4STAbits.UTXISEL0 = 1;
        U4STAbits.UTXISEL1 = 0;
	IPC22bits.U4TXIP2 = 1; //Set Uart RX Interrupt Priority = 5
	IPC22bits.U4TXIP1 = 0;
	IPC22bits.U4TXIP0 = 1;
	IEC5bits.U4TXIE  = 0; //Enable Transmit Interrupt

}
void init_timer6 (void) {
    T6CON = 0x8000;
    PR6 = 20000;
//	IEC2bits.T6IE = 1;
}
void init_timer5 (void) {
    T5CON = 0x8000;
    PR5 = 3704;
//	IEC1bits.T5IE = 1;
}
void init_timer7 (void) {
// прерывания через 12 мкс
    IPC12bits.T7IP = 6;
    T7CON = 0x0000;
    PR7 = 728;

}
void init_timer3 (void) {
    T3CON = 0x8000; //0x8000
	PR3 = 10000; //4000
	IEC0bits.T3IE = 1;
}
void init_timer4 (void) {
    T4CON = 0x8010; // 20Mhz/8 => period 0.4 us
	PR4 = 25000;    // 10 ms interrupts
	IEC1bits.T4IE = 1;
}
void init_timer1 (void) {
    
    IPC0bits.T1IP = 5;
    T1CON = 0x0030;
    IEC0bits.T1IE = 1;
    
}
void init_timer2 (void) {
    
    IPC1bits.T2IP = 5;
    T2CON = 0x0030; // 12.8us
    TMR2 = 0;
    PR2 = 594; // 7.5ms
    IEC0bits.T2IE = 1;
    
}
void init_timer8 (void) {
    
    IPC12bits.T8IP = 5;
    T8CON = 0x0010; // 12.8us
    TMR8 = 0;
    PR8 = 6250; //12500 5ms; 6250 2.5ms  2500 1ms
    IEC3bits.T8IE = 1;
    
}
void init_sms_ptrs_buf (void) {
    SMS_to_send_ptrs_buf[0] = (unsigned int)SMS_to_send_buf0; SMS_to_send_ptrs_buf[1] = (unsigned int)SMS_to_send_buf1;
    SMS_to_send_ptrs_buf[2] = (unsigned int)SMS_to_send_buf2; SMS_to_send_ptrs_buf[3] = (unsigned int)SMS_to_send_buf3;
    SMS_to_send_ptrs_buf[4] = (unsigned int)SMS_to_send_buf4;
}
void init_GPRS_nums_to_send_buf (void) {
    GPRS_nums_to_send_buf[0] = (unsigned int)GPRS_to_send_buf0;
    GPRS_nums_to_send_buf[1] = (unsigned int)GPRS_to_send_buf1;
    GPRS_nums_to_send_buf[2] = (unsigned int)GPRS_to_send_buf2;
    GPRS_nums_to_send_buf[3] = (unsigned int)GPRS_to_send_buf3;
    GPRS_nums_to_send_buf[4] = (unsigned int)GPRS_to_send_buf4;
}
void init_save_to_flash_ptrs_buf (void) {
    
    save_to_flash_ptrs_buf[0] = (unsigned int)save_to_flash_buf0;
    save_to_flash_ptrs_buf[1] = (unsigned int)save_to_flash_buf1;
    save_to_flash_ptrs_buf[2] = (unsigned int)save_to_flash_buf2;
    save_to_flash_ptrs_buf[3] = (unsigned int)save_to_flash_buf3;

}

# if defined (L76_L)
int  get_navigation_data (void) {

unsigned char  *rmc_end_ptr, *rmc_start_ptr, *gga_end_ptr, *gga_start_ptr, *gsa1_end_ptr, *gsa1_start_ptr;
unsigned char  *gsa2_end_ptr, *gsa2_start_ptr, *tmp_ptr, *tmp_ptr2, *tmp_ptr3, *tmp_ptr4, *speed_start_ptr, *speed_end_ptr, *course_start_ptr, *course_end_ptr;
unsigned char *alt_start_ptr, *alt_end_ptr;
unsigned int z, z1, z2, z3, z5, speed_point, course_point, alt_point, speed_len, course_len, alt_len;
//unsigned char z4, gga, gsa1, gsa2, rmc;
int rmc_len, gga_len, gsa1_len, gsa2_len, number_of_strings;
unsigned char GPGL_sat_number;
unsigned char GL_sat_number, GSV_flag, MTK_flag;


//_LATB6 = 1;

//z1 = 0; z2 = 0; z3 = 0, z5 = 0;
//gga = 0x30; gsa1 = 0x30; gsa2 = 0x30; rmc = 0x30;
speed_point = 0;
course_point = 0;

const unsigned char str1[] = "\r\n\0";
const unsigned char str2[] = ",\0";
const unsigned char str3[] = ".\0";
const unsigned char str4[] = "*\0";
const unsigned char RMC[]  = "RMC\0";
const unsigned char GGA[]  = "GGA\0";
const unsigned char GSA[]  = "GSA\0";

const unsigned char set_sentence[] = "$PMTK314,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0*2D\r\n"; //
//const unsigned char set_sentence[] = "$PMTK314,1,1,1,1,1,5,0,0,0,0,0,0,0,0,0,0,0,1,0*2?\r\n";

unsigned int rmc_comma_ptrs [17];
unsigned int gga_comma_ptrs [18];
unsigned int gsa2_comma_ptrs [21];
volatile unsigned int $_ptrs [11], end_mark_ptrs [11];

if (UART2_buf[0] != '$') { restart_navdata_receiving(); return 0; }
if (UART2_buf[3] != 'R' || UART2_buf[4] != 'M' || UART2_buf[5] != 'C') { 
    restart_navdata_receiving(); 
    return 0; 
}

    IEC1bits.U2RXIE = 0;
        memmove ( UART_Rx_copy_buf, UART2_buf, num_of_bytes_tmp ); //UART_Rx_copy_buf //UART_Rx_copy_buf_gnss
        UART_Rx_copy_buf[num_of_bytes_tmp] = 0; //UART_Rx_copy_buf //UART_Rx_copy_buf_gnss
//        Start_accumulation = 0;
//        num_of_bytes = 0;
    IEC1bits.U2RXIE = 1;

    if (navi_wait_timer > 0) return 0;
    
    number_of_strings = 0;

    unsigned char *temp_ptr, temp1, temp2, temp3, temp4;
    temp_ptr = &UART_Rx_copy_buf[0]; //UART_Rx_copy_buf //UART_Rx_copy_buf_gnss
    
    for ( z = 0; z < 11; z++ ) {
        $_ptrs[z] = strstr(temp_ptr, "$");
        end_mark_ptrs[z] = strstr(temp_ptr, "*");
        if (end_mark_ptrs[z] == 0) { $_ptrs[z] = 0; break; }
        temp_ptr = end_mark_ptrs[z] + 1;
    }        
    $_ptrs[10] = 0; end_mark_ptrs[10] = 0;
    gga_start_ptr = 0; gsa1_start_ptr = 0; gsa2_start_ptr = 0; rmc_start_ptr  = 0;
    gga_end_ptr = 0;   gsa1_end_ptr = 0;   gsa2_end_ptr = 0;   rmc_end_ptr  = 0;
    gga_len = 0;       gsa1_len = 0;       gsa1_len = 0;       rmc_len  = 0;

GSV_flag = 0;
MTK_flag = 0; 
    for ( z1 = 0; z1 < z; z1 ++ ) {
        temp_ptr = $_ptrs[z1];
        if (*(temp_ptr + 3)  =='G'  && *(temp_ptr + 4)  =='G' && *(temp_ptr + 5)   =='A') {gga_start_ptr  = temp_ptr + 3;  gga_end_ptr  =  end_mark_ptrs[z1];}
        if (*(temp_ptr + 3)  =='G'  && *(temp_ptr + 4)  =='S' && *(temp_ptr + 5)   =='A') {
            if (gsa1_start_ptr == 0) {
                gsa1_start_ptr = temp_ptr + 3;  gsa1_end_ptr = end_mark_ptrs[z1];
            } else {
                gsa2_start_ptr = temp_ptr + 3;  gsa2_end_ptr = end_mark_ptrs[z1];
            }
        }
//        if ( gsa1_start_ptr != 0    && *(temp_ptr + 3)  =='G' && *(temp_ptr + 4)   =='S' && *(temp_ptr + 5)=='A') {gsa2_start_ptr = temp_ptr + 3;  gsa2_end_ptr = $_ptrs[z1 + 1] - 2;}
        if (*(temp_ptr + 3)  =='R'  && *(temp_ptr + 4)  =='M' && *(temp_ptr + 5)   =='C') {rmc_start_ptr  = temp_ptr + 3;  rmc_end_ptr  = end_mark_ptrs[z1];}
        if (*(temp_ptr + 3)  =='G'  && *(temp_ptr + 4)  =='S' && *(temp_ptr + 5)   =='V') GSV_flag = 1;
        if (*(temp_ptr + 3)  =='M'  && *(temp_ptr + 4)  =='T' && *(temp_ptr + 5)   =='K') MTK_flag = 1;
    }

if (MTK_flag == 1) {
    Nop();Nop();Nop();
}

unsigned char check_summ, check_summ1, check_summ2;
check_summ = 0;
if (GSV_flag == 1) {
    
    for (z = 1; z <= 45; z ++) {
        check_summ = check_summ ^ set_sentence[z];
    }
    Nop();Nop();Nop();
    check_summ1 = (check_summ & 0xF0) >> 4;
    check_summ2 = check_summ & 0x0F;
    memmove ( UART2_Tx_buf, set_sentence, 52 );
    if (check_summ1 >= 0 && check_summ1 <= 9) {UART2_Tx_buf[47] = check_summ1 + 0x30;}
    else {UART2_Tx_buf[47] = check_summ1 + 0x37;}
    if (check_summ2 >= 0 && check_summ2 <= 9) {UART2_Tx_buf[48] = check_summ2 + 0x30;}
    else {UART2_Tx_buf[48] = check_summ2 + 0x37;}
    Nop();Nop();Nop();
    start_UART2_transmission (0);
    
}



int *cptr; // было int *cptr;
check_summ = 0;
check_summ1 = 0;
check_summ2 = 0;


// Check summ and comma's pointers of RMC string
    cptr = rmc_comma_ptrs;
    *cptr = 0;
    cptr++;
    tmp_ptr = rmc_start_ptr - 2;
    tmp_ptr2 = rmc_end_ptr;
    
if (rmc_end_ptr == 0xFFFE) {
Nop(); Nop();Nop();
return 0;
}    
    
    while (tmp_ptr < tmp_ptr2) {
            check_summ = check_summ ^ *tmp_ptr;
            if (*tmp_ptr == ',') {*cptr = tmp_ptr; cptr++;}
            tmp_ptr++;
    }
    *cptr = 0;
    check_summ1 = *(rmc_end_ptr + 1);
    check_summ2 = *(rmc_end_ptr + 2);
    if (check_summ1 > 0x40) check_summ1 = check_summ1 - 0x37;
    else check_summ1 = check_summ1 - 0x30;
    if (check_summ2 > 0x40) check_summ2 = check_summ2 - 0x37;
    else check_summ2 = check_summ2 - 0x30;
    check_summ1 = (check_summ1 << 4) + check_summ2;
    if (check_summ != check_summ1) {  return 0; }// restart_navdata_receiving();


// Check summ and comma's pointers of GSA2 string
    check_summ = 0;
    cptr = gsa2_comma_ptrs;
    *cptr = 0;
    cptr++;
    tmp_ptr = gsa2_start_ptr - 2;
    tmp_ptr2 = gsa2_end_ptr;
        while (tmp_ptr < tmp_ptr2) {
            check_summ = check_summ ^ *tmp_ptr;
            if (*tmp_ptr == ',') { *cptr = tmp_ptr; cptr++; }
            tmp_ptr++;
        }
    if (gsa2_start_ptr != 0) { // GSA2 string exist
        *cptr = 0;
        check_summ1 = *(gsa2_end_ptr + 1);
        check_summ2 = *(gsa2_end_ptr + 2);
        if (check_summ1 > 0x40) check_summ1 = check_summ1 - 0x37;
        else check_summ1 = check_summ1 - 0x30;
        if (check_summ2 > 0x40) check_summ2 = check_summ2 - 0x37;
        else check_summ2 = check_summ2 - 0x30;
        check_summ1 = (check_summ1 << 4) + check_summ2;
        if (check_summ != check_summ1) {  return 0; }// restart_navdata_receiving();
    }

// Check summ and comma's pointers of GGA string
    check_summ = 0;
    cptr = gga_comma_ptrs;
    *cptr = 0;
    cptr++;
    tmp_ptr = gga_start_ptr - 2;
    tmp_ptr2 = gga_end_ptr;
    while (tmp_ptr < tmp_ptr2) {
            check_summ = check_summ ^ *tmp_ptr;
            if (*tmp_ptr == ',') {*cptr = tmp_ptr; cptr++;}
            tmp_ptr++;
    }
    *cptr = 0;
    check_summ1 = *(gga_end_ptr + 1);
    check_summ2 = *(gga_end_ptr + 2);
    if (check_summ1 > 0x40) check_summ1 = check_summ1 - 0x37;
    else check_summ1 = check_summ1 - 0x30;
    if (check_summ2 > 0x40) check_summ2 = check_summ2 - 0x37;
    else check_summ2 = check_summ2 - 0x30;
    check_summ1 = (check_summ1 << 4) + check_summ2;
    if (check_summ != check_summ1) {  return 0; }// restart_navdata_receiving();

    
    
// Type of navigation P - GPS, L - GLONASS, N - GPS+GLONASS
	tmp_ptr = rmc_start_ptr;
        Navi_str [68] = *(--tmp_ptr);
        Navi_str_last_known [68] = Navi_str [68];
        Navi_str [69] = ',';
// Status of fix: V - not correct, A - correct
	tmp_ptr = rmc_comma_ptrs[2];
//	Navigation_mode_ind = *(++tmp_ptr);
        Navi_str [62] = *(++tmp_ptr);
        Navi_str_last_known [62] = Navi_str [62];
        Navi_str [63] = ',';
// 1 - not correct fix, 2 - 2D fix, 3 - 3D fix
       	tmp_ptr = gsa1_start_ptr;
//	Mode_of_operation = *(tmp_ptr + 6);
        Navi_str [66] = *(tmp_ptr + 6);
        Navi_str_last_known [66] = Navi_str [66];
        Navi_str [67] = ',';
// N - not correct, E - not anought satellites, A - autonomous, D - differential
    tmp_ptr = rmc_comma_ptrs[12];
        Navi_str [64] = *(++tmp_ptr);
        Navi_str_last_known [64] = Navi_str [64];
        Navi_str [65] = ',';
        
/*   memmove ( Navi_str_last_known, Navi_str, 76 ); */

        // Time
            tmp_ptr = rmc_comma_ptrs[1];
                Navi_str [0] =  *(++tmp_ptr); Navi_str [1] = *(++tmp_ptr);
                Navi_str [2] =  *(++tmp_ptr); Navi_str [3] = *(++tmp_ptr);
                Navi_str [4] =  *(++tmp_ptr); Navi_str [5] = *(++tmp_ptr);
                Navi_str [6] =  *(++tmp_ptr); Navi_str [7] = *(++tmp_ptr);
                Navi_str [8] = ',';
                
        /* Date*/
            tmp_ptr = rmc_comma_ptrs[9];	tmp_ptr2 = rmc_comma_ptrs[10];
                memmove(Navi_str + 9, tmp_ptr + 1, tmp_ptr2 - tmp_ptr - 1);
                Navi_str [15] = ',';

         /* Full number of satellits in view */
            tmp_ptr = gga_comma_ptrs[7];
            Navi_str[70] = *(++tmp_ptr);
            Navi_str[71] = *(++tmp_ptr);
            if (Navi_str[71] == ',') {Navi_str[71] = Navi_str[70]; Navi_str[70] = '0';}
            Navi_str_last_known [70] = Navi_str [70]; Navi_str_last_known [71] = Navi_str [71];
            Navi_str[72] = ',';
            GPGL_sat_number = 0;
            GPGL_sat_number = 10 * (Navi_str[70] - 0x30) + (Navi_str[71] - 0x30);
            if (GPGL_sat_number > 15) GPGL_sat_number = 15;                
                
    if (Navi_str [62] == 'A') {            
                
        /* Latitude*/
            tmp_ptr = rmc_comma_ptrs[3];
                Navi_str [16] = *(++tmp_ptr);	Navi_str [17] = *(++tmp_ptr);
                Navi_str [18] = *(++tmp_ptr);	Navi_str [19] = *(++tmp_ptr);
                Navi_str [20] = *(++tmp_ptr);	Navi_str [21] = *(++tmp_ptr);
                Navi_str [22] = *(++tmp_ptr);	Navi_str [23] = *(++tmp_ptr);
                Navi_str [24] = *(++tmp_ptr);   Navi_str [25] = 0x30;
                Navi_str [26] = ',';
        /*N/S*/        
                tmp_ptr = rmc_comma_ptrs[4];
                Navi_str[27] = *(++tmp_ptr);
                Navi_str[28] = ',';

        /* Longitude*/
            tmp_ptr = rmc_comma_ptrs[5];
                Navi_str [29] = *(++tmp_ptr);	Navi_str [30] = *(++tmp_ptr);
                Navi_str [31] = *(++tmp_ptr);	Navi_str [32] = *(++tmp_ptr);
                Navi_str [33] = *(++tmp_ptr);	Navi_str [34] = *(++tmp_ptr);
                Navi_str [35] = *(++tmp_ptr);	Navi_str [36] = *(++tmp_ptr);
                Navi_str [37] = *(++tmp_ptr);	Navi_str [38] = *(++tmp_ptr);
                Navi_str [39] = 0x30;
                Navi_str [40] = ',';

                tmp_ptr = rmc_comma_ptrs[6];
                Navi_str [41] = *(++tmp_ptr);
                Navi_str [42] = ',';

        /* Speed*/
        //	tmp_ptr = Navi_str; tmp_ptr = tmp_ptr + 48;
            tmp_ptr  = &Navi_str[50];
            tmp_ptr3 = &Navi_str[54];
            tmp_ptr2 = rmc_comma_ptrs[8];
            tmp_ptr4 = rmc_comma_ptrs[7];
            tmp_ptr--; tmp_ptr2 = tmp_ptr2 - 2; tmp_ptr4++; //tmp_ptr2--;
            while (tmp_ptr2 >= tmp_ptr4) {
                    if (tmp_ptr3 == tmp_ptr) break;
                    *tmp_ptr3 = *tmp_ptr2;
                    tmp_ptr2--; tmp_ptr3--;
            }
            while (tmp_ptr3 > tmp_ptr) {
                    *tmp_ptr3 = '0';
                    tmp_ptr3--;
            }
            Navi_str[55] = ',';

        /* Course*/
            tmp_ptr  = &Navi_str[56];
            tmp_ptr3 = &Navi_str[60];
            tmp_ptr2 = rmc_comma_ptrs[9];
            tmp_ptr4 = rmc_comma_ptrs[8];
            tmp_ptr--; tmp_ptr2 = tmp_ptr2 - 2; tmp_ptr4++;
            while (tmp_ptr2 >= tmp_ptr4) {
                    if (tmp_ptr3 == tmp_ptr) break;
                    *tmp_ptr3 = *tmp_ptr2;
                    tmp_ptr2--; tmp_ptr3--;
            }
            while (tmp_ptr3 > tmp_ptr) {
                    *tmp_ptr3 = '0';
                    tmp_ptr3--;
            }
            Navi_str[61] = ',';

//        /* Date*/
//                tmp_ptr = rmc_comma_ptrs[9];	tmp_ptr2 = rmc_comma_ptrs[10];
//            memmove(Navi_str + 9, tmp_ptr + 1, tmp_ptr2 - tmp_ptr - 1);
//                Navi_str [15] = ',';

        /* Altitude*/
            tmp_ptr = &Navi_str[43];
            tmp_ptr3 = tmp_ptr + 4; //5
            tmp_ptr2 = gga_comma_ptrs[10];	tmp_ptr4 = gga_comma_ptrs[9];
            tmp_ptr--; tmp_ptr2--; tmp_ptr4++;

            while (tmp_ptr2 >= tmp_ptr4) {
                    if (tmp_ptr3 == tmp_ptr) break;
                    *tmp_ptr3 = *tmp_ptr2;
                    tmp_ptr2--; tmp_ptr3--;
            }
            while (tmp_ptr3 > tmp_ptr) {
                    *tmp_ptr3 = '0';
                    tmp_ptr3--;
            }
            tmp_ptr2 = gga_comma_ptrs[10];
            tmp_ptr2++;
            Navi_str[48] = *tmp_ptr2;
            Navi_str[49] = ',';

         /* Full number of satellits in view */
//            tmp_ptr = gga_comma_ptrs[7];
//            Navi_str[70] = *(++tmp_ptr);
//            Navi_str[71] = *(++tmp_ptr);
//            if (Navi_str[71] == ',') {Navi_str[71] = Navi_str[70]; Navi_str[70] = '0';}
//            Navi_str[72] = ',';
//            GPGL_sat_number = 0;
//            GPGL_sat_number = 10 * (Navi_str[70] - 0x30) + (Navi_str[71] - 0x30);
//            if (GPGL_sat_number > 15) GPGL_sat_number = 15;
         /* Calculation number of GPS and GLONASS satellites separately */
                if (Navi_str[68] == 'P') { // Only GPS using
                    Navi_str[73] = '0';
                    Navi_str[74] = '0';
                }
                if (Navi_str[68] == 'L') { // Only GLONASS using
                    Navi_str[73] = Navi_str[70];
                    Navi_str[74] = Navi_str[71];
                }

        unsigned char i;        
                if (Navi_str[68] == 'N') { // Combyne
                    GL_sat_number = 0;
            // If second GSA string exists then colculate number of GLONASS satellites
                    if (gsa2_start_ptr != 0) {
                        i = 3;
                        while ((gsa2_comma_ptrs[i] + 1) != gsa2_comma_ptrs[i+1] ) {
                            i++;
                            GL_sat_number++;
                        }
                    }
                    bin_2_bcd ((long)GL_sat_number);
                    Navi_str[73] = bin_2_bcd_buf [7];
                    Navi_str[74] = bin_2_bcd_buf [8];
                }
                    Navi_str[75] = 0;
                    
                memmove ( Navi_str_last_known, Navi_str, 76 );
                int z;
                for (z = 0; z < 76; z++) {//Загрузка последней известной позиции в FRAM
                    FM25_write_1 (z + 434, Navi_str_last_known[z]);
                }
                
    } // if (Navi_str [62] == "A")
    else {
        memmove ( Navi_str + 15, Navi_str_last_known + 15, 60 );// 60
        GL_sat_number = 0; GPGL_sat_number = 0;
//        return 0;
    }            
                
        nav_trigger = 1;
        FIXFLAGSbits.ready = 1;
        
        
        
//        load_nav_telit_buf ();


unsigned char dig1, dig2, dig3, dig4, dig5, dig6, dig7, gig8, dig9, dig10;         
unsigned long navi_tmp, navi_tmp1, navi_tmp2;
int Alt;
// Lattitude
	navi_tmp = 0; navi_tmp1 = 0;
    navi_tmp1 = 100000000 * (unsigned long)(Navi_str[16] - 0x30) + 10000000 * (unsigned long)(Navi_str[17] - 0x30);
	dig1 = (Navi_str[18] - 0x30); dig2 = (Navi_str[19] - 0x30); dig3 = (Navi_str[21] - 0x30);
	dig4 = (Navi_str[22] - 0x30); dig5 = (Navi_str[23] - 0x30); dig6 = (Navi_str[24] - 0x30);
    dig7 = (Navi_str[25] - 0x30);
	navi_tmp =            100000000 * (unsigned long)dig1; navi_tmp = navi_tmp + 10000000  * (unsigned long)dig2;
    navi_tmp = navi_tmp + 1000000   * (unsigned long)dig3; navi_tmp = navi_tmp + 100000    * (unsigned long)dig4;
    navi_tmp = navi_tmp + 10000     * (unsigned long)dig5; navi_tmp = navi_tmp + 1000      * (unsigned long)dig6;
    navi_tmp = navi_tmp + 100       * (unsigned long)dig7;
    navi_tmp = (navi_tmp + 30)/60;
    navi_tmp1 = navi_tmp1 + navi_tmp;
    Lat1 = (float) navi_tmp1 / 10000000.0;
// Longitude    
	navi_tmp = 0; navi_tmp2 = 0;
    navi_tmp2 = 1000000000 * (Navi_str[29] - 0x30) + 100000000 * (Navi_str[30] - 0x30) + 10000000 * (Navi_str[31] - 0x30);
	dig1 = (Navi_str[32] - 0x30); dig2 = (Navi_str[33] - 0x30); dig3 = (Navi_str[35] - 0x30);
	dig4 = (Navi_str[36] - 0x30); dig5 = (Navi_str[37] - 0x30); dig6 = (Navi_str[38] - 0x30);
    dig7 = (Navi_str[39] - 0x30);
	navi_tmp =            100000000 * (unsigned long)dig1; navi_tmp = navi_tmp + 10000000  * (unsigned long)dig2;
    navi_tmp = navi_tmp + 1000000   * (unsigned long)dig3; navi_tmp = navi_tmp + 100000    * (unsigned long)dig4;
    navi_tmp = navi_tmp + 10000     * (unsigned long)dig5; navi_tmp = navi_tmp + 1000      * (unsigned long)dig6;
    navi_tmp = navi_tmp + 100       * (unsigned long)dig7;
    navi_tmp = (navi_tmp + 30)/60;
    navi_tmp2 = navi_tmp2 + navi_tmp;
    Long1 = (float)navi_tmp2 / 10000000.0;
// Altitude
    Alt = 0;
    if (Navi_str[43] == '-') {
        Alt = 10 * (Navi_str[44] - 0x30) + (Navi_str[45] - 0x30);
        Alt = Alt * (-1);
    }
    else {
        Alt = 100 * (Navi_str[43] - 0x30) + 10 * (Navi_str[44] - 0x30) + (Navi_str[45] - 0x30); //Alt = 100 * (Navi_str[43] - 0x30) + 10 * (Navi_str[44] - 0x30) + (Navi_str[45] - 0x30);
    }
    
// Heading
	course2 =           (Navi_str [56] - 0x30) * 100;
	course2 = course2 + (Navi_str [57] - 0x30) * 10;
	course2 = course2 + (Navi_str [58] - 0x30);
    
// Speed
	navi_tmp =            (Navi_str[50] - 0x30) * 1000;
	navi_tmp = navi_tmp + (Navi_str[51] - 0x30) * 100;
	navi_tmp = navi_tmp + (Navi_str[52] - 0x30) * 10;
	navi_tmp = navi_tmp + (Navi_str[54] - 0x30);
	navi_tmp =	navi_tmp * 1852; navi_tmp =	(navi_tmp + 5000) / 10000; // From knots to km/h
	if (navi_tmp > 255) navi_tmp = 255;
	speed2 = (unsigned char)navi_tmp;

    if (speed2 > max_speed) max_speed = speed2;
    
    load_navi_bin ( navi_tmp1, navi_tmp2, Alt, speed2, course2, GPGL_sat_number, GL_sat_number );
    
    
/* Distance between two points*/
float fi, lambda, sin2_fi, sin2_lambda, cos_lat1, cos_lat2;
	Lat1  = Lat1  * 0.0174533;
	Long1 = Long1 * 0.0174533;
	fi = (Lat1 - Lat2) / 2.0;
	lambda = (Long1 - Long2) / 2.0;
	sin2_fi = sinf(fi);
	sin2_fi = sin2_fi * sin2_fi;
	sin2_lambda = sinf(lambda);
	sin2_lambda = sin2_lambda * sin2_lambda;
	cos_lat1 = cosf(Lat1);
	cos_lat2 = cosf(Lat2);
	distance = cos_lat1 * cos_lat2;
	distance = distance * sin2_lambda;
	distance = distance + sin2_fi;
	distance = sqrtf(distance);
	distance = asinf(distance);
	distance = 2.0 * distance;
	distance = 57.2957795 * distance;
	distance = distance * 111.12;	// kilometers
	distance = distance * 1000.0;	// meters

	fix_to_fix_mileage = fix_to_fix_mileage + distance;

//static unsigned char odo_counter = 0;
    
    static unsigned int fix_good_counter = 0;
    if (Navi_str [62] == 'A') {
        if (fix_good_counter < 2) fix_good_counter ++;
    }  

if (Navi_str [62] == 'A' && fix_good_counter >= 2) {    
    if (ignition == 1) {
        navi_tmp = (unsigned long) (distance * 10.0);
        GPS_odometer = GPS_odometer + navi_tmp; 
        FM25_write_4( 71, (unsigned long) GPS_odometer );// 71, 72, 73, 74
    }
}

// Time
unsigned int c;
	time2 = (Navi_str[0] - 0x30) * 36000; c = (Navi_str[1] - 0x30) * 3600;
	time2 = time2 + c; c = (Navi_str[2] - 0x30) * 600;
	time2 = time2 + c; c = (Navi_str[3] - 0x30) * 60;
	time2 = time2 + c; c = (Navi_str[4] - 0x30) * 10;
	time2 = time2 + c; c = (Navi_str[5] - 0x30);
	time2 = time2 + c;
        
    Lat2  = Lat1;
	Long2 = Long1;

//restart_navdata_receiving();
return 1;
}
# endif
# if defined (KL3333)
int  get_navigation_data (void) {

unsigned char  *rmc_end_ptr, *rmc_start_ptr, *gga_end_ptr, *gga_start_ptr, *gsa1_end_ptr, *gsa1_start_ptr;
unsigned char  *gsa2_end_ptr, *gsa2_start_ptr, *tmp_ptr, *tmp_ptr2, *tmp_ptr3, *tmp_ptr4;//, *speed_start_ptr, *speed_end_ptr, *course_start_ptr, *course_end_ptr;
unsigned char *alt_start_ptr, *alt_end_ptr;
unsigned int z, z1, z2, z3, z5, speed_point, course_point, alt_point, speed_len, course_len, alt_len;
//unsigned char z4, gga, gsa1, gsa2, rmc;
int rmc_len, gga_len, gsa1_len, gsa2_len, number_of_strings;
unsigned char GPGL_sat_number = 0x0;
unsigned char GL_sat_number, GSV_flag, MTK_flag;


//_LATB6 = 1;

//z1 = 0; z2 = 0; z3 = 0, z5 = 0;
//gga = 0x30; gsa1 = 0x30; gsa2 = 0x30; rmc = 0x30;
speed_point = 0;
course_point = 0;

const unsigned char str1[] = "\r\n\0";
const unsigned char str2[] = ",\0";
const unsigned char str3[] = ".\0";
const unsigned char str4[] = "*\0";
const unsigned char RMC[]  = "RMC\0";
const unsigned char GGA[]  = "GGA\0";
const unsigned char GSA[]  = "GSA\0";

const unsigned char set_sentence[] = "$PMTK314,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0*2D\r\n"; //
//const unsigned char set_sentence[] = "$PMTK314,1,1,1,1,1,5,0,0,0,0,0,0,0,0,0,0,0,1,0*2?\r\n";

unsigned int rmc_comma_ptrs [17];
unsigned int gga_comma_ptrs [18];
unsigned int gsa2_comma_ptrs [21];
unsigned int $_ptrs [31];

if (UART2_buf[0] != '$') { restart_navdata_receiving(); return 0; }
if (UART2_buf[3] != 'G' || UART2_buf[4] != 'G' || UART2_buf[5] != 'A') { 
    restart_navdata_receiving(); 
    return 0; 
}

    IEC1bits.U2RXIE = 0;
        memmove ( UART_Rx_copy_buf, UART2_buf, num_of_bytes_tmp ); //UART_Rx_copy_buf //UART_Rx_copy_buf_gnss
        UART_Rx_copy_buf[num_of_bytes_tmp] = 0; //UART_Rx_copy_buf //UART_Rx_copy_buf_gnss
//        Start_accumulation = 0;
//        num_of_bytes = 0;
    IEC1bits.U2RXIE = 1;

    if (navi_wait_timer > 0) return 0;
    
    number_of_strings = 0;

    unsigned char *temp_ptr;//, temp1, temp2, temp3, temp4;
    temp_ptr = &UART_Rx_copy_buf[0]; //UART_Rx_copy_buf //UART_Rx_copy_buf_gnss
    
    for ( z = 0; z < 30; z++ ) {
        $_ptrs[z] = strstr(temp_ptr, "$");
        if ($_ptrs[z] == 0) break;
        temp_ptr = $_ptrs[z] + 1;
    }        
    $_ptrs[30] = 0;
    gga_start_ptr = 0; gsa1_start_ptr = 0; gsa2_start_ptr = 0; rmc_start_ptr  = 0;
    gga_end_ptr = 0;   gsa1_end_ptr = 0;   gsa2_end_ptr = 0;   rmc_end_ptr  = 0;
    gga_len = 0;       gsa1_len = 0;       gsa1_len = 0;       rmc_len  = 0;

GSV_flag = 0;
MTK_flag = 0; 
    for ( z1 = 0; z1 < z; z1 ++ ) {
        temp_ptr = $_ptrs[z1];
        if (*(temp_ptr + 3)  =='G'  && *(temp_ptr + 4)  =='G' && *(temp_ptr + 5)   =='A')                         {gga_start_ptr  = temp_ptr + 3;  gga_end_ptr  = $_ptrs[z1 + 1] - 2;}
        if (*(temp_ptr + 2)  =='P'  && *(temp_ptr + 3)  =='G' && *(temp_ptr + 4)   =='S' && *(temp_ptr + 5)=='A') {gsa1_start_ptr = temp_ptr + 3;  gsa1_end_ptr = $_ptrs[z1 + 1] - 2;}
        if (*(temp_ptr + 2)  =='L'  && *(temp_ptr + 3)  =='G' && *(temp_ptr + 4)   =='S' && *(temp_ptr + 5)=='A') {gsa2_start_ptr = temp_ptr + 3;  gsa2_end_ptr = $_ptrs[z1 + 1] - 2;}
        if (*(temp_ptr + 3)  =='R'  && *(temp_ptr + 4)  =='M' && *(temp_ptr + 5)   =='C')                         {rmc_start_ptr  = temp_ptr + 3;  rmc_end_ptr  = $_ptrs[z1 + 1] - 2;}
        if (*(temp_ptr + 3)  =='G'  && *(temp_ptr + 4)  =='S' && *(temp_ptr + 5)   =='V') GSV_flag = 1;
        if (*(temp_ptr + 3)  =='M'  && *(temp_ptr + 4)  =='T' && *(temp_ptr + 5)   =='K') MTK_flag = 1;
    }

if (MTK_flag == 1) {
    Nop();Nop();Nop();
}

unsigned char check_summ, check_summ1, check_summ2;
check_summ = 0;
if (GSV_flag == 1) {
    
    for (z = 1; z <= 45; z ++) {
        check_summ = check_summ ^ set_sentence[z];
    }
    Nop();Nop();Nop();
    check_summ1 = (check_summ & 0xF0) >> 4;
    check_summ2 = check_summ & 0x0F;
    memmove ( UART2_Tx_buf, set_sentence, 52 );
    if (check_summ1 >= 0 && check_summ1 <= 9) {UART2_Tx_buf[47] = check_summ1 + 0x30;}
    else {UART2_Tx_buf[47] = check_summ1 + 0x37;}
    if (check_summ2 >= 0 && check_summ2 <= 9) {UART2_Tx_buf[48] = check_summ2 + 0x30;}
    else {UART2_Tx_buf[48] = check_summ2 + 0x37;}
    Nop();Nop();Nop();
    start_UART2_transmission (0);
    
}



int *cptr; // было int *cptr;
check_summ = 0;
check_summ1 = 0;
check_summ2 = 0;


// Check summ and comma's pointers of RMC string
    cptr = rmc_comma_ptrs;
    *cptr = 0;
    cptr++;
    tmp_ptr = rmc_start_ptr - 2;
    tmp_ptr2 = rmc_end_ptr - 3;
    
if (rmc_end_ptr == 0xFFFE) {
Nop(); Nop();Nop();
return 0;
}    
    
    while (tmp_ptr < tmp_ptr2) {
            check_summ = check_summ ^ *tmp_ptr;
            if (*tmp_ptr == ',') {*cptr = tmp_ptr; cptr++;}
            tmp_ptr++;
    }
    *cptr = 0;
    check_summ1 = *(rmc_end_ptr - 2);
    check_summ2 = *(rmc_end_ptr - 1);
    if (check_summ1 > 0x40) check_summ1 = check_summ1 - 0x37;
    else check_summ1 = check_summ1 - 0x30;
    if (check_summ2 > 0x40) check_summ2 = check_summ2 - 0x37;
    else check_summ2 = check_summ2 - 0x30;
    check_summ1 = (check_summ1 << 4) + check_summ2;
    if (check_summ != check_summ1) {  return 0; }// restart_navdata_receiving();


// Check summ and comma's pointers of GSA2 string
    check_summ = 0;
    cptr = gsa2_comma_ptrs;
    *cptr = 0;
    cptr++;
    tmp_ptr = gsa2_start_ptr - 2;
    tmp_ptr2 = gsa2_end_ptr - 3;
        while (tmp_ptr < tmp_ptr2) {
            check_summ = check_summ ^ *tmp_ptr;
            if (*tmp_ptr == ',') { *cptr = tmp_ptr; cptr++; }
            tmp_ptr++;
        }
    if (gsa2_start_ptr != 0) { // GSA2 string exist
        *cptr = 0;
        check_summ1 = *(gsa2_end_ptr - 2);
        check_summ2 = *(gsa2_end_ptr - 1);
        if (check_summ1 > 0x40) check_summ1 = check_summ1 - 0x37;
        else check_summ1 = check_summ1 - 0x30;
        if (check_summ2 > 0x40) check_summ2 = check_summ2 - 0x37;
        else check_summ2 = check_summ2 - 0x30;
        check_summ1 = (check_summ1 << 4) + check_summ2;
        if (check_summ != check_summ1) {  return 0; }// restart_navdata_receiving();
    }

// Check summ and comma's pointers of GGA string
    check_summ = 0;
    cptr = gga_comma_ptrs;
    *cptr = 0;
    cptr++;
    tmp_ptr = gga_start_ptr - 2;
    tmp_ptr2 = gga_end_ptr - 3;
    while (tmp_ptr < tmp_ptr2) {
            check_summ = check_summ ^ *tmp_ptr;
            if (*tmp_ptr == ',') {*cptr = tmp_ptr; cptr++;}
            tmp_ptr++;
    }
    *cptr = 0;
    check_summ1 = *(gga_end_ptr - 2);
    check_summ2 = *(gga_end_ptr - 1);
    if (check_summ1 > 0x40) check_summ1 = check_summ1 - 0x37;
    else check_summ1 = check_summ1 - 0x30;
    if (check_summ2 > 0x40) check_summ2 = check_summ2 - 0x37;
    else check_summ2 = check_summ2 - 0x30;
    check_summ1 = (check_summ1 << 4) + check_summ2;
    if (check_summ != check_summ1) {  return 0; }// restart_navdata_receiving();

    
    
// Type of navigation P - GPS, L - GLONASS, N - GPS+GLONASS
	tmp_ptr = gga_start_ptr;
        Navi_str [68] = *(--tmp_ptr);
        Navi_str_last_known [68] = Navi_str [68];
        Navi_str [69] = ',';
// Status of fix: V - not correct, A - correct
	tmp_ptr = rmc_comma_ptrs[2];
//	Navigation_mode_ind = *(++tmp_ptr);
        Navi_str [62] = *(++tmp_ptr);
        Navi_str_last_known [62] = Navi_str [62];
        Navi_str [63] = ',';
// 1 - not correct fix, 2 - 2D fix, 3 - 3D fix
       	tmp_ptr = gsa1_start_ptr;
//	Mode_of_operation = *(tmp_ptr + 6);
        Navi_str [66] = *(tmp_ptr + 6);
        Navi_str_last_known [66] = Navi_str [66];
        Navi_str [67] = ',';
// N - not correct, E - not anought satellites, A - autonomous, D - differential
    tmp_ptr = rmc_comma_ptrs[12];
        Navi_str [64] = *(++tmp_ptr);
        Navi_str_last_known [64] = Navi_str [64];
        Navi_str [65] = ',';
        
/*   memmove ( Navi_str_last_known, Navi_str, 76 ); */

        // Time
            tmp_ptr = rmc_comma_ptrs[1];
                Navi_str [0] =  *(++tmp_ptr); Navi_str [1] = *(++tmp_ptr);
                Navi_str [2] =  *(++tmp_ptr); Navi_str [3] = *(++tmp_ptr);
                Navi_str [4] =  *(++tmp_ptr); Navi_str [5] = *(++tmp_ptr);
                Navi_str [6] =  *(++tmp_ptr); Navi_str [7] = *(++tmp_ptr);
                Navi_str [8] = ',';
                
        /* Date*/
            tmp_ptr = rmc_comma_ptrs[9];	tmp_ptr2 = rmc_comma_ptrs[10];
                memmove(Navi_str + 9, tmp_ptr + 1, tmp_ptr2 - tmp_ptr - 1);
                Navi_str [15] = ',';

         /* Full number of satellits in view */
            tmp_ptr = gga_comma_ptrs[7];
            Navi_str[70] = *(++tmp_ptr);
            Navi_str[71] = *(++tmp_ptr);
            if (Navi_str[71] == ',') {Navi_str[71] = Navi_str[70]; Navi_str[70] = '0';}
            Navi_str_last_known [70] = Navi_str [70]; Navi_str_last_known [71] = Navi_str [71];
            Navi_str[72] = ',';
            GPGL_sat_number = 0;
            GPGL_sat_number = 10 * (Navi_str[70] - 0x30) + (Navi_str[71] - 0x30);
            if (GPGL_sat_number > 15) GPGL_sat_number = 15;                
                
    if (Navi_str [62] == 'A') {            
                
        /* Latitude*/
            tmp_ptr = rmc_comma_ptrs[3];
                Navi_str [16] = *(++tmp_ptr);	Navi_str [17] = *(++tmp_ptr);
                Navi_str [18] = *(++tmp_ptr);	Navi_str [19] = *(++tmp_ptr);
                Navi_str [20] = *(++tmp_ptr);	Navi_str [21] = *(++tmp_ptr);
                Navi_str [22] = *(++tmp_ptr);	Navi_str [23] = *(++tmp_ptr);
                Navi_str [24] = *(++tmp_ptr);   Navi_str [25] = 0x30;
                Navi_str [26] = ',';
//                Navi_str [23] = 0x30;Navi_str [24] = 0x30;// !!!!ЗАКОММЕНТИРОВАТЬ
        /*N/S*/        
                tmp_ptr = rmc_comma_ptrs[4];
                Navi_str[27] = *(++tmp_ptr);
                Navi_str[28] = ',';

        /* Longitude*/
            tmp_ptr = rmc_comma_ptrs[5];
                Navi_str [29] = *(++tmp_ptr);	Navi_str [30] = *(++tmp_ptr);
                Navi_str [31] = *(++tmp_ptr);	Navi_str [32] = *(++tmp_ptr);
                Navi_str [33] = *(++tmp_ptr);	Navi_str [34] = *(++tmp_ptr);
                Navi_str [35] = *(++tmp_ptr);	Navi_str [36] = *(++tmp_ptr);
                Navi_str [37] = *(++tmp_ptr);	Navi_str [38] = *(++tmp_ptr);
                Navi_str [39] = 0x30;
                Navi_str [40] = ',';

                tmp_ptr = rmc_comma_ptrs[6];
                Navi_str [41] = *(++tmp_ptr);
                Navi_str [42] = ',';

        /* Speed*/
        //	tmp_ptr = Navi_str; tmp_ptr = tmp_ptr + 48;
            tmp_ptr  = &Navi_str[50];
            tmp_ptr3 = &Navi_str[54];
            tmp_ptr2 = rmc_comma_ptrs[8];
            tmp_ptr4 = rmc_comma_ptrs[7];
            tmp_ptr--; tmp_ptr2 = tmp_ptr2 - 2; tmp_ptr4++; //tmp_ptr2--;
            while (tmp_ptr2 >= tmp_ptr4) {
                    if (tmp_ptr3 == tmp_ptr) break;
                    *tmp_ptr3 = *tmp_ptr2;
                    tmp_ptr2--; tmp_ptr3--;
            }
            while (tmp_ptr3 > tmp_ptr) {
                    *tmp_ptr3 = '0';
                    tmp_ptr3--;
            }
            Navi_str[55] = ',';

        /* Course*/
            tmp_ptr  = &Navi_str[56];
            tmp_ptr3 = &Navi_str[60];
            tmp_ptr2 = rmc_comma_ptrs[9];
            tmp_ptr4 = rmc_comma_ptrs[8];
            tmp_ptr--; tmp_ptr2 = tmp_ptr2 - 2; tmp_ptr4++;
            while (tmp_ptr2 >= tmp_ptr4) {
                    if (tmp_ptr3 == tmp_ptr) break;
                    *tmp_ptr3 = *tmp_ptr2;
                    tmp_ptr2--; tmp_ptr3--;
            }
            while (tmp_ptr3 > tmp_ptr) {
                    *tmp_ptr3 = '0';
                    tmp_ptr3--;
            }
            Navi_str[61] = ',';

//        /* Date*/
//                tmp_ptr = rmc_comma_ptrs[9];	tmp_ptr2 = rmc_comma_ptrs[10];
//            memmove(Navi_str + 9, tmp_ptr + 1, tmp_ptr2 - tmp_ptr - 1);
//                Navi_str [15] = ',';

        /* Altitude*/
            tmp_ptr = &Navi_str[43];
            tmp_ptr3 = tmp_ptr + 4; //5
            tmp_ptr2 = gga_comma_ptrs[10];	tmp_ptr4 = gga_comma_ptrs[9];
            tmp_ptr--; tmp_ptr2--; tmp_ptr4++;

            while (tmp_ptr2 >= tmp_ptr4) {
                    if (tmp_ptr3 == tmp_ptr) break;
                    *tmp_ptr3 = *tmp_ptr2;
                    tmp_ptr2--; tmp_ptr3--;
            }
            while (tmp_ptr3 > tmp_ptr) {
                    *tmp_ptr3 = '0';
                    tmp_ptr3--;
            }
            tmp_ptr2 = gga_comma_ptrs[10];
            tmp_ptr2++;
            Navi_str[48] = *tmp_ptr2;
            Navi_str[49] = ',';

         /* Full number of satellits in view */
//            tmp_ptr = gga_comma_ptrs[7];
//            Navi_str[70] = *(++tmp_ptr);
//            Navi_str[71] = *(++tmp_ptr);
//            if (Navi_str[71] == ',') {Navi_str[71] = Navi_str[70]; Navi_str[70] = '0';}
//            Navi_str[72] = ',';
//            GPGL_sat_number = 0;
//            GPGL_sat_number = 10 * (Navi_str[70] - 0x30) + (Navi_str[71] - 0x30);
//            if (GPGL_sat_number > 15) GPGL_sat_number = 15;
         /* Calculation number of GPS and GLONASS satellites separately */
                if (Navi_str[68] == 'P') { // Only GPS using
                    Navi_str[73] = '0';
                    Navi_str[74] = '0';
                }
                if (Navi_str[68] == 'L') { // Only GLONASS using
                    Navi_str[73] = Navi_str[70];
                    Navi_str[74] = Navi_str[71];
                }

        unsigned char i;        
                if (Navi_str[68] == 'N') { // Combyne
                    GL_sat_number = 0;
            // If second GSA string exists then colculate number of GLONASS satellites
                    if (gsa2_start_ptr != 0) {
                        i = 3;
                        while ((gsa2_comma_ptrs[i] + 1) != gsa2_comma_ptrs[i+1] ) {
                            i++;
                            GL_sat_number++;
                        }
                    }
                    bin_2_bcd ((long)GL_sat_number);
                    Navi_str[73] = bin_2_bcd_buf [7];
                    Navi_str[74] = bin_2_bcd_buf [8];
                }
                    Navi_str[75] = 0;
                    
                memmove ( Navi_str_last_known, Navi_str, 76 );
                int z;
                for (z = 0; z < 76; z++) {//Загрузка последней известной позиции в FRAM
                    FM25_write_1 (z + 434, Navi_str_last_known[z]);
                }
                
    } // if (Navi_str [62] == "A")
    else {
        memmove ( Navi_str + 15, Navi_str_last_known + 15, 60 );// 60
        GL_sat_number = 0; GPGL_sat_number = 0;
//        return 0;
    }            
                
        nav_trigger = 1;
        FIXFLAGSbits.ready = 1;
        
        
        
//        load_nav_telit_buf ();


unsigned char dig1, dig2, dig3, dig4, dig5, dig6, dig7;//, gig8, dig9, dig10;         
unsigned long navi_tmp, navi_tmp1, navi_tmp2;
int Alt;
// Lattitude
	navi_tmp = 0; navi_tmp1 = 0;
    navi_tmp1 = 100000000 * (unsigned long)(Navi_str[16] - 0x30) + 10000000 * (unsigned long)(Navi_str[17] - 0x30);
	dig1 = (Navi_str[18] - 0x30); dig2 = (Navi_str[19] - 0x30); dig3 = (Navi_str[21] - 0x30);
	dig4 = (Navi_str[22] - 0x30); dig5 = (Navi_str[23] - 0x30); dig6 = (Navi_str[24] - 0x30);
    dig7 = (Navi_str[25] - 0x30);
	navi_tmp =            100000000 * (unsigned long)dig1; navi_tmp = navi_tmp + 10000000  * (unsigned long)dig2;
    navi_tmp = navi_tmp + 1000000   * (unsigned long)dig3; navi_tmp = navi_tmp + 100000    * (unsigned long)dig4;
    navi_tmp = navi_tmp + 10000     * (unsigned long)dig5; navi_tmp = navi_tmp + 1000      * (unsigned long)dig6;
    navi_tmp = navi_tmp + 100       * (unsigned long)dig7;
    navi_tmp = (navi_tmp + 30)/60;
    navi_tmp1 = navi_tmp1 + navi_tmp;
    Lat1 = (float) navi_tmp1 / 10000000.0;
// Longitude    
	navi_tmp = 0; navi_tmp2 = 0;
    navi_tmp2 = 1000000000 * (Navi_str[29] - 0x30) + 100000000 * (Navi_str[30] - 0x30) + 10000000 * (Navi_str[31] - 0x30);
	dig1 = (Navi_str[32] - 0x30); dig2 = (Navi_str[33] - 0x30); dig3 = (Navi_str[35] - 0x30);
	dig4 = (Navi_str[36] - 0x30); dig5 = (Navi_str[37] - 0x30); dig6 = (Navi_str[38] - 0x30);
    dig7 = (Navi_str[39] - 0x30);
	navi_tmp =            100000000 * (unsigned long)dig1; navi_tmp = navi_tmp + 10000000  * (unsigned long)dig2;
    navi_tmp = navi_tmp + 1000000   * (unsigned long)dig3; navi_tmp = navi_tmp + 100000    * (unsigned long)dig4;
    navi_tmp = navi_tmp + 10000     * (unsigned long)dig5; navi_tmp = navi_tmp + 1000      * (unsigned long)dig6;
    navi_tmp = navi_tmp + 100       * (unsigned long)dig7;
    navi_tmp = (navi_tmp + 30)/60;
    navi_tmp2 = navi_tmp2 + navi_tmp;
    Long1 = (float)navi_tmp2 / 10000000.0;
// Altitude
    Alt = 0;
    if (Navi_str[43] == '-') {
        Alt = 10 * (Navi_str[44] - 0x30) + (Navi_str[45] - 0x30);
        Alt = Alt * (-1);
    }
    else {
        Alt = 100 * (Navi_str[43] - 0x30) + 10 * (Navi_str[44] - 0x30) + (Navi_str[45] - 0x30); //Alt = 100 * (Navi_str[43] - 0x30) + 10 * (Navi_str[44] - 0x30) + (Navi_str[45] - 0x30);
    }
    
// Heading
	course2 =           (Navi_str [56] - 0x30) * 100;
	course2 = course2 + (Navi_str [57] - 0x30) * 10;
	course2 = course2 + (Navi_str [58] - 0x30);
    
// Speed
	navi_tmp =            (Navi_str[50] - 0x30) * 1000;
	navi_tmp = navi_tmp + (Navi_str[51] - 0x30) * 100;
	navi_tmp = navi_tmp + (Navi_str[52] - 0x30) * 10;
	navi_tmp = navi_tmp + (Navi_str[54] - 0x30);
	navi_tmp =	navi_tmp * 1852; navi_tmp =	(navi_tmp + 5000) / 10000; // From knots to km/h
	if (navi_tmp > 255) navi_tmp = 255;
	speed2 = (unsigned char)navi_tmp;
    
    unsigned char gps_tmp = 0;
    gps_tmp = GPGL_sat_number - GL_sat_number;
    
    if (gps_tmp >= 4 || GL_sat_number >= 4) {
        if (speed2 > max_speed) max_speed = speed2;
    }
    
    load_navi_bin ( navi_tmp1, navi_tmp2, Alt, speed2, course2, GPGL_sat_number, GL_sat_number );
    
    
/* Distance between two points*/
float fi, lambda, sin2_fi, sin2_lambda, cos_lat1, cos_lat2;
	Lat1  = Lat1  * 0.0174533;
	Long1 = Long1 * 0.0174533;
	fi = (Lat1 - Lat2) / 2.0;
	lambda = (Long1 - Long2) / 2.0;
	sin2_fi = sinf(fi);
	sin2_fi = sin2_fi * sin2_fi;
	sin2_lambda = sinf(lambda);
	sin2_lambda = sin2_lambda * sin2_lambda;
	cos_lat1 = cosf(Lat1);
	cos_lat2 = cosf(Lat2);
	distance = cos_lat1 * cos_lat2;
	distance = distance * sin2_lambda;
	distance = distance + sin2_fi;
	distance = sqrtf(distance);
	distance = asinf(distance);
	distance = 2.0 * distance;
	distance = 57.2957795 * distance;
	distance = distance * 111.12;	// kilometers
	distance = distance * 1000.0;	// meters

	fix_to_fix_mileage = fix_to_fix_mileage + distance;

//static unsigned char odo_counter = 0;
    
    static unsigned int fix_good_counter = 0;
    if (Navi_str [62] == 'A') {
        if (fix_good_counter < 2) fix_good_counter ++;
    }  

if (Navi_str [62] == 'A' && fix_good_counter >= 2) {    
    if (ignition == 1) {
        navi_tmp = (unsigned long) (distance * 10.0);
        GPS_odometer = GPS_odometer + navi_tmp; 
        FM25_write_4( 71, (unsigned long) GPS_odometer );// 71, 72, 73, 74
    }
}

// Time
unsigned int c;
	time2 = (Navi_str[0] - 0x30) * 36000; c = (Navi_str[1] - 0x30) * 3600;
	time2 = time2 + c; c = (Navi_str[2] - 0x30) * 600;
	time2 = time2 + c; c = (Navi_str[3] - 0x30) * 60;
	time2 = time2 + c; c = (Navi_str[4] - 0x30) * 10;
	time2 = time2 + c; c = (Navi_str[5] - 0x30);
	time2 = time2 + c;
        
    Lat2  = Lat1;
	Long2 = Long1;

//restart_navdata_receiving();
return 1;
}
# endif


/*
void load_last_known_bin (void){
    
unsigned char dig1, dig2, dig3, dig4, dig5, dig6, dig7, gig8, dig9, dig10;         
unsigned long navi_tmp, navi_tmp1, navi_tmp2;
int Alt;
// Lattitude
	navi_tmp = 0; navi_tmp1 = 0;
    navi_tmp1 = 100000000 * (unsigned long)(Navi_str[16] - 0x30) + 10000000 * (unsigned long)(Navi_str[17] - 0x30);
	dig1 = (Navi_str[18] - 0x30); dig2 = (Navi_str[19] - 0x30); dig3 = (Navi_str[21] - 0x30);
	dig4 = (Navi_str[22] - 0x30); dig5 = (Navi_str[23] - 0x30); dig6 = (Navi_str[24] - 0x30);
    dig7 = (Navi_str[25] - 0x30);
	navi_tmp =            100000000 * (unsigned long)dig1; navi_tmp = navi_tmp + 10000000  * (unsigned long)dig2;
    navi_tmp = navi_tmp + 1000000   * (unsigned long)dig3; navi_tmp = navi_tmp + 100000    * (unsigned long)dig4;
    navi_tmp = navi_tmp + 10000     * (unsigned long)dig5; navi_tmp = navi_tmp + 1000      * (unsigned long)dig6;
    navi_tmp = navi_tmp + 100       * (unsigned long)dig7;
    navi_tmp = (navi_tmp + 30)/60;
    navi_tmp1 = navi_tmp1 + navi_tmp;
    Lat1 = (float) navi_tmp1 / 10000000.0;
// Longitude    
	navi_tmp = 0; navi_tmp2 = 0;
    navi_tmp2 = 1000000000 * (Navi_str[29] - 0x30) + 100000000 * (Navi_str[30] - 0x30) + 10000000 * (Navi_str[31] - 0x30);
	dig1 = (Navi_str[32] - 0x30); dig2 = (Navi_str[33] - 0x30); dig3 = (Navi_str[35] - 0x30);
	dig4 = (Navi_str[36] - 0x30); dig5 = (Navi_str[37] - 0x30); dig6 = (Navi_str[38] - 0x30);
    dig7 = (Navi_str[39] - 0x30);
	navi_tmp =            100000000 * (unsigned long)dig1; navi_tmp = navi_tmp + 10000000  * (unsigned long)dig2;
    navi_tmp = navi_tmp + 1000000   * (unsigned long)dig3; navi_tmp = navi_tmp + 100000    * (unsigned long)dig4;
    navi_tmp = navi_tmp + 10000     * (unsigned long)dig5; navi_tmp = navi_tmp + 1000      * (unsigned long)dig6;
    navi_tmp = navi_tmp + 100       * (unsigned long)dig7;
    navi_tmp = (navi_tmp + 30)/60;
    navi_tmp2 = navi_tmp2 + navi_tmp;
    Long1 = (float)navi_tmp2 / 10000000.0;
// Altitude
    Alt = 0;
    if (Navi_str[43] == '-') {
        Alt = 10 * (Navi_str[44] - 0x30) + (Navi_str[45] - 0x30);
        Alt = Alt * (-1);
    }
    else {
        Alt = 100 * (Navi_str[43] - 0x30) + 10 * (Navi_str[44] - 0x30) + (Navi_str[45] - 0x30); //Alt = 100 * (Navi_str[43] - 0x30) + 10 * (Navi_str[44] - 0x30) + (Navi_str[45] - 0x30);
    }
    
// Heading
	course2 =           (Navi_str [56] - 0x30) * 100;
	course2 = course2 + (Navi_str [57] - 0x30) * 10;
	course2 = course2 + (Navi_str [58] - 0x30);
    
// Speed
	navi_tmp =            (Navi_str[50] - 0x30) * 1000;
	navi_tmp = navi_tmp + (Navi_str[51] - 0x30) * 100;
	navi_tmp = navi_tmp + (Navi_str[52] - 0x30) * 10;
	navi_tmp = navi_tmp + (Navi_str[54] - 0x30);
	navi_tmp =	navi_tmp * 1852; navi_tmp =	(navi_tmp + 5000) / 10000; // From knots to km/h
	if (navi_tmp > 255) navi_tmp = 255;
	speed2 = (unsigned char)navi_tmp;

    if (speed2 > max_speed) max_speed = speed2;
    
    load_navi_bin ( navi_tmp1, navi_tmp2, Alt, speed2, course2, 0, 0 );    
    
}
*/

void load_navi_bin (unsigned long Lat, unsigned long Long, int Alt, unsigned char speed, unsigned int course, unsigned char GPGLnum, unsigned char GLnum ) {

    Nop();Nop();Nop();
// Time    
    Navi_bin[0] =                      Navi_str[0]  - 0x30;
    Navi_bin[0] = (Navi_bin[0] << 4) + Navi_str[1]  - 0x30;    
    Navi_bin[1] =                      Navi_str[2]  - 0x30;
    Navi_bin[1] = (Navi_bin[1] << 4) + Navi_str[3]  - 0x30;
    Navi_bin[2] =                      Navi_str[4]  - 0x30;
    Navi_bin[2] = (Navi_bin[2] << 4) + Navi_str[5]  - 0x30;
// Date    
    Navi_bin[3] =                      Navi_str[9]  - 0x30;
    Navi_bin[3] = (Navi_bin[3] << 4) + Navi_str[10] - 0x30;    
    Navi_bin[4] =                      Navi_str[11] - 0x30;
    Navi_bin[4] = (Navi_bin[4] << 4) + Navi_str[12] - 0x30;
    Navi_bin[5] =                      Navi_str[13] - 0x30;
    Navi_bin[5] = (Navi_bin[5] << 4) + Navi_str[14] - 0x30;
// Lattitude
    Navi_bin[6] = Lat >> 24;
    Navi_bin[7] = Lat >> 16;
    Navi_bin[8] = Lat >> 8;    
    Navi_bin[9] = Lat;
// Longitude
    Navi_bin[10]  = Long >> 24;
    Navi_bin[11] = Long >> 16;
    Navi_bin[12] = Long >> 8;    
    Navi_bin[13] = Long;
// EWRTC
    Navi_bin[14] = 0;
    if (Navi_str[27] == 'N') { 
        Navi_bin[14] = 0b01000000; 
    }
    else Navi_bin[14] = 0b10000000;
    if (Navi_str[41] == 'E') { 
        Navi_bin[14] = Navi_bin[14] +  0b00010000; 
    }
    else Navi_bin[14] = Navi_bin[14] + 0b00100000;
// Altitude
    Navi_bin[15] = Alt >> 8;
    Navi_bin[16] = Alt;
// Speed
    Navi_bin[17] = speed;
//    Navi_bin[17] = 50; // Чтоббы эмулировать тревоги на скорости
// Altitude
    Navi_bin[18] = course >> 8;
    Navi_bin[19] = course;
// Validity
    AVbits.AV = 0;
    if (Navi_str[68] == 'P') {AVbits.PLN = 1;} // Режим
    else {
        if (Navi_str[68] == 'L') {AVbits.PLN = 2;}
        else {
            if (Navi_str[68] == 'N') {AVbits.PLN = 3;}
        }
    }
    if (Navi_str[66] == '3') {AVbits.DIM = 3;} // 
    else {
        if (Navi_str[66] == '2') {AVbits.DIM = 2;}
    }
    if (Navi_str[64] == 'A') {AVbits.NEAD = 3;}
    else {
        if (Navi_str[64] == 'N') {AVbits.NEAD = 1;}
        else {
            if (Navi_str[64] == 'E') {AVbits.NEAD = 2;}
            else {
                if (Navi_str[64] == 'D') {AVbits.NEAD = 4;}
            }
        }
    }
    if (Navi_str[62] == 'A') {AVbits.S = 1;} //
    else AVbits.S = 0;
    Navi_bin[20] = AVbits.AV;
// Number of satellites
   Navi_bin[21] = GPGLnum; 
   Navi_bin[21] = (Navi_bin[21] << 4) + GLnum; 
   
   crash_trek_record ();
   
}
void restart_navdata_receiving(void) {
//	UART2_buf [0] = 0;
	IEC1bits.U2RXIE = 0;
	Start_accumulation = 0;
	num_of_bytes = 0;
	IEC1bits.U2RXIE = 1;
}
int  bin_2_bcd (long bin_num) {

unsigned long long bcd;
unsigned char temp, sign;
int j;

	if (bin_num < 0) {
		bin_num = -1 * bin_num;
		sign = '-';	
	} else sign = '+';

	if (bin_num > 0xFFFFFF) return 0;

	bcd = 0;
	temp = 0;
	bcd = bin_num;

	for (j = 0; j < 23; j ++) {
		bcd = bcd << 1;
		temp = (bcd >> 24) & 0x0F;	if (temp >= 5) bcd = bcd + 0x3000000; 
		temp = (bcd >> 28) & 0x0F;	if (temp >= 5) bcd = bcd + 0x30000000; 
		temp = (bcd >> 32) & 0x0F;	if (temp >= 5) bcd = bcd + 0x300000000;
		temp = (bcd >> 36) & 0x0F;	if (temp >= 5) bcd = bcd + 0x3000000000;
		temp = (bcd >> 40) & 0x0F;	if (temp >= 5) bcd = bcd + 0x30000000000;
		temp = (bcd >> 44) & 0x0F;	if (temp >= 5) bcd = bcd + 0x300000000000;
		temp = (bcd >> 48) & 0x0F;	if (temp >= 5) bcd = bcd + 0x3000000000000;
		temp = (bcd >> 52) & 0x0F;	if (temp >= 5) bcd = bcd + 0x30000000000000;
		temp = (bcd >> 56) & 0x0F;	if (temp >= 5) bcd = bcd + 0x300000000000000;
	}
	bcd = bcd << 1;

	bcd = bcd >> 24;bin_2_bcd_buf[8] = (bcd & 0x0F) + 0x30;
	bcd = bcd >> 4;	bin_2_bcd_buf[7] = (bcd & 0x0F) + 0x30;
	bcd = bcd >> 4;	bin_2_bcd_buf[6] = (bcd & 0x0F) + 0x30;
	bcd = bcd >> 4;	bin_2_bcd_buf[5] = (bcd & 0x0F) + 0x30;
	bcd = bcd >> 4;	bin_2_bcd_buf[4] = (bcd & 0x0F) + 0x30;
	bcd = bcd >> 4;	bin_2_bcd_buf[3] = (bcd & 0x0F) + 0x30;
	bcd = bcd >> 4;	bin_2_bcd_buf[2] = (bcd & 0x0F) + 0x30;
	bcd = bcd >> 4;	bin_2_bcd_buf[1] = (bcd & 0x0F) + 0x30;
					bin_2_bcd_buf[0] = sign;

 return 1;
 } // bin_2_bcd()

void init_GPRS_header (void) {
    
    GPRS_header_buf [0] = 0x26;
    
    GPRS_header_buf [1] = 0;
    GPRS_header_buf [1] = ( GPRS_header_buf [1] + (IMEI_str[0] - 0x30) ) << 4; 
    GPRS_header_buf [1] =   GPRS_header_buf [1] + (IMEI_str[1] - 0x30);        

    GPRS_header_buf [2] = 0;
    GPRS_header_buf [2] = ( GPRS_header_buf [2] + (IMEI_str[2] - 0x30) ) << 4; 
    GPRS_header_buf [2] =   GPRS_header_buf [2] + (IMEI_str[3] - 0x30);        

    GPRS_header_buf [3] = 0;
    GPRS_header_buf [3] = ( GPRS_header_buf [3] + (IMEI_str[4] - 0x30) ) << 4; 
    GPRS_header_buf [3] =   GPRS_header_buf [3] + (IMEI_str[5] - 0x30);        

    GPRS_header_buf [4] = 0;
    GPRS_header_buf [4] = ( GPRS_header_buf [4] + (IMEI_str[6] - 0x30) ) << 4; 
    GPRS_header_buf [4] =   GPRS_header_buf [4] + (IMEI_str[7] - 0x30);        

    GPRS_header_buf [5] = 0;
    GPRS_header_buf [5] = ( GPRS_header_buf [5] + (IMEI_str[8] - 0x30) ) << 4; 
    GPRS_header_buf [5] =   GPRS_header_buf [5] + (IMEI_str[9] - 0x30);        

    GPRS_header_buf [6] = 0;
    GPRS_header_buf [6] = ( GPRS_header_buf [6] + (IMEI_str[10] - 0x30) ) << 4; 
    GPRS_header_buf [6] =   GPRS_header_buf [6] + (IMEI_str[11] - 0x30);        

    GPRS_header_buf [7] = 0;
    GPRS_header_buf [7] = ( GPRS_header_buf [7] + (IMEI_str[12] - 0x30) ) << 4; 
    GPRS_header_buf [7] =   GPRS_header_buf [7] + (IMEI_str[13] - 0x30);        
    
    GPRS_header_buf [8] = IMEI_str[14] & 0x0F;
    GPRS_header_buf [8] = GPRS_header_buf [8] << 4; 
        
    GPRS_header_buf [9] = 0; GPRS_header_buf [10] = 0; GPRS_header_buf [11] = 0;
    
}
void reload_GPRS_header (unsigned char N, unsigned char name, unsigned int type) {

    GPRS_header_buf [8]  = ( GPRS_header_buf [8] & 0xF0 ) + N;
    GPRS_header_buf [9]  = name;
    GPRS_header_buf [10] = (unsigned char) (type >> 8);
    GPRS_header_buf [11] = (unsigned char) type;
    
}
void start_UART2_transmission (int wait) {
// Data Transmit and receiving the data using interrupts
    Tx2_DataAvailable = 0;
    IEC1bits.U2TXIE = 1;
    IFS1bits.U2TXIF = 1;
    if (wait == 1) {
        while(Tx2_DataAvailable != 1); //wait till data is transmitted
        Tx2_DataAvailable = 0;
    }
}
void load_UART2_Tx_buf (void) {
    unsigned int i;
    i = 0;
    while (Navi_str[i] !=0) {
      UART2_Tx_buf[i] =  Navi_str[i];
      i++;
    }
      UART2_Tx_buf[i] = 0x0D; i++;
      UART2_Tx_buf[i] = 0x0A; i++;
      UART2_Tx_buf[i] = 0;
}
void start_UART4_transmission (int wait) {
// Data Transmit and receiving the data using interrupts
    Tx4_DataAvailable = 0;
    IEC5bits.U4TXIE = 1;
    IFS5bits.U4TXIF = 1;
    if (wait == 1) {
        while(Tx4_DataAvailable != 1); //wait till data is transmitted
        Tx4_DataAvailable = 0;
    }
}
void start_UART1_transmission (int wait, unsigned int length) {
// Data transmit the data using interrupts
    U1_Tx_length = length;
    Tx1_DataAvailable = 0;
    IEC0bits.U1TXIE = 1;
    IFS0bits.U1TXIF = 1;
    if (wait == 1) {
        while(Tx1_DataAvailable != 1); //wait till data is transmitted
        Tx1_DataAvailable = 0;
    }
}
void load_UART4_Tx_buf (unsigned char *ptr) {
    unsigned int i;
    i = 0;
    while (*ptr !=0) {
      UART4_Tx_buf[i] =  *ptr;
      i++;
      if (i >= 525) break; // Ограничение максимального к-ва 528 байт в буфере UART4 (передача макс 526 байт)
      ptr ++;
    }
      UART4_Tx_buf[i] = '\r'; i++;
      UART4_Tx_buf[i] = '\n'; i++;
      UART4_Tx_buf[i] = 0;
}
int  load_UART1_Tx_buf (char *ptr) {
    unsigned int i;
    i = 0;
    while (*ptr !=0) {
      UART1_Tx_buf[i] =  *ptr;
      i++;
      ptr ++;
    }
//      UART1_Tx_buf[i] = '\r'; i++;
//      UART1_Tx_buf[i] = '\n'; i++;
      UART1_Tx_buf[i] = 0;
//      U1_Tx_length = i;
      return i;
}
int  load_UART1_Tx_buf1 (char *ptr, unsigned int length) {
    unsigned int i;
    i = 0;
    for (i = 0; i < length; i ++) {
      UART1_Tx_buf[i] =  *ptr;
      ptr ++;
    }
//      UART1_Tx_buf[i] = '\r'; i++;
//      UART1_Tx_buf[i] = '\n'; i++;
//      UART1_Tx_buf[i] = 0;
//      U1_Tx_length = i;
      return i;
}
int  load_uart_at_to_UART1_Tx_buf (char *ptr) {
    unsigned int i;
    i = 0;
    while (*ptr != '\n') {
      UART1_Tx_buf[i] =  *ptr;
      i++;
      ptr ++;
    }

      UART1_Tx_buf[i] = 0;

      return i;
}
int  check_UART4_command(void) {
// Возвращает:
// 0 - ошибка
// 1 -
// 2 -
//


int temp;
temp = 0;

const unsigned char ENTER[3] = "\r\n\0";
const unsigned char GNSSDEBUG[11] = "gnssdebug=\0";
const unsigned char GSMDEBUG[10] = "gsmdebug=\0";
const unsigned char GSMDEBUGOFF[24] = "ERROR: gsm debug is off\0";
//const unsigned char ATOUT[] = "atout\0";
const unsigned char GSMOUT[7] = "gsmout\0";

//	Ответ ок на кнопку enter
	if ((strstr(UART4_Rx_buf, ENTER))&&(num_of_bytes_tmp4 == 3)) {
            load_UART4_Tx_buf (ok);
            return 1;
	}

        temp = strstr(UART4_Rx_buf, SET_GET_PARAMETER);
	if (temp) {
            check_setting ( 1, temp );
            load_UART4_Tx_buf (ok);
            Nop(); Nop(); Nop();
            return 3;
	}
        
//      Управление трансляцией GNSS данных в дебажный порт
	if (strstr(UART4_Rx_buf, GNSSDEBUG)) {
            if ((UART4_Rx_buf[10] == '1')||(UART4_Rx_buf[10] == '0')) {
                navistrout_ON = UART4_Rx_buf[10] - 0x30;
                navistrtype = UART4_Rx_buf[12] - 0x30;
                if(navistrtype != 1) navistrtype = 0;
                if (navistrout_ON == 1) gsmdebug_ON = 0;
                load_UART4_Tx_buf (ok);
                return 1;
            }
            load_UART4_Tx_buf (error);
            return 0;
	}

//      Управление трансляцией GSM данных в дебажный порт
	if (strstr(UART4_Rx_buf, GSMDEBUG)) {
            if ((UART4_Rx_buf[9] == '1')||(UART4_Rx_buf[9] == '0')) {
                gsmdebug_ON = UART4_Rx_buf[9] - 0x30;
                if(gsmdebug_ON == 1) {navistrout_ON = 0;}
                load_UART4_Tx_buf (ok);
                return 1;
            }
            load_UART4_Tx_buf (error);
            return 0;
	}

//
        temp = strstr(UART4_Rx_buf, AT_TO_MODEM);
	if (temp) {
            if (gsmdebug_ON == 1) {
                UARTATMODEMbits.start = 1;
                UARTATMODEMbits.at_ptr = temp + 3;
                return 2;
            } else {
                load_UART4_Tx_buf (GSMDEBUGOFF);
                return 1;
            }
	}

       	if (strstr(UART4_Rx_buf, GSMOUT)) {
            moden_off_puls_counter = 1;
            return 1;
	}





load_UART4_Tx_buf (error);
return 0;
} // Разбор данных NMEA

int  check_UART1_command(void) {
// Возвращает:
// 0 - ошибка
// 1 -
// 2 -
//
volatile unsigned int temp;
unsigned int temp1, ACK_type0_number;
volatile unsigned char *ptr;
temp = 0;
//_LATB5 = 1;
    if (SMSSENDbits.waiting_cmgs_result == 1) {    
            temp = strstr(UART_Rx_copy_buf, CMGS);
        if (temp != 0) {
//            clear_gsm_task_busy_timer ();
//            SMSSENDbits.plus_cmgs = 1;
            cmgs_result (temp + 9);
        }
    }

	if (strstr(UART_Rx_copy_buf, OK)) {
            modem_UART_check_counter = 0;
            if (MODEMTASCKSbits.MODEMTASCKS) gsm_task_result_check (1);
        }
	if (strstr(UART_Rx_copy_buf, ERROR)) {
            modem_UART_check_counter = 0;
            gsm_task_result_check (2);
        }

    temp = strstr(UART_Rx_copy_buf, CONNECT_OK);
	if ( temp != 0 ) {
# if defined (UC15)
        ptr = temp;
        if (*(ptr + 13) == 0x30) {
            GPRSSTATUSbits.connect_ok = 1;
            GPRSSTATUSbits.connect_fail = 0;
            clear_gsm_task_busy_timer ();  
        } else {
            GPRSSTATUSbits.connect_ok = 0;
            GPRSSTATUSbits.connect_fail = 1;
            clear_gsm_task_busy_timer ();            
        }
# else        
//            MODEMTASCKSbits.qiopen = 0;
            GPRSSTATUSbits.connect_ok = 1;
            GPRSSTATUSbits.connect_fail = 0;
            clear_gsm_task_busy_timer ();
# endif
        }
	if (strstr(UART_Rx_copy_buf, ALREADY_CONNECT)) {
//            MODEMTASCKSbits.qiopen = 0;
            GPRSSTATUSbits.already_connect = 1;
            GPRSSTATUSbits.connect_fail = 0;
            clear_gsm_task_busy_timer ();
        }
	if (strstr(UART_Rx_copy_buf, CONNECT_FAIL)) {
//            MODEMTASCKSbits.qiopen = 0;
            GPRSSTATUSbits.connect_ok = 0;
            GPRSSTATUSbits.connect_fail = 1;
            clear_gsm_task_busy_timer ();
        }
	if (strstr(UART_Rx_copy_buf, CLOSED)) {
            NETWORKSTATUSbits.cgreg = 0;
            GPRSSTATUSbits.qiopen_ok = 0;
            GPRSSTATUSbits.qiopen_error = 0;
            GPRSSTATUSbits.connect_ok = 0;
            GPRSSTATUSbits.connect_fail = 0;
        }
	if (strstr(UART_Rx_copy_buf, CLOSE_OK)) {
            CONNECTIONCLSbits.close_ok = 1;
            
            clear_gsm_task_busy_timer ();
        }
	if (strstr(UART_Rx_copy_buf, PDP_DEACT)) {
            GPRSSTATUSbits.GPRSSTATUS = 0;
        }
    if (MODEMTASCKSbits.data_sending == 1) {
        if (strstr(UART_Rx_copy_buf, CNTRLZ)) {
                GPRSSENDbits.cntrlz = 1;
//                clear_gsm_task_busy_timer (); // Это не правильно, ПОПРАВИТЬ!
            }
    }
	if (strstr(UART_Rx_copy_buf, SEND_OK)) {
            clear_gsm_task_busy_timer ();
            SEND_OK_timer = ACK_timer;
            GPRSSENDbits.send_ok = 1;
        }
	if (strstr(UART_Rx_copy_buf, SEND_FAIL)) {
            clear_gsm_task_busy_timer ();
            GPRSSENDbits.send_fail = 1;
        }
    if (FLASHDATASENDbits.waiting_ACK == 1) {
//    if ((FLASHDATASENDbits.waiting_ACK == 1)||( TYPE0SENDbits.waiting_ACK == 1 )) {
        temp = strstr(UART_Rx_copy_buf, ACK);
        if ( temp ) { 
            gprs_start_timer = 0; 
            ptr = temp + 3;
            if ( (*(ptr + 2) == '\r') && (*(ptr + 3) == '\n') ) {
                Nop();Nop();Nop();
                ACK_number = (unsigned int) *ptr;
                ACK_number = (ACK_number << 8) + *(ptr + 1);
                
//                if ( TYPE0SENDbits.waiting_ACK == 1 ) {
//                    TYPE0SENDbits.ACK = 1;
//                    TYPE0SENDbits.received_ACK = ACK_number;
//                }
                GPRSCHECKbits.GPRSCHECK = 0;
                if (ACK_number == 65535) {
                    Nop();Nop();Nop();
                    
                    Nop();Nop();Nop();
                }
                
                FLASHDATASENDbits.ACK = 1;                
                FLASHDATASENDbits.received_ACK = ACK_number;
                
                bin_2_bcd ( (unsigned long)ACK_number );
                ptr = temp - 2;
                *ptr++ = 'A';*ptr++ = 'C';*ptr++ = 'K';
                *ptr++ = ' ';*ptr++ = bin_2_bcd_buf[4];
                *ptr++ = bin_2_bcd_buf[5]; *ptr++ = bin_2_bcd_buf[6];
                *ptr++ = bin_2_bcd_buf[7]; *ptr++ = bin_2_bcd_buf[8];
                Nop();Nop();Nop();
            }
        }    
    }

    if (GPRSCHECKbits.start == 1) {
        temp = strstr(UART_Rx_copy_buf, ACK);
        if ( temp ) {

            ptr = temp + 3;
            if ( (*(ptr + 2) == '\r') && (*(ptr + 3) == '\n') ) {
                Nop();Nop();Nop();
                ACK_type0_number = 0;
                ACK_type0_number = (unsigned int) *ptr;
                ACK_type0_number = (ACK_type0_number << 8) + *(ptr + 1);
                
                if (ACK_type0_number == 65535) {
                    Nop();Nop();Nop();
                    GPRSCHECKbits.GPRSCHECK = 0;
                    Nop();Nop();Nop();
                }            
            }
        }
    }

// Получена АТ команда блока at$
        temp = strstr(UART_Rx_copy_buf, SET_GET_PARAMETER);
	if ( temp )  { 
        if (MODEMTASCKSbits.sms_reading == 0) { check_setting ( 2, temp ); }
    }
// Получено RDY 
	if (strstr(UART_Rx_copy_buf, RDY)) {  GSMSTATUSbits.rdy = 1; }
// CFUN       
    temp = strstr(UART_Rx_copy_buf, CFUN);
	if (temp != 0) { ptr = temp + 9; GSMSTATUSbits.cfun = *ptr - 0x30; }
// CPIN
    temp = strstr(UART_Rx_copy_buf, CPIN);
	if (temp != 0) {
            GSMSTATUSbits.cpin = 0;
            ptr = temp + 9; //temp = *ptr;
            if (*ptr == 'R'){ GSMSTATUSbits.cpin = 1; } //temp == 'R'
            else {
                ptr = temp + 13; //temp = *ptr;
                if (*ptr == 'R'){ GSMSTATUSbits.cpin = 2; } //temp == 'R'
                else {
                    if (*ptr == 'I'){ GSMSTATUSbits.cpin = 3; }
                    else { GSMSTATUSbits.cpin = 0;}
                }
            }
	}
// CALL READY
    
# if defined (UC15)  
    if (strstr(UART_Rx_copy_buf, PBDONE)) { GSMSTATUSbits.callready = 1; }
# else
	if (strstr(UART_Rx_copy_buf, CALLREADY)) { GSMSTATUSbits.callready = 1; }
# endif
        temp = strstr(UART_Rx_copy_buf, CREG);
	if (temp != 0) {
            MODEMTASCKSbits.creg_check = 0;
            ptr = temp + 10; temp = *ptr;
            if (temp == 0x0D){
                ptr = ptr - 1;
                NETWORKSTATUSbits.creg = *ptr - 0x30;
                gprs_start_timer = 250;
            }
	}
        temp = strstr(UART_Rx_copy_buf, CGREG);
	if (temp != 0) {
            MODEMTASCKSbits.cgreg_check = 0;
# if defined (UC15)
            ptr = temp + 11; temp = *ptr;
            if (temp == 0x0D){ptr = ptr - 1; NETWORKSTATUSbits.cgreg = *ptr - 0x30;}
# else            
            ptr = temp + 13; temp = *ptr;
            if (temp == 0x0D){ptr = ptr - 1; NETWORKSTATUSbits.cgreg = *ptr - 0x30;}
# endif            
	}

    temp = strstr(UART_Rx_copy_buf, CSQ);
	if (temp != 0) {
            MODEMTASCKSbits.cgreg_check = 0;
            ptr = temp;
            GSMSINGLALLEVELbits.GSMSINGLALLEVEL = 0;
            GSMSINGLALLEVELbits.rssi = GSMSINGLALLEVELbits.rssi + (*(ptr + 8) - 0x30);
            GSMSINGLALLEVELbits.rssi = GSMSINGLALLEVELbits.rssi * 10;
            GSMSINGLALLEVELbits.rssi = GSMSINGLALLEVELbits.rssi + (*(ptr + 9) - 0x30);
            GSMSINGLALLEVELbits.ber = GSMSINGLALLEVELbits.ber + (*(ptr + 11) - 0x30);
	}        
        
        temp = strstr(UART_Rx_copy_buf, CMS_ERROR);
	if (temp !=0) { cms_error (temp); }
    
        temp = strstr(UART_Rx_copy_buf, CME_ERROR);
	if (temp !=0) { cme_error (temp); }
        
	if (strstr(UART_Rx_copy_buf, NORMAL_POWER_DOWN)) {
            GSMSTATUSbits.GSMSTATUS = GSMSTATUSbits.GSMSTATUS & 0x0001;
            GSMSTATUSbits.normal_pw_dwn = 1;
	}
        
    if (MODEMTASCKSbits.sms_sending == 1) { if (strstr(UART_Rx_copy_buf, CNTRLZ)) { SMSSENDbits.cntrlz = 1; } }
        
// Пришла СМС, запись ее номера в буфер номеров принятых СМС
# if defined (UC15)
    temp = strstr(UART_Rx_copy_buf, CMTI_ME);        
# else
    temp = strstr(UART_Rx_copy_buf, CMTI_SM);
# endif
	if (temp != 0) {
// Здесь никак не проверяется корректность цифр номеров СМС, а так же что номер цифровой (сделать?).          
            ptr = temp + 14; 
            if (*(ptr + 1) == '\r') { temp = 0x3000; temp = temp + *ptr; write_SMS_number_to_buf ( temp ); } 
            else {  temp = 0; temp = *ptr; temp = temp << 8; temp = temp + *(ptr +1); write_SMS_number_to_buf ( temp ); }
	}
// Чтение текста СМС        
    temp = strstr( UART_Rx_copy_buf, CMGR );
	if (temp != 0) {
        clear_gsm_task_busy_timer ();
        SMSREADbits.at_cmgr_ok = 1;
        ptr = temp + 9; 
        temp1 = strstr( UART_Rx_copy_buf, rnOK );
        temp = temp1 - temp;
        
            if (temp > 247) {
                temp = 247;
                memmove (SMS_temp_buf, ptr, temp);
                SMS_temp_buf[247] = '\r'; SMS_temp_buf[248] = '\n'; SMS_temp_buf[249] = '\0';
            } 
            else {
                memmove (SMS_temp_buf, ptr, temp);
                SMS_temp_buf[temp - 1] = '\0';            
            }
	}
    if (MODEMTASCKSbits.get_imsi == 1) {    
        temp = strstr(UART_Rx_copy_buf, CPIN);
    	if (temp != 0) {
            temp1 = strstr(UART_Rx_copy_buf, OK);
            if (temp1 != 0 && ((temp1 - temp) == 35)) {
                Nop();Nop();Nop();
                GETIMSIbits.done = 1;
                temp = temp + 18;
                memmove ( IMSI_buf, temp, 15 );
            }
    	}
    }    

//    temp = strstr(UART_Rx_copy_buf, CALRST);
//	if (temp) { reset_calibration (); }

    
//_LATB5 = 0;
return 0;
} // Разбор ответов модема
void gsm_task_result_check (int res) {

    if (res == 1) { // OK
        if (MODEMTASCKSbits.set_cnt_sgp) {
            MODEMTASCKSbits.set_cnt_sgp = 0;
            CONTEXTSTATUSbits.context_ok = 1;
            clear_gsm_task_busy_timer ();
        }

        if (MODEMTASCKSbits.qiopen) {
            GPRSSTATUSbits.qiopen_ok = 1;
            clear_gsm_task_busy_timer ();
        }
        if (MODEMTASCKSbits.cgreg_check) {
            MODEMTASCKSbits.cgreg_check = 0;
            clear_gsm_task_busy_timer ();
        }
        if (MODEMTASCKSbits.at_to_modem == 1) {
            MODEMTASCKSbits.at_to_modem = 0;
            UARTATMODEMbits.UARTATMODEM = 0;
            clear_gsm_task_busy_timer ();
        }
        if (MODEMTASCKSbits.sms_deleting == 1) {
           SMSDELETEbits.at_qmgda_ok = 1;
           clear_gsm_task_busy_timer ();
        }
        if (MODEMTASCKSbits.get_imsi == 1) {
           GETIMSIbits.ok = 1;
           clear_gsm_task_busy_timer ();
        }        
//        if (SMSSENDbits.waiting_cmgs_result == 1) {
//            SMSSENDbits.cmgs_ok = 1;
//        }
    }
    else { // ERROR

        if (MODEMTASCKSbits.modem_UART_check == 1) {// Ошибка ответа на АТ
            clear_gsm_task_busy_timer ();
            modem_on_off (MODEM_RESTART);
        }
        if (MODEMTASCKSbits.creg_check == 1) {      // Ошибка команды AT+CREG?
            clear_gsm_task_busy_timer ();
            modem_on_off (MODEM_RESTART);
        }
        if (MODEMTASCKSbits.set_cnt_sgp == 1) {     // Ошибка AT+QICNT;+QISGP=
            MODEMTASCKSbits.set_cnt_sgp = 0;
            CONTEXTSTATUSbits.context_error = 1;
            clear_gsm_task_busy_timer ();
        }
//        if (MODEMTASCKSbits.set_sgp == 1) {         // Ошибка AT+QISGP=
//            clear_gsm_task_busy_timer ();
//            modem_on_off (MODEM_RESTART);
//        }
        if (MODEMTASCKSbits.qiopen == 1) {            // Ошибка AT+QIOPEN=
            clear_gsm_task_busy_timer ();
            GPRSSTATUSbits.qiopen_error = 1;
//            MODEMTASCKSbits.qiopen = 0;
//            if (GPRSSTATUSbits.already_connect == 1) GPRSSTATUSbits.qiopen_error = 0;
//            else GPRSSTATUSbits.qiopen_error = 1;
        }
        if (MODEMTASCKSbits.qiclose == 1) {            // Ошибка AT+QICLOSE
            clear_gsm_task_busy_timer ();
            CONNECTIONCLSbits.close_error = 1;
//            MODEMTASCKSbits.qiclose = 0;
        }
        if (MODEMTASCKSbits.pdp_deact == 1) {       // Ошибка AT+QIDEACT
            clear_gsm_task_busy_timer ();
        }
        if (MODEMTASCKSbits.cgreg_check == 1) {     // Ошибка AT+CGREG?
            clear_gsm_task_busy_timer ();
            modem_on_off (MODEM_RESTART);
        }
        if (MODEMTASCKSbits.data_sending == 1) { // Ошибка отсылки по GPRS: connection is not established or disconnected
            clear_gsm_task_busy_timer ();
//            MODEMTASCKSbits.data_sending = 0;
//            GPRSSENDbits.GPRSSEND = 0; //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            GPRSSENDbits.send_error = 1;
        }
        if (MODEMTASCKSbits.at_to_modem == 1) {
            MODEMTASCKSbits.at_to_modem = 0;
            UARTATMODEMbits.UARTATMODEM = 0;
            clear_gsm_task_busy_timer ();
        }
        if (MODEMTASCKSbits.sms_deleting == 1) {
           SMSDELETEbits.at_qmgda_error = 1;
           clear_gsm_task_busy_timer ();
        }
        if (MODEMTASCKSbits.get_imsi == 1) {
           GETIMSIbits.error = 1;
           clear_gsm_task_busy_timer ();
        }        
    }


} // Разбор ответов на АТ команды - ОК и ERROR
void cme_error (unsigned char *ptr) {

    unsigned int temp, i;
    
    temp = 0; 
    ptr = ptr + 14;
    for (i = 0; i < 4; i ++) {
        if (*ptr < 0x30 || *ptr > 0x39) break;
        temp = temp + (*ptr - 0x30); ptr ++;
        if (*ptr < 0x30 || *ptr > 0x39) break;
        temp = temp * 10;
    }
    
        if (MODEMTASCKSbits.at_to_modem == 1) {
            MODEMTASCKSbits.at_to_modem = 0;
            UARTATMODEMbits.UARTATMODEM = 0;
            clear_gsm_task_busy_timer ();
        }
    
    if (MODEMTASCKSbits.sms_reading == 1) {
        clear_gsm_task_busy_timer ();
        SMSREADbits.cme_error = 1;
        SMSREADbits.result_code = temp;
    }
    if (MODEMTASCKSbits.get_imsi == 1) {
        clear_gsm_task_busy_timer ();
        GETIMSIbits.cms_cme_error = 1;
    }    
}
void cms_error (unsigned char *ptr) {

    unsigned int temp, i;
    
    temp = 0; 
    ptr = ptr + 14;
    for (i = 0; i < 4; i ++) {
        if (*ptr < 0x30 || *ptr > 0x39) break;
        temp = temp + (*ptr - 0x30); ptr ++;
        if (*ptr < 0x30 || *ptr > 0x39) break;
        temp = temp * 10;
    }
    
    if (MODEMTASCKSbits.at_to_modem == 1) {
        MODEMTASCKSbits.at_to_modem = 0;
        UARTATMODEMbits.UARTATMODEM = 0;
        clear_gsm_task_busy_timer ();
    }

    if (MODEMTASCKSbits.sms_sending == 1) {
        SMSSENDbits.cms_error = 1;
        SMSSENDbits.result_code = temp;
    }

    if (MODEMTASCKSbits.sms_reading == 1) {
        clear_gsm_task_busy_timer ();
        SMSREADbits.cms_error = 1;
        SMSREADbits.result_code = temp;
    }
    if (MODEMTASCKSbits.get_imsi == 1) {
        clear_gsm_task_busy_timer ();
        GETIMSIbits.cms_cme_error = 1;
    }    
        
}
void cmgs_result (unsigned char *ptr) {

    unsigned int temp, i;
    
    temp = 0; 
    for (i = 0; i < 4; i ++) {
        if (*ptr < 0x30 || *ptr > 0x39) break;
        temp = temp + (*ptr - 0x30); ptr ++;
        if (*ptr < 0x30 || *ptr > 0x39) break;
        temp = temp * 10;
    }
            SMSSENDbits.plus_cmgs = 1;
            SMSSENDbits.result_code = temp;
            
            ptr = ptr + 4;
            if (*ptr == 'O') {
                ptr ++;
                if (*ptr == 'K') {
                   SMSSENDbits.cmgs_ok = 1; 
                }
            }
}
void gsm_tasck_timeout (void) {

// Таймаут регистрации в сети
    if (MODEMTASCKSbits.onoff == 1) {
        modem_tasck_timeout_flag = 0;
        MODEMTASCKSbits.onoff = 0;
//        modem_on_off (MODEM_RESTART);
        return;
    }

// Таймаут ответа на команду AT_QIFGCNT_QIFGSGP
    if (MODEMTASCKSbits.set_cnt_sgp == 1) {
        MODEMTASCKSbits.set_cnt_sgp = 0;
        CONTEXTSTATUSbits.context_timeout = 1;
        modem_tasck_timeout_flag = 0;
        return;
    }

// Таймаут ответа на команду AT_QIOPEN - регистрации в сети
    if (MODEMTASCKSbits.qiopen == 1) {
//        MODEMTASCKSbits.qiopen = 0;
        GPRSSTATUSbits.qiopen_timeout = 1;
        modem_tasck_timeout_flag = 0;
        return;
    }
// Таймаут ответа на команду AT_QICLOSE
    if (MODEMTASCKSbits.qiclose == 1) {
//        MODEMTASCKSbits.qiclose = 0;
        CONNECTIONCLSbits.close_timeout = 1;
        modem_tasck_timeout_flag = 0;
        return;
    }
// Таймаут задачи проверки статуса GPRS (at+cgreg?)
    if (MODEMTASCKSbits.cgreg_check == 1) {
        MODEMTASCKSbits.cgreg_check = 0;
        modem_tasck_timeout_flag = 0;
        return;
    }

// Таймаут отсылки по данных GPRS
    if (MODEMTASCKSbits.data_sending == 1) {
        MODEMTASCKSbits.data_sending = 0;
        modem_tasck_timeout_flag = 0;
        GPRSSENDbits.qisend_timeout = 1;
        return;
    }


// Таймаут команды отсылки SMS at+cmgs
    if (MODEMTASCKSbits.sms_sending == 1) {
//        MODEMTASCKSbits.sms_sending = 0;
        modem_tasck_timeout_flag = 0;
        SMSSENDbits.at_cmgs_timeout = 1;
        return;
    }

// Таймаут команды чтения SMS at+cmgr
    if (MODEMTASCKSbits.sms_reading == 1) {
        modem_tasck_timeout_flag = 0;
        SMSREADbits.at_cmgr_timeout = 1;
    }
    if (MODEMTASCKSbits.sms_deleting == 1) {
       SMSDELETEbits.at_qmgda_timeout = 1;
       clear_gsm_task_busy_timer ();
    }

// Таймаут команды запроса IMSI at+cimi
    if (MODEMTASCKSbits.get_imsi == 1) {
        modem_tasck_timeout_flag = 0;
        GETIMSIbits.timeout = 1;
        clear_gsm_task_busy_timer ();
        return;
    }    
    
} //

int  UART1_buf_to_UART1_copy_buf (unsigned int W_tmp) {

UART1_Rx_data_len = 0;
if(U1_num_R == W_tmp) return 0;

	while(U1_num_R != W_tmp) {
            UART_Rx_copy_buf [UART1_Rx_data_len ++] = UART1_Rx_buf [U1_num_R ++];
            if (U1_num_R == UART1_Rx_buf_SIZE) U1_num_R = 0; //U1_num_R %= UART1_buf_SIZE;
	}
	UART_Rx_copy_buf [UART1_Rx_data_len] = '\0';

return 1;
}
void transmit_GNSSdata_to_debug (void) {
    if (navistrtype == 1) {load_UART4_Tx_buf (Navi_str);} // Распарсенные данные
    else {load_UART4_Tx_buf (UART_Rx_copy_buf);} // Сырые данные
    start_UART4_transmission(WAITOFF);
}
void transmit_GSMdata_to_debug (void) {
    load_UART4_Tx_buf (UART_Rx_copy_buf);
    start_UART4_transmission(WAITOFF);
}

void gnss_LED_blinking () {
static unsigned char gnss_blink_counter = 0;

if ( io_reset_flag == 1 || gps_reset_flag == 1 ) return; 

    if (nav_trigger == 1) {
        if (gnss_blink_counter < 10) { gnss_blink_counter ++; }
        else {
            gnss_blink_counter = 0;
            if (Navi_str[62] == 'A') { GNSSLED_green = !GNSSLED_green;  }
            else { GNSSLED_green = 0; }            
//            if (Navi_str[62] == 'A') {GNSSLED_green = !GNSSLED_green; GNSSLED_red = 0;}
//            else {GNSSLED_red = !GNSSLED_red; GNSSLED_green = 0;}        
        }

    } else { nav_trigger = 0; GNSSLED_green = 0; }

}
void gsm_LED_blinking () {
    static unsigned char counter = 0;
    static unsigned char blink_period;
    
    if ( io_reset_flag == 1 || gps_reset_flag == 1 ) return;

    if (NETWORKSTATUSbits.cgreg == 1 || NETWORKSTATUSbits.cgreg == 5) blink_period = 3;
    else blink_period = 10;
    
    if (NETWORKSTATUSbits.creg == 1 || NETWORKSTATUSbits.cgreg == 5) {
        if (counter < blink_period) { counter ++; }
        else {counter = 0; GSM_LED = !GSM_LED; }
    } else {GSM_LED = 1; }
}
void stop_gsm_task () {

}

int  modem_on_off (unsigned int type) {

IEC1bits.T4IE = 0;
Nop();Nop();Nop();
    GSMSTATUSbits.unexpected_off = 0;
    GSMSTATUSbits.normal_on = 0;
    GSMSTATUSbits.rdy = 0;
    GSMSTATUSbits.cfun = 0;
    GSMSTATUSbits.cpin = 0;
    GSMSTATUSbits.callready = 0;
    NETWORKSTATUSbits.NETWORKSTATUS = 0;

    GPRSSTATUSbits.GPRSSTATUS = 0;
    gprs_start_timer = 0;

    CONNECTIONCLSbits.CONNECTIONCLS = 0;
    
    SMSSENDbits.SMSSEND = 0;
    SMSREADbits.SMSREAD = 0;
    SMSDELETEbits.SMSDELETE = 0;
    
    MODEMTASCKSbits.MODEMTASCKS = 0;
    MODEMTASCKSbits.onoff = 1;

    if (type == MODEM_ON) {
        modem_busy_max_value = 2300; // 1150
        modem_on_off_type = MODEM_ON;
    }

    if (type == MODEM_OFF) {
        modem_busy_max_value = 3000;//1500
        modem_on_off_type = MODEM_OFF;
    }

    if (type == MODEM_EMERG_RST) {
        modem_busy_max_value = 2700; // 1350
        modem_on_off_type = MODEM_EMERG_RST;
    }


      if (type == MODEM_RESTART) {
        modem_busy_max_value = 6000; // 3000
        modem_on_off_type = MODEM_RESTART;
    }
  
    modem_on_off_counter = 1;
    set_sgm_tasck_busy_timer (modem_busy_max_value);
//    gsm_task_busy_timer = 1;
//    gsm_task_busy_max_value = modem_busy_max_value;
    
IEC1bits.T4IE = 1;
}
void set_sgm_tasck_busy_timer (unsigned int timer) {
IEC1bits.T4IE = 0;
//        _LATB3 = 1;
        gsm_task_busy_timer = 1;
        gsm_task_busy_max_value = timer;
IEC1bits.T4IE = 1;
}
void clear_gsm_task_busy_timer (void) {
IEC1bits.T4IE = 0;

    gsm_task_busy_timer = 0;
//    _LATB3 = 0;

IEC1bits.T4IE = 1;
}
void get_gprs_status (int gsm_status, int context_status) {

    // Таймер задачи проверки GPRS соединения
    if (( NETWORKSTATUSbits.creg == 1 || NETWORKSTATUSbits.creg == 5 ) && MODEMTASCKSbits.MODEMTASCKS == 0 ) {
        if (gprs_start_timer < 300) gprs_start_timer ++;
        else {
            gprs_start_timer = 0;
            MODEMTASCKSbits.cgreg_check = 1;
            set_sgm_tasck_busy_timer (50); // Таймаут функции 500 мс
            start_UART1_transmission (WAITOFF, (unsigned int)load_UART1_Tx_buf (GET_CGREG));
        }
    }

} // Проверка GPRS соединения AT+CGREG?
void get_IMSI ( void ) {

    if (GETIMSIbits.start == 0) {
        GETIMSIbits.GETIMSI = 0;
        return;
    }
    
    if ( MODEMTASCKSbits.MODEMTASCKS == 0 && GSMSTATUSbits.cpin == 1 ) {
        MODEMTASCKSbits.get_imsi = 1;
        set_sgm_tasck_busy_timer (50); // Таймаут функции 500 мс
        start_UART1_transmission (WAITOFF, (unsigned int)load_UART1_Tx_buf (GET_IMSI));
    }
    if (GETIMSIbits.ok == 1) {
        if (GETIMSIbits.done == 1) {
            Nop();Nop();Nop();
            load_content_IMSI_event_by_sms ( 73, &IMSI_buf, &sms_temp_buf1 );
            write_text_to_SMS_buf ( &sms_temp_buf1, &PHONE_to_send_buf ); 
            generate_content_of_message ( 73, 1 );
            GETIMSIbits.GETIMSI = 0;
            MODEMTASCKSbits.get_imsi = 0;
        } else load_answer ( GETIMSIbits.sours_of_command, "ok:error", 0, 0 );    
    }
    if (GETIMSIbits.error == 1) {
        Nop();Nop();Nop();
        load_answer ( GETIMSIbits.sours_of_command, "ok:error", 0, 0 );
        GETIMSIbits.GETIMSI = 0;
        MODEMTASCKSbits.get_imsi = 0;
    }    
    if (GETIMSIbits.timeout == 1) {
        Nop();Nop();Nop();
        load_answer ( GETIMSIbits.sours_of_command, "ok:error", 0, 0 );
        GETIMSIbits.GETIMSI = 0;
        MODEMTASCKSbits.get_imsi = 0;
    }
    
    if (GETIMSIbits.tasck_timeout < 200) GETIMSIbits.tasck_timeout ++;
    else {
        load_answer ( GETIMSIbits.sours_of_command, "ok:error", 0, 0 );
        GETIMSIbits.GETIMSI = 0;
        MODEMTASCKSbits.get_imsi = 0;        
    }

} // Проверка GPRS соединения AT+CGREG?
int  set_gprs_context (void) {
// Открытие GPRS сессии

    if ((CONTEXTSTATUSbits.start == 1)&&(MODEMTASCKSbits.MODEMTASCKS == 0)) { //(NETWORKSTATUSbits.creg == 1 || NETWORKSTATUSbits.creg == 5)&&
//        if (CONTEXTSTATUSbits.cnt_sgp == 0) {
            MODEMTASCKSbits.set_cnt_sgp = 1;
            CONTEXTSTATUSbits.cnt_sgp = 1;
            CONTEXTSTATUSbits.start = 0;
            set_sgm_tasck_busy_timer (50); // Таймаут функции 500 мс
            start_UART1_transmission ( WAITOFF, (unsigned int)load_UART1_Tx_buf (AT_CNT_SGP) );
//        }
/*
        // Установка контекста
        if (GPRSSTATUSbits.cnt == 0) {
                MODEMTASCKSbits.set_cnt_sgp = 1;
                set_sgm_tasck_busy_timer (50); // Таймаут функции 500 мс
                load_UART1_Tx_buf (AT_QIFGCNT);
                start_UART1_transmission (WAITOFF, 13);
        }
        // Установка APN
        if ((GPRSSTATUSbits.cnt)&&( ! GPRSSTATUSbits.sgp )) {
                MODEMTASCKSbits.set_sgp = 1;
                set_sgm_tasck_busy_timer (50); // Таймаут функции 500 мс
                load_UART1_Tx_buf (AT_QICSGP);
                start_UART1_transmission (WAITOFF, 49);
        }
*/
    }

    if (MODEMTASCKSbits.onoff == 1)                                       return  0;
    if (CONTEXTSTATUSbits.start == 1 && MODEMTASCKSbits.set_cnt_sgp == 0) return  1; // Задача установки контекста в ожидании запуска
    if (MODEMTASCKSbits.set_cnt_sgp == 1)                                 return  2; // Задача установки контекста выполняется
    if (CONTEXTSTATUSbits.cnt_sgp && CONTEXTSTATUSbits.context_ok)        return  3; // Задача установки контекста выполнена успешно
    if (CONTEXTSTATUSbits.cnt_sgp && CONTEXTSTATUSbits.context_error)     return -1; // Ошибка задача установки контекста
    if (CONTEXTSTATUSbits.cnt_sgp && CONTEXTSTATUSbits.context_timeout)   return -2; // Таймаут задачи установки контекста

    return -3;

}
int  check_gsm_status (void) {

// Выполняется задача включения, выключения, рестарта
    if (MODEMTASCKSbits.onoff == 1) return 0;
    
/*
    Когда процесс включения/рестарта закончился, проверка состояние SIM,
    правильности и полноты включения модема
*/
    if ( modem_on_off_finished_flag ) {
        modem_on_off_finished_flag = 0;

            if (modem_on_off_type != MODEM_OFF) {
                if (!GSMSTATUSbits.power )     return -2;  // Модем не включился или выключился в процессе включения и рестарта
                if (!GSMSTATUSbits.rdy )       return -3;  // Модем не готов принимать команды
                if ( GSMSTATUSbits.cpin != 1 ) return -4;  // SIM не работает 
                if (!GSMSTATUSbits.callready ) return -5;  // Модем не не готов для звонков
                GSMSTATUSbits.normal_on  = 1;
                GSMSTATUSbits.normal_off = 0;
                CONTEXTSTATUSbits.start = 1;
            }
            else {
                if ( GSMSTATUSbits.power )         return -6; //
                if (!GSMSTATUSbits.normal_pw_dwn ) return -7; //
                GSMSTATUSbits.normal_on  = 0;
                GSMSTATUSbits.normal_off = 1;
            }
//        if ( GSMSTATUSbits.normal_on ) { // Модем был включен или перезагружен
//            if (!GSMSTATUSbits.power )    { return -2; } // Модем не включился или выключился в процессе включения и рестарта
//            if (!GSMSTATUSbits.rdy )      { return -3; } // Модем не готов принимать команды
//            if ( GSMSTATUSbits.cpin != 1 ){ return -4; } // SIM не работает или модем не готов к приему команд
//            if (!GSMSTATUSbits.callready ){ return -5; } // Модем не не готов для звонков
//        } else {
//            // здесь должна быть проверка на корректность выключения
//            if (GSMSTATUSbits.normal_pw_dwn && !GSMSTATUSbits.power) return -11; // Выключение завершилось удачно
//            else return -12;
//        }
    } // if ( modem_on_off_finished_flag )

// Недопустимые сочетания on и off
    if (!GSMSTATUSbits.normal_on && !GSMSTATUSbits.normal_off)  return -8;
    if ( GSMSTATUSbits.normal_on &&  GSMSTATUSbits.normal_off)  return -8;

// Когда модем находится в состоянии включен
    if ( GSMSTATUSbits.normal_on ) {

        if ( GSMSTATUSbits.cpin != 1 )  return -9;   // SIM карта отказала
        if ( GSMSTATUSbits.cfun != 1 )  return -10;  // Не полная функциональность модема
        if (!GSMSTATUSbits.power )      return -11;  // Модем выключился
                                        return 1;
    }  
        if ( GSMSTATUSbits.normal_off ) return 2;  // Модем выключен


// Неизвестное состояние
    return -12;

}
int  start_udp_tcp_connection (int context_status) {

    static unsigned int server_connection_timer = 0;
    unsigned int temp;

//const int qiopenidle        = 0b0000000000000000; //
//const int qiopenstart       = 0b0000000000000001; // start
//const int qiopenok          = 0b0000000000000010; // qiopen_ok
//const int qiopenerror       = 0b0000000000000100; // qiopen_error
//const int qiopentimeout     = 0b0000000000001000; // qiopen_timeout
//
//const int connectok         = 0b0000000000010010; // qiopen_ok & connect_ok
//const int connectfail       = 0b0000000001000010; // qiopen_ok & connect_fail
//const int connecterror      = 0b0000000010000010; //
//const int alreadyconnect    = 0b0000000010100000; // already_connect & qiopen_error
//const int waitingconnect    = 0b0000001000000010; // qiopen_ok & waiting_connection
//const int connecttimeout    = 0b0000000100000010; // qiopen_ok & connect_timeout

        // Установка соединения с сервером
    if (GPRSSTATUSbits.start == 1) {
        if ((NETWORKSTATUSbits.cgreg == 1 || NETWORKSTATUSbits.cgreg == 5) && MODEMTASCKSbits.MODEMTASCKS == 0) {
                if ((context_status == 3)&&( ! GPRSSTATUSbits.qiopen_ok)) { //GPRSSTATUSbits.cnt
                    MODEMTASCKSbits.qiopen = 1;
                    GPRSSTATUSbits.start = 0;
# if defined (UC15)
                    set_sgm_tasck_busy_timer (500); // Таймаут функции 500мс
# else
                    set_sgm_tasck_busy_timer (50); // Таймаут функции 500мс
# endif
                    start_UART1_transmission (WAITOFF, (unsigned int)load_UART1_Tx_buf (AT_QIOPEN));
                }
        }
    }


    if ( GPRSSTATUSbits.qiopen_ok && MODEMTASCKSbits.qiopen ) {
        MODEMTASCKSbits.qiopen = 0;
        GPRSSTATUSbits.waiting_connection = 1;
    }

    if (GPRSSTATUSbits.waiting_connection) {
        if (server_connection_timer < 750) {
            server_connection_timer ++;
            server_connection_timer_tmp = server_connection_timer;
            temp = GPRSSTATUSbits.GPRSSTATUS & 0b1111110111111111;
            if (temp == connectok      || temp == connecterror ||
                temp == alreadyconnect || temp == connectfail) {
                GPRSSTATUSbits.waiting_connection = 0;
                server_connection_timer = 0;
            }
        }
        else {
            server_connection_timer_tmp = server_connection_timer;
            server_connection_timer = 0;
            GPRSSTATUSbits.connect_timeout = 1;
            GPRSSTATUSbits.waiting_connection = 0;
        }
    }

    if (GPRSSTATUSbits.GPRSSTATUS == qiopenidle  && MODEMTASCKSbits.qiopen == 0)  return  QIOPENIDLE;      //  0 Задача соединения с сервером простаивает, соединения нет
    if (GPRSSTATUSbits.GPRSSTATUS == qiopenstart && MODEMTASCKSbits.qiopen == 0)  return  QIOPENSTART;     //  1 Задача соединения с сервером ждет запуска
    if (GPRSSTATUSbits.GPRSSTATUS == qiopenidle  && MODEMTASCKSbits.qiopen == 1)  return  QIOPENRUNNING;   //  2 Команда AT+QIOPEN выполняется

    if (GPRSSTATUSbits.GPRSSTATUS == waitingconnect)                              return  WAITINGCONNECT;  //  3 Команда AT+QIOPEN выполнена, ожидается соединение с сервером
    if (GPRSSTATUSbits.GPRSSTATUS == connectok) {
        GPRSSTATUSbits.waiting_connection = 0;        MODEMTASCKSbits.qiopen = 0; return  CONNECTOK;}      //  4 Соединение установлено
    if (GPRSSTATUSbits.GPRSSTATUS == alreadyconnect) {MODEMTASCKSbits.qiopen = 0; return  ALREADYCONNECT;} //  5 Соединение было установлено ранее
    if (GPRSSTATUSbits.GPRSSTATUS == qiopenerror)    {MODEMTASCKSbits.qiopen = 0; return  QIOPENERROR;}    // -1 Ошибка в АТ команде AT+QIOPEN
    if (GPRSSTATUSbits.GPRSSTATUS == qiopentimeout)  {MODEMTASCKSbits.qiopen = 0; return  QIOPENTIMEOUT;}  // -2 Таймаут АТ команды AT+QIOPEN
    if (GPRSSTATUSbits.GPRSSTATUS == connectfail)    {MODEMTASCKSbits.qiopen = 0; return  CONNECTFAIL;}    // -3 Соединение не произошло
    if (GPRSSTATUSbits.GPRSSTATUS == connecterror)   {MODEMTASCKSbits.qiopen = 0; return  CONNECTERROR;}   // -4 Ошибка соединения с сервером
    if (GPRSSTATUSbits.GPRSSTATUS == connecttimeout) {MODEMTASCKSbits.qiopen = 0; return  CONNECTTIMEOUT;} // -5 Таймаут соединения с сервером

    return CONNECTEXCEPTION;
}
int  server_connection_monitor (int server_connection_status) {

        if (server_connection_status >= 0) {

            if (server_connection_status == ALREADYCONNECT) { // Соединение уже установлено ранее - закрыть соединение
                GPRSSTATUSbits.connect_ok = 1; //1
                GPRSSTATUSbits.qiopen_ok = 1;
                GPRSSTATUSbits.already_connect = 0;
                GPRSSTATUSbits.qiopen_error = 0;
                close_udp_tcp_connection (1);
            }
            if (server_connection_status == WAITINGCONNECT) {
                Nop(); Nop(); Nop();
            }

        } else {
            Nop(); Nop(); Nop();
            if (server_connection_status == CONNECTEXCEPTION) modem_on_off (MODEM_EMERG_RST); // Таймаут соединения - сброс модема
            if (server_connection_status == CONNECTTIMEOUT)   modem_on_off (MODEM_EMERG_RST); // Таймаут соединения - сброс модема
            if (server_connection_status == QIOPENERROR) {                                    // Синтаксическая ошибка команды AT+QIOPEN 
                Nop();Nop();Nop();
                // здесь сделать откат команды, остылку SMS сообщения об ошибке?    
            }
            if (server_connection_status == CONNECTFAIL) {
            // Здесь надо как то отработать
                Nop(); Nop(); Nop();
            }
        }
        
}
int  close_udp_tcp_connection (unsigned int start) {

//const int qicloseidle    = 0x0000;
//const int qiclosestart   = 0x0001;
//const int qicloseok      = 0x0002;
//const int qicloseerror   = 0x0004;
//const int qiclosetimeout = 0x0008;

    if (start == 1) CONNECTIONCLSbits.start = 1;

    if (CONNECTIONCLSbits.start == 1) {
        if (MODEMTASCKSbits.MODEMTASCKS == 0) {
            CONNECTIONCLSbits.start = 0;
            MODEMTASCKSbits.qiclose = 1;
            set_sgm_tasck_busy_timer (50); // Таймаут функции 500мс
            start_UART1_transmission (WAITOFF, (unsigned int)load_UART1_Tx_buf (AT_QICLOSE));

        }
    }

    if (CONNECTIONCLSbits.CONNECTIONCLS == qicloseidle   && MODEMTASCKSbits.qiclose == 0)    return QICLOSEIDLE; // Задача свободна
    if (CONNECTIONCLSbits.CONNECTIONCLS == qiclosestart  && MODEMTASCKSbits.qiclose == 0)    return QICLOSESTART; // Задача ждет запуска
    if (CONNECTIONCLSbits.CONNECTIONCLS == qicloseidle   && MODEMTASCKSbits.qiclose == 1)    return QICLOSERUNNING; // Задача выполняется
    if (CONNECTIONCLSbits.CONNECTIONCLS == qicloseok     && MODEMTASCKSbits.qiclose == 1) {
        MODEMTASCKSbits.qiclose = 0;                                                         return QICLOSEOK; // Выполнена успешно
    }
    if (CONNECTIONCLSbits.CONNECTIONCLS == qicloseerror  && MODEMTASCKSbits.qiclose == 1) {
        MODEMTASCKSbits.qiclose = 0;                                                         return QICLOSEERROR; // Ошибка закрытия соединения
    }
    if (CONNECTIONCLSbits.CONNECTIONCLS == qiclosetimeout && MODEMTASCKSbits.qiclose == 1) {
        MODEMTASCKSbits.qiclose = 0;                                                         return QICLOSETIMEOUT; // Таймаут закрытия соединения
    }

return QICLOSEEXCEPTION;
}
void close_udp_tcp_connection_monitor (int close_connection_status) {
    
        if (close_connection_status >= 0) {
           if (close_connection_status == 3) { // Соединение закрыто
               GPRSSTATUSbits.GPRSSTATUS = 0;
               CONNECTIONCLSbits.CONNECTIONCLS = 0;
           }
        } else {
            if (close_connection_status == QICLOSETIMEOUT) modem_on_off (MODEM_EMERG_RST); // Таймаут закрытия соединения - сброс модема
            if (close_connection_status == QICLOSEEXCEPTION) modem_on_off (MODEM_EMERG_RST); //
        }

}

void convert_acc_settings_to_string (unsigned long long temp) {
char par0, par1, par2, par3, par4, par5, par6, par7;

    par0 = (char) temp;
    par1 = (char) (temp >> 8);
    par2 = (char) (temp >> 16);
    par3 = (char) (temp >> 24);
    par4 = (char) (temp >> 32);
    par5 = (char) (temp >> 40);
    par6 = (char) (temp >> 48);
    par7 = (char) (temp >> 56);

    bin_2_bcd ( (long)par0 );
    flash_sector_buf[0] = bin_2_bcd_buf [6];
    flash_sector_buf[1] = bin_2_bcd_buf [7];
    flash_sector_buf[2] = bin_2_bcd_buf [8];
    flash_sector_buf[3] = ',';
    
    bin_2_bcd ( (long)par1 );
    flash_sector_buf[4] = bin_2_bcd_buf [7];
    flash_sector_buf[5] = bin_2_bcd_buf [8];
    flash_sector_buf[6] = ',';
 
    bin_2_bcd ( (long)par2 );
    flash_sector_buf[7] = bin_2_bcd_buf [6];
    flash_sector_buf[8] = bin_2_bcd_buf [7];
    flash_sector_buf[9] = bin_2_bcd_buf [8];
    flash_sector_buf[10] = ',';

    bin_2_bcd ( (long)par3 );
    flash_sector_buf[11] = bin_2_bcd_buf [7];
    flash_sector_buf[12] = bin_2_bcd_buf [8];
    flash_sector_buf[13] = ',';
 
    bin_2_bcd ( (long)par4 );
    flash_sector_buf[14] = bin_2_bcd_buf [6];
    flash_sector_buf[15] = bin_2_bcd_buf [7];
    flash_sector_buf[16] = bin_2_bcd_buf [8];
    flash_sector_buf[17] = ',';

    bin_2_bcd ( (long)par5 );
    flash_sector_buf[18] = bin_2_bcd_buf [7];
    flash_sector_buf[19] = bin_2_bcd_buf [8];
    flash_sector_buf[20] = ',';
 
    bin_2_bcd ( (long)par6 );
    flash_sector_buf[21] = bin_2_bcd_buf [6];
    flash_sector_buf[22] = bin_2_bcd_buf [7];
    flash_sector_buf[23] = bin_2_bcd_buf [8];
    flash_sector_buf[24] = ',';
    
    bin_2_bcd ( (long)par7 );
    flash_sector_buf[25] = bin_2_bcd_buf [7];
    flash_sector_buf[26] = bin_2_bcd_buf [8];
    flash_sector_buf[27] = ';';
    
    flash_sector_buf[28] = 0;
    
}
unsigned long long convert_acc_settings_to_bin (char *ptr) {
unsigned long long temp;
unsigned char par0, par1, par2, par3, par4, par5, par6, par7;

par0 = (*(ptr + 1) - 0x30)*100 + (*(ptr + 2) - 0x30)*10 + *(ptr + 3) - 0x30;
par1 = (*(ptr + 5) - 0x30)*10 + *(ptr + 6) - 0x30;
par2 = (*(ptr + 8) - 0x30)*100 + (*(ptr + 9) - 0x30)*10 + *(ptr + 10) - 0x30;
par3 = (*(ptr + 12) - 0x30)*10 + *(ptr + 13) - 0x30;
par4 = (*(ptr + 15) - 0x30)*100 + (*(ptr + 16) - 0x30)*10 + *(ptr + 17) - 0x30;
par5 = (*(ptr + 19) - 0x30)*10 + *(ptr + 20) - 0x30;
par6 = (*(ptr + 22) - 0x30)*100 + (*(ptr + 23) - 0x30)*10 + *(ptr + 24) - 0x30;
par7 = (*(ptr + 26) - 0x30)*10 + *(ptr + 27) - 0x30;

temp =               (unsigned long long) par7;
temp = (temp << 8) + (unsigned long long) par6;
temp = (temp << 8) + (unsigned long long) par5;
temp = (temp << 8) + (unsigned long long) par4;
temp = (temp << 8) + (unsigned long long) par3;
temp = (temp << 8) + (unsigned long long) par2;
temp = (temp << 8) + (unsigned long long) par1;
temp = (temp << 8) + (unsigned long long) par0;

return temp;        
}
int  check_setting (int source_of_command, char *at_ptr) {

    unsigned int i, temp, offset;//, length;
    int res, dig1, dig2;
    char *ptr;//, *ptr1;
    volatile unsigned char temp_byte;
    long temp1; long long temp2;


        Nop(); Nop(); Nop();
        temp = strstr( at_ptr, APN_PARAM ); //command_temp_buf
	if (temp) {
            ptr = temp + 3;
            if (*ptr == '=') {
                res = apn_correctness ( ptr + 2 );
                if (res == 1) {
                    offset = 20;
                    for ( i = offset; i < 98; i ++ ) {
                      AT_CNT_SGP[i] =  *ptr; if (*ptr == ';') break; ptr ++;
                    }
                    AT_CNT_SGP [i] = '\r'; AT_CNT_SGP [++i] = 0;
                    GSMPARAMTASCKbits.change_apn = 1;
                    load_answer ( source_of_command, "ok:at$apn", 0, 0 );
                }
                else  load_answer ( source_of_command, "error:at$apn", 0, 0 ); 
            }
            else {
                if (*ptr == '?') { load_answer ( source_of_command, "at$apn=", &AT_CNT_SGP[21], 1 ); }
                else load_answer ( source_of_command, "error:at$apn?", 0, 0 );
            }
    }

        temp = strstr ( at_ptr, SERVER_PARAM );
	if (temp) {
            Nop(); Nop(); Nop();
            ptr = temp + 6; // Указатель на знак = или ? в строке server
            if (*ptr == '=') {
                res = server_correctness ( ptr + 1 );
                if (res == 1) {
                    offset = 20;
                    for ( i = offset; i < 60; i ++ ) {
                      AT_QIOPEN [i] =  *ptr; if (*ptr == ';') break; ptr ++;
                    }
                      AT_QIOPEN [i] = '\r'; AT_QIOPEN [++i] = 0; // AT_CNT_SGP
                      GSMPARAMTASCKbits.change_server = 1;
                      load_answer ( source_of_command, "ok:at$server", 0, 0 );
                } 
                else { load_answer ( source_of_command, "error:at$server", 0, 0 ); }
            }
            else {
                if (*ptr == '?') { load_answer ( source_of_command, "at$server=", &AT_QIOPEN[21], 1 ); }
                else load_answer ( source_of_command, "error:at$server?", 0, 0 );
            }
    }

        temp = strstr( at_ptr, IGNTT ); //command_temp_buf
	if (temp) {
           
    }

        temp = strstr( at_ptr, IGNFT ); //command_temp_buf
	if (temp) {
            
    }

    temp = strstr( at_ptr, IGNVT ); //command_temp_buf
	if (temp) {
            ptr = temp;
            Nop(); Nop(); Nop();
            if ( (*(ptr + 5) =='=')&&(*(ptr + 10) ==';') ) {
            temp1 = (int) convert_str_to_hex ( ptr + 6, 4 );
            if (temp1 < 0) {                    
                load_answer ( source_of_command, "error:at$ignvt", 0, 0 );
            } else {
                ign_volt_trh = (unsigned int) temp1;
                FM25_write_2( 1592, (unsigned int) ign_volt_trh );
                OC1R = ign_volt_trh;
                load_answer ( source_of_command, "ok:at$ignvt", 0, 0 );
            }
            }
            else {
                if (*(ptr + 5) == '?') {
                    bin_2_bcd ((long ) ign_volt_trh);
                    flash_sector_buf[0] = bin_2_bcd_buf[4];
                    flash_sector_buf[1] = bin_2_bcd_buf[5];
                    flash_sector_buf[2] = bin_2_bcd_buf[6];
                    flash_sector_buf[3] = bin_2_bcd_buf[7];
                    flash_sector_buf[4] = bin_2_bcd_buf[8];                    
                    flash_sector_buf[5] = '\0';
                    load_answer ( source_of_command, "at$ignvt=", &flash_sector_buf, 0 ); 
                } else {
                    load_answer ( source_of_command, "error:at$ignvt", 0, 0 );
                }
            }
    }

    temp = strstr( at_ptr, ACEL ); //command_temp_buf
	if (temp) {
            ptr = temp + 4;
            if (*ptr == '=') {
                Nop(); Nop(); Nop();
                if ( (*(ptr + 4) ==',')&&(*(ptr + 7) ==',')&&(*(ptr + 11) ==',')&&(*(ptr + 14) ==',')&&(*(ptr + 18) ==',')&&(*(ptr + 21) ==',')&&(*(ptr + 25) ==',')&&(*(ptr + 28) ==';') ) {
                    Nop(); Nop(); Nop();
                    ACELbits.ACEL = convert_acc_settings_to_bin ( temp + 4 );
                    FM25_write_8( 1610, (unsigned long long) ACELbits.ACEL );
                    load_answer ( source_of_command, "ok:at$acel", 0, 0 );
                }
                else load_answer ( source_of_command, "error:at$acel", 0, 0 );
            }
            else {
                if (*ptr == '?') {
                    convert_acc_settings_to_string ( ACELbits.ACEL );
                    Nop(); Nop(); Nop();
                    load_answer ( source_of_command, "at$acel=", &flash_sector_buf[0], 1 ); 
                }
                else load_answer ( source_of_command, "error:at$acel", 0, 0 );
            }
    }

    temp = strstr( at_ptr, DCEL ); //command_temp_buf
	if (temp) {
            ptr = temp + 4;
            if (*ptr == '=') {
                Nop(); Nop(); Nop();
                if ( (*(ptr + 4) ==',')&&(*(ptr + 7) ==',')&&(*(ptr + 11) ==',')&&(*(ptr + 14) ==',')&&(*(ptr + 18) ==',')&&(*(ptr + 21) ==',')&&(*(ptr + 25) ==',')&&(*(ptr + 28) ==';') ) {
                    Nop(); Nop(); Nop();
                    DCELbits.DCEL = convert_acc_settings_to_bin ( temp + 4 );
                    DCELbits.trh1 = -1 * DCELbits.trh1;
                    DCELbits.trh2 = -1 * DCELbits.trh2;
                    DCELbits.trh3 = -1 * DCELbits.trh3;
                    DCELbits.trh4 = -1 * DCELbits.trh4;
                    FM25_write_8( 1618, (unsigned long long) DCELbits.DCEL );
                    load_answer ( source_of_command, "ok:at$dcel", 0, 0 );
                }
                else load_answer ( source_of_command, "error:at$dcel", 0, 0 );
            }
            else {
                if (*ptr == '?') {
                    convert_acc_settings_to_string ( DCELbits.DCEL );
                    Nop(); Nop(); Nop();
                    load_answer ( source_of_command, "at$dcel=", &flash_sector_buf[0], 1 ); 
                }
                else load_answer ( source_of_command, "error:at$dcel", 0, 0 );
            }
    }    

    temp = strstr( at_ptr, LALL ); //command_temp_buf
	if (temp) {
            ptr = temp + 4;
            if (*ptr == '=') {
                Nop(); Nop(); Nop();
                if ( (*(ptr + 4) ==',')&&(*(ptr + 7) ==',')&&(*(ptr + 11) ==',')&&(*(ptr + 14) ==',')&&(*(ptr + 18) ==',')&&(*(ptr + 21) ==',')&&(*(ptr + 25) ==',')&&(*(ptr + 28) ==';') ) {
                    Nop(); Nop(); Nop();
                    LALLbits.LALL = convert_acc_settings_to_bin ( temp + 4 );
                    LALRbits.LALR =      LALLbits.LALL;
                    LALRbits.trh1 = -1 * LALRbits.trh1;
                    LALRbits.trh2 = -1 * LALRbits.trh2;
                    LALRbits.trh3 = -1 * LALRbits.trh3;
                    LALRbits.trh4 = -1 * LALRbits.trh4;
                    FM25_write_8( 1626, (unsigned long long) LALLbits.LALL );
                    load_answer ( source_of_command, "ok:at$lall", 0, 0 );
                }
                else load_answer ( source_of_command, "error:at$lall", 0, 0 );
            }
            else {
                if (*ptr == '?') {
                    convert_acc_settings_to_string ( LALLbits.LALL );
                    Nop(); Nop(); Nop();
                    load_answer ( source_of_command, "at$lall=", &flash_sector_buf[0], 1 ); 
                }
                else load_answer ( source_of_command, "error:at$lall", 0, 0 );
            }
    }    
    
    temp = strstr( at_ptr, SMSEN ); //command_temp_buf
	if (temp) {
            ptr = temp + 5;
            if (*ptr == '=') {
                Nop(); Nop(); Nop();
                if ( ( *(ptr + 10) ==';') ) {
                    Nop(); Nop(); Nop();
                    SMSENbits.pwr_on       = *(ptr + 1) - 0x30;
                    SMSENbits.pwr_off      = *(ptr + 2) - 0x30;
                    SMSENbits.ign_on       = *(ptr + 3) - 0x30;
                    SMSENbits.ign_off      = *(ptr + 4) - 0x30;
                    SMSENbits.static_compl = *(ptr + 5) - 0x30;
                    SMSENbits.clbr_compl   = *(ptr + 6) - 0x30;
                    SMSENbits.acel         = *(ptr + 7) - 0x30;
                    SMSENbits.dcel         = *(ptr + 8) - 0x30;
                    SMSENbits.lal          = *(ptr + 9) - 0x30;
                    load_answer ( source_of_command, "ok", 0, 0 );
                }
                else load_answer ( source_of_command, "error", 0, 0 );
            }
            else {
                load_answer ( source_of_command, "error", 0, 0 );
            }
    }    
    
	if ( strstr( at_ptr, AT_NAVI ) ) { load_answer ( source_of_command, "at$navi=", Navi_str, 0 );  }        
        
        temp = strstr( at_ptr, SMS_SEND ); //command_temp_buf
	if ( temp ) {
            write_text_to_SMS_buf ( temp + 7, "\"+79032559788\"\0" );
            
    }
    temp = strstr( at_ptr, GPRS_SEND ); //command_temp_buf
	if ( temp ) {
//            write_text_to_SMS_buf ( temp + 7, PHONE_NUMBER );
        type0_send_flag = 1;
//        write_data_to_GPRS_buf ( TYPE0, 9 );            
    }        
    temp = strstr( at_ptr, RUN );
	if (temp) {
        Nop();Nop();Nop();
        if (source_of_command == 3) source_of_command = 2;        
        ptr = temp;
        if ((*(ptr + 3) == '=')&&(*(ptr + 8) == ';')&&(STARTENGINEbits.start == 0) && (SERVFLAGSbits.serv_status == 0)) { //
            Nop();Nop();Nop();
//            if (STARTENGINEbits.start == 0) {
                STARTENGINEbits.pulse_duration = 0;
                temp = 0;
                temp = temp + (*(ptr + 4) - 0x30) * 1000;
                temp = temp + (*(ptr + 5) - 0x30) * 100;
                temp = temp + (*(ptr + 6) - 0x30) * 10;
                temp = temp + (*(ptr + 7) - 0x30);
                temp = (temp + 50)/100;
                    if ((temp > 0)||(temp <= 20)) {
                        if (temp > 5) {
                            fire_rel_transaction_flag = 1;
                            STARTENGINEbits.start = 1;
                            STARTENGINEbits.pulse_duration = temp; 
                            STARTENGINEbits.source_of_command = source_of_command;
                            load_answer ( source_of_command, "ok:at$run", 0, 0 );

//                            LOCKAUTORUNbits.LOCKAUTORUN = 0;
//                            LOCKAUTORUNbits.start = 1;
//                            LOCKAUTORUNbits.counter = 19200; //19200 
                            IGNINTROFFAUTORUNbits.IGNINTROFFAUTORUN = 0;
                            IGNINTROFFAUTORUNbits.start = 1;

                            generate_content_of_message ( 37, 1 );
                        } else {
                            Nop();Nop();Nop();
                            generate_content_of_message ( 87, 1 );
                            LOCKAUTORUNbits.start = 1;
                            DOORAUTORUNbits.start = 1;
                            dd_intrusion_off_timer = dd_intrusion_off_setting;
                            stop_autorun_engine ( 1, temp );
                        }
                        
                    } else load_answer ( source_of_command, "error:at$run", 0, 0 );
//            }
            
        } else load_answer ( source_of_command, "error:at$run", 0, 0 );
        
    }
    temp = strstr( at_ptr, RUNS );
	if (temp) {
        Nop();Nop();Nop();
        if (source_of_command == 3) source_of_command = 2;        
        ptr = temp;
        if ((*(ptr + 7) == ';') && (SERVFLAGSbits.serv_status == 0)) {//&&(STARTENGINESbits.start == 0)
            Nop();Nop();Nop();

                STARTENGINEbits.pulse_duration = 0;
                temp = 0;
                temp = temp + (*(ptr + 5) - 0x30) * 10;
                temp = temp + (*(ptr + 6) - 0x30);
                if (STARTENGINESbits.start == 0) {
                    if ((temp > 1) && (temp <= 60)) {
                        temp = temp * 600;
                        fire_rel_transaction_flag = 1;
                        STARTENGINESbits.start = 1;
                        STARTENGINESbits.pulse_duration = temp; 
                        STARTENGINESbits.source_of_command = source_of_command;
                        load_answer ( source_of_command, "ok:at$runs", 0, 0 );

//                        LOCKAUTORUNbits.LOCKAUTORUN = 0;
//                        LOCKAUTORUNbits.start = 1;
//                        LOCKAUTORUNbits.counter = 19200; //19200 
                        IGNINTROFFAUTORUNbits.IGNINTROFFAUTORUN = 0;
                        IGNINTROFFAUTORUNbits.start = 1;

                        generate_content_of_message ( 37, 1 );
                    }
                    else load_answer ( source_of_command, "error:at$runs", 0, 0 );
                } 
                else {
                    if (temp == 0) {
# if defined (MCP23S08)

# else                        
                        AUTO_START = 0;
# endif
                        generate_puls_after_autorun_off ( 1 );
                        STARTENGINESbits.pulse_duration = 0;
                        STARTENGINESbits.running_duration = 0;
                        STARTENGINESbits.source_of_command = 0;
                        STARTENGINESbits.start = 0;
                        STARTENGINESbits.start_success = 0;
                        STARTENGINESbits.wait_duration = 0;
                        generate_content_of_message ( 87, 1 );
//                        LOCKAUTORUNbits.LOCKAUTORUN = 0;
//                        LOCKAUTORUNbits.start = 1;
                        IGNINTROFFAUTORUNbits.IGNINTROFFAUTORUN = 0;
                        delayd_wired_bloking_during_autorun ( 1 );
                        dd_intrusion_off_timer = dd_intrusion_off_setting;
                        load_answer ( source_of_command, "ok:at$runs", 0, 0 );
                    } else  load_answer ( source_of_command, "error:at$runs", 0, 0 );
                }
        } else load_answer ( source_of_command, "error:at$runs", 0, 0 );
        
    }    
    
volatile unsigned int dur1, dur2, dur3;    
    temp = strstr( at_ptr, RUND );
	if (temp) {
        Nop();Nop();Nop();
        if (source_of_command == 3) source_of_command = 2;        
        ptr = temp;
        if ((*(ptr + 4) == '=')&&(*(ptr + 19) == ';')&&(STARTENGINEDLbits.start == 0) && (SERVFLAGSbits.serv_status == 0)) {
            Nop();Nop();Nop();
//            if (gearbox2_status == 1) {
                dur1 = get_rund_puls_duration ( ptr + 5 );
                dur2 = get_rund_puls_duration ( ptr + 10 );
                dur3 = get_rund_puls_duration ( ptr + 15 );
                dur1 = dur1 * 10;
                dur2 = (dur2 + 50)/100;
                dur3 = (dur3 + 50)/100;            
                    if ((dur1 >= 1200 && dur1 <= 18000)&&(dur2 >= 20 && dur2 <= 99)&&(dur3 >= 1 && dur3 <= 40)) {
                        fire_rel_transaction_flag = 1;
                        STARTENGINEDLbits.STARTENGINEDL = 0;
                        STARTENGINEDLbits.start = 1;
                        STARTENGINEDLbits.run_duration   = dur1;
                        STARTENGINEDLbits.pulse_delay    = dur2;
                        STARTENGINEDLbits.pulse_duration = dur3; 
                        STARTENGINEDLbits.source_of_command = source_of_command;
                        load_answer ( source_of_command, "ok:at$rund", 0, 0 );

//                        LOCKAUTORUNbits.LOCKAUTORUN = 0;
//                        LOCKAUTORUNbits.start = 1;
//                        LOCKAUTORUNbits.counter = 600; //19200
                        IGNINTROFFAUTORUNbits.IGNINTROFFAUTORUN = 0;
                        IGNINTROFFAUTORUNbits.start = 1;

                        generate_content_of_message ( 37, 1 );

                    } else load_answer ( source_of_command, "error:at$rund", 0, 0 );

//            } else { // АКПП не в паркинге
//                load_answer ( source_of_command, "error:at$rund", 0, 0 );
//                generate_content_of_message ( 59, 1 );
//            }
        } else {
            
            dur1 = get_rund_puls_duration ( ptr + 5 );
            if ( dur1 == 0 && STARTENGINEDLbits.start == 1 ) {// Остановка уже запущенного далинка
                generate_content_of_message ( 87, 1 );
                STARTENGINEDLbits.pulse_delay = 0;
                STARTENGINEDLbits.pulse_duration = 0;
                STARTENGINEDLbits.run_duration = 0;
                STARTENGINEDLbits.source_of_command = 0;
                STARTENGINEDLbits.start = 0;
                STARTENGINEDLbits.success_message_generated = 0;
//                LOCKAUTORUNbits.LOCKAUTORUN = 0;
//                LOCKAUTORUNbits.start = 1;
                
# if defined (MCP23S08)
                
# else                
                if (OUTFUNCbits.pin9 == 5) AUTO_START = 0; 
                if (OUTFUNCbits.pin15 == 5) L_OUT = 0;
# endif
                dd_intrusion_off_timer = dd_intrusion_off_setting;
                load_answer ( source_of_command, "ok:at$rund", 0, 0 );
            } else load_answer ( source_of_command, "error:at$rund", 0, 0 );            
            
        } 
        
    }
    temp = strstr( at_ptr, RUNP );
	if (temp) {
        Nop();Nop();Nop();
        if (source_of_command == 3) source_of_command = 2;        
        ptr = temp;
        if ((*(ptr + 4) == '=')&&(*(ptr + 9) == ',')&&(*(ptr + 14) == ',')&&(*(ptr + 17) == ';') && (SERVFLAGSbits.serv_status == 0)) {
            Nop();Nop();Nop();
                dur1 = get_rund_puls_duration ( ptr + 5 );
                dur2 = get_rund_puls_duration ( ptr + 10 );
                dur3 = get_runp_puls_duration ( ptr + 15 );
                dur1 = (dur1 + 50) / 100;
                dur2 = (dur2 + 50) / 100;
                dur3 = dur3 * 600; 
                if (dur3 != 0) {
                        if (STARTENGINEPbits.start == 0 && (dur3 >= 1200 && dur3 <= 18000) && (dur1 >= 1 && dur1 <= 63) && (dur2 >= 1 && dur2 <= 63)) {
                            fire_rel_transaction_flag = 1;
                            STARTENGINEPbits.STARTENGINEP = 0;
                            STARTENGINEPbits.start = 1;
                            STARTENGINEPbits.start_pulse_duration = dur1;
                            STARTENGINEPbits.stop_pulse_duration  = dur2;
                            STARTENGINEPbits.run_duration = dur3; 
                            STARTENGINEPbits.source_of_command = source_of_command;
                            load_answer ( source_of_command, "ok:at$runp", 0, 0 );

//                            LOCKAUTORUNbits.LOCKAUTORUN = 0;
//                            LOCKAUTORUNbits.start = 1;
//                            LOCKAUTORUNbits.counter = 19200; //19200
                            IGNINTROFFAUTORUNbits.IGNINTROFFAUTORUN = 0;
                            IGNINTROFFAUTORUNbits.start = 1;

                            generate_content_of_message ( 37, 1 );

                        }
                        else load_answer ( source_of_command, "error:at$runp", 0, 0 );
                } else {
                    
                    if (STARTENGINEPbits.start == 1 && (dur2 >= 1 && dur2 <= 63) ) {
//                        LOCKAUTORUNbits.LOCKAUTORUN = 0;
//                        LOCKAUTORUNbits.start = 1;
                        generate_content_of_message ( 87, 1 );
                        stop_autorun_engine ( 1, dur2 ); // запуск импульса стоп
                        STARTENGINEPbits.start_pulse_duration = 0;
                        STARTENGINEPbits.stop_pulse_duration = 0;
                        STARTENGINEPbits.run_duration = 0;
                        STARTENGINEPbits.source_of_command = 0;
                        STARTENGINEPbits.start = 0;
                        STARTENGINEPbits.success_message_generated = 0;
                        dd_intrusion_off_timer = dd_intrusion_off_setting; // 5 секундный таймер игнорирования вторжения по дверям 
                        load_answer ( source_of_command, "ok:at$runp", 0, 0 );
                    }else load_answer ( source_of_command, "error:at$runp", 0, 0 );
                }

        } else load_answer ( source_of_command, "error:at$runp", 0, 0 );
        
    }
#ifdef RUN_O
/*    
volatile unsigned int dur4;
temp = strstr( at_ptr, RUNO );
  //at$runo=XXXX,YYYY,ZZZZ,CCCC; 
  //XXXX - time of engine work sec; YYYY - time of start/stop pulse ms; ZZZZ - time of pause between start/stop pulses ms
  //CCCC - count of start/stop pulses.
	if (temp) {
        Nop();Nop();Nop();
        //if (source_of_command == 3) source_of_command = 2;        
        ptr = temp;
        if ((*(ptr + 4) == '=')&&(*(ptr + 24) == ';') && STARTENGINEObits.start == 0 && (OUTbits.serv_flag == 0)) { //&&(STARTENGINEDLbits.start == 0) && (SERVFLAGSbits.serv_status == 0)) {
            Nop();Nop();Nop();
                dur1 = get_rund_puls_duration ( ptr + 5 ); //time of work XXX in SECS
                dur2 = get_rund_puls_duration ( ptr + 10 );//start/stop pulse duration in MSECS
                dur3 = get_rund_puls_duration ( ptr + 15 );//pause duration in MSEC
                dur4 = get_rund_puls_duration ( ptr + 20 );//number of start/stop pulses
                dur1 = dur1 * 10;
                dur2 = (dur2 + 50)/100;
                dur3 = (dur3 + 50)/100;            
                    if ((dur1 >= 1200 && dur1 <= 18000)) { //limits for at$runo inputs
                        fire_rel_transaction_flag = 1;
                        STARTENGINEObits.STARTENGINEO = 0; // reset all early data in union structure
                        STARTENGINEObits.run_duration   = dur1;
                        STARTENGINEObits.pulse_duration = dur2;
                        STARTENGINEObits.pulse_delay    = dur3;
                        STARTENGINEObits.pulse_count    = dur4;
                        STARTENGINEObits.start = 1; //start flag for start_engine_o () func
                        load_answer ( source_of_command, "ok:at$runo", 0, 0 );
                        Nop();Nop();Nop();
                        IGNINTROFFAUTORUNbits.start = 1;
                        generate_content_of_message ( 37, 1 );
                    } else load_answer ( source_of_command, "error:at$runo", 0, 0 );
        } else {            
            dur1 = get_rund_puls_duration ( ptr + 5 );
            if ( dur1 == 0 && STARTENGINEObits.start == 1 ) {// stop currently running autostart procedure
                STARTENGINEObits.stop = 1; // stop FL for task
                load_answer ( source_of_command, "ok:at$runo", 0, 0 );
            } else load_answer ( source_of_command, "error:at$runo", 0, 0 );            
       } 
    }
*/
//volatile unsigned int dur4;
temp = strstr( at_ptr, RUNO );
  //at$runo=XXXX,YYYY,ZZZZ,CCCC;
  //XXXX - time of engine work sec; YYYY - time of start/stop pulse ms; ZZZZ - time of pause between start/stop pulses ms
  //CCCC - count of start/stop pulses.
  //new version for 2 algorithms
  //at$runo=XXXX; 
  //XXXX - time of engine work sec;
  	if (temp) {
        static char alg_ver = 0; //<-replace with Algorithm_option->
        Nop();Nop();Nop();
        ptr = temp;
        STARTENGINEOSETbits.STARTENGINEOSET = (unsigned long)FM25_read_4 (1688);
        if (( STARTENGINEOSETbits.alg_type == 1 || STARTENGINEOSETbits.alg_type == 2 ) && (*(ptr + 4) == '=')&&(*(ptr + 9) == ';') && (OUTbits.serv_flag == 0) ) {        
            //if (source_of_command == 3) source_of_command = 2;        
            
            if (STARTENGINEO1bits.start == 0 && STARTENGINEObits.start == 0) { //&&(STARTENGINEDLbits.start == 0) && (SERVFLAGSbits.serv_status == 0)) {
                Nop();Nop();Nop();
                    dur1 = get_rund_puls_duration ( ptr + 5 ); //time of work XXX in SECS
                    //dur2 = get_rund_puls_duration ( ptr + 10 );//start/stop pulse duration in MSECS
                    //dur3 = get_rund_puls_duration ( ptr + 15 );//pause duration in MSEC
                    //dur4 = get_rund_puls_duration ( ptr + 20 );//number of start/stop pulses

    //                dur2 = 1000; //<replace by settings var>
    //                dur3 = 1000; 
    //                dur4 = 1; 
   
                    dur1 = dur1 * 10;
                    dur2 = (STARTENGINEOSETbits.dur2 + 50)/100;//dur2
                    dur3 = (STARTENGINEOSETbits.dur3 + 50)/100;//dur3            
                        if ((dur1 >= 1200 && dur1 <= 18000) && STARTENGINEOSETbits.alg_type == 1) { //limits for at$runo inputs
                            fire_rel_transaction_flag = 1;
                            STARTENGINEObits.STARTENGINEO = 0; // reset all early data in union structure
                            STARTENGINEObits.run_duration   = dur1;
                            STARTENGINEObits.pulse_duration = dur2;
                            STARTENGINEObits.pulse_delay    = dur3;
                            STARTENGINEObits.pulse_count    = STARTENGINEOSETbits.dur4;//dur4
                            STARTENGINEObits.start = 1; //start flag for start_engine_o () func
                            OBDRPMREQbits.start = 1;
                            load_answer ( source_of_command, "ok:at$runo", 0, 0 );
                            Nop();Nop();Nop();
                            IGNINTROFFAUTORUNbits.start = 1;
                            DOORAUTORUNObits.start = 1;
                            generate_content_of_message ( 37, 1 );
                        } else {
                            if (STARTENGINEOSETbits.alg_type == 1) load_answer ( source_of_command, "error:at$runo", 0, 0 );
                        }
                        if ((dur1 >= 1200 && dur1 <= 18000) && STARTENGINEOSETbits.alg_type == 2) { //limits for at$runo inputs
                            fire_rel_transaction_flag = 1;
                            STARTENGINEO1bits.STARTENGINEO1 = 0; // reset all early data in union structure
                            STARTENGINEO1bits.run_duration   = dur1;
                            STARTENGINEO1bits.pulse_duration = dur2;
                            STARTENGINEO1bits.pulse_delay    = dur3;
                            STARTENGINEO1bits.pulse_count    = STARTENGINEOSETbits.dur4;//
                            STARTENGINEO1bits.start = 1; //start flag for start_engine_o () func
                            OBDRPMREQbits.start = 1;
                            load_answer ( source_of_command, "ok:at$runo", 0, 0 );
                            Nop();Nop();Nop();
                            IGNINTROFFAUTORUNbits.start = 1;
                            DOORAUTORUNObits.start = 1;
                            generate_content_of_message ( 37, 1 );
                        } else {
                            if (STARTENGINEOSETbits.alg_type == 2) load_answer ( source_of_command, "error:at$runo", 0, 0 );
                        }

            } else {            
                dur1 = get_rund_puls_duration ( ptr + 5 );
                if ( dur1 == 0 ) {
                    DOORAUTORUNObits.start = 1;
//                    generate_content_of_message ( 87, 1 );
                    if ( STARTENGINEObits.start == 1 ) {// stop currently running autostart procedure
                        STARTENGINEObits.stop = 1; // stop FL for task
                        load_answer ( source_of_command, "ok:at$runo", 0, 0 );
                    } else {  
                        if ( STARTENGINEO1bits.start == 1 ) {// stop currently running autostart procedure
                            STARTENGINEO1bits.stop = 1; // stop FL for task
                            load_answer ( source_of_command, "ok:at$runo", 0, 0 );
                        } else load_answer ( source_of_command, "error:at$runo", 0, 0 );
                    }
                } else load_answer ( source_of_command, "error:at$runo", 0, 0 );
           }
        } else load_answer ( source_of_command, "error:at$runo", 0, 0 );
    }
temp = strstr( at_ptr, ROST );
  //at$runo=X,YYYY,ZZZZ,CCCC;
  //X = 0 off 
  //YYYY - time of start/stop pulse ms; ZZZZ - time of pause between start/stop pulses ms
  //CCCC - count of start/stop pulses.
  //new version for 2 algorithms
//at$rost=2,1000,1000,1;
  	if (temp) {
        ptr = temp;
        if ((*(ptr + 4) == '=')&&(*(ptr + 6) == ',')&&(*(ptr + 11) == ',')&&(*(ptr + 16) == ',')&&(*(ptr + 18) == ';')) {
            STARTENGINEOSETbits.alg_type = *(ptr + 5) - 0x30;//start/stop pulse duration in MSECS
            STARTENGINEOSETbits.dur2 = get_rund_puls_duration ( ptr + 7 );//start/stop pulse duration in MSECS
            STARTENGINEOSETbits.dur3 = get_rund_puls_duration ( ptr + 12 );//pause duration in MSEC
            STARTENGINEOSETbits.dur4 =  *(ptr + 17) - 0x30;//number of start/stop pulses 
            if ( (STARTENGINEOSETbits.alg_type >= 0 && STARTENGINEOSETbits.alg_type <= 2) && 
                  STARTENGINEOSETbits.dur2 >= 100 && STARTENGINEOSETbits.dur3 >= 100 && STARTENGINEOSETbits.dur4 >= 1 ) {
                FM25_write_4 ( 1688, (unsigned long)STARTENGINEOSETbits.STARTENGINEOSET );
                load_answer ( source_of_command, "ok:at$rost", 0, 0 );
            } else load_answer ( source_of_command, "error:at$rost", 0, 0 ); 
        }
    }
#endif
    volatile unsigned long temp_dig;
    temp = strstr( at_ptr, RUNC );
	if (temp) {

        Nop();Nop();Nop();
        if (source_of_command == 3) source_of_command = 2;        
        ptr = temp;
        if ((*(ptr + 4) == '=') && (*(ptr + 9) == ';') && OUTbits.serv_flag == 0 && wbst_startenginecan_switch == 1 ) {
            dur1 = get_rund_puls_duration ( ptr + 5 );
            temp_dig = (unsigned long)dur1;
            temp_dig = temp_dig * 100ul;
            Nop();Nop();Nop();
            if (temp_dig > 0) { //temp_dig
                
                if (STARTENGINECbits.start_tasck == 0) { //
//                   fire_rel_transaction_flag = 1;
                   OBDRPMREQbits.start = 1; 
                   IGNINTROFFAUTORUNbits.start = 1;
                   STARTENGINECbits.start_tasck = 1;
                   STARTENGINECbits.run_duration = temp_dig; //temp_dig
                   generate_content_of_message ( 37, 1 );
                   load_answer ( source_of_command, "ok:at$runc", 0, 0 );
                } else load_answer ( source_of_command, "error:at$runc", 0, 0 ); 

            } else {
//                generate_content_of_message ( 87, 1 );
                if( STARTENGINECbits.start == 0 && STARTENGINECbits.stop == 0 && STARTENGINECbits.run_duration > 0 ) { // WEBASTO включено и не идет процесс включения/выключения
                    STARTENGINECbits.stop_tasck = 1; // не идет процесс включения/выключения выключение через 2 секунды
                    load_answer ( source_of_command, "ok:at$runc", 0, 0 );
                } else load_answer ( source_of_command, "error:at$runc", 0, 0 );
            }
            
        } else load_answer ( source_of_command, "error:at$runc", 0, 0 );

    }

    temp = strstr( at_ptr, WBSF );
	if (temp) {
        Nop();Nop();Nop();
        if (source_of_command == 3) source_of_command = 2;        
        ptr = temp;
        if ( fisical_input_enable == 3 && (*(ptr + 4) == '=')&&(*(ptr + 9) == ',')&&(*(ptr + 14) == ',')&&(*(ptr + 17) == ';') && OUTbits.serv_flag == 0 ) {
            Nop();Nop();Nop();
                dur1 = get_rund_puls_duration ( ptr + 5 );
                dur2 = get_rund_puls_duration ( ptr + 10 );
                dur3 = get_runp_puls_duration ( ptr + 15 );
                dur1 = (dur1 + 50) / 100;
                dur2 = (dur2 + 50) / 100;
                dur3 = dur3 * 600; 
                if (dur3 != 0) {
                        if (FUNCONTROLbits.start == 0 && (dur3 >= 1200 && dur3 <= 36000) && (dur1 >= 1 && dur1 <= 63) && (dur2 >= 1 && dur2 <= 63)) {
                            fire_rel_transaction_flag = 1;
                            FUNCONTROLbits.FUNCONTROL = 0;
                            FUNCONTROLbits.start = 1;
                            FUNCONTROLbits.start_pulse_duration = dur1;
                            FUNCONTROLbits.stop_pulse_duration  = dur2;
                            FUNCONTROLbits.run_duration = dur3; 
                            FUNCONTROLbits.source_of_command = source_of_command;
                            load_answer ( source_of_command, "ok:at$wbsf", 0, 0 );

//                            LOCKAUTORUNbits.LOCKAUTORUN = 0;
//                            LOCKAUTORUNbits.start = 1;
//                            LOCKAUTORUNbits.counter = 600; //19200
//                            IGNINTROFFAUTORUNbits.IGNINTROFFAUTORUN = 0;
//                            IGNINTROFFAUTORUNbits.start = 1;

//                            generate_content_of_message ( 37, 1 );

                        }
                        else load_answer ( source_of_command, "error:at$wbsf", 0, 0 );
                } else {
                    
                    if (FUNCONTROLbits.start == 1 && (dur2 >= 1 && dur2 <= 63) ) {
                        generate_content_of_message ( 52, 1 );
                        stop_autorun_engine ( 1, dur2 ); // запуск импульса стоп
                        FUNCONTROLbits.start_pulse_duration = 0;
                        FUNCONTROLbits.stop_pulse_duration = 0;
                        FUNCONTROLbits.run_duration = 0;
                        FUNCONTROLbits.source_of_command = 0;
                        FUNCONTROLbits.start = 0;
                        FUNCONTROLbits.success_message_generated = 0;
//                        dd_intrusion_off_timer = dd_intrusion_off_setting; // 5 секундный таймер игнорирования вторжения по дверям 
                        load_answer ( source_of_command, "ok:at$wbsf", 0, 0 );
                    }else load_answer ( source_of_command, "error:at$wbsf", 0, 0 );
                }

        } else load_answer ( source_of_command, "error:at$wbsf", 0, 0 );
        
    }
    

    temp = strstr( at_ptr, WBST );
	if (temp) {

        Nop();Nop();Nop();
        if (source_of_command == 3) source_of_command = 2;        
        ptr = temp;
        if ((*(ptr + 4) == '=') && (*(ptr + 9) == ';') && OUTbits.serv_flag == 0 && wbst_startenginecan_switch == 0 ) {
            dur1 = get_rund_puls_duration ( ptr + 5 );
            temp_dig = (unsigned long)dur1 * 100;
            Nop();Nop();Nop();
            if (temp_dig > 0) {
                
                if (WEBASTObits.task_start == 0) { // Задача управления WEBASTO простаивает
                   WEBASTObits.task_start = 1;
                   WEBASTObits.counter = temp_dig;
                   load_answer ( source_of_command, "ok:at$wbst", 0, 0 );
                } else load_answer ( source_of_command, "error:at$wbst", 0, 0 ); 

            } else {
                if( WEBASTObits.start == 0 && WEBASTObits.stop == 0 && WEBASTObits.counter > 0 ) { // WEBASTO включено и не идет процесс включения/выключения
                    WEBASTObits.counter = 200; // не идет процесс включения/выключения выключение через 2 секунды
                    load_answer ( source_of_command, "ok:at$wbst", 0, 0 );
                } else load_answer ( source_of_command, "error:at$wbst", 0, 0 );
            }
            
        } else load_answer ( source_of_command, "error:at$wbst", 0, 0 );

    }
    
    temp = strstr( at_ptr, SRV );
	if (temp) {
        Nop();Nop();Nop();
        if (source_of_command == 3) source_of_command = 2;        
        ptr = temp;
        if ((*(ptr + 3) == '=')&&(*(ptr + 5) == ';')) {
            Nop();Nop();Nop();
            temp = *(ptr + 4);
                if ((temp == 0x30)||(temp == 0x31)) {
                    load_answer ( source_of_command, "ok:at$srv", 0, 0 );
                    if (temp == 0x31) {
                        if (OUTbits.serv_flag == 0) start_beep_task ( 7, 7, 3 );
                        service_ON ();
                        OUTbits.serv_flag = 1;
                        OUTbits.arm_flag = 0;
                        fire_rel_transaction_flag = 1;
                        RELTRANSFLGSbits.rel_serv_on = 1;
                    } else {
                        if (OUTbits.serv_flag == 1) start_beep_task ( 7, 7, 3 );
                        service_OFF ();
                        OUTbits.serv_flag = 0;
                        fire_rel_transaction_flag = 1;
                        RELTRANSFLGSbits.rel_serv_off = 1;
                    }
                }
                else load_answer ( source_of_command, "error:at$srv", 0, 0 );
            
        } else {
            if (*(ptr + 3) != 'r') load_answer ( source_of_command, "error:at$srv", 0, 0 );
        }
        
    }    

    temp = strstr( at_ptr, DLU );
	if (temp) {
        Nop();Nop();Nop();
//        if (source_of_command == 3) source_of_command = 2;        
        ptr = temp;
        if ((*(ptr + 3) == '=')&&(*(ptr + 5) == ';')) {
            Nop();Nop();Nop();
            temp = *(ptr + 4);
                if ((temp == 0x30)||(temp == 0x31)) {
                    
                    load_answer ( source_of_command, "ok:at$dlu", 0, 0 );
                    if (temp == 0x31) { 
                        if( OUTbits.arm_flag == 1 ) disarm_by_doors_unlock ();
                        LOCKUNLOCKbits.LOCKUNLOCK = 0;LOCKUNLOCKbits.start = 1; LOCKUNLOCKbits.unlock = 1; 
                    } 
                    else { 
                        LOCKUNLOCKbits.LOCKUNLOCK = 0;LOCKUNLOCKbits.start = 1; LOCKUNLOCKbits.lock = 1; 
                    }
                }
                else load_answer ( source_of_command, "error:at$dlu", 0, 0 );
        } else load_answer ( source_of_command, "error:at$dlu", 0, 0 );
    }
    temp = strstr( at_ptr, BTLU );
	if (temp) {
        Nop();Nop();Nop();
//        if (source_of_command == 3) source_of_command = 2;        
        ptr = temp;
        if ((*(ptr + 4) == '=')&&(*(ptr + 6) == ';')) {
            Nop();Nop();Nop();
            temp = *(ptr + 5);
                if ((temp == 0x30)||(temp == 0x31)) {
                    if (temp == 0x31) { 
                        if ( CBTUNLOCKSET1bits.can_number != 0 || CBTUNLOCKSET2bits.can_number != 0 || CBTUNLOCKSET3bits.can_number != 0 ) {
                            boot_lock_unlock_flag = 1;LOCKUNLOCKbits.LOCKUNLOCK = 0;
                            LOCKUNLOCKbits.start = 1; LOCKUNLOCKbits.unlock = 1; 
                            load_answer ( source_of_command, "ok:at$btlu", 0, 0 );
                        } else {
                            if ( lin_boot_unlock_start == 0) {
                                if( OUTbits.arm_flag == 1 ) disarm_by_doors_unlock ();
                                lin_boot_unlock_start = 1;
                                load_answer ( source_of_command, "ok:at$btlu", 0, 0 );
                            } else { load_answer ( source_of_command, "error:at$btlu", 0, 0 ); }
                        }

                    } 
                    else { load_answer ( source_of_command, "error:at$btlu", 0, 0 ); } //LOCKUNLOCKbits.LOCKUNLOCK = 0;LOCKUNLOCKbits.start = 1; LOCKUNLOCKbits.lock = 1;
                }
                else load_answer ( source_of_command, "error:at$btlu", 0, 0 );
        } else load_answer ( source_of_command, "error:at$btlu", 0, 0 );
    }

    temp = strstr( at_ptr, DLLU );
	if (temp) {
        Nop();Nop();Nop();
//        if (source_of_command == 3) source_of_command = 2;        
        ptr = temp;
        if ((*(ptr + 4) == '=')&&(*(ptr + 6) == ';')) {
            Nop();Nop();Nop();
            temp = *(ptr + 5);
                if ((temp == 0x30)||(temp == 0x31)) {
                    load_answer ( source_of_command, "ok:at$dllu", 0, 0 );
                    if (temp == 0x31) { 
                        LINLOCKUNLOCKbits.start = 1; LINLOCKUNLOCKbits.command = 1;
                        //if (lin_lock_flag_tmp2 == 0) {LINLOCKUNLOCKbits.start = 1; LINLOCKUNLOCKbits.command = 1;} // команда открыть замки 
                    } 
                    else { 
                        if( OUTbits.arm_flag == 1 ) disarm_by_doors_unlock ();
                        LINLOCKUNLOCKbits.start = 1; LINLOCKUNLOCKbits.command = 0;
                        //if (lin_lock_flag_tmp2 == 1) {LINLOCKUNLOCKbits.start = 1; LINLOCKUNLOCKbits.command = 0;} // команда закрыть замки  
                    }
                }
                else load_answer ( source_of_command, "error:at$dllu", 0, 0 );
        } else load_answer ( source_of_command, "error:at$dllu", 0, 0 );
    }
#if defined (MAZDA_LOCK)
    temp = strstr( at_ptr, DULU );
	if (temp) {
        Nop();Nop();Nop();
//        if (source_of_command == 3) source_of_command = 2;        
        ptr = temp;
        if ((*(ptr + 4) == '=')&&(*(ptr + 6) == ',')&&(*(ptr + 8) == ';')) {
            Nop();Nop();Nop();
            temp = *(ptr + 5);
                if ((temp == 0x30)||(temp == 0x31)) {
                    load_answer ( source_of_command, "ok:at$dulu", 0, 0 );
                    if (temp == 0x31) { mazda_lock_start_flag = 1; } 
                    else { mazda_lock_start_flag = 2; }
                    temp = *(ptr + 7);
                    if (temp == '0') mazda_lock_type = 0;
                    else mazda_lock_type = 1; 
                        
                } else load_answer ( source_of_command, "error:at$dulu", 0, 0 );
        } else load_answer ( source_of_command, "error:at$dulu", 0, 0 );
    }

# endif    
unsigned char hf_en_tmp;    
    temp = strstr( at_ptr, HFEN );
	if (temp) {
        ptr = temp;
        if (*(ptr + 6) == ';') {
            temp = *(ptr + 5);
                if ((temp == 0x30)||(temp == 0x31)||(temp == 0x32)) {
                    hf_en_tmp = (unsigned char)(temp - 0x30);
                    if ((hands_free_enable != 2) && (hf_en_tmp == 2)) generate_content_of_message ( 91, 1 );
                    if ((hands_free_enable == 2) && (hf_en_tmp != 2)) generate_content_of_message ( 90, 1 );
                    hands_free_enable = temp - 0x30;
                    FM25_write_1( 1000, (unsigned int) hands_free_enable );
                    load_answer ( source_of_command, "ok:at$hfen", 0, 0 );
                } else load_answer ( source_of_command, "error:at$hfen", 0, 0 );
        } else load_answer ( source_of_command, "error:at$hfen", 0, 0 );
    }     
    temp = strstr( at_ptr, REN );
	if (temp) {
        ptr = temp;
        if (*(ptr + 5) == ';') {
            temp = *(ptr + 4);
                if ((temp == 0x30)||(temp == 0x31)) {
                    relay_enable = temp - 0x30;
                    FM25_write_1( 1001, (unsigned int) relay_enable );
                    load_answer ( source_of_command, "ok:at$ren", 0, 0 );
                } else load_answer ( source_of_command, "error:at$ren", 0, 0 );
        } else load_answer ( source_of_command, "error:at$ren", 0, 0 );
    }
    temp = strstr( at_ptr, ARMEN );
	if (temp) {
        ptr = temp;
        if (*(ptr + 5) == '=' && *(ptr + 7) == ';') {
            temp = *(ptr + 6);
                if ((temp == 0x30)||(temp == 0x31)) {
                    arm_enable = temp - 0x30;
                    FM25_write_1( 1002, (unsigned int) arm_enable );
                    load_answer ( source_of_command, "ok:at$armen", 0, 0 );
                } else load_answer ( source_of_command, "error:at$armen", 0, 0 );
        } else load_answer ( source_of_command, "error:at$armen", 0, 0 );
    }
    temp = strstr( at_ptr, ALCEN );
	if (temp) {
        ptr = temp;
        if (*(ptr + 5) == '=' && *(ptr + 7) == ';') {
            temp = *(ptr + 6);
                if ((temp == 0x30)||(temp == 0x31)) {
                    lock_close_autorun_enable = temp - 0x30;
                    FM25_write_1( 1003, (unsigned int) lock_close_autorun_enable );
                    load_answer ( source_of_command, "ok:at$alcen", 0, 0 );
                } else load_answer ( source_of_command, "error:at$alcen", 0, 0 );
        } else load_answer ( source_of_command, "error:at$alcen", 0, 0 );
    }    
    temp = strstr( at_ptr, CDAT );
	if (temp) { 
        if ( apply_can_settings(temp) ) {load_answer ( source_of_command, "ok:at$cdat", 0, 0 );}
        else {load_answer ( source_of_command, "error:at$cdat", 0, 0 );} 
    }    
    temp = strstr( at_ptr, CSET );
	if (temp) { 
        if ( apply_can_speed(temp) ) {load_answer ( source_of_command, "ok:at$cset", 0, 0 );}
        else {load_answer ( source_of_command, "error:at$cset", 0, 0 );} 
    }
    temp = strstr( at_ptr, CCFG );
	if (temp) { 
        if ( apply_can_config(temp) ) {load_answer ( source_of_command, "ok:at$ccfg", 0, 0 );}
        else {load_answer ( source_of_command, "error:at$ccfg", 0, 0 );} 
    }    
char name;    
    temp = strstr( at_ptr, MDAT );
	if (temp) {
        ptr = temp;
        if ( *(ptr + 4) == '=' && *(ptr + 7) == ',' && *(ptr + 9) == ',' && *(ptr + 26) == ';' ) {
            Nop();Nop();Nop();
            temp = 0; name = 0;
            name = get_fw_nibble (ptr + 5);
            temp = get_fw_nibble (ptr + 6); 
            if ( temp >= 0 && name >= 0 ) {
                name = (name << 4) + temp;
                if ( save_dataflags_by_name ( name, ptr + 8 ) ) {load_answer ( source_of_command, "ok:at$mdat", 0, 0 );}
                else {load_answer ( source_of_command, "error:at$mdat", 0, 0 );} 
                
            } else {load_answer ( source_of_command, "error:at$mdat", 0, 0 );}
        } else {load_answer ( source_of_command, "error:at$mdat", 0, 0 );}
    }
    temp = strstr( at_ptr, MSET );
	if (temp) {
        ptr = temp;
        if ( *(ptr + 4) == '=' && *(ptr + 7) == ',' && *(ptr + 9) == ',' ) {
            Nop();Nop();Nop();
            temp = 0; name = 0;
            name = get_fw_nibble (ptr + 5);
            temp = get_fw_nibble (ptr + 6); 
            if ( temp >= 0 && name >= 0 ) {
                name = (name << 4) + temp;
                if ( save_settings_by_name ( name, ptr + 8 ) ) {load_answer ( source_of_command, "ok:at$mset", 0, 0 );}
                else {load_answer ( source_of_command, "error:at$mset", 0, 0 );} 
                
            } else {load_answer ( source_of_command, "error:at$mset", 0, 0 );}
        } else {load_answer ( source_of_command, "error:at$mset", 0, 0 );}
    }    
// Сброс ошибок            
    temp = strstr( at_ptr, DRST );
	if (temp) {
        Nop();Nop();Nop();
        dtc_reset_start = 1;
        KFASTDTCRESETTASKbits.start = 1;
        load_answer ( source_of_command, "ok:at$drst", 0, 0 );
    }
// Запрос VIN и DTCs
    temp = strstr( at_ptr, DVRQ );
	if (temp) {
        Nop();Nop();Nop();
        dvrq_start = 1;
        load_answer ( source_of_command, "ok:at$dvrq", 0, 0 );
    }            
// Сброс блока
    temp = strstr( at_ptr, UNRST );
	if (temp) {
        Nop();Nop();Nop();
        asm ("reset");
    }

// Команда прошивки
    temp = strstr( at_ptr, FW );
	if (temp) {
        Nop();Nop();Nop();
        if (check_atfw_comand ( temp ) > 0) {
            FM25_write_1 (2025, 0);// стереть признак скачанности прошивки
            load_answer ( source_of_command, "ok:at$fw", 0, 0 );
            at_ptr = temp;
            fw_req_buf[8]  = *(at_ptr + 3);  fw_req_buf[9]  = *(at_ptr + 4);
            fw_req_buf[10] = *(at_ptr + 5);  fw_req_buf[11] = *(at_ptr + 6); fw_req_buf[12] = *(at_ptr + 7);

            FM25_write_1 (2032, *(at_ptr + 3)); FM25_write_1 (2033, *(at_ptr + 4)) ;FM25_write_1 (2034, *(at_ptr + 5)); FM25_write_1 (2035, *(at_ptr + 6)); FM25_write_1 (2036, *(at_ptr + 7));
            FM25_write_1 (2037, *(at_ptr + 9)); FM25_write_1 (2038, *(at_ptr + 10));FM25_write_1 (2039, *(at_ptr + 11));FM25_write_1 (2040, *(at_ptr + 12));FM25_write_1 (2041, *(at_ptr + 13));
            FM25_write_1 (2042, *(at_ptr + 15));FM25_write_1 (2043, *(at_ptr + 16));FM25_write_1 (2044, *(at_ptr + 17));FM25_write_1 (2045, *(at_ptr + 18));FM25_write_1 (2046, *(at_ptr + 19));
            FWDTASCKbits.start = 1;
        } else load_answer ( source_of_command, "error:at$fw", 0, 0 );
        
//        load_answer ( source_of_command, "at$fwrq=00010,00000", 0, 0 );
    }    
// Команда прошивки
    temp = strstr( at_ptr, FWRS );
	if (temp) {
        Nop();Nop();Nop();
        if ( FWDTASCKbits.start == 1 ) {
            memmove ( fw_page_buf, at_ptr, 512 );
            for ( i = 461; i < 512; i ++) {fw_page_buf[i] = 0;}
            FWDTASCKbits.page_received = 1;
            Nop();Nop();Nop();
        }
    }
char r;    
    temp = strstr( at_ptr, FWRNW );
	if (temp) {
        Nop();Nop();Nop();
        ptr = temp;
        r = FM25_read_1 (2025); // признак скачанности прошивки
Nop();Nop();Nop();        
        if ( (*(ptr + 5) == '=') && (*(ptr + 10) == ';') && r == 1 ) {
            Nop();Nop();Nop();
            temp = get_mem_reset_flags ( ptr + 6 );
            
            if ( temp == 1 ) {
                Nop();Nop();Nop();
                FM25_write_2 (2023, (unsigned int)0 ); //MEMRESFLAGSbits.MEMRESFLAGS
                FM25_write_1 (2031, (*(ptr + 6) - 0x30));// Команда блоку стереть историю и/или настройки
                FM25_write_1 (2047, 1);// Команда бутлоадеру - прошить
                RCONbits.SWDTEN = 0;
                asm ("clrwdt");
                asm ("reset");
            } else load_answer ( source_of_command, "error:at$fwrnw", 0, 0 );
        }
        else  load_answer ( source_of_command, "error:at$fwrnw", 0, 0 );
    }
// Настройка реле    
    temp = strstr( at_ptr, RSET );
	if (temp) {
        Nop();Nop();Nop();
        ptr = temp;
        if ( *(ptr + 6) == ',' && *(ptr + 8)== ';' ) {
            dig1 = hex_2_bin (*(ptr + 5));
            dig2 = hex_2_bin (*(ptr + 7));
            if ( dig1 >= 0 && dig2 >= 0) {
                RELOUTbits.command = (unsigned char)dig1; RELOUTbits.param_value = (unsigned char)dig2;
                fire_rel_transaction_flag = 1;
                load_answer ( source_of_command, "ok:at$rset", 0, 0 );
            } else  load_answer ( source_of_command, "error:at$rset", 0, 0 );
            
        } else  load_answer ( source_of_command, "error:at$rset", 0, 0 );
    }
// Блокировка/разблокировка проводного реле    
    temp = strstr( at_ptr, OBLK );
	if (temp) {
        Nop();Nop();Nop();
        ptr = temp;
        if (*(ptr + 6) == ';' && (*(ptr + 5) == 0x30 || *(ptr + 5) == 0x31)) {
            wired_block = (*(ptr + 5) - 0x30);
            load_answer ( source_of_command, "ok:at$oblk", 0, 0 );
        } else  load_answer ( source_of_command, "error:at$oblk", 0, 0 );
    }    
// Блокировка/разблокировка реле    
    temp = strstr( at_ptr, RBLK );
	if (temp) {
        Nop();Nop();Nop();
        ptr = temp;
        if (*(ptr + 6) == ';' && (*(ptr + 5) == 0x30 || *(ptr + 5) == 0x31)) {
            RELOUTbits.block_flag = (unsigned char)(*(ptr + 5) - 0x30);
            fire_rel_transaction_flag = 1;
            if ( RELOUTbits.block_flag == 1 ) RELTRANSFLGSbits.rel_block = 1;
            else RELTRANSFLGSbits.rel_unblock= 1; 
            load_answer ( source_of_command, "ok:at$rblk", 0, 0 );
        } else  load_answer ( source_of_command, "error:at$rblk", 0, 0 );
    }
// Обучение реле
    if (strstr(at_ptr, RLRN)) {
        if (RLEARNTASKSbits.start == 0) {
            RLEARNTASKSbits.start = 1;
            RELTRANSFLGSbits.rel_learn = 1;
            load_answer ( source_of_command, "ok:at$rlrn", 0, 0 );
        } else load_answer ( source_of_command, "error:at$rlrn", 0, 0 );
    }
// Обучение меток
    if (strstr(at_ptr, TLRN)) {
        if (TLEARNTASKSbits.start == 0) {
            TLEARNTASKSbits.start = 1;
            load_answer ( source_of_command, "ok:at$tlrn", 0, 0 );
        } else load_answer ( source_of_command, "error:at$tlrn", 0, 0 );
    }    
// Стирание меток
    temp = strstr(at_ptr, TDEL);
    if (temp) {
        ptr = temp;
        if ( (*(ptr + 5) >= 0x31) && (*(ptr + 5) <= 0x35) && (*(ptr + 6) == ';')) {
            temp = *(ptr + 5) - 0x30;
            
            if (temp == 1) {Transp_flags[1] = 0; FM25_write_1 ( 32, 0 );}
            if (temp == 2) {Transp_flags[2] = 0; FM25_write_1 ( 33, 0 );}
            if (temp == 3) {Transp_flags[3] = 0; FM25_write_1 ( 34, 0 );}
            if (temp == 4) {Transp_flags[4] = 0; FM25_write_1 ( 35, 0 );}
            if (temp == 5) {Transp_flags[5] = 0; FM25_write_1 ( 36, 0 );}
            
            load_answer ( source_of_command, "ok:at$tdel", 0, 0 );
        } else load_answer ( source_of_command, "error:at$tdel", 0, 0 );        
    }
    temp = strstr(at_ptr, TDIS);
    if (temp) {
        ptr = temp;
        if ( (*(ptr + 5) >= 0x31) && (*(ptr + 5) <= 0x35) && (*(ptr + 6) == ';')) {
            temp = *(ptr + 5) - 0x30;
            
            if (temp == 1) {Transp_flags[1] = 7; FM25_write_1 ( 32, 7 );}
            if (temp == 2) {Transp_flags[2] = 7; FM25_write_1 ( 33, 7 );}
            if (temp == 3) {Transp_flags[3] = 7; FM25_write_1 ( 34, 7 );}
            if (temp == 4) {Transp_flags[4] = 7; FM25_write_1 ( 35, 7 );}
            if (temp == 5) {Transp_flags[5] = 7; FM25_write_1 ( 36, 7 );}
            
            load_answer ( source_of_command, "ok:at$tdis", 0, 0 );
        } else load_answer ( source_of_command, "error:at$tdis", 0, 0 );        
    } 
    
    temp = strstr(at_ptr, CALRST);
	if (temp) {
        load_answer ( source_of_command, "ok:at$calrst", 0, 0 );
        reset_calibration (); 
    }
    temp = strstr(at_ptr, SMSG);
	if (temp) {
        ptr = temp;
        if ((*(ptr + 4) == '=') && (*(ptr + 5) == 0x30 || *(ptr + 5) == 0x31 || *(ptr + 5) == 0x32 )) {
//            if (*(ptr + 5) == 0x30) { status_mesage_flag = 1; } 
//            else { status_mesage_flag = 2; }
            load_answer ( source_of_command, "ok:at$smsg", 0, 0 );
            status_mesage_flag = (*(ptr + 5) - 0x30) + 1;
        } else  load_answer ( source_of_command, "error:at$smsg", 0, 0 );
    } 
    
    temp = strstr(at_ptr, CRSH);
	if (temp) {
        generate_crash_flag = 1;
    }
    temp = strstr(at_ptr, PHNS);
	if (temp) {
        source_of_command = 2;
        ptr = temp + 4;
        if (*ptr == '=') {
            if (save_phone_number ((ptr + 1)) == 1) load_answer ( source_of_command, "ok:at$phns", 0, 0 );
            else load_answer ( source_of_command, "error:at$phns", 0, 0 );
        } else load_answer ( source_of_command, "error:at$phns", 0, 0 ); 
    } 
    
    temp = strstr( at_ptr, TMSG );
	if (temp) {
        ptr = temp;
        if ( *(ptr + 4) == '=' && *(ptr + 6) == ',' && *(ptr + 10) == ',' && *(ptr + 15) == ';' ) {
            Nop();Nop();Nop();
            temp = 0; name = 0;
            temp = convert_str_to_hex ( ptr + 5, 1 );
            
            if (TESTMSGSETbits.number_of_attempts != 0 && temp == 0) {
                load_answer ( source_of_command, "ok:at$tmsg", 0, 0 );
                TESTMSGSETbits.TESTMSGSET = 0;
            }
            if (temp != 0) {
                while (1) {
                    TESTMSGSETbits.mem = temp;
                    if (TESTMSGSETbits.mem > 2) {load_answer ( source_of_command, "error:at$tmsg", 0, 0 ); TESTMSGSETbits.TESTMSGSET = 0; break;}
                    TESTMSGSETbits.period = convert_str_to_hex ( ptr + 7, 3 );
                    if (TESTMSGSETbits.period < 2  ) {load_answer ( source_of_command, "error:at$tmsg", 0, 0 ); TESTMSGSETbits.TESTMSGSET = 0; break;}
                    TESTMSGSETbits.number_of_attempts = convert_str_to_hex ( ptr + 11, 4 );
                    if (TESTMSGSETbits.period > 20000  ) {load_answer ( source_of_command, "error:at$tmsg", 0, 0 ); TESTMSGSETbits.TESTMSGSET = 0; break;}
                    TESTMSGSETbits.start = 1;
                    load_answer ( source_of_command, "ok:at$tmsg", 0, 0 );
                    break;
                }
            } 
            
        }
    }
    
    temp = strstr( at_ptr, SMSD );
	if (temp) { 
        Nop();Nop();Nop();
        delete_SMS ( 1, AT_QMGDA_ALL );
        load_answer ( source_of_command, "ok:at$smsd", 0, 0 );
    }
// Блокировка/разблокировка реле    
    temp = strstr( at_ptr, DDIS );
	if (temp) {
        Nop();Nop();Nop();
        ptr = temp;
        if (*(ptr + 4) == '=' && (*(ptr + 7) == ';')) {
            res = 0;
            res = convert_str_to_hex ( ptr + 5, 2 );
            if (res >= 0) {
                dd_intrusion_off_setting = (unsigned int)(res * 10);
                FM25_write_2( 1529, (unsigned int)  dd_intrusion_off_setting );
                load_answer ( source_of_command, "ok:at$ddis", 0, 0 );
            } else  load_answer ( source_of_command, "error:at$ddis", 0, 0 ); 
            
        } else  load_answer ( source_of_command, "error:at$ddis", 0, 0 );
    }

    temp = strstr( at_ptr, CRQSET );
	if (temp) {
        Nop();Nop();Nop();
        ptr = temp;
        if (*(ptr + 6) == '=' && (*(ptr + 38) == ';')) {
            res = 0;
            res = save_can_request_settings ( ptr + 7 );
            if (res >= 0) {

                load_answer ( source_of_command, "ok:at$crqset", 0, 0 );
            } else  load_answer ( source_of_command, "error:at$crqset", 0, 0 ); 
            
        } else  load_answer ( source_of_command, "error:at$crqset", 0, 0 );
    }

    temp = strstr( at_ptr, INSET );
	if (temp) {
        Nop();Nop();Nop();
        ptr = temp;
        if (*(ptr + 5) == '=' && (*(ptr + 7) == ';')) {
            if (*(ptr + 6) >= 0x30 && (*(ptr + 6) <= 0x35)) {
                fisical_input_enable = *(ptr + 6) - 0x30;
                FM25_write_1( 1587, (unsigned int) fisical_input_enable ); //
                load_answer ( source_of_command, "ok:at$inset", 0, 0 );
            } else  load_answer ( source_of_command, "error:at$inset", 0, 0 ); 
            
        } else  load_answer ( source_of_command, "error:at$inset", 0, 0 );
    }
    temp = strstr( at_ptr, GODO );
	if (temp) {
        Nop();Nop();Nop();
        ptr = temp;
        if (*(ptr + 4) == '=' && (*(ptr + 13) == ';')) {
            temp1 = (long) convert_str_to_hex ( ptr + 5, 8 );
            if (temp1 >= 0) {
                GPS_odometer = (unsigned long) (temp1 * 10);
                FM25_write_4( 71, (unsigned long) GPS_odometer ); //
                load_answer ( source_of_command, "ok:at$godo", 0, 0 );
            } else  load_answer ( source_of_command, "error:at$godo", 0, 0 ); 
            
        } else  load_answer ( source_of_command, "error:at$godo", 0, 0 );
    }    

    temp = strstr( at_ptr, IVFL );
	if (temp) {
        Nop();Nop();Nop();
        ptr = temp;
        if (*(ptr + 4) == '=' && *(ptr + 6) == ',' && *(ptr + 9) == ',' && *(ptr + 14) == ';') {
            temp1 = (long) save_voltage_fall_detection_settings ( ptr + 5 );
            if (temp1 > 0) {
                load_answer ( source_of_command, "ok:at$ivfl", 0, 0 );
            } else  load_answer ( source_of_command, "error:at$ivfl", 0, 0 ); 
            
        } else  load_answer ( source_of_command, "error:at$ivfl", 0, 0 );
    }
    temp = strstr( at_ptr, USLP );
	if (temp) {
        Nop();Nop();Nop();
        sleep_counter = 17800;
        load_answer ( source_of_command, "ok:at$uslp", 0, 0 );
    }
    
    temp = strstr( at_ptr, SETSLP );
	if (temp) {
        Nop();Nop();Nop();
        ptr = temp;
        if (*(ptr + 6) == '=' && *(ptr + 11) == ';') {
            temp1 = (long) convert_str_to_hex ( ptr + 7, 4 );
            if (temp1 >= 0) {
                PERIFSLEEPSETbits.PERIFSLEEPSET = (unsigned int) temp1;
                FM25_write_2( 1700, (unsigned int) PERIFSLEEPSETbits.PERIFSLEEPSET ); // PERIFSLEEPSETbits
                load_answer ( source_of_command, "ok:at$setslp", 0, 0 );
            } else  load_answer ( source_of_command, "error:at$setslp", 0, 0 ); 
            
        } else  load_answer ( source_of_command, "error:at$setslp", 0, 0 );
    }

    temp = strstr( at_ptr, CRTYP );
	if (temp) {
        Nop();Nop();Nop();
        ptr = temp;
        if (*(ptr + 5) == '=' && (*(ptr + 7) == ';')) {
            if (*(ptr + 6) >= 0x30 && (*(ptr + 6) <= 0x31)) {
                crash_detection_type = *(ptr + 6) - 0x30;
                FM25_write_1( 1702, (unsigned int) crash_detection_type ); //
                load_answer ( source_of_command, "ok:at$crtyp", 0, 0 );
            } else  load_answer ( source_of_command, "error:at$crtyp", 0, 0 ); 
            
        } else  load_answer ( source_of_command, "error:at$crtyp", 0, 0 );
    }    

    temp = strstr( at_ptr, LSET );
	if (temp) {
        Nop();Nop();Nop();
        ptr = temp;
        if (*(ptr + 4) == '=' && (*(ptr + 53) == ';')) {
            if (save_lock_control_settings ( ptr, 1 )) {

                load_answer ( source_of_command, "ok:at$lset", 0, 0 );
            } else  load_answer ( source_of_command, "error:at$lset", 0, 0 ); 
            
        } else  load_answer ( source_of_command, "error:at$lset", 0, 0 );
    }
    temp = strstr( at_ptr, DSET );
	if (temp) {
        Nop();Nop();Nop();
        ptr = temp;
        if (*(ptr + 4) == '=' && (*(ptr + 53) == ';')) {
            if (save_lock_control_settings ( ptr, 2 )) {

                load_answer ( source_of_command, "ok:at$dset", 0, 0 );
            } else  load_answer ( source_of_command, "error:at$dset", 0, 0 ); 
            
        } else  load_answer ( source_of_command, "error:at$dset", 0, 0 );
    }    
    
    temp = strstr( at_ptr, WSET );
	if (temp) {
        Nop();Nop();Nop();
        ptr = temp;
        if (*(ptr + 4) == '=' && (*(ptr + 53) == ';') && wbst_startenginecan_switch == 0) { //
            if (save_webasto_control_settings ( ptr )) {

                load_answer ( source_of_command, "ok:at$wset", 0, 0 );
            } else  load_answer ( source_of_command, "error:at$wset", 0, 0 ); 
            
        } else  load_answer ( source_of_command, "error:at$wset", 0, 0 );
    }
    temp = strstr( at_ptr, SSET );
	if (temp) {
        Nop();Nop();Nop();
        ptr = temp;
        if (*(ptr + 4) == '=' && (*(ptr + 53) == ';') && wbst_startenginecan_switch == 1) { //
            if ( save_start_engine_can_settings ( ptr ) ) {

                load_answer ( source_of_command, "ok:at$sset", 0, 0 );
            } else  load_answer ( source_of_command, "error:at$sset", 0, 0 ); 
            
        } else  load_answer ( source_of_command, "error:at$sset", 0, 0 );
    } 
    temp = strstr( at_ptr, WSSWT );
	if (temp) {
        Nop();Nop();Nop();
        ptr = temp;
        if (*(ptr + 5) == '=' && (*(ptr + 7) == ';' && (*(ptr + 6) == 0x30 || *(ptr + 6) == 0x31 ))) { //
            wbst_startenginecan_switch = *(ptr + 6) - 0x30;
            FM25_write_1( 1692, wbst_startenginecan_switch );
            load_answer ( source_of_command, "ok:at$wsswt", 0, 0 );
        } else  load_answer ( source_of_command, "error:at$wsswt", 0, 0 );
    }    
//    temp = strstr( at_ptr, WRSET );
//	if (temp) {
//        Nop();Nop();Nop();
//        ptr = temp;
//        if (*(ptr + 5) == '=' && (*(ptr + 54) == ';')) {
//            if (save_webasto_control_settings ( ptr )) {
//
//                load_answer ( source_of_command, "ok:at$wrset", 0, 0 );
//            } else  load_answer ( source_of_command, "error:at$wrset", 0, 0 ); 
//            
//        } else  load_answer ( source_of_command, "error:at$wrset", 0, 0 );
//    }    
    temp = strstr( at_ptr, FEQ );
	if (temp) {
        Nop();Nop();Nop();
        ptr = temp;
        if (*(ptr + 3) == '=' && *(ptr + 8) == ',' && *(ptr + 13) == ',' && (*(ptr + 18) == ';')) {
            if (save_fuel_equation_settings ( ptr ) == 1) {

                load_answer ( source_of_command, "ok:at$feq", 0, 0 );
            } else  load_answer ( source_of_command, "error:at$feq", 0, 0 ); 
            
        } else  load_answer ( source_of_command, "error:at$feq", 0, 0 );
    }
# if defined (LIN)    
    temp = strstr( at_ptr, LLDAT );
	if (temp) {
        Nop();Nop();Nop();
        ptr = temp;
        if (*(ptr + 5) == '=' && (*(ptr + 41) == ';')) {
            if (save_lin_lock_settings ( ptr ) == 1) {

                load_answer ( source_of_command, "ok:at$lldat", 0, 0 );
            } else  load_answer ( source_of_command, "error:at$lldat", 0, 0 ); 
            
        } else  load_answer ( source_of_command, "error:at$lldat", 0, 0 );
    }
    
    temp = strstr( at_ptr, LBDAT );
	if (temp) {
        Nop();Nop();Nop();
        ptr = temp;
        if (*(ptr + 5) == '=' && (*(ptr + 41) == ';')) {
            if (save_lin_boot_lock_settings ( ptr ) == 1) {

                load_answer ( source_of_command, "ok:at$lbdat", 0, 0 );
            } else  load_answer ( source_of_command, "error:at$lbdat", 0, 0 ); 
            
        } else  load_answer ( source_of_command, "error:at$lbdat", 0, 0 );
    }
#endif    
    temp = strstr( at_ptr, OFUN );
	if (temp) {
        Nop();Nop();Nop();
        ptr = temp;
        if (*(ptr + 4) == '=' && (*(ptr + 28) == ';')) {
            if (save_functions_of_outputs_setting ( ptr ) == 1) {

                load_answer ( source_of_command, "ok:at$ofun", 0, 0 );
            } else  load_answer ( source_of_command, "error:at$ofun", 0, 0 ); 
            
        } else  load_answer ( source_of_command, "error:at$ofun", 0, 0 );
    }
    temp = strstr( at_ptr, IFUN );
	if (temp) {
        Nop();Nop();Nop();
        ptr = temp;
        if (*(ptr + 4) == '=' && (*(ptr + 28) == ';')) {
            if (save_functions_of_inputs_setting ( ptr ) == 1) {

                load_answer ( source_of_command, "ok:at$ifun", 0, 0 );
            } else  load_answer ( source_of_command, "error:at$ifun", 0, 0 ); 
            
        } else  load_answer ( source_of_command, "error:at$ifun", 0, 0 );
    }
    temp = strstr( at_ptr, LBEN );
	if (temp) {
        ptr = temp;
        if (*(ptr + 6) == ';') {
            temp = *(ptr + 5);
                if ((temp == 0x30)||(temp == 0x31)) {
                    lockbytes_enable = temp - 0x30;
                    FM25_write_1( 876, (unsigned int) lockbytes_enable );
                    load_answer ( source_of_command, "ok:at$lben", 0, 0 );
                } else load_answer ( source_of_command, "error:at$lben", 0, 0 );
        } else load_answer ( source_of_command, "error:at$lben", 0, 0 );
    }    
// Обучение замков
    temp = strstr(at_ptr, LBLRN);
    if ( temp ) {
        ptr = temp;
        if (*(ptr + 5) == '=' && *(ptr + 7) == ';' && (*(ptr + 6) == 0x31 || *(ptr + 6) == 0x32 || *(ptr + 6) == 0x33 )) {
            if (LOCKBYTESTASCKbits.start == 0 && lockbytes_enable == 1) {
                LOCKBYTESTASCKbits.start = 1;
                lockbytes_learn_param = *(ptr + 6) - 0x30;
                load_answer ( source_of_command, "ok:at$lblrn", 0, 0 );
            } else load_answer ( source_of_command, "error:at$lblrn", 0, 0 );
        } else load_answer ( source_of_command, "error:at$lblrn", 0, 0 );
    }
// Настройки чтения из LIN
# if defined (LIN)    
    temp = strstr( at_ptr, LNDAT );
	if (temp) { 
        if ( apply_LIN_settings(temp) ) {load_answer ( source_of_command, "ok:at$lndat", 0, 0 );}
        else {load_answer ( source_of_command, "error:at$lndat", 0, 0 );} 
    }
# endif    
// Настройка длины запроса MIL
    temp = strstr( at_ptr, MRLEN );
	if (temp) {
        ptr = temp;
        if ( *(ptr + 5) == '=' && *(ptr + 7) == ';' && (*(ptr + 6) == 0x30 || *(ptr + 6) == 0x31 ) ) {
            mil_req_len = *(ptr + 6) - 0x30;
            FM25_write_1 ( 1841, (unsigned int) mil_req_len );
            load_answer ( source_of_command, "ok:at$mrlen", 0, 0 );
        }
        else {load_answer ( source_of_command, "error:at$mrlen", 0, 0 );} 
    }
// Настройка снифа LIN
    temp = strstr( at_ptr, LSNF );
	if (temp) {
        ptr = temp;
        if ( *(ptr + 4) == '=' && *(ptr + 6) == ';' && (*(ptr + 5) == 0x30 || *(ptr + 5) == 0x31 ) ) {
            lin_snif_enable = *(ptr + 5) - 0x30;
            FM25_write_1 ( 1883, (unsigned int) lin_snif_enable );
            load_answer ( source_of_command, "ok:at$lsnf", 0, 0 );
        }
        else {load_answer ( source_of_command, "error:at$lsnf", 0, 0 );} 
    }

// Настройки температуры
    temp = strstr( at_ptr, TSET );
	if (temp) {
        ptr = temp;
        if ( *(ptr + 4) == '=' && *(ptr + 6) == ',' && (*(ptr + 9) == ',' && *(ptr + 12) == ',' && *(ptr + 15) == ';' ) ) {
            if ( apply_temperature_settings(temp) ) load_answer ( source_of_command, "ok:at$tset", 0, 0 );
        }
        else {load_answer ( source_of_command, "error:at$tset", 0, 0 );} 
    }
// Настройка заряда батареи
    temp = strstr( at_ptr, BCHRG );
	if (temp) {
        ptr = temp;
        if ( *(ptr + 5) == '=' && (*(ptr + 6) == 0x30 || (*(ptr + 6) == 0x31 )) && *(ptr + 7) == ';' ) {
            battery_charge_type = *(ptr + 6) - 0x30;
            FM25_write_1 ( 1886, (unsigned int) battery_charge_type );        
            load_answer ( source_of_command, "ok:at$bchrg", 0, 0 );
        }
        else {load_answer ( source_of_command, "error:at$bchrg", 0, 0 );} 
    }
// Запуск повторителя поворотов
    temp = strstr( at_ptr, RPTR );
	if (temp) {
        ptr = temp;
        if ( *(ptr + 4) == '=' && (*(ptr + 6) == ',' || (*(ptr + 8) == ',' )) && *(ptr + 12) == ';' ) {
            if (*(ptr + 5) == '1' ) {
                
                if ( BLINKRPTRTASKbits.start == 0 ) {
                    if ( get_blinkrptr_parameters ( ptr ) ) {
                        generate_content_of_message ( 64, 1 );
                        BLINKRPTRTASKbits.start = 1;
                        load_answer ( source_of_command, "ok:at$rptr", 0, 0 ); 
                    } else {load_answer ( source_of_command, "error:at$rptr", 0, 0 );}
                } else {load_answer ( source_of_command, "error:at$rptr", 0, 0 );} 
                
            } else {
                generate_content_of_message ( 65, 1 );
                BLINKRPTRTASKbits.BLINKRPTRTASK = 0;
                load_answer ( source_of_command, "ok:at$rptr", 0, 0 );
            }
        
            
        }
        else {load_answer ( source_of_command, "error:at$rptr", 0, 0 );} 
    }
// Запуск повторителя поворотов
    temp = strstr( at_ptr, LMDS );
	if (temp) {
        ptr = temp;
        if ( *(ptr + 4) == '=' && *(ptr + 7) == ';' ) {

            if ((*(ptr + 5) >= 0x30 && *(ptr + 5) <= 0x39) && *(ptr + 6) >= 0x30 && *(ptr + 6) <= 0x39) {
                unlock_message_off_timer = 0;
                unlock_message_off_timer = (*(ptr + 5) - 0x30) * 10 + (*(ptr + 6) - 0x30);
                FM25_write_1 ( 1902, (unsigned int) unlock_message_off_timer );
                unlock_message_off_timer = 0;
//                unlock_message_off_timer = (unsigned int) FM25_read_1 ( 1902 );
                load_answer ( source_of_command, "ok:at$lmds", 0, 0 );
            } else {load_answer ( source_of_command, "error:at$lmds", 0, 0 );}
            
        }
    }
    
// Настройка заряда батареи
    temp = strstr( at_ptr, RRFEN );
	if (temp) {
        ptr = temp;
        if ( *(ptr + 5) == '=' && (*(ptr + 6) == 0x30 || (*(ptr + 6) == 0x31 ) || (*(ptr + 6) == 0x32 )) && *(ptr + 7) == ';' ) {
            rf_reset_enable = *(ptr + 6) - 0x30;
            FM25_write_1 ( 1955, (unsigned int) rf_reset_enable );        
            load_answer ( source_of_command, "ok:at$rrfen", 0, 0 );
        }
        else {load_answer ( source_of_command, "error:at$rrfen", 0, 0 );} 
    }
    
    temp = strstr( at_ptr, MMSG );
	if (temp) {
        ptr = temp;
        if ( *(ptr + 4) == '=' && *(ptr + 10) == ';' ) {
            if ( get_ack_of_request ( temp ) ) {
                GETMEMMSGTASKbits.start = 1;
                load_answer ( source_of_command, "ok:at$mmsg", 0, 0 );
            } else {load_answer ( source_of_command, "error:at$mmsg", 0, 0 );}
        }
        else {load_answer ( source_of_command, "error:at$mmsg", 0, 0 );} 
    }    
// Включение датчика топлива LIN
    temp = strstr( at_ptr, FLEN );
	if (temp) {
        ptr = temp;
        if ( *(ptr + 4) == '=' && *(ptr + 6) == ';' && (*(ptr + 5) >= 0x30 && *(ptr + 5) <= 0x33 ) ) {
            fuel_sensor_enable = *(ptr + 5) - 0x30;
            FM25_write_1 ( 1917, (unsigned int) fuel_sensor_enable );
            load_answer ( source_of_command, "ok:at$flen", 0, 0 );
        }
        else {
            if (*(ptr + 4) == '?') {
                Nop();Nop();Nop();
//                fuel_level_lin = 12345;
                bin_2_bcd ((long ) fuel_level_lin);
                load_answer ( source_of_command, "max fuel=", &bin_2_bcd_buf[4], 1 );
            } else load_answer ( source_of_command, "error:at$flen", 0, 0 );
        } 
    }
// Порог напряжения для детектирования автозапуска
    temp = strstr( at_ptr, SEVT );
	if (temp) {
        ptr = temp;
        if ( *(ptr + 4) == '=' && *(ptr + 7) == ';' ) {
            temp = (int)convert_str_to_hex ( ptr + 5, 2 );
            if (temp > 0){
                start_engine_volt_trh = (unsigned char)temp;
                FM25_write_1 ( 1930, (unsigned char) start_engine_volt_trh );
                load_answer ( source_of_command, "ok:at$sevt", 0, 0 );
            }else load_answer ( source_of_command, "error:at$sevt", 0, 0 );
        }
        else load_answer ( source_of_command, "error:at$sevt", 0, 0 );
         
    }
//////////////////
#if defined (WBUS)
    temp = strstr( at_ptr, WBSW ); //WBUS CMD received 
    if (temp) {
        Nop();Nop();Nop();
        if (source_of_command == 3) source_of_command = 2;        
        ptr = temp;
        if ((*(ptr + 4) == '=') && (*(ptr + 9) == ';') && OUTbits.serv_flag == 0 ) {

                dur3 = get_rund_puls_duration ( ptr + 5 );
                dur3 = dur3 * 10; //time from STR to seconds in dur3
                if (WBSWTASKbits.start == 0) {
                        if ( dur3 != 0) {
                            WBSWTASKbits.start = 1;
                            WBSWTASKbits.counter = dur3;
                            generate_content_of_message ( 51, 1 );
                            load_answer ( source_of_command, "ok:at$wbsw", 0, 0 );
                        } else load_answer ( source_of_command, "error:at$wbsw", 0, 0 );
                    } else {
                        if ( dur3 == 0) {
                            WBSWTASKbits.stop = 1;
                            load_answer ( source_of_command, "ok:at$wbsw", 0, 0 );                            
                  
                        } else load_answer ( source_of_command, "error:at$wbsw", 0, 0 );                
                    }
                
        } else load_answer ( source_of_command, "error:at$wbsw", 0, 0 );
    } 
    // clear webasto errors through WBUS            
    temp = strstr( at_ptr, DRSTW );
    if (temp) {
       ptr = temp;
       if (  *(ptr + 5) == ';' ) {
        Nop();Nop();Nop();
        DRSTWTASKbits.start = 1; //start  DRSTW TASK
        load_answer ( source_of_command, "ok:at$drstw", 0, 0 );
       }
    }
    // request webasto errors through WBUS
    temp = strstr( at_ptr, DVRQW );
	if (temp) {
       ptr = temp;
       if (  *(ptr + 5) == ';' ) {
        Nop();Nop();Nop();
        DVRQWTASKbits.start = 1; //start  DVRQW TASK
        wbus_err_crc++; //corrupt old CRC - for garantee send errors
        load_answer ( source_of_command, "ok:at$dvrqw", 0, 0 );
       }
}           
#endif
    //////////////////
    temp = strstr( at_ptr, WBSA );
	if (temp) {
        Nop();Nop();Nop();
        if (source_of_command == 3) source_of_command = 2;        
        ptr = temp;
        if ((*(ptr + 4) == '=') && (*(ptr + 21) == ';') && ((*(ptr + 5) == '1')||(*(ptr + 5) == '2')) && OUTbits.serv_flag == 0 ) {

                dur1 = get_rund_puls_duration ( ptr + 7 );
                dur2 = get_rund_puls_duration ( ptr + 12 );
                Nop();Nop();Nop();                
                dur3 = get_rund_puls_duration ( ptr + 17 );
                dur1 = (dur1 + 50) / 100;
                dur2 = (dur2 + 50) / 100;
                dur3 = dur3 * 10;
                if (*(ptr + 5) == '1') {
                    if (WBSATASKbits.start == 0) {
                        if ( dur3 != 0) {
                            WBSATASKbits.start = 1;
                            WBSATASKbits.counter = dur3;
                            generate_content_of_message ( 51, 1 );
                            load_answer ( source_of_command, "ok:at$wbsa", 0, 0 );
                        } else load_answer ( source_of_command, "error:at$wbsa", 0, 0 );
                    } else {
                        if ( dur3 == 0) {
                            WBSATASKbits.stop = 1;
                            load_answer ( source_of_command, "ok:at$wbsa", 0, 0 );                            
//                            WBSATASKbits.WBSATASK = 0;
//                            if (OUTFUNCbits.pin15 == 0x0C) L_OUT = 0;
//                            if (OUTFUNCbits.pin9 == 0x0C)  AUTO_START = 0;
//                            generate_content_of_message ( 52, 1 );                            
                        } else load_answer ( source_of_command, "error:at$wbsa", 0, 0 );                
                    }
                }
                if (*(ptr + 5) == '2') {    
                    if (WBSATASK2bits.start == 0) {
                        if ( dur3 != 0) {
                            WBSATASK2bits.start = 1;
                            WBSATASK2bits.start_puls = dur1;
                            WBSATASK2bits.stop_pulse = dur2;
                            WBSATASK2bits.counter = dur3;
                            generate_content_of_message ( 51, 1 );
                            load_answer ( source_of_command, "ok:at$wbsa", 0, 0 );
                        } else load_answer ( source_of_command, "error:at$wbsa", 0, 0 );
                    } else {
                        if ( dur3 == 0) {
                            WBSATASK2bits.stop = 1;
                            load_answer ( source_of_command, "ok:at$wbsa", 0, 0 );
                        } else load_answer ( source_of_command, "error:at$wbsa", 0, 0 );                
                    }
                }
            
        } else load_answer ( source_of_command, "error:at$wbsa", 0, 0 );

    }    

    temp = strstr( at_ptr, INPOL );
	if (temp) {
        Nop();Nop();Nop();
        ptr = temp;
        if (*(ptr + 5) == '=' && (*(ptr + 7) == ';')) {
            res = (int)convert_str_to_hex ( ptr + 6, 1 );
            if ( res != -1 ) {
                INPPOLbits.INPPOL = (unsigned char)res;
                FM25_write_1( 1933, (unsigned int) INPPOLbits.INPPOL ); //
                load_answer ( source_of_command, "ok:at$inpol", 0, 0 );
            } else  load_answer ( source_of_command, "error:at$inpol", 0, 0 ); 
            
        } else  load_answer ( source_of_command, "error:at$inpol", 0, 0 );
    }
# if defined (MCP23S08)    
    temp = strstr( at_ptr, OPOL );
	if (temp) {
        Nop();Nop();Nop();
        ptr = temp;
        if (*(ptr + 4) == '=' && (*(ptr + 7) == ';')) {
            res = (int)convert_str_to_hex ( ptr + 5, 2 );
            if ( res != -1 ) {
                dig1 = OUTPOLbits.OUTPOL;
                OUTPOLbits.OUTPOL = (unsigned char)res;
                FM25_write_1( 1968, (unsigned char)OUTPOLbits.OUTPOL ); //
                apply_outputs_polarity ( (unsigned char)dig1 );
                load_answer ( source_of_command, "ok:at$opol", 0, 0 );
            } else  load_answer ( source_of_command, "error:at$opol", 0, 0 ); 
            
        } else  load_answer ( source_of_command, "error:at$opol", 0, 0 );
    }
# endif    
    if ( strstr( at_ptr, IMSI ) ) { 
        GETIMSIbits.start = 1;
        GETIMSIbits.sours_of_command = source_of_command;
        load_answer ( source_of_command, "ok:at$imsi", 0, 0 );
    }

    temp = strstr( at_ptr, ASOP );
	if (temp) {
        Nop();Nop();Nop();
        if (source_of_command == 3) source_of_command = 2;        
        ptr = temp;
        if ((*(ptr + 4) == '=')&&(*(ptr + 9) == ',')&&(*(ptr + 12) == ';')) {
            Nop();Nop();Nop();
                dur1 = get_rund_puls_duration ( ptr + 5 );
                dur3 = get_runp_puls_duration ( ptr + 10 );
                dur1 = (dur1 + 50) / 100;
                dur3 = dur3 * 10;
                PULSAFTERAUOTORUNPRMSbits.puls_duration = (unsigned char) dur1;
                PULSAFTERAUOTORUNPRMSbits.delay = (unsigned int) dur3;
                FM25_write_2( 1942, (unsigned int) PULSAFTERAUOTORUNPRMSbits.PULSAFTERAUOTORUNPRMS );
                load_answer ( source_of_command, "ok:at$asop", 0, 0 );
        } else load_answer ( source_of_command, "error:at$asop", 0, 0 );
    }
    temp = strstr( at_ptr, CLBR );
	if (temp) {
        ptr = temp;
        if ( *(ptr + 4) == '=' && *(ptr + 9) == ',' && *(ptr + 14) == ',' && *(ptr + 19) == ';' ) {
            Nop();Nop();Nop();
            if ( set_calibration_coeffitients ( temp ) > 0 ) { load_answer ( source_of_command, "ok:at$clbr", 0, 0 );} 
            else load_answer ( source_of_command, "error:at$clbr", 0, 0 );
        } else load_answer ( source_of_command, "error:at$clbr", 0, 0 );
    }

    temp = strstr( at_ptr, TLTMR );
	if (temp) {
        Nop();Nop();Nop();
        ptr = temp;
        if ((*(ptr + 5) == '=') && (*(ptr + 7) == ';')) {//&&(STARTENGINESbits.start == 0)
            Nop();Nop();Nop();
            temp = 0;
            temp = temp + (*(ptr + 6) - 0x30);
            t_lights_off_timeout = (unsigned char)(temp * 10);
            FM25_write_1( 1946, t_lights_off_timeout );
            load_answer ( source_of_command, "ok:at$tltmr", 0, 0 );
        } else load_answer ( source_of_command, "error:at$tltmr", 0, 0 ); 
    }
    temp = strstr( at_ptr, DFLT );
	if (temp) {
        if ( dflt_flag == 0 ) {
            Nop();Nop();Nop();
            FM25_write_1( 1932, 1 );
            asm volatile ("reset");
        } else load_answer ( source_of_command, "error:at$dflt", 0, 0 );
    } 
    
    temp = strstr( at_ptr, DSIG );
	if (temp) {
        ptr = temp;
        if ( *(ptr + 4) == '=' && *(ptr + 13) == ';' ) {
            Nop();Nop();Nop();
            temp2 = (long long)convert_str_to_hex ( ptr + 5, 8 );
            if ( temp2 >= 0 ) {
                DIAGNSIGNALSbits.DIAGNSIGNALS = (unsigned long) temp2;
                FM25_write_4( 1964, (unsigned long) DIAGNSIGNALSbits.DIAGNSIGNALS );
                load_answer ( source_of_command, "ok:at$dsig", 0, 0 );
            } else load_answer ( source_of_command, "error:at$dsig", 0, 0 );
        } else load_answer ( source_of_command, "error:at$dsig", 0, 0 );
    }    

//#if defined (WBUS)
//    temp = strstr( at_ptr, WBSW ); //WBUS CMD received 
//    if (temp) {
//        Nop();Nop();Nop();
//        if (source_of_command == 3) source_of_command = 2;        
//        ptr = temp;
//        if ((*(ptr + 4) == '=') && (*(ptr + 9) == ';') && OUTbits.serv_flag == 0 ) {
//
//                dur3 = get_rund_puls_duration ( ptr + 5 );
//                dur3 = dur3 * 10; //time from STR to seconds in dur3
//                if (WBSWTASKbits.start == 0) {
//                        if ( dur3 != 0) {
//                            WBSWTASKbits.start = 1;
//                            WBSWTASKbits.counter = dur3;
//                            generate_content_of_message ( 51, 1 );
//                            load_answer ( source_of_command, "ok:at$wbsw", 0, 0 );
//                        } else load_answer ( source_of_command, "error:at$wbsw", 0, 0 );
//                    } else {
//                        if ( dur3 == 0) {
//                            WBSWTASKbits.stop = 1;
//                            load_answer ( source_of_command, "ok:at$wbsw", 0, 0 );                            
//                  
//                        } else load_answer ( source_of_command, "error:at$wbsw", 0, 0 );                
//                    }
//                
//        } else load_answer ( source_of_command, "error:at$wbsw", 0, 0 );
//    }  
//#endif


# if defined (MCP23S08)

    temp = strstr( at_ptr, OPLS );
	if (temp) {
        ptr = temp;
        if ( *(ptr + 4) == '=' && *(ptr + 9) == ',' && *(ptr + 14) == ',' && *(ptr + 17) == ','  &&  *(ptr + 19) == ';' ) {
            Nop();Nop();Nop();
            temp1 = (long)convert_str_to_hex ( ptr + 5, 4 );
            temp2 = (long long)convert_str_to_hex ( ptr + 10, 4 );
            dig1 = (int)convert_str_to_hex ( ptr + 15, 2 );
            dig2 = (int)convert_str_to_hex ( ptr + 18, 1 );
            if ( temp2 >= 0 && temp1 >= 0 && dig1 >= 0 && dig2 > 0 ) {
                OUTPLSTASCKbits.pulse = (unsigned int) temp1;
                OUTPLSTASCKbits.pause = (unsigned int) temp2;
                OUTPLSTASCKbits.num = (unsigned char) dig1;
                OUTPLSTASCKbits.output_number = (unsigned char) dig2;
                OUTPLSTASCKbits.start = 1;
                load_answer ( source_of_command, "ok:at$opls", 0, 0 );
            } else {
                
                
                
                load_answer ( source_of_command, "error:at$opls", 0, 0 );
            }
        } else load_answer ( source_of_command, "error:at$opls", 0, 0 );
    }    
    temp = strstr( at_ptr, IORST );
	if (temp) {
        ptr = temp;
        if ( *(ptr + 5) == ';' && gps_reset_flag == 0 ) {
            Nop();Nop();Nop();
            io_reset_flag = 1;
            load_answer ( source_of_command, "ok:at$iorst", 0, 0 );
        } else load_answer ( source_of_command, "error:at$iorst", 0, 0 );
    }
# endif

    temp = strstr( at_ptr, FRTR );
	if (temp) {
        fire_rel_transaction_flag = 1;
        load_answer ( source_of_command, "ok:at$frtr", 0, 0 );
    }
    temp = strstr( at_ptr, TLST );
	if (temp) {
        sent_transponed_list_flag = 1;
        load_answer ( source_of_command, "ok:at$tlst", 0, 0 );
    }
    temp = strstr( at_ptr, TEN );
	if (temp) {
        ptr = temp;
        if (*(ptr + 5) == ';') {
            temp = *(ptr + 4);
                if ((temp >= 0x31)||(temp <= 0x35)) {
                    temp = temp - 0x30;
                    enable_transponder ( (unsigned char) temp );
                    load_answer ( source_of_command, "ok:at$ten", 0, 0 );
                } else load_answer ( source_of_command, "error:at$ten", 0, 0 );
        } else load_answer ( source_of_command, "error:at$ten", 0, 0 );
    }
    temp = strstr( at_ptr, ORQEN );
	if (temp) {
        ptr = temp;
        if (*(ptr + 5) == '=' && *(ptr + 8) == ';') {
            temp = (int)convert_str_to_hex ( ptr + 6, 2 );
                if (temp >= 0) {
                    OBDREQENbits.OBDREQEN = (unsigned char)temp;
                    FM25_write_1( 1969, OBDREQENbits.OBDREQEN );
                    load_answer ( source_of_command, "ok:at$orqen", 0, 0 );
                } else load_answer ( source_of_command, "error:at$orqen", 0, 0 );
        } else load_answer ( source_of_command, "error:at$orqen", 0, 0 );
    }
    temp = strstr( at_ptr, CCOF );
	if (temp) {
        ptr = temp;
        if (*(ptr + 4) == '=' && *(ptr + 6) == ';') {
            temp = *(ptr + 5) - 0x30;
                if ( temp <= 4 && temp >= 0 ) {
                    filt_crash_first_entrance = 0;
                    crash_filt_cutoff_frq = (unsigned char)temp;
                    temp_byte = FM25_read_1( 1970 );
                    temp_byte = temp_byte & 0xF0;
                    temp_byte = temp_byte + crash_filt_cutoff_frq;
                    FM25_write_1( 1970, temp_byte );
                    load_answer ( source_of_command, "ok:at$ccof", 0, 0 );
                } else load_answer ( source_of_command, "error:at$ccof", 0, 0 );
        } else load_answer ( source_of_command, "error:at$ccof", 0, 0 );
    } 
    temp = strstr( at_ptr, CFRQ );
	if (temp) {
        ptr = temp;
        if (*(ptr + 4) == '=' && *(ptr + 6) == ';') {
            temp = *(ptr + 5) - 0x30;
                if ( temp <= 3 && temp > 0 ) {
                    acc_sampling_frequency = (unsigned char)temp;
                    temp_byte = FM25_read_1( 1970 );
                    temp_byte = temp_byte & 0x0F;
                    temp_byte = temp_byte + (acc_sampling_frequency << 4);
                    apply_acc_sampling_frequency ( (unsigned char)acc_sampling_frequency );
                    FM25_write_1( 1970, temp_byte );
                    load_answer ( source_of_command, "ok:at$cfrq", 0, 0 );
                } else load_answer ( source_of_command, "error:at$cfrq", 0, 0 );
        } else load_answer ( source_of_command, "error:at$cfrq", 0, 0 );
    } 
    temp = strstr( at_ptr, SRVR );
	if (temp) {
        ptr = temp;
        if (*(ptr + 4) == '=' && *(ptr + 6) == ';') {
            temp = *(ptr + 5) - 0x30;
                if ( temp >= 0 && temp <= 1 ) {
                    fire_rel_transaction_flag = 1;
                    if (temp == 1) RELTRANSFLGSbits.rel_only_serv_on = 1; else RELTRANSFLGSbits.rel_only_serv_off = 1;
                    srvr_flag = (unsigned char)temp;
                    FM25_write_1( 1971, srvr_flag );
                    load_answer ( source_of_command, "ok:at$srvr", 0, 0 );
                } else load_answer ( source_of_command, "error:at$srvr", 0, 0 );
        } else load_answer ( source_of_command, "error:at$srvr", 0, 0 );
    } 
    temp = strstr( at_ptr, TLTR );
	if (temp) {
        tilt_detection ( 1 );
        load_answer ( source_of_command, "ok:at$tltr", 0, 0 );
    }
    temp = strstr( at_ptr, SLPT );
	if (temp) {
        ptr = temp;
        if (*(ptr + 4) == '=' && *(ptr + 7) == ';') {
            temp = (int) convert_str_to_hex ( ptr + 5, 2 );
                if ( temp >= 5 && temp <= 30 ) {
                    sleep_timer = (unsigned int)temp * 600;
                    FM25_write_1( 1972, (unsigned char)temp );
                    load_answer ( source_of_command, "ok:at$slpt", 0, 0 );
                } else load_answer ( source_of_command, "error:at$slpt", 0, 0 );
        } else load_answer ( source_of_command, "error:at$slpt", 0, 0 );
    }     
    temp = strstr( at_ptr, DDUN );
	if (temp) {
        ptr = temp;
        if (*(ptr + 6) == ';') {
            temp = *(ptr + 5);
                if ((temp == 0x30)||(temp == 0x31)) {
                    disarm_by_doors_unlock_enable = temp - 0x30;
                    FM25_write_1( 1974, (unsigned int) disarm_by_doors_unlock_enable );
                    load_answer ( source_of_command, "ok:at$ddun", 0, 0 );
                } else load_answer ( source_of_command, "error:at$ddun", 0, 0 );
        } else load_answer ( source_of_command, "error:at$ddun", 0, 0 );
    }
    temp = strstr( at_ptr, SAEN );
	if (temp) {
        ptr = temp;
        if (*(ptr + 4) == '=' && *(ptr + 6) == ',' &&  *(ptr + 8) == ',' && *(ptr + 10) == ';') {
            temp = *(ptr + 5);
                if ((*(ptr + 5) == 0x30)||(*(ptr + 5) == 0x31)&&(*(ptr + 7) == 0x30)||(*(ptr + 7) == 0x31)&&(*(ptr + 9) >= 0x31)&&(*(ptr + 7) <= 0x39)) {
                    SECONDAUTHORbits.on = *(ptr + 5) - 0x30;
                    SECONDAUTHORbits.type = 0;// *(ptr + 7) - 0x30;
                    SECONDAUTHORbits.num = *(ptr + 9) - 0x30;
                    FM25_write_1( 1977, (unsigned int) SECONDAUTHORbits.SECONDAUTHOR );
                    load_answer ( source_of_command, "ok:at$saen", 0, 0 );
                } else load_answer ( source_of_command, "error:at$saen", 0, 0 );
        } else load_answer ( source_of_command, "error:at$saen", 0, 0 );
    }
    
    temp = strstr( at_ptr, RPRD );
	if (temp) {
        FM25_write_1 ( 1931, 1 );
        asm volatile ( "reset" );
    }
    temp = strstr( at_ptr, SPRD );
	if (temp) {
        if (PRODERRORSbits.batt == 1) {
            PRODERRORSbits.batt = 0;
            if (PRODERRORSbits.PRODERRORS == 0) {
                FM25_write_1 ( 1931, 0 );
                asm volatile ( "reset" );
            }
        }
    }
    temp = strstr( at_ptr, FDOTP );
	if (temp) {
        ptr = temp;
        if (*(ptr + 5) == '=' && *(ptr + 7) == ';') {
            temp = *(ptr + 6);
                if ((*(ptr + 6) == 0x30)||(*(ptr + 6) == 0x31)) {
                    fake_doors_open_type = *(ptr + 6) - 0x30;
                    FM25_write_1( 1981, (unsigned int) fake_doors_open_type );
                    load_answer ( source_of_command, "ok:at$fdotp", 0, 0 );
                } else load_answer ( source_of_command, "error:at$fdotp", 0, 0 );
        } else load_answer ( source_of_command, "error:at$fdotp", 0, 0 );
    }

    
# if defined (DIRECTTX)
    temp = strstr( at_ptr, DTRNS );
	if (temp) {
        Nop();Nop();Nop();
        ptr = temp;
            if (*(ptr + 5) == '=' && *(ptr + 7) == ';') {
                if (*(ptr + 6) == 0x30) {
 //                   CHANGE_STATE[1] = READY;// READY
//                    Si4461_CMD_stream ( CHANGE_STATE, 2 );
                    RFRESETbits.start = 1;
                    load_answer ( source_of_command, "ok:at$dtren", 0, 0 );
                } else {
                    if (*(ptr + 6) == 0x31) {
                        CHANGE_STATE[1] = TX_STATE;// READY
                        Si4461_CMD_stream ( CHANGE_STATE, 2 );
//                        RFRESETbits.start = 1;
                        load_answer ( source_of_command, "ok:at$dtren", 0, 0 );
                    } else load_answer ( source_of_command, "error:at$dtren", 0, 0 );
            }
        } else load_answer ( source_of_command, "error:at$dtren", 0, 0 );
    }    
# endif    
/*
    temp = strstr( at_ptr, CSNF );
	if (temp) {
        unsigned long id;
        unsigned char u;
        ptr = temp;
        if (*(ptr + 4) == '=' && *(ptr + 13) == ';') {
            u = *(ptr + 5);
            ID_to_sniff = 0; u = 0;
            u = get_nibble_from_str ( ptr );
            id = u;
            u = get_nibble_from_str ( ptr + 1 );
            id = (id << 4) + u;
            u = get_nibble_from_str ( ptr + 2 );
            id = (id << 4) + u;
            u = get_nibble_from_str ( ptr + 3 );
            id = (id << 4) + u;
            u = get_nibble_from_str ( ptr + 4 );
            id = (id << 4) + u;
            u = get_nibble_from_str ( ptr + 5 );
            id = (id << 4) + u;
            u = get_nibble_from_str ( ptr + 6 );
            id = (id << 4) + u;
            u = get_nibble_from_str ( ptr + 7 );
            id = (id << 4) + u;
            ID_to_sniff = id;
            ecan1WriteRxAcptFilter( (int)0x0A, (long)id, 1, 15, 0);
            load_answer ( source_of_command, "ok:at$csnf", 0, 0 );
        } else load_answer ( source_of_command, "error:at$csnf", 0, 0 );
        } else load_answer ( source_of_command, "error:at$csnf", 0, 0 );
*/        
}
void apply_acc_sampling_frequency ( temp ) {

    T8CON = 0x0010; // 12.8us
    TMR8 = 0;
    IEC3bits.T8IE = 0;
    
    switch (temp) {
        
        case 1: // 100Hz
            PR8 = 25000; //25000 10ms; 6250 2.5ms  2500 1ms
            number_of_samples = 1;
            ACC_spi_R_W (0x00 | 0x00 | 0x20, 0x2F); //write cntrl_reg1 0x2F - 100Hz,
        break;
            
        case 2: // 400Hz
            PR8 = 6250; //6250 2.5ms
            number_of_samples = 4;
            ACC_spi_R_W (0x00 | 0x00 | 0x20, 0x37); //write cntrl_reg1 0x37 - 400Hz
        break;
            
        case 3: // 1000Hz
            PR8 = 2500; //2500 1ms 
            number_of_samples = 10;
            ACC_spi_R_W (0x00 | 0x00 | 0x20, 0x3F); //write cntrl_reg1 0x3F - 1000Hz
        break;
        
        default:
            break;
    }
    
    T8CONbits.TON = 1; // 12.8us
    TMR8 = 0;
    IEC3bits.T8IE = 1;    
    
}
void enable_transponder ( unsigned char num ) {
    
    switch ( num ) {
        
        case 1:
            FM25_write_1( 32, 1 );
            Transp_flags[1] = 1;
        break;

        case 2:
            FM25_write_1( 33, 2 );
            Transp_flags[2] = 2;
        break;

        case 3:
            FM25_write_1( 34, 3 );
            Transp_flags[3] = 3;
        break;        

        case 4:
            FM25_write_1( 35, 4 );
            Transp_flags[4] = 4;
        break;

        case 5:
            FM25_write_1( 36, 5 );
            Transp_flags[5] = 5;
        break;
        
        default: 
        break;
        
    }
//	Transp_flags[0] = 0;
//	Transp_flags[1] = FM25_read_1( 32 ); Transp_flags[2] = FM25_read_1( 33 ); // 1-я, 2-я
//	Transp_flags[3] = FM25_read_1( 34 ); Transp_flags[4] = FM25_read_1( 35 ); // 3-я, 4-я
//	Transp_flags[5] = FM25_read_1( 36 ); Transp_flags[6] = FM25_read_1( 37 ); // 5-я, 6-я     
}
int set_calibration_coeffitients ( volatile char *ptr ) {

    volatile unsigned char x_coeff, y_coeff, z_coeff;//, i;// coeff;
    //int temp;
    ptr = ptr + 5;
//    for (i = 5; i < 19;  i ++) {
//        if (*ptr != '1') ;
//        else {
//            if (*ptr != '0') ;
//            else {
//                if (*ptr != ',') ;
//                else return 0;
//            }
//        }
//        ptr ++;
//    }
    
    x_coeff = 0;
    x_coeff =           *(ptr++) - 0x30; x_coeff = x_coeff << 1;
    x_coeff = x_coeff + *(ptr++) - 0x30; x_coeff = x_coeff << 1;
    x_coeff = x_coeff + *(ptr++) - 0x30; x_coeff = x_coeff << 1;
    x_coeff = x_coeff + *(ptr++) - 0x30; 
    ptr ++;

    y_coeff = 0;
    y_coeff =           *(ptr++) - 0x30; y_coeff = y_coeff << 1;
    y_coeff = y_coeff + *(ptr++) - 0x30; y_coeff = y_coeff << 1;
    y_coeff = y_coeff + *(ptr++) - 0x30; y_coeff = y_coeff << 1;
    y_coeff = y_coeff + *(ptr++) - 0x30; 
    ptr ++;    

    z_coeff = 0;
    z_coeff =           *(ptr++) - 0x30; z_coeff = z_coeff << 1;
    z_coeff = z_coeff + *(ptr++) - 0x30; z_coeff = z_coeff << 1;
    z_coeff = z_coeff + *(ptr++) - 0x30; z_coeff = z_coeff << 1;
    z_coeff = z_coeff + *(ptr++) - 0x30; 

    
//    temp =  (int)convert_str_to_hex ( ptr + 5, 2 );
//    if ( temp < 0 ) return 0;
//    x_coeff = (unsigned char) temp;
//    
//    temp =  (int)convert_str_to_hex ( ptr + 8, 2 );
//    if ( temp < 0 ) return 0;
//    y_coeff = (unsigned char) temp;
//
//    temp =  (int)convert_str_to_hex ( ptr + 11, 2 );
//    if ( temp < 0 ) return 0;
//    z_coeff = (unsigned char) temp;


    m11 = 0; m12 = 0; m13 = 0;
    if ((x_coeff & 0x04) != 0) { if ( (x_coeff & 0x08) == 0 ) m11 = 1.0; else m11 = -1.0; }
    if ((x_coeff & 0x02) != 0) { if ( (x_coeff & 0x08) == 0 ) m12 = 1.0; else m12 = -1.0; }        
    if ((x_coeff & 0x01) != 0) { if ( (x_coeff & 0x08) == 0 ) m13 = 1.0; else m13 = -1.0; }

    m21 = 0; m22 = 0; m23 = 0;
    if ((y_coeff & 0x04) != 0) { if ( (y_coeff & 0x08) == 0 ) m21 = 1.0; else m21 = -1.0; }
    if ((y_coeff & 0x02) != 0) { if ( (y_coeff & 0x08) == 0 ) m22 = 1.0; else m22 = -1.0; }        
    if ((y_coeff & 0x01) != 0) { if ( (y_coeff & 0x08) == 0 ) m23 = 1.0; else m23 = -1.0; }

    m31 = 0; m32 = 0; m33 = 0;
    if ((z_coeff & 0x04) != 0) { if ( (z_coeff & 0x08) == 0 ) m31 = 1.0; else m31 = -1.0; }
    if ((z_coeff & 0x02) != 0) { if ( (z_coeff & 0x08) == 0 ) m32 = 1.0; else m32 = -1.0; }        
    if ((z_coeff & 0x01) != 0) { if ( (z_coeff & 0x08) == 0 ) m33 = 1.0; else m33 = -1.0; }        
        
    cosg = 1.0; sing = 0.0;
    invertion_flag = 0;
    AUTOCALSTATUSbits.staticcal = 1;
    AUTOCALSTATUSbits.finished  = 1;
    save_autocal_results (1);
    
    return 1;
}
int get_ack_of_request ( char *ptr ) {

    volatile unsigned long temp;
    
    if (*(ptr + 5) < 0x30 || *(ptr + 5) > 0x39) return 0;
    if (*(ptr + 6) < 0x30 || *(ptr + 6) > 0x39) return 0;
    if (*(ptr + 7) < 0x30 || *(ptr + 7) > 0x39) return 0;
    if (*(ptr + 8) < 0x30 || *(ptr + 8) > 0x39) return 0;
    if (*(ptr + 9) < 0x30 || *(ptr + 9) > 0x39) return 0;
    
    temp = 0;
    
    temp = (unsigned long)(*(ptr + 5) - 0x30);
    temp = temp * 10;
    temp = temp + (unsigned long)(*(ptr + 6) - 0x30);
    temp = temp * 10;
    temp = temp + (unsigned long)(*(ptr + 7) - 0x30);
    temp = temp * 10;
    temp = temp + (unsigned long)(*(ptr + 8) - 0x30);
    temp = temp * 10;
    temp = temp + (unsigned long)(*(ptr + 9) - 0x30);
    
    if ( temp > 32767 ) return 0;
    
    GETMEMMSGTASKbits.addr = (unsigned int) temp;
    
return 1;    
}
int get_blinkrptr_parameters ( char *ptr ) {
//char temp;

    if ( *(ptr + 7) < 0x30 || *(ptr + 7) > 0x31 ) return 0;
    BLINKRPTRTASKbits.type = *(ptr + 7) - 0x30;
    
    BLINKRPTRTASKbits.timer = 0;
    if ( *(ptr + 9) < 0x30 || *(ptr + 9) > 0x33 ) return 0;
    BLINKRPTRTASKbits.timer = (unsigned int)(*(ptr + 9) - 0x30); 
    BLINKRPTRTASKbits.timer = BLINKRPTRTASKbits.timer * 10;
    
    if ( *(ptr + 10) < 0x30 || *(ptr + 10) > 0x39 ) return 0;
    BLINKRPTRTASKbits.timer = (unsigned int)(*(ptr + 10) - 0x30) + BLINKRPTRTASKbits.timer; 
    BLINKRPTRTASKbits.timer = BLINKRPTRTASKbits.timer * 10;

    if ( *(ptr + 11) < 0x30 || *(ptr + 11) > 0x39 ) return 0;
    BLINKRPTRTASKbits.timer = (unsigned int)(*(ptr + 11) - 0x30) + BLINKRPTRTASKbits.timer; 
    BLINKRPTRTASKbits.timer = BLINKRPTRTASKbits.timer * 10;    
    
return 1;    
}
int apply_temperature_settings(unsigned char *ptr) {

    char temp, temp1, temp2, temp3, temp4;
    
    temp = 0;
    temp = (char)convert_str_to_hex ( ptr + 5, 1 );
    if (temp < 0 || temp > 1) return 0;
    temp1 = temp;
    
    temp2 = 0;
    temp = (char)convert_str_to_hex ( ptr + 7, 1 ); 
    if (temp < 0) return 0;
    temp2 = temp;
    temp = (char)convert_str_to_hex ( ptr + 8, 1 );
    if (temp < 0) return 0;
    temp2 = (temp2 << 4) + temp;

    temp3 = 0;
    temp = (char)convert_str_to_hex ( ptr + 10, 1 ); 
    if (temp < 0) return 0;
    temp3 = temp;
    temp = (char)convert_str_to_hex ( ptr + 11, 1 );
    if (temp < 0) return 0;
    temp3 = (temp3 << 4) + temp;
    
    temp4 = 0;
    temp = (char)convert_str_to_hex ( ptr + 13, 1 ); 
    if (temp < 0) return 0;
    temp4 = temp;
    temp = (char)convert_str_to_hex ( ptr + 14, 1 );
    if (temp < 0) return 0;
    temp4 = (temp4 << 4) + temp;   

    TEMPERATURESETbits.enable = temp1;
    TEMPERATURESETbits.delta1 = temp2;
    TEMPERATURESETbits.delta2 = temp3;
    temperatura_correct_timer_setting = temp4;
    FM25_write_2 ( 1884, (unsigned int) TEMPERATURESETbits.TEMPERATURESET );
    FM25_write_1 ( 1945, (unsigned int) temperatura_correct_timer_setting );
    
return 1;    
}
int save_functions_of_outputs_setting (unsigned char *ptr) {

    int  byte0, byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8;
    
    if ( *(ptr + 7)  != ',' || *(ptr + 10)  != ',' || *(ptr + 13) != ',' || *(ptr + 16) != ',' || *(ptr + 19) != ',' || 
         *(ptr + 22) != ',' || *(ptr + 25) != ',' || *(ptr + 28) != ';' ) return 0;
    

    byte0 = (int)convert_str_to_hex ( ptr + 5, 2 );
    if (byte0 < 0) return 0;
    byte1 = (int)convert_str_to_hex ( ptr + 8, 2 );
    if (byte1 < 0) return 0;
    byte2 = (int)convert_str_to_hex ( ptr + 11, 2 );
    if (byte2 < 0) return 0;
    byte3 = (int)convert_str_to_hex ( ptr + 14, 2 );
    if (byte3 < 0) return 0;
    byte4 = (int)convert_str_to_hex ( ptr + 17, 2 );
    if (byte4 < 0) return 0;
    byte5 = (int)convert_str_to_hex ( ptr + 20, 2 );
    if (byte5 < 0) return 0;
    byte6 = (int)convert_str_to_hex ( ptr + 23, 2 );
    if (byte6 < 0) return 0;
    byte7 = (int)convert_str_to_hex ( ptr + 26, 2 );
    if (byte7 < 0) return 0;

    OUTFUNCbits.pin1  = byte0;
    OUTFUNCbits.pin2  = byte1;
    OUTFUNCbits.pin8  = byte2;
    OUTFUNCbits.pin9  = byte3;
    OUTFUNCbits.pin10 = byte4;
    OUTFUNCbits.pin12 = byte5;
    OUTFUNCbits.pin13 = byte6;
    OUTFUNCbits.pin15 = byte7;

    FM25_write_8 ( 1739, (unsigned long long) OUTFUNCbits.OUTFUNC );
       
    
return 1;    
}
int save_functions_of_inputs_setting (unsigned char *ptr) {

    int  byte0, byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8;
    
    if ( *(ptr + 7)  != ',' || *(ptr + 10)  != ',' || *(ptr + 13) != ',' || *(ptr + 16) != ',' || *(ptr + 19) != ',' || 
         *(ptr + 22) != ',' || *(ptr + 25) != ',' || *(ptr + 28) != ';' ) return 0;
    

    byte0 = (int)convert_str_to_hex ( ptr + 5, 2 );
    if (byte0 < 0) return 0;
    byte1 = (int)convert_str_to_hex ( ptr + 8, 2 );
    if (byte1 < 0) return 0;
    byte2 = (int)convert_str_to_hex ( ptr + 11, 2 );
    if (byte2 < 0) return 0;
    byte3 = (int)convert_str_to_hex ( ptr + 14, 2 );
    if (byte3 < 0) return 0;
    byte4 = (int)convert_str_to_hex ( ptr + 17, 2 );
    if (byte4 < 0) return 0;
    byte5 = (int)convert_str_to_hex ( ptr + 20, 2 );
    if (byte5 < 0) return 0;
    byte6 = (int)convert_str_to_hex ( ptr + 23, 2 );
    if (byte6 < 0) return 0;
    byte7 = (int)convert_str_to_hex ( ptr + 26, 2 );
    if (byte7 < 0) return 0;

    INFUNCbits.pin1  = byte0;
    INFUNCbits.pin2  = byte1;
    INFUNCbits.pin8  = byte2;
    INFUNCbits.pin9  = byte3;
    INFUNCbits.pin10 = byte4;
    INFUNCbits.pin12 = byte5;
    INFUNCbits.pin13 = byte6;
    INFUNCbits.pin15 = byte7;

    FM25_write_8 ( 1956, (unsigned long long) INFUNCbits.INFUNC );
       
    
return 1;    
}
int save_fuel_equation_settings (unsigned char *ptr) {
    int temp1, temp2; long long temp3;    
    
    temp1 = (int)convert_str_to_hex ( ptr + 4, 4 ); // номер запроса
    if (temp1 <= 0) return -1;
    
    temp2 = (int)convert_str_to_hex ( ptr + 9, 4 ); // номер кана
    if (temp2 < 0) return -1;

    temp3 = (long long)convert_str_to_hex ( ptr + 14, 4 ); // длина сообщения
    if (temp3 < 0) return -1;
    
    FEQUbits.a = (unsigned int) temp1;
    FEQUbits.b = (unsigned int) temp2;
    FEQUbits.c = (int) temp3;
    
    FM25_write_8( 1918, (unsigned long long) FEQUbits.FEQU );
    
return 1;    
}
int save_lock_control_settings ( unsigned char *ptr, unsigned char command_type ) {
    
    int temp1, temp2, temp3;
    long temp4;
    long temp;
    long long temp8, temp9;

    
    if ( *(ptr + 6) != ',' || *(ptr + 8) != ',' || *(ptr + 25) != ',' || *(ptr + 27) != ',' || *(ptr + 36) != ',' ) return -1;
    
    temp1 = (int)convert_str_to_hex ( ptr + 5, 1 ); // номер запроса
    if (temp1 <= 0 || temp1 > 9) return -1;
    
    temp2 = (int)convert_str_to_hex ( ptr + 7, 1 ); // номер кана
    if (temp2 < 0) return -1;

    temp3 = (int)convert_str_to_hex ( ptr + 26, 1 ); // длина сообщения
    if (temp3 < 0) return -1;

    temp4 = (long)convert_str_to_hex ( ptr + 28, 8 ); // ID
    if (temp4 < 0) return -1;
    
    if (temp2 > 2) return -1;
    if (temp3 > 8) return -1;

    temp8 = 0;
    temp = (int)convert_str_to_hex ( ptr + 37, 2 );
    if (temp < 0) return -1;
    temp8 = temp8 + temp;
    temp = (int)convert_str_to_hex ( ptr + 39, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 41, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 43, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 45, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 47, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 49, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 51, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;    

    temp9 = 0;
    temp = (int)convert_str_to_hex ( ptr + 9, 2 );
    if (temp < 0) return -1;
    temp9 = temp9 + temp;
    temp = (int)convert_str_to_hex ( ptr + 11, 2 );
    if (temp < 0) return -1;
    temp9 = (temp9 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 13, 2 );
    if (temp < 0) return -1;
    temp9 = (temp9 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 15, 2 );
    if (temp < 0) return -1;
    temp9 = (temp9 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 17, 2 );
    if (temp < 0) return -1;
    temp9 = (temp9 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 19, 2 );
    if (temp < 0) return -1;
    temp9 = (temp9 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 21, 2 );
    if (temp < 0) return -1;
    temp9 = (temp9 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 23, 2 );
    if (temp < 0) return -1;
    temp9 = (temp9 << 8) + temp;

if ( command_type == 1 ) {    
    if (temp1 == 1) {
        CLOCKSET1bits.can_number  = (unsigned char) temp2;
        CLOCKSET1bits.len         = (unsigned char) temp3;
        CLOCKSET1bits.id          = (unsigned long) temp4;
        CLOCKDAT1bits.CLOCKDAT1   = (unsigned long long) temp8;
        CLOCKTIME1bits.CLOCKTIME1 = (unsigned long long) temp9;
        FM25_write_8( 676, (unsigned long long) CLOCKSET1bits.CLOCKSET1 );
        FM25_write_8( 684, (unsigned long long) CLOCKDAT1bits.CLOCKDAT1 );
        FM25_write_8( 692, (unsigned long long) CLOCKTIME1bits.CLOCKTIME1 );
        
    }
    if (temp1 == 2) {
        CLOCKSET2bits.can_number  = (unsigned char) temp2;
        CLOCKSET2bits.len         = (unsigned char) temp3;
        CLOCKSET2bits.id          = (unsigned long) temp4;
        CLOCKDAT2bits.CLOCKDAT2   = (unsigned long long) temp8;
        CLOCKTIME2bits.CLOCKTIME2 = (unsigned long long) temp9;
        FM25_write_8( 700, (unsigned long long) CLOCKSET2bits.CLOCKSET2 );
        FM25_write_8( 708, (unsigned long long) CLOCKDAT2bits.CLOCKDAT2 );
        FM25_write_8( 716, (unsigned long long) CLOCKTIME2bits.CLOCKTIME2 );        
    }    
    if (temp1 == 3) {
        CLOCKSET3bits.can_number  = (unsigned char) temp2;
        CLOCKSET3bits.len         = (unsigned char) temp3;
        CLOCKSET3bits.id          = (unsigned long) temp4;
        CLOCKDAT3bits.CLOCKDAT3   = (unsigned long long) temp8;
        CLOCKTIME3bits.CLOCKTIME3 = (unsigned long long) temp9;
        FM25_write_8( 724, (unsigned long long) CLOCKSET3bits.CLOCKSET3 );
        FM25_write_8( 732, (unsigned long long) CLOCKDAT3bits.CLOCKDAT3 );
        FM25_write_8( 740, (unsigned long long) CLOCKTIME3bits.CLOCKTIME3 );        
    }

    if (temp1 == 4) {
        CUNLOCKSET1bits.can_number  = (unsigned char) temp2;
        CUNLOCKSET1bits.len         = (unsigned char) temp3;
        CUNLOCKSET1bits.id          = (unsigned long) temp4;
        CUNLOCKDAT1bits.CUNLOCKDAT1   = (unsigned long long) temp8;
        CLOCKTIME1bits.CLOCKTIME1 = (unsigned long long) temp9;
        FM25_write_8( 748, (unsigned long long) CUNLOCKSET1bits.CUNLOCKSET1 );
        FM25_write_8( 756, (unsigned long long) CUNLOCKDAT1bits.CUNLOCKDAT1 );
        FM25_write_8( 692, (unsigned long long) CLOCKTIME1bits.CLOCKTIME1 );
        
    }
    if (temp1 == 5) {
        CUNLOCKSET2bits.can_number  = (unsigned char) temp2;
        CUNLOCKSET2bits.len         = (unsigned char) temp3;
        CUNLOCKSET2bits.id          = (unsigned long) temp4;
        CUNLOCKDAT2bits.CUNLOCKDAT2   = (unsigned long long) temp8;
        CLOCKTIME2bits.CLOCKTIME2 = (unsigned long long) temp9;
        FM25_write_8( 764, (unsigned long long) CUNLOCKSET2bits.CUNLOCKSET2 );
        FM25_write_8( 772, (unsigned long long) CUNLOCKDAT2bits.CUNLOCKDAT2 );
        
        FM25_write_8( 716, (unsigned long long) CLOCKTIME2bits.CLOCKTIME2 );        
    }    
    if (temp1 == 6) {
        CUNLOCKSET3bits.can_number  = (unsigned char) temp2;
        CUNLOCKSET3bits.len         = (unsigned char) temp3;
        CUNLOCKSET3bits.id          = (unsigned long) temp4;
        CUNLOCKDAT3bits.CUNLOCKDAT3   = (unsigned long long) temp8;
        CLOCKTIME3bits.CLOCKTIME3 = (unsigned long long) temp9;
        FM25_write_8( 780, (unsigned long long) CUNLOCKSET3bits.CUNLOCKSET3 );
        FM25_write_8( 788, (unsigned long long) CUNLOCKDAT3bits.CUNLOCKDAT3 );
        
        FM25_write_8( 740, (unsigned long long) CLOCKTIME3bits.CLOCKTIME3 );        
    }            
//            
    if (temp1 == 7) {
        CBTUNLOCKSET1bits.can_number      = (unsigned char) temp2;
        CBTUNLOCKSET1bits.len             = (unsigned char) temp3;
        CBTUNLOCKSET1bits.id              = (unsigned long) temp4;
        CBTUNLOCKDAT1bits.CBTUNLOCKDAT1   = (unsigned long long) temp8;
        CBTUNLOCKTIME1bits.CBTUNLOCKTIME1 = (unsigned long long) temp9;
        FM25_write_8( 796, (unsigned long long) CBTUNLOCKSET1bits.CBTUNLOCKSET1 );
        FM25_write_8( 804, (unsigned long long) CBTUNLOCKDAT1bits.CBTUNLOCKDAT1 );
        FM25_write_8( 812, (unsigned long long) CBTUNLOCKTIME1bits.CBTUNLOCKTIME1 );
        
    }
    if (temp1 == 8) {
        CBTUNLOCKSET2bits.can_number      = (unsigned char) temp2;
        CBTUNLOCKSET2bits.len             = (unsigned char) temp3;
        CBTUNLOCKSET2bits.id              = (unsigned long) temp4;
        CBTUNLOCKDAT2bits.CBTUNLOCKDAT2   = (unsigned long long) temp8;
        CBTUNLOCKTIME2bits.CBTUNLOCKTIME2 = (unsigned long long) temp9;
        FM25_write_8( 820, (unsigned long long) CBTUNLOCKSET2bits.CBTUNLOCKSET2 );
        FM25_write_8( 828, (unsigned long long) CBTUNLOCKDAT2bits.CBTUNLOCKDAT2 );
        FM25_write_8( 836, (unsigned long long) CBTUNLOCKTIME2bits.CBTUNLOCKTIME2 );        
    }    
    if (temp1 == 9) {
        CBTUNLOCKSET3bits.can_number      = (unsigned char) temp2;
        CBTUNLOCKSET3bits.len             = (unsigned char) temp3;
        CBTUNLOCKSET3bits.id              = (unsigned long) temp4;
        CBTUNLOCKDAT3bits.CBTUNLOCKDAT3   = (unsigned long long) temp8;
        CBTUNLOCKTIME3bits.CBTUNLOCKTIME3 = (unsigned long long) temp9;
        FM25_write_8( 844, (unsigned long long) CBTUNLOCKSET3bits.CBTUNLOCKSET3 );
        FM25_write_8( 852, (unsigned long long) CBTUNLOCKDAT3bits.CBTUNLOCKDAT3 );
        FM25_write_8( 860, (unsigned long long) CBTUNLOCKTIME3bits.CBTUNLOCKTIME3 );        
    } 
}

if ( command_type == 2 ) {
        DOPENSET1bits.can_number  = (unsigned char) temp2;
        DOPENSET1bits.len         = (unsigned char) temp3;
        DOPENSET1bits.id          = (unsigned long) temp4;
        DOPENDAT1bits.DOPENDAT1   = (unsigned long long) temp8;
        DOPENTIME1bits.DOPENTIME1 = (unsigned long) temp9;
        FM25_write_8( 1650, (unsigned long long) DOPENSET1bits.DOPENSET1 );
        FM25_write_8( 1658, (unsigned long long) DOPENDAT1bits.DOPENDAT1 );
        FM25_write_4( 1666, (unsigned long)      DOPENTIME1bits.DOPENTIME1 );    
}    
    
    
return 1;    
}
int save_webasto_control_settings ( unsigned char *ptr ) {
    
    int temp1, temp2, temp3;
    long temp4;
    long temp;
    volatile long long temp8, temp9;

    
    if ( *(ptr + 6) != ',' || *(ptr + 8) != ',' || *(ptr + 25) != ',' || *(ptr + 27) != ',' || *(ptr + 36) != ',' ) return -1;
    
    temp1 = (int)convert_str_to_hex ( ptr + 5, 1 ); // номер запроса
    if (temp1 <= 0 || temp1 > 13) return -1;

    if ( temp1 < 13 ) {
        
    } else {
        
    }
    
    temp2 = (int)convert_str_to_hex ( ptr + 7, 1 ); // номер кана
    if (temp2 < 0) return -1;

    temp3 = (int)convert_str_to_hex ( ptr + 26, 1 ); // длина сообщения
    if (temp3 < 0) return -1;

    temp4 = (long)convert_str_to_hex ( ptr + 28, 8 ); // ID
    if (temp4 < 0) return -1;
    
    if (temp2 > 2) return -1;
    if (temp3 > 8) return -1;

    temp8 = 0;
    temp = (int)convert_str_to_hex ( ptr + 37, 2 );
    if (temp < 0) return -1;
    temp8 = temp8 + temp;
    temp = (int)convert_str_to_hex ( ptr + 39, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 41, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 43, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 45, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 47, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 49, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 51, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;    

    temp9 = 0;
    temp = (int)convert_str_to_hex ( ptr + 9, 2 );
    if (temp < 0) return -1;
    temp9 = temp9 + temp;
    temp = (int)convert_str_to_hex ( ptr + 11, 2 );
    if (temp < 0) return -1;
    temp9 = (temp9 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 13, 2 );
    if (temp < 0) return -1;
    temp9 = (temp9 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 15, 2 );
    if (temp < 0) return -1;
    temp9 = (temp9 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 17, 2 );
    if (temp < 0) return -1;
    temp9 = (temp9 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 19, 2 );
    if (temp < 0) return -1;
    temp9 = (temp9 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 21, 2 );
    if (temp < 0) return -1;
    temp9 = (temp9 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 23, 2 );
    if (temp < 0) return -1;
    temp9 = (temp9 << 8) + temp;

    if (temp1 == 1) {
        WBSTSTARTSET1bits.can_number  = (unsigned char) temp2;
        WBSTSTARTSET1bits.len         = (unsigned char) temp3;
        WBSTSTARTSET1bits.id          = (unsigned long) temp4;
        WBSTSTARTDAT1bits.WBSTSTARTDAT1   = (unsigned long long) temp8;
        WBSTSTARTTIME1bits.WBSTSTARTTIME1 = (unsigned long long) temp9;
        
        FM25_write_8( 166, (unsigned long long) WBSTSTARTSET1bits.WBSTSTARTSET1 );
        FM25_write_8( 422, (unsigned long long) WBSTSTARTDAT1bits.WBSTSTARTDAT1 );
        FM25_write_8( 414, (unsigned long long) WBSTSTARTTIME1bits.WBSTSTARTTIME1 );
        
    }
    if (temp1 == 2) {
        WBSTSTARTSET2bits.can_number  = (unsigned char) temp2;
        WBSTSTARTSET2bits.len         = (unsigned char) temp3;
        WBSTSTARTSET2bits.id          = (unsigned long) temp4;
        WBSTSTARTDAT2bits.WBSTSTARTDAT2   = (unsigned long long) temp8;
        WBSTSTARTTIME2bits.WBSTSTARTTIME2 = (unsigned long long) temp9;
        FM25_write_8( 406, (unsigned long long) WBSTSTARTSET2bits.WBSTSTARTSET2 );
        FM25_write_8( 398, (unsigned long long) WBSTSTARTDAT2bits.WBSTSTARTDAT2 );
        FM25_write_8( 390, (unsigned long long) WBSTSTARTTIME2bits.WBSTSTARTTIME2 );       
    }    
    if (temp1 == 3) {
        WBSTSTARTSET3bits.can_number  = (unsigned char) temp2;
        WBSTSTARTSET3bits.len         = (unsigned char) temp3;
        WBSTSTARTSET3bits.id          = (unsigned long) temp4;
        WBSTSTARTDAT3bits.WBSTSTARTDAT3   = (unsigned long long) temp8;
        WBSTSTARTTIME3bits.WBSTSTARTTIME3 = (unsigned long long) temp9;
        FM25_write_8( 382, (unsigned long long) WBSTSTARTSET3bits.WBSTSTARTSET3 );
        FM25_write_8( 374, (unsigned long long) WBSTSTARTDAT3bits.WBSTSTARTDAT3 );
        FM25_write_8( 366, (unsigned long long) WBSTSTARTTIME3bits.WBSTSTARTTIME3 );        
    }

    if (temp1 == 4) {
        WBSTSTARTSET4bits.can_number  = (unsigned char) temp2;
        WBSTSTARTSET4bits.len         = (unsigned char) temp3;
        WBSTSTARTSET4bits.id          = (unsigned long) temp4;
        WBSTSTARTDAT4bits.WBSTSTARTDAT4   = (unsigned long long) temp8;
        WBSTSTARTTIME4bits.WBSTSTARTTIME4 = (unsigned long long) temp9;
        FM25_write_8( 358, (unsigned long long) WBSTSTARTSET4bits.WBSTSTARTSET4 );
        FM25_write_8( 350, (unsigned long long) WBSTSTARTDAT4bits.WBSTSTARTDAT4 );
        FM25_write_8( 342, (unsigned long long) WBSTSTARTTIME4bits.WBSTSTARTTIME4 );
        
    }
    if (temp1 == 5) {
        WBSTSTARTSET5bits.can_number  = (unsigned char) temp2;
        WBSTSTARTSET5bits.len         = (unsigned char) temp3;
        WBSTSTARTSET5bits.id          = (unsigned long) temp4;
        WBSTSTARTDAT5bits.WBSTSTARTDAT5   = (unsigned long long) temp8;
        WBSTSTARTTIME5bits.WBSTSTARTTIME5 = (unsigned long long) temp9;
        FM25_write_8( 334, (unsigned long long) WBSTSTARTSET5bits.WBSTSTARTSET5 );
        FM25_write_8( 326, (unsigned long long) WBSTSTARTDAT5bits.WBSTSTARTDAT5 );
        FM25_write_8( 318, (unsigned long long) WBSTSTARTTIME5bits.WBSTSTARTTIME5 );        
    }
    if (temp1 == 6) {
        WBSTSTARTSET6bits.can_number  = (unsigned char) temp2;
        WBSTSTARTSET6bits.len         = (unsigned char) temp3;
        WBSTSTARTSET6bits.id          = (unsigned long) temp4;
        WBSTSTARTDAT6bits.WBSTSTARTDAT6   = (unsigned long long) temp8;
        WBSTSTARTTIME6bits.WBSTSTARTTIME6 = (unsigned long long) temp9;
        FM25_write_8( 158, (unsigned long long) WBSTSTARTSET6bits.WBSTSTARTSET6 );
        FM25_write_8( 150, (unsigned long long) WBSTSTARTDAT6bits.WBSTSTARTDAT6 );
        FM25_write_8( 142, (unsigned long long) WBSTSTARTTIME6bits.WBSTSTARTTIME6 );        
    }    
    if (temp1 == 7) {
        WBSTSTOPSET1bits.can_number  = (unsigned char) temp2;
        WBSTSTOPSET1bits.len         = (unsigned char) temp3;
        WBSTSTOPSET1bits.id          = (unsigned long) temp4;
        WBSTSTOPDAT1bits.WBSTSTOPDAT1   = (unsigned long long) temp8;
        WBSTSTOPTIME1bits.WBSTSTOPTIME1 = (unsigned long long) temp9;
        
        FM25_write_8( 310, (unsigned long long) WBSTSTOPSET1bits.WBSTSTOPSET1 );
        FM25_write_8( 302, (unsigned long long) WBSTSTOPDAT1bits.WBSTSTOPDAT1 );
        FM25_write_8( 294, (unsigned long long) WBSTSTOPTIME1bits.WBSTSTOPTIME1 );        
    }            
    if (temp1 == 8) {
        WBSTSTOPSET2bits.can_number  = (unsigned char) temp2;
        WBSTSTOPSET2bits.len         = (unsigned char) temp3;
        WBSTSTOPSET2bits.id          = (unsigned long) temp4;
        WBSTSTOPDAT2bits.WBSTSTOPDAT2   = (unsigned long long) temp8;
        WBSTSTOPTIME2bits.WBSTSTOPTIME2 = (unsigned long long) temp9;
        
        FM25_write_8( 286, (unsigned long long) WBSTSTOPSET2bits.WBSTSTOPSET2 );
        FM25_write_8( 278, (unsigned long long) WBSTSTOPDAT2bits.WBSTSTOPDAT2 );
        FM25_write_8( 270, (unsigned long long) WBSTSTOPTIME2bits.WBSTSTOPTIME2 );        
    }
    if (temp1 == 9) {
        WBSTSTOPSET3bits.can_number  = (unsigned char) temp2;
        WBSTSTOPSET3bits.len         = (unsigned char) temp3;
        WBSTSTOPSET3bits.id          = (unsigned long) temp4;
        WBSTSTOPDAT3bits.WBSTSTOPDAT3   = (unsigned long long) temp8;
        WBSTSTOPTIME3bits.WBSTSTOPTIME3 = (unsigned long long) temp9;
        
        FM25_write_8( 262, (unsigned long long) WBSTSTOPSET3bits.WBSTSTOPSET3 );
        FM25_write_8( 254, (unsigned long long) WBSTSTOPDAT3bits.WBSTSTOPDAT3 );
        FM25_write_8( 246, (unsigned long long) WBSTSTOPTIME3bits.WBSTSTOPTIME3 );        
    }    
    if (temp1 == 10) {
        WBSTSTOPSET4bits.can_number  = (unsigned char) temp2;
        WBSTSTOPSET4bits.len         = (unsigned char) temp3;
        WBSTSTOPSET4bits.id          = (unsigned long) temp4;
        WBSTSTOPDAT4bits.WBSTSTOPDAT4   = (unsigned long long) temp8;
        WBSTSTOPTIME4bits.WBSTSTOPTIME4 = (unsigned long long) temp9;
        
        FM25_write_8( 238, (unsigned long long) WBSTSTOPSET4bits.WBSTSTOPSET4 );
        FM25_write_8( 230, (unsigned long long) WBSTSTOPDAT4bits.WBSTSTOPDAT4 );
        FM25_write_8( 222, (unsigned long long) WBSTSTOPTIME4bits.WBSTSTOPTIME4 );       
    }            
    if (temp1 == 11) {
        WBSTSTOPSET5bits.can_number  = (unsigned char) temp2;
        WBSTSTOPSET5bits.len         = (unsigned char) temp3;
        WBSTSTOPSET5bits.id          = (unsigned long) temp4;
        WBSTSTOPDAT5bits.WBSTSTOPDAT5   = (unsigned long long) temp8;
        WBSTSTOPTIME5bits.WBSTSTOPTIME5 = (unsigned long long) temp9;
        
        FM25_write_8( 214, (unsigned long long) WBSTSTOPSET5bits.WBSTSTOPSET5 );
        FM25_write_8( 206, (unsigned long long) WBSTSTOPDAT5bits.WBSTSTOPDAT5 );
        FM25_write_8( 198, (unsigned long long) WBSTSTOPTIME5bits.WBSTSTOPTIME5 );        
    } 
    if (temp1 == 12) {
        WBSTSTOPSET6bits.can_number  = (unsigned char) temp2;
        WBSTSTOPSET6bits.len         = (unsigned char) temp3;
        WBSTSTOPSET6bits.id          = (unsigned long) temp4;
        WBSTSTOPDAT6bits.WBSTSTOPDAT6   = (unsigned long long) temp8;
        WBSTSTOPTIME6bits.WBSTSTOPTIME6 = (unsigned long long) temp9;
        
        FM25_write_8( 134, (unsigned long long) WBSTSTOPSET6bits.WBSTSTOPSET6 );
        FM25_write_8( 126, (unsigned long long) WBSTSTOPDAT6bits.WBSTSTOPDAT6 );
        FM25_write_8( 118, (unsigned long long) WBSTSTOPTIME6bits.WBSTSTOPTIME6 );        
    }
    if (temp1 == 13) { //  запрос статуса вебасто
        WBSTRSET1bits.can_number  = (unsigned char) temp2;
        WBSTRSET1bits.len         = (unsigned char) temp3;
        WBSTRSET1bits.id          = (unsigned long) temp4;
        WBSTRDAT1bits.WBSTRDAT1   = (unsigned long long) temp8;
//        WBSTRTIME1bits.WBSTRTIME1 = (unsigned long long) temp9;
        temp9 = temp9 & 0x000000000000FFFF;
        WBSTCANWAKETIMEbits.after_delay = (unsigned int)(temp9 & 0x00000000000000FF);
        WBSTCANWAKETIMEbits.period      = (unsigned int)(temp9 >> 8);
        WBSTCANWAKETIMEbits.after_delay = WBSTCANWAKETIMEbits.after_delay * 100;
        FM25_write_8( 190, (unsigned long long) WBSTRSET1bits.WBSTRSET1 );
        FM25_write_8( 182, (unsigned long long) WBSTRDAT1bits.WBSTRDAT1 );
        FM25_write_8( 174, (unsigned long long) WBSTCANWAKETIMEbits.WBSTCANWAKETIME );        
    }    
    
return 1;    
}
int save_start_engine_can_settings ( unsigned char *ptr ) {
    
    int temp1, temp2, temp3;
    long temp4;
    long temp;
    volatile long long temp8, temp9;

    
    if ( *(ptr + 6) != ',' || *(ptr + 8) != ',' || *(ptr + 25) != ',' || *(ptr + 27) != ',' || *(ptr + 36) != ',' ) return -1;
    
    temp1 = (int)convert_str_to_hex ( ptr + 5, 1 ); // номер запроса
    if (temp1 <= 0 || temp1 > 13) return -1;

    if ( temp1 < 13 ) {
        
    } else {
        
    }
    
    temp2 = (int)convert_str_to_hex ( ptr + 7, 1 ); // номер кана
    if (temp2 < 0) return -1;

    temp3 = (int)convert_str_to_hex ( ptr + 26, 1 ); // длина сообщения
    if (temp3 < 0) return -1;

    temp4 = (long)convert_str_to_hex ( ptr + 28, 8 ); // ID
    if (temp4 < 0) return -1;
    
    if (temp2 > 2) return -1;
    if (temp3 > 8) return -1;

    temp8 = 0;
    temp = (int)convert_str_to_hex ( ptr + 37, 2 );
    if (temp < 0) return -1;
    temp8 = temp8 + temp;
    temp = (int)convert_str_to_hex ( ptr + 39, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 41, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 43, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 45, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 47, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 49, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 51, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;    

    temp9 = 0;
    temp = (int)convert_str_to_hex ( ptr + 9, 2 );
    if (temp < 0) return -1;
    temp9 = temp9 + temp;
    temp = (int)convert_str_to_hex ( ptr + 11, 2 );
    if (temp < 0) return -1;
    temp9 = (temp9 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 13, 2 );
    if (temp < 0) return -1;
    temp9 = (temp9 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 15, 2 );
    if (temp < 0) return -1;
    temp9 = (temp9 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 17, 2 );
    if (temp < 0) return -1;
    temp9 = (temp9 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 19, 2 );
    if (temp < 0) return -1;
    temp9 = (temp9 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 21, 2 );
    if (temp < 0) return -1;
    temp9 = (temp9 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 23, 2 );
    if (temp < 0) return -1;
    temp9 = (temp9 << 8) + temp;

    if (temp1 == 1) {
        STRTENGCSTARTSET1bits.can_number  = (unsigned char) temp2; //STRTENGC
        STRTENGCSTARTSET1bits.len         = (unsigned char) temp3;
        STRTENGCSTARTSET1bits.id          = (unsigned long) temp4;
        STRTENGCSTARTDAT1bits.STRTENGCSTARTDAT1   = (unsigned long long) temp8;
        STRTENGCSTARTTIME1bits.STRTENGCSTARTTIME1 = (unsigned long long) temp9;
        
        FM25_write_8( 166, (unsigned long long) STRTENGCSTARTSET1bits.STRTENGCSTARTSET1 );
        FM25_write_8( 422, (unsigned long long) STRTENGCSTARTDAT1bits.STRTENGCSTARTDAT1 );
        FM25_write_8( 414, (unsigned long long) STRTENGCSTARTTIME1bits.STRTENGCSTARTTIME1 );
        
    }
    if (temp1 == 2) {
        STRTENGCSTARTSET2bits.can_number  = (unsigned char) temp2;
        STRTENGCSTARTSET2bits.len         = (unsigned char) temp3;
        STRTENGCSTARTSET2bits.id          = (unsigned long) temp4;
        STRTENGCSTARTDAT2bits.STRTENGCSTARTDAT2   = (unsigned long long) temp8;
        STRTENGCSTARTTIME2bits.STRTENGCSTARTTIME2 = (unsigned long long) temp9;
        FM25_write_8( 406, (unsigned long long) STRTENGCSTARTSET2bits.STRTENGCSTARTSET2 );
        FM25_write_8( 398, (unsigned long long) STRTENGCSTARTDAT2bits.STRTENGCSTARTDAT2 );
        FM25_write_8( 390, (unsigned long long) STRTENGCSTARTTIME2bits.STRTENGCSTARTTIME2 );       
    }    
    if (temp1 == 3) {
        STRTENGCSTARTSET3bits.can_number  = (unsigned char) temp2;
        STRTENGCSTARTSET3bits.len         = (unsigned char) temp3;
        STRTENGCSTARTSET3bits.id          = (unsigned long) temp4;
        STRTENGCSTARTDAT3bits.STRTENGCSTARTDAT3   = (unsigned long long) temp8;
        STRTENGCSTARTTIME3bits.STRTENGCSTARTTIME3 = (unsigned long long) temp9;
        FM25_write_8( 382, (unsigned long long) STRTENGCSTARTSET3bits.STRTENGCSTARTSET3 );
        FM25_write_8( 374, (unsigned long long) STRTENGCSTARTDAT3bits.STRTENGCSTARTDAT3 );
        FM25_write_8( 366, (unsigned long long) STRTENGCSTARTTIME3bits.STRTENGCSTARTTIME3 );        
    }

    if (temp1 == 4) {
        STRTENGCSTARTSET4bits.can_number  = (unsigned char) temp2;
        STRTENGCSTARTSET4bits.len         = (unsigned char) temp3;
        STRTENGCSTARTSET4bits.id          = (unsigned long) temp4;
        STRTENGCSTARTDAT4bits.STRTENGCSTARTDAT4   = (unsigned long long) temp8;
        STRTENGCSTARTTIME4bits.STRTENGCSTARTTIME4 = (unsigned long long) temp9;
        FM25_write_8( 358, (unsigned long long) STRTENGCSTARTSET4bits.STRTENGCSTARTSET4 );
        FM25_write_8( 350, (unsigned long long) STRTENGCSTARTDAT4bits.STRTENGCSTARTDAT4 );
        FM25_write_8( 342, (unsigned long long) STRTENGCSTARTTIME4bits.STRTENGCSTARTTIME4 );
        
    }
    if (temp1 == 5) {
        STRTENGCSTARTSET5bits.can_number  = (unsigned char) temp2;
        STRTENGCSTARTSET5bits.len         = (unsigned char) temp3;
        STRTENGCSTARTSET5bits.id          = (unsigned long) temp4;
        STRTENGCSTARTDAT5bits.STRTENGCSTARTDAT5   = (unsigned long long) temp8;
        STRTENGCSTARTTIME5bits.STRTENGCSTARTTIME5 = (unsigned long long) temp9;
        FM25_write_8( 334, (unsigned long long) STRTENGCSTARTSET5bits.STRTENGCSTARTSET5 );
        FM25_write_8( 326, (unsigned long long) STRTENGCSTARTDAT5bits.STRTENGCSTARTDAT5 );
        FM25_write_8( 318, (unsigned long long) STRTENGCSTARTTIME5bits.STRTENGCSTARTTIME5 );        
    }
   
    if (temp1 == 7) {
        STRTENGCSTOPSET1bits.can_number  = (unsigned char) temp2;
        STRTENGCSTOPSET1bits.len         = (unsigned char) temp3;
        STRTENGCSTOPSET1bits.id          = (unsigned long) temp4;
        STRTENGCSTOPDAT1bits.STRTENGCSTOPDAT1   = (unsigned long long) temp8;
        STRTENGCSTOPTIME1bits.STRTENGCSTOPTIME1 = (unsigned long long) temp9;
        
        FM25_write_8( 310, (unsigned long long) STRTENGCSTOPSET1bits.STRTENGCSTOPSET1 );
        FM25_write_8( 302, (unsigned long long) STRTENGCSTOPDAT1bits.STRTENGCSTOPDAT1 );
        FM25_write_8( 294, (unsigned long long) STRTENGCSTOPTIME1bits.STRTENGCSTOPTIME1 );        
    }            
    if (temp1 == 8) {
        STRTENGCSTOPSET2bits.can_number  = (unsigned char) temp2;
        STRTENGCSTOPSET2bits.len         = (unsigned char) temp3;
        STRTENGCSTOPSET2bits.id          = (unsigned long) temp4;
        STRTENGCSTOPDAT2bits.STRTENGCSTOPDAT2   = (unsigned long long) temp8;
        STRTENGCSTOPTIME2bits.STRTENGCSTOPTIME2 = (unsigned long long) temp9;
        
        FM25_write_8( 286, (unsigned long long) STRTENGCSTOPSET2bits.STRTENGCSTOPSET2 );
        FM25_write_8( 278, (unsigned long long) STRTENGCSTOPDAT2bits.STRTENGCSTOPDAT2 );
        FM25_write_8( 270, (unsigned long long) STRTENGCSTOPTIME2bits.STRTENGCSTOPTIME2 );        
    }
    if (temp1 == 9) {
        STRTENGCSTOPSET3bits.can_number  = (unsigned char) temp2;
        STRTENGCSTOPSET3bits.len         = (unsigned char) temp3;
        STRTENGCSTOPSET3bits.id          = (unsigned long) temp4;
        STRTENGCSTOPDAT3bits.STRTENGCSTOPDAT3   = (unsigned long long) temp8;
        STRTENGCSTOPTIME3bits.STRTENGCSTOPTIME3 = (unsigned long long) temp9;
        
        FM25_write_8( 262, (unsigned long long) STRTENGCSTOPSET3bits.STRTENGCSTOPSET3 );
        FM25_write_8( 254, (unsigned long long) STRTENGCSTOPDAT3bits.STRTENGCSTOPDAT3 );
        FM25_write_8( 246, (unsigned long long) STRTENGCSTOPTIME3bits.STRTENGCSTOPTIME3 );        
    }    
    if (temp1 == 10) {
        STRTENGCSTOPSET4bits.can_number  = (unsigned char) temp2;
        STRTENGCSTOPSET4bits.len         = (unsigned char) temp3;
        STRTENGCSTOPSET4bits.id          = (unsigned long) temp4;
        STRTENGCSTOPDAT4bits.STRTENGCSTOPDAT4   = (unsigned long long) temp8;
        STRTENGCSTOPTIME4bits.STRTENGCSTOPTIME4 = (unsigned long long) temp9;
        
        FM25_write_8( 238, (unsigned long long) STRTENGCSTOPSET4bits.STRTENGCSTOPSET4 );
        FM25_write_8( 230, (unsigned long long) STRTENGCSTOPDAT4bits.STRTENGCSTOPDAT4 );
        FM25_write_8( 222, (unsigned long long) STRTENGCSTOPTIME4bits.STRTENGCSTOPTIME4 );       
    }            
    if (temp1 == 11) {
        STRTENGCSTOPSET5bits.can_number  = (unsigned char) temp2;
        STRTENGCSTOPSET5bits.len         = (unsigned char) temp3;
        STRTENGCSTOPSET5bits.id          = (unsigned long) temp4;
        STRTENGCSTOPDAT5bits.STRTENGCSTOPDAT5   = (unsigned long long) temp8;
        STRTENGCSTOPTIME5bits.STRTENGCSTOPTIME5 = (unsigned long long) temp9;
        
        FM25_write_8( 214, (unsigned long long) STRTENGCSTOPSET5bits.STRTENGCSTOPSET5 );
        FM25_write_8( 206, (unsigned long long) STRTENGCSTOPDAT5bits.STRTENGCSTOPDAT5 );
        FM25_write_8( 198, (unsigned long long) STRTENGCSTOPTIME5bits.STRTENGCSTOPTIME5 );        
    } 
   
    
return 1;    
}
int save_voltage_fall_detection_settings ( char *ptr ) {

int temp;
unsigned char temp1, temp2;
unsigned int temp3;

    temp = (int) convert_str_to_hex ( ptr, 1 );
    if (temp < 0) return -1;
    temp1 = (unsigned char) temp;
    
    if (temp1 > 1) return -1;
    
    temp = (int) convert_str_to_hex ( ptr + 2, 2 );
    if (temp < 0) return -1;
    temp2 = (unsigned char) temp;

    temp = (int) convert_str_to_hex ( ptr + 5, 4 );
    if (temp < 0) return -1;
    temp3 = (unsigned int) temp;    

    IGNPULSVFALLTSETbits.enable = temp1;
    IGNPULSVFALLTSETbits.voltage_treshold = temp2;
    IGNPULSVFALLTSETbits.timer_value = temp3;
    
    FM25_write_4( 1588, (unsigned long) IGNPULSVFALLTSETbits.IGNPULSVFALLTSET ); //IGNPULSVFAULTSETbits    
//    temp3 = (unsigned long)FM25_read_4( 1588 );
//    IGNPULSVFALLTSETbits.IGNPULSVFALLTSET = (unsigned long)FM25_read_4( 1588 );

    Nop();Nop();Nop();    
    return 1;
}
int save_can_request_settings (char *ptr) {

    int temp1, temp2, temp3;
    long temp4;
    long temp;
    long long temp8;

    
    if ( *(ptr + 1) != ',' || *(ptr + 3) != ',' || *(ptr + 5) != ',' || *(ptr + 14) != ',' ) return -1;
    
    temp1 = (int)convert_str_to_hex ( ptr, 1 ); // номер запроса
    if (temp1 < 0) return -1;
    
    temp2 = (int)convert_str_to_hex ( ptr + 2, 1 ); // номер кана
    if (temp2 < 0) return -1;

    temp3 = (int)convert_str_to_hex ( ptr + 4, 1 ); // длина сообщения
    if (temp3 < 0) return -1;

    temp4 = (long)convert_str_to_hex ( ptr + 6, 8 ); // ID
    if (temp4 < 0) return -1;
    
    if (temp2 > 2) return -1;
    if (temp3 > 8) return -1;

    temp8 = 0;
    temp = (int)convert_str_to_hex ( ptr + 15, 2 );
    if (temp < 0) return -1;
    temp8 = temp8 + temp;
    temp = (int)convert_str_to_hex ( ptr + 17, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 19, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 21, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 23, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 25, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 27, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 29, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    
    if (temp1 == 1) {
        CANREQ1SETbits.can_number = (unsigned char)temp2;
        CANREQ1SETbits.len        = (unsigned char)temp3;
        CANREQ1SETbits.id         = (unsigned long)temp4;
        FM25_write_8( 1534, (unsigned long long) CANREQ1SETbits.CANREQ1SET );
//        CANREQ1SETbits.CANREQ1SET = FM25_read_8( 1534 );
//        Nop();Nop();Nop();
        CANREQ1DATbits.CANREQ1DAT = (unsigned long long)temp8;
//        Nop();Nop();Nop();
        FM25_write_8( 1558, (unsigned long long) CANREQ1DATbits.CANREQ1DAT );
//        CANREQ1DATbits.CANREQ1DAT = FM25_read_8( 1558 );
//        Nop();Nop();Nop();        
        return 1;
    }
    if (temp1 == 2) {
        CANREQ2SETbits.can_number = (unsigned char)temp2;
        CANREQ2SETbits.len        = (unsigned char)temp3;
        CANREQ2SETbits.id         = (unsigned long)temp4;
        FM25_write_8( 1542, (unsigned long long) CANREQ2SETbits.CANREQ2SET );
        CANREQ2DATbits.CANREQ2DAT = (unsigned long long)temp8;
        FM25_write_8( 1566, (unsigned long long) CANREQ2DATbits.CANREQ2DAT );        
        return 1;
    }
    if (temp1 == 3) {
        CANREQ3SETbits.can_number = (unsigned char)temp2;
        CANREQ3SETbits.len        = (unsigned char)temp3;
        CANREQ3SETbits.id         = (unsigned long)temp4;
        FM25_write_8( 1550, (unsigned long long) CANREQ3SETbits.CANREQ3SET );
        CANREQ3DATbits.CANREQ3DAT = (unsigned long long)temp8;
        FM25_write_8( 1574, (unsigned long long) CANREQ3DATbits.CANREQ3DAT );        
        return 1;
    }
    
return -1;    
}
/*
int save_can_request_data (char *ptr) {
    long temp;
    long long temp8;
    int temp1;
    
    temp1 = (int)convert_str_to_hex ( ptr, 1 );
    if (temp1 < 0) return -1;
    
    temp8 = 0;
    temp = (int)convert_str_to_hex ( ptr + 2, 2 );
    if (temp < 0) return -1;
    temp8 = temp8 + temp;
    temp = (int)convert_str_to_hex ( ptr + 4, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 6, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 8, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 10, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 12, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 14, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    temp = (int)convert_str_to_hex ( ptr + 16, 2 );
    if (temp < 0) return -1;
    temp8 = (temp8 << 8) + temp;
    
    if (temp1 == 1) {
        CANREQ1DATbits.CANREQ1DAT = (unsigned long)temp8;
        FM25_write_8( 1558, (unsigned long long) CANREQ1DATbits.CANREQ1DAT );
        CANREQ1DATbits.CANREQ1DAT = FM25_read_8( 1558 );
        Nop();Nop();Nop();
        return 1;
    }
    if (temp1 == 2) {
        CANREQ2DATbits.CANREQ2DAT = (unsigned long)temp8;
        FM25_write_8( 1566, (unsigned long long) CANREQ2DATbits.CANREQ2DAT );
        return 1;
    }
    if (temp1 == 3) {
        CANREQ3DATbits.CANREQ3DAT = (unsigned long)temp8;
        FM25_write_8( 1574, (unsigned long long) CANREQ3DATbits.CANREQ3DAT );
        return 1;
    }
    
return -1;    
    
}
 */
int save_phone_number ( char *ptr ) {
    
unsigned char num, i, res, len;
char *tmp_ptr;
int addr;

    if (*(ptr + 1) != ',') return 0;
    if ( *ptr < 0x30 && *ptr > 0x36 ) return 0;

    num = *ptr - 0x30;
    if (num == 0) return 0;
    Nop();Nop();Nop();
    res = 0;
    ptr = ptr + 2;
    tmp_ptr = ptr;
    for (i = 0; i < 14; i ++) {
        if ( *ptr < 0x30 || *ptr > 0x39 ) {
            if (*ptr == ';') {res = 1; break;}
            else {
                if (i == 0 && *ptr == '+') {}
                else {
                    res = 0; break;
                }
            }
        }
        ptr ++;
    }
    Nop();Nop();Nop();
    len = i;
    if (res == 1 && len > 5 && len < 15) {
        if (num == 0) addr = 1385; if (num == 1) addr = 1400; if (num == 2) addr = 1415;
        if (num == 3) addr = 1430; if (num == 4) addr = 1445; if (num == 5) addr = 1460;
        for (i = 0; i < 15; i ++) { 
            PHONES_buf[num][i] = 0; 
        }
        memmove ( &PHONES_buf[num][0], tmp_ptr, len );
        for ( i = 0; i < 15; i ++ ) {
            FM25_write_1 ( (addr + i), PHONES_buf[num][i]);
        }
        
    } else res = 0;
    
    Nop();Nop();Nop();    
    
return res;    
}
int check_phone_number ( char *ptr ) {
int temp;

    Nop();Nop();Nop();
    temp = strstr( ptr, &PHONES_buf[0][0] ); 
    if (temp != 0) return 0;
    temp = strstr( ptr, &PHONES_buf[1][0] ); 
    if (temp != 0) return 1;
    temp = strstr( ptr, &PHONES_buf[2][0] ); 
    if (temp != 0) return 2;
    temp = strstr( ptr, &PHONES_buf[3][0] ); 
    if (temp != 0) return 3;
    temp = strstr( ptr, &PHONES_buf[4][0] ); 
    if (temp != 0) return 4; 
    
return -1;    
}
int get_mem_reset_flags ( char *ptr) {

    unsigned int temp;
    char temp_byte;
    
    temp_byte = 0; temp = 0;
    MEMRESFLAGSbits.MEMRESFLAGS = 0;
    
    temp_byte = get_fw_nibble ( ptr );
    if (temp_byte == -1) return 0;
    temp = temp + temp_byte;
    temp = temp << 4; ptr ++;
    
    temp_byte = get_fw_nibble ( ptr );
    if (temp_byte == -1) return 0;
    temp = temp + temp_byte;
    temp = temp << 4; ptr ++;

    temp_byte = get_fw_nibble ( ptr );
    if (temp_byte == -1) return 0;
    temp = temp + temp_byte;
    temp = temp << 4; ptr ++;

    temp_byte = get_fw_nibble ( ptr );
    if (temp_byte == -1) return 0;
    temp = temp + temp_byte;
    
    MEMRESFLAGSbits.MEMRESFLAGS = temp;
    
return 1;    
}
unsigned int get_rund_puls_duration ( char *ptr ) {
unsigned int temp;    
    temp = 0;
    temp = temp + (*ptr - 0x30) * 1000;
    temp = temp + (*(ptr + 1) - 0x30) * 100;
    temp = temp + (*(ptr + 2) - 0x30) * 10;
    temp = temp + (*(ptr + 3) - 0x30);
  
    Nop();Nop();Nop();
    return temp;
}
unsigned int get_runp_puls_duration ( char *ptr ) {
unsigned int temp;    
    temp = 0;
    temp = temp + (*ptr - 0x30) * 10;
    temp = temp + (*(ptr + 1) - 0x30);
  
    Nop();Nop();Nop();
    return temp;
}
int check_atfw_comand (unsigned char *fw_ptr) {
    unsigned long fw_version, num_of_strings, num_of_pages;
    unsigned char i;
    char nibble;
    
Nop();Nop();Nop();
    fw_ptr = fw_ptr + 3;
    
    if ( *(fw_ptr + 5) != ',' || *(fw_ptr + 11) != ',' || *(fw_ptr + 17) != ';' ) {
        return 0;
    }
    
    fw_version = 0;
    i = 0;
    
    nibble = get_fw_nibble ( fw_ptr );
    if (nibble == -1) return 0;
    fw_version = nibble;
    fw_ptr ++;

    nibble = get_fw_nibble ( fw_ptr );
    if (nibble == -1) return 0;
    fw_version = fw_version << 4;
    fw_version = fw_version + nibble;
    fw_ptr ++;

    nibble = get_fw_nibble ( fw_ptr );
    if (nibble == -1) return 0;
    fw_version = fw_version << 4;
    fw_version = fw_version + nibble;
    fw_ptr ++;

    nibble = get_fw_nibble ( fw_ptr );
    if (nibble == -1) return 0;
    fw_version = fw_version << 4;
    fw_version = fw_version + nibble;
    fw_ptr ++;

    nibble = get_fw_nibble ( fw_ptr );
    if (nibble == -1) return 0;
    fw_version = fw_version << 4;
    fw_version = fw_version + nibble;
//    fw_ptr ++;    
    
//    while (*fw_ptr >= 0x30 && *fw_ptr <= 0x39) {
//        fw_version = fw_version + *fw_ptr - 0x30;
//        if (i >= 4) break;
//        fw_version = fw_version * 10;
//        fw_ptr ++;
//        i++;
//    }
//    if (i != 4) return 0;
    
    num_of_strings = 0;
    fw_ptr = fw_ptr + 2;
    i = 0;
    while (*fw_ptr >= 0x30 && *fw_ptr <= 0x39) {
        
        num_of_strings = num_of_strings + *fw_ptr - 0x30;
        if (i >= 4) break;
        num_of_strings = num_of_strings * 10;
        fw_ptr ++;
        i++;
    }
    if (i != 4) return 0;
    
    num_of_pages = 0;
    fw_ptr = fw_ptr + 2;
    i = 0;
    while (*fw_ptr >= 0x30 && *fw_ptr <= 0x39) {
        num_of_pages = num_of_pages + *fw_ptr - 0x30;
        if (i >= 4) break;
        num_of_pages = num_of_pages * 10;
        fw_ptr ++;
        i++;
    }    
    if (i != 4) return 0;
    
    FW_version     = fw_version;
    Num_of_strings = num_of_strings;    
    Num_of_pages   = num_of_pages;
    
    if ((FW_version & 0x000000FF) != hw_version) return 0;
            
return 1;
}
char get_fw_nibble (char *ptr) {

    if (*ptr >= 0x30 && *ptr <= 0x39) {
        return (*ptr - 0x30);
    }
    
    if (*ptr == 'A' || *ptr == 'a') return 10;
    if (*ptr == 'B' || *ptr == 'b') return 11;
    if (*ptr == 'C' || *ptr == 'c') return 12;
    if (*ptr == 'D' || *ptr == 'd') return 13;
    if (*ptr == 'E' || *ptr == 'e') return 14;
    if (*ptr == 'F' || *ptr == 'f') return 15;

return -1;    
}
void load_answer ( int source_of_command, char *str_to_load1, char *str_to_load2, unsigned char type ) {

    int length, length_header, length_str1, length_str2;
    
    
                length_header = 12;
                length_str1 = strlen( str_to_load1 );
                if ( str_to_load2 ) {length_str2 = strlen( str_to_load2 );}
                else length_str2 = 0;
                length = length_str1 + length_str2 + length_header;
                
                if (source_of_command == 1 || source_of_command == 3) {
                    memmove ( command_temp_buf, str_to_load1, length_str1 ); // 8 всместо length_str1
                    command_temp_buf[length_str1] = 0;
                    strcat  ( command_temp_buf, str_to_load2);                
                    if (source_of_command == 3) { write_text_to_SMS_buf  ( command_temp_buf, PHONENUMPTR ); }// из СМС
                } // из дебажного ком-порта
                
                if (source_of_command == 2) { // с сервера
                    reload_GPRS_header ( 1, 0x00, 0x0003); // N = 1, name = 0, type = 3 ответы на АТ-команды
                    memmove ( command_temp_buf, GPRS_header_buf, length_header );
                    memmove ( &command_temp_buf[ length_header ], str_to_load1, length_str1 );
                    if ( length_str2 ) memmove ( &command_temp_buf[ length_header + length_str1 ], str_to_load2, length_str2 );
                    if ( type ){ command_temp_buf[ length - 1] = ';'; }
                    else { command_temp_buf[ length ] = ';'; length ++; }
                    write_data_to_GPRS_buf ( command_temp_buf, length ); 
                }

    
}
int  apply_setting (void) {

    int i, j;
    
    if(GSMPARAMTASCKbits.change_apn == 1) {
        GSMPARAMTASCKbits.change_apn = 0;
        GSMPARAMTASCKbits.change_server = 0; 
        modem_on_off (MODEM_RESTART); 
    }

    if (GSMPARAMTASCKbits.change_server == 1) {
        GSMPARAMTASCKbits.change_server = 0;
        j = 0;
        for ( i = 28; i < 60; i++ ) {
            if (AT_QIOPEN [i] == '"') break;            
            if ((AT_QIOPEN [i] >= 0x30)&&(AT_QIOPEN [i] <= 0x39)||(AT_QIOPEN [i] == '.')) j = i;
        }
        if ( j == (i - 1) ) { AT_QIOPEN [11] = '0'; }
        else AT_QIOPEN [11] = '1';
        
        close_udp_tcp_connection ( 1 );           // Перезапустить соединение
    }
    
}
int hex_2_bin (unsigned char nibble) {
    
    if (nibble >= 0x30 && nibble <= 0x39) {
        return (int)(nibble - 0x30);
    }
    
    if (nibble == 'a' || nibble == 'A') return 10;
    if (nibble == 'b' || nibble == 'B') return 11;
    if (nibble == 'c' || nibble == 'C') return 12;
    if (nibble == 'd' || nibble == 'D') return 13;
    if (nibble == 'e' || nibble == 'E') return 14;
    if (nibble == 'f' || nibble == 'F') return 15;
    
    return -1;
}

int  reload_command_temp_buf (unsigned int offset, char *ptr1) {
unsigned int i;

    for ( i = offset; i < 100; i ++ ) {
      command_temp_buf[i] =  *ptr1;
      if (*ptr1 == 0) break;
      ptr1 ++;
    }

}
int  apn_correctness (char *ptr) {

    unsigned int i, j, len_apn, len_log, len_pass;
    const unsigned char str[] = ",\"\",\"\",\"\";\0"; // Шаблон знаков ,"","","";
    unsigned int ptrs[11];                          // Массив указателей на знаки ' " ; 

    j = 0;
    for ( i = 0; i < 100; i ++ ) {
        if (*ptr == ',' || *ptr == '"' || *ptr == ';')  { 
            command_temp_buf[j] =  *ptr; ptrs[j] = ptr; 
            if (j < 10) { j++; } else  {return -1;}      // Слишком много знаков
        }
            if (*ptr == ';') { command_temp_buf[j] = 0; ptrs[j] = 0; break; }
            ptr ++;
    }
    if ( i > 84 ) return -1;                           // Слишком длинная строка
    if (strstr( command_temp_buf, str ) == 0) return -1; // Последовательность знаков не правильная
    len_apn  = ptrs[2] - ptrs[1] - 1;
    len_log  = ptrs[5] - ptrs[4] - 1;
    len_pass = ptrs[8] - ptrs[7] - 1;
    if ( len_apn == 0 || len_apn > 25 ) return -1; // Пустой или слишком длинный АПН
    if ( len_log > 10 ) return -1; // Слишком длинный логин
    if ( len_pass > 10 ) return -1; // Слишком длинный пароль    
    
    for (i = 1756; i < 1781; i ++) {
        FM25_write_1 ( i, 0 );        
    }
    
    ptr = ptrs[1] + 1;
    for ( i = 0; i < len_apn; i ++) {
        FM25_write_1 ( (i + 1756), *( ptr++ ) );
    }
    ptr = ptrs[4] + 1;
    for ( i = 0; i < len_log; i ++) {
        FM25_write_1 ( (i + 1781), *( ptr++ ) );
    }
    ptr = ptrs[7] + 1;
    for ( i = 0; i < len_pass; i ++) {
        FM25_write_1 ( (i + 1791), *( ptr++ ) );
    }
    
    return 1;
}
int  server_correctness (char *ptr) {

    unsigned int i, j, len_serv, len_port;
    const unsigned char str[] = "\"\",\"\",;\0"; // Шаблон знаков "","",;
    unsigned int ptrs[8];                          // Массив указателей на знаки ' " ; 
    char *ptr1, *ptr2, *ptr3;
    
    j = 0;
    for ( i = 0; i < 69; i ++ ) { //60
        if (*ptr == ',' || *ptr == '"' || *ptr == ';')  { 
            command_temp_buf[j] =  *ptr; ptrs[j] = ptr; 
            if (j < 10) { j++; } else  {return -1;}      // Слишком много знаков
        }
            if (*ptr == ';') { command_temp_buf[j] = 0; ptrs[j] = 0; break; }
            ptr ++;
    }
    if ( i > 68 ) return -1;  //i == 60                          // Слишком длинная строка
    if (strstr( command_temp_buf, str ) == 0) return -1; // Последовательность знаков не правильная
    
    ptr1 = ptrs[0] + 1; ptr2 = ptr1 + 1; ptr3 = ptr2 + 1;
    if (*ptr1 != 'U' || *ptr2 != 'D' || *ptr3 != 'P') return -1; // не UDP
    
    len_serv = ptrs[4] - ptrs[3] - 1;
    len_port = ptrs[6] - ptrs[5] - 1;
    
    if (len_serv == 0 || len_serv > 30) return -1; // Пустой сервер
    if (len_port == 0 || len_port > 5)  return -1; // Пустой сервер    

    for (i = 1801; i < 1836; i ++) {
        FM25_write_1 ( i, 0 );        
    }
    
    ptr = ptrs[3] + 1;
    for ( i = 0; i < len_serv; i ++) {
        FM25_write_1 ( (i + 1801), *( ptr++ ) );
    }
    ptr = ptrs[5] + 1;
    for ( i = 0; i < len_port; i ++) {
        FM25_write_1 ( (i + 1831), *( ptr++ ) );
    }
    
    return 1;
}
void uart_at_connand_to_modem (void) {
    
    if (UARTATMODEMbits.start == 1) {
        if (MODEMTASCKSbits.MODEMTASCKS == 0) {
            UARTATMODEMbits.start = 0;
            MODEMTASCKSbits.at_to_modem = 1;
            set_sgm_tasck_busy_timer (50); // Таймаут функции 500мс
            start_UART1_transmission (WAITOFF, (unsigned int)load_uart_at_to_UART1_Tx_buf (UARTATMODEMbits.at_ptr));            
        }
    }
    
    if (UARTATMODEMbits.at_timeout == 1) {
        UARTATMODEMbits.UARTATMODEM = 0;
        MODEMTASCKSbits.at_to_modem = 0;
    }
    
    
}

int  load_phone_to_cmgs_buf (unsigned char *phone_ptr) {

    unsigned char *cmgs_ptr;
    unsigned int i;
# if defined (UC15) 
    Nop();Nop();Nop();
    cmgs_ptr = AT_CMGS_CMGF;
    cmgs_ptr = cmgs_ptr + 28;
# else
    cmgs_ptr = AT_CMGS;
    cmgs_ptr = cmgs_ptr + 8;
# endif   

    for (i = 0; i < 18; i ++) {
        *cmgs_ptr = *phone_ptr;
        cmgs_ptr ++; phone_ptr ++;
        if (*phone_ptr == 0) break;
    }
    *cmgs_ptr = '\r';
     cmgs_ptr ++;
    *cmgs_ptr = '\0';

    
}
int  send_sms (int start) {
    unsigned int SMSSEND;
    unsigned int ptr_to_send;
//    static unsigned char start_sending = 0, at_qisend = 0, cntrlz = 0;

    if (start == 1) SMSSENDbits.start_sending = 1; // Запуск процесса передачи
        
        if ( SMSSENDbits.start_sending && ! MODEMTASCKSbits.MODEMTASCKS ) {
                SMSSENDbits.SMSSEND = 0;
                SMSSENDbits.at_cmgs = 1;
                MODEMTASCKSbits.sms_sending = 1;
                set_sgm_tasck_busy_timer (500); 
                ptr_to_send = SMS_to_send_ptrs_buf[SMS_ptr_R];
                load_phone_to_cmgs_buf ( ptr_to_send + 143 );
# if defined (UC15)
                start_UART1_transmission (WAITOFF, (unsigned int) load_UART1_Tx_buf (AT_CMGS_CMGF));
# else
                start_UART1_transmission (WAITOFF, (unsigned int) load_UART1_Tx_buf (AT_CMGS));
# endif
        }
        if ( SMSSENDbits.at_cmgs && SMSSENDbits.cntrlz ) { // AT+QISEND уже отправлена в модем и от модема получено >
                SMSSENDbits.at_cmgs = 0;
                SMSSENDbits.waiting_cmgs_result = 1;
                SMS_ACK_timer = 1;                         // Запуск таймера акноледжа                
                ptr_to_send = SMS_to_send_ptrs_buf[SMS_ptr_R];
                start_UART1_transmission (WAITOFF, (unsigned int) load_SMS_text_UART1_Tx_buf (ptr_to_send));
        }
    
    
    SMSSEND = (unsigned int) (SMSSENDbits.SMSSEND & 0x0000FFFF);
    if ( SMS_ACK_timer > 0 ) {
        
        if ( SMS_ACK_timer == 2 ) { clear_gsm_task_busy_timer (); }
        SMS_sending_time = SMS_ACK_timer;
        
        while (1) {
            
            if (SMSSEND == smssentok || SMSSEND == cmserror || SMSSEND == cmeerror ) {
                SMS_ACK_timer = 0; break;
            }
            
            if ( SMS_ACK_timer < 1200 ) { SMS_ACK_timer ++; }
            else { 
                SMS_ACK_timer = 0; SMSSENDbits.sms_send_timeout = 1; 
                SMSSEND = (unsigned int)(SMSSENDbits.SMSSEND & 0x0000FFFF);
            }
            break;
        }
    }

    if (SMSSEND == cmgsidle)                                         return SMSSENDIDLE;
    if (SMSSEND == cmgsstart)                                        return CMGSWAITING;
    if (SMSSEND == cmgsrunning)                                      return CMGSRUNNING;        
    if (SMSSEND == smssending)                                       return SMSSENDING;
    if (SMSSEND == smssentok)      {MODEMTASCKSbits.sms_sending = 0; return SMSSENDSUCCESS;}
    if (SMSSEND == cmserror)       {MODEMTASCKSbits.sms_sending = 0; return CMSERROR;}
    if (SMSSEND == cmeerror)       {MODEMTASCKSbits.sms_sending = 0; return CMEERROR;}    
    if (SMSSEND == smssendtimeout) {MODEMTASCKSbits.sms_sending = 0; return SMSSENDTIMEOUT;}
    if (SMSSEND == atcmgstimeout)  {MODEMTASCKSbits.sms_sending = 0; return ATCMGSTIMEOUT;}

    return SMSSENDEXCEPTION;
} 
int  send_sms_monitor (int send_sms_status) {

    
    if (send_sms_status == SMSSENDIDLE) {
        Nop();Nop();Nop();
        if ( SMS_ptr_R != SMS_ptr_W ) {
            if ( NETWORKSTATUSbits.creg == 1 || NETWORKSTATUSbits.cgreg == 5 ) send_sms (1); // Если задача свободна и есть данные для отправки - запуск отсылки SMS  
        }
    }
    if (send_sms_status == CMGSWAITING) {
        Nop();Nop();Nop();        
    }
    if (send_sms_status == CMGSRUNNING) {
        Nop();Nop();Nop();        
    }
    if (send_sms_status == SMSSENDING) {
        Nop();Nop();Nop();        
    }
    if (send_sms_status == SMSSENDSUCCESS) {
        Nop();Nop();Nop();
        SMSSENDbits.SMSSEND = 0;
        SMS_ptr_R ++; SMS_ptr_R %= 5;             // Если SMS отослана - инкремент указателя отсылки
        
    }
    if (send_sms_status == CMSERROR) {
        Nop();Nop();Nop();
/*+CMS ERROR: 604 +CMS ERROR: 603 возникают когда модем не сконфигурирован правильно ОТРАБОТАТЬ!!!*/        
//        if (SMSSENDbits.result_code == 3518) {
//            SMS_ptr_R ++; SMS_ptr_R %= 5;
//        }
        SMS_ptr_R ++; SMS_ptr_R %= 5;
        SMSSENDbits.SMSSEND = 0;
    }
    if (send_sms_status == CMEERROR) {
        Nop();Nop();Nop();        
    }
    if (send_sms_status == SMSSENDTIMEOUT) {
        Nop();Nop();Nop();
        modem_on_off (MODEM_RESTART);
        SMSSENDbits.SMSSEND = 0;
    }
    if (send_sms_status == ATCMGSTIMEOUT) {
        Nop();Nop();Nop();
        modem_on_off (MODEM_RESTART);
    }
    if (send_sms_status == SMSSENDEXCEPTION) {
        Nop();Nop();Nop();
        modem_on_off (MODEM_RESTART);
# if defined (UC15)        
        SMSSENDbits.SMSSEND = 0;
        SMS_ptr_R ++; SMS_ptr_R %= 5;             // Если SMS отослана - инкремент указателя отсылки
# endif        
    }    
}
int  load_SMS_text_UART1_Tx_buf (char *ptr) {
    unsigned int i;
    i = 0;
    while (*ptr !=0) {
      UART1_Tx_buf[i] =  *ptr;
      i++;
      ptr ++;
    }

      UART1_Tx_buf[i++] = 0x1A;
      UART1_Tx_buf[i] = 0;
      return i;
}

int  write_text_to_SMS_buf (unsigned char *text_ptr, unsigned char *phone_ptr) {
// Возвращает 0 - если буфер FIFO не переполнен, -1 - если переполнен    
    int i, overflow;
    unsigned char *SMS_buf_ptr;
    
    overflow = 0;
    SMS_buf_ptr = SMS_to_send_ptrs_buf[SMS_ptr_W]; // Извлечение указателя на буфер, в который записываем текст SMS для отправки
    
    for ( i = 0; i < 139; i ++ ) { // Текст SMS не более 140 символов
       *SMS_buf_ptr = *text_ptr;
       if(*text_ptr == '\0' || *text_ptr == '\r') break;
       SMS_buf_ptr ++; text_ptr ++;
    }
    Nop();Nop();Nop();
    *SMS_buf_ptr = 0;
    
    SMS_buf_ptr = SMS_to_send_ptrs_buf[SMS_ptr_W] + 143;// Извлечение указателя на буфер, в который записываем текст номер телефона для отправки 
    for ( i = 0; i < 20; i ++ ) {
        *SMS_buf_ptr = *phone_ptr;
        if(*phone_ptr == '\0' || *phone_ptr == '\r' || *phone_ptr == ',') break;
        SMS_buf_ptr ++; phone_ptr ++;
    }
    Nop();Nop();Nop();
    *SMS_buf_ptr = 0;    
    
	if ((SMS_ptr_W + 1) % 5 != SMS_ptr_R) { SMS_ptr_W ++; } // Инкремент указателя записи, если буфер не заполнен
    else { SMS_ptr_R ++; SMS_ptr_R %= 5; SMS_ptr_W ++; overflow = -1;}    // иначе - инкремент буферов чтения и записи. Потеря самой старой SMS
	SMS_ptr_W %= 5;

return overflow;    
}
int  write_phone_num_to_SMS_buf (unsigned char *ptr) {
// Возвращает 0 - если буфер FIFO не переполнен, -1 - если переполнен    
    int i, overflow;
    unsigned char *SMS_buf_ptr;
    
    overflow = 0;
    SMS_buf_ptr = SMS_to_send_ptrs_buf[SMS_ptr_W]; // Извлечение указателя на буфер, в который записываем SMS для отправки
    
    for ( i = 0; i < 141; i ++ ) {
       *SMS_buf_ptr = *ptr;
       if(*ptr == '\0' || *ptr == '\r') break;
       SMS_buf_ptr ++; ptr ++;
    }
    Nop();Nop();Nop();
    *SMS_buf_ptr = 0;
    
	if ((SMS_ptr_W + 1) % 5 != SMS_ptr_R) { SMS_ptr_W ++; } // Инкремент указателя записи, если буфер не заполнен
    else { SMS_ptr_R ++; SMS_ptr_R %= 5; SMS_ptr_W ++; overflow = -1;}    // иначе - инкремент буферов чтения и записи. Потеря самой старой SMS
	SMS_ptr_W %= 5;

return overflow;    
}

int  write_SMS_number_to_buf (unsigned int SMS_num) {
// Возвращает 0 - если буфер FIFO не переполнен, -1 - если переполнен    
    int overflow;
    
    overflow = 0;
    SMS_nums_to_read_buf [SMS_read_ptr_W] = SMS_num; // Сохранение номера принятой СМС в буфере
    
	if ((SMS_read_ptr_W + 1) % 10 != SMS_read_ptr_R) { SMS_read_ptr_W ++; } // Инкремент указателя записи, если буфер не заполнен
    else { SMS_read_ptr_R ++; SMS_read_ptr_R %= 10; SMS_read_ptr_W ++; overflow = -1;}    // иначе - инкремент буферов чтения и записи. Потеря самой старой SMS
	SMS_read_ptr_W %= 10;

return overflow;     
}

int  read_SMS_from_modem (int start) {

    unsigned int num, SMSREAD;
    
    if (start == 1) SMSREADbits.start_reading = 1; // Запуск процесса передачи
        
        if ( SMSREADbits.start_reading && ! MODEMTASCKSbits.MODEMTASCKS ) {
                SMSREADbits.SMSREAD = 0;
                SMSREADbits.at_cmgr = 1;
                MODEMTASCKSbits.sms_reading = 1;
                set_sgm_tasck_busy_timer (500);
                num = SMS_nums_to_read_buf [SMS_read_ptr_R];
                start_UART1_transmission (WAITOFF, (unsigned int) load_CMGR_to_UART1_Tx_buf (num));
        } 

//union {
//   volatile unsigned long SMSREAD;
//   struct
//    {
//        unsigned char start_reading:1;
//        unsigned char at_cmgr:1;
//        unsigned char at_cmgr_ok:1;
//        unsigned char cms_error:1;
//        unsigned char cme_error:1;
//        unsigned char at_cmgr_timeout:1;
//        unsigned int :10;
//        
//        unsigned int result_code:16;
//    };
//} SMSREADbits;
    
    
//# define cmgridle    0b0000000000000000
//# define cmgrwaiting 0b0000000000000001
//# define cmgrrunning 0b0000000000000010
//# define cmgrok      0b0000000000000110     
//# define cmserror    0b0000000000001010
//# define cmeerror    0b0000000000010010
//# define cmgrtimeout 0b0000000000100010
//    
//# define CMGRIDLE        0
//# define CMGRWAITING     1
//# define CMGRRUNNING     2
//# define CMGROK          3     
//# define CMGRCMSERROR   -1
//# define CMGRCMEERROR   -2
//# define CMGRTIMEOUT    -3
//# define CMGREXCEPTION  -4
    
    SMSREAD = (unsigned int) SMSREADbits.SMSREAD;
    
    if (SMSREAD == cmgridle)                                    return CMGRIDLE;
    if (SMSREAD == cmgrwaiting)                                 return CMGRWAITING;
    if (SMSREAD == cmgrrunning)                                 return CMGRRUNNING;
    if (SMSREAD == cmgrok) { 
        MODEMTASCKSbits.sms_reading = 0;
                                                                return CMGROK;
    }
    if (SMSREAD == cmgrcmserror) {
        MODEMTASCKSbits.sms_reading = 0;
                                                                return CMGRCMSERROR;
    }
    if (SMSREAD == cmgrcmeerror) {
        MODEMTASCKSbits.sms_reading = 0;
                                                                return CMGRCMEERROR;
    }
    if (SMSREAD == cmgrtimeout) {
        MODEMTASCKSbits.sms_reading = 0;
                                                                return CMGRTIMEOUT;
    }
    
return CMGREXCEPTION;     
}
int  read_SMS_monitor (int SMS_read_status) {
unsigned char i;

    if ( SMS_read_status == CMGRIDLE ) {
        Nop();Nop();Nop();
        if ( SMS_read_ptr_R != SMS_read_ptr_W ) { read_SMS_from_modem (1); }
    }
    if ( SMS_read_status == CMGRWAITING ) {
        Nop();Nop();Nop();
    }
    if ( SMS_read_status == CMGRRUNNING ) {
        Nop();Nop();Nop();
        
    }
    if ( SMS_read_status == CMGROK ) {
        SMSREADbits.SMSREAD = 0;
        SMS_read_ptr_R ++; SMS_read_ptr_R %= 10;
        look_for_SMS_parts ();
        phone_num_check_result = check_phone_number ( PHONENUMPTR ); // Проверка номера на валидность
        if(phone_num_check_result >= 0) { // Отработка команды только валидных номеров
            if (phone_num_check_result == 0) phone_num_check_result = 5; //Если смс поступила с номера Element, то ответ отправляем другой на заданный номер
            for (i = 0; i < 16; i ++) {
                PHONE_to_send_buf[i + 1] = PHONES_buf[phone_num_check_result][i];
                if (PHONES_buf[phone_num_check_result][i] == 0 ) break;
            }
            i++;
            PHONE_to_send_buf[0] = '"'; PHONE_to_send_buf[i] = '"'; PHONE_to_send_buf[i + 1] = 0;
            PHONENUMPTR = &PHONE_to_send_buf; // указатель на массив с номером для отправки смс
            check_setting ( 3, SMSTEXTPTR );
        }
//!!!!!!!!!!!!!!!!!!!!!?????????????????????????????????????? 
/*        
        if (strstr( PHONENUMPTR, PHONE_NUMBER ) == 0) {
            write_text_to_SMS_buf ( PHONENUMPTR, PHONE_NUMBER ); //"OK\0" PHONE_NUMBER SMSTEXTPTR
        } else {write_text_to_SMS_buf ( "OK\0", PHONE_NUMBER );}
*/        
            if (SMS_read_ptr_R == SMS_read_ptr_W) {
                Nop();Nop();Nop();
                delete_SMS ( 1, AT_QMGDA_ALL ); //AT_QMGDA_READ
            }
    }     
    if ( SMS_read_status == CMGRCMSERROR ) {
        Nop();Nop();Nop();
        SMSREADbits.SMSREAD = 0;
    }
    if ( SMS_read_status == CMGRCMEERROR ) {
        Nop();Nop();Nop();
        SMSREADbits.SMSREAD = 0;
    }
    if ( SMS_read_status == CMGRTIMEOUT ) {
        Nop();Nop();Nop();
        SMSREADbits.SMSREAD = 0;
        modem_on_off (MODEM_RESTART);
    }
    if ( SMS_read_status == CMGREXCEPTION ) {
        Nop();Nop();Nop();
        MODEMTASCKSbits.sms_reading = 0;
        SMSREADbits.SMSREAD = 0;
    }
    
}
int  look_for_SMS_parts (void) {

    unsigned char *temp;
    
    SMS_parts_ptrs_buf[0] = SMS_temp_buf; // начало "REC UNREAD" 
    temp = strstr( SMS_temp_buf, "," );
    SMS_parts_ptrs_buf[1] = temp - 1;     // конец "REC UNREAD" 
    temp ++;
    SMS_parts_ptrs_buf[2] = temp;         // начало номера телефона
    temp = strstr( temp, "," );
    SMS_parts_ptrs_buf[3] = temp - 1;     // конец номера телефона
    temp ++;
    temp = strstr( temp, "," );
    temp ++;
    SMS_parts_ptrs_buf[4] = temp;         // начало даты/времени
    temp = strstr( temp, "\r\n" );
    SMS_parts_ptrs_buf[5] = temp - 1;     // конец даты/времени
//    temp = temp + 2;
    *temp = ' '; // замена \r\n пробелами
    temp ++;
    *temp = ' ';
    temp ++;
    SMS_parts_ptrs_buf[6] = temp;         // начало текста SMS
    temp = strstr( temp, "\r\n" );
    SMS_parts_ptrs_buf[7] = temp - 1;     // конец текста SMS
    *temp = '\0';
    
}
int  load_CMGR_to_UART1_Tx_buf (unsigned int sms_num) {

# if defined (UC15)
    memmove (UART1_Tx_buf, AT_CMGR_CMGF, 32);
    UART1_Tx_buf[28] = (unsigned char) (sms_num >> 8);
    UART1_Tx_buf[29] = (unsigned char) (sms_num);
    return 31;
# else    
    memmove (UART1_Tx_buf, AT_CMGR, 12);
    UART1_Tx_buf[8] = (unsigned char) (sms_num >> 8);
    UART1_Tx_buf[9] = (unsigned char) (sms_num);
    return 11;
# endif    
    
    
}

int  delete_SMS ( int start, unsigned char *type_ptr ) {

    unsigned int SMSDELETE;
    
    if (start == 1) SMSDELETEbits.start_deleting = 1; // Запуск процесса передачи
        
        if ( SMSDELETEbits.start_deleting && ! MODEMTASCKSbits.MODEMTASCKS ) {
                SMSDELETEbits.SMSDELETE = 0;
                SMSDELETEbits.at_qmgda = 1;
                MODEMTASCKSbits.sms_deleting = 1;
                set_sgm_tasck_busy_timer (500);
                start_UART1_transmission (WAITOFF, (unsigned int) load_UART1_Tx_buf (type_ptr));
        } 


    
    SMSDELETE = (unsigned int) SMSDELETEbits.SMSDELETE;
    
    if (SMSDELETE == 0b0000000000000000) return SMSDELIDLE;
    if (SMSDELETE == 0b0000000000000001) return SMSDELWAITING;
    if (SMSDELETE == 0b0000000000000010) return SMSDELRUNNING;
    if (SMSDELETE == 0b0000000000000110) {
        SMSDELETEbits.SMSDELETE = 0;
        MODEMTASCKSbits.sms_deleting = 0;
                                         return SMSDELOK;
    }
    if (SMSDELETE == 0b0000000000001010) {
        SMSDELETEbits.SMSDELETE = 0;
        MODEMTASCKSbits.sms_deleting = 0;
                                         return SMSDELERROR;
    }
    if (SMSDELETE == 0b0000000000010010) {
        SMSDELETEbits.SMSDELETE = 0;
        MODEMTASCKSbits.sms_deleting = 0;
                                         return SMSDELCMSERROR;
    }
    if (SMSDELETE == 0b0000000000100010) {
        SMSDELETEbits.SMSDELETE = 0;
        MODEMTASCKSbits.sms_deleting = 0;
                                         return SMSDELTIMEOUT;
    }
    
    SMSDELETEbits.SMSDELETE = 0;
    MODEMTASCKSbits.sms_deleting = 0;  
    
return SMSDELEXCEPTION;    
}

int  check_udp_data_correctness (unsigned char *buf_ptr) {
    if (*buf_ptr != '&')         return -1; buf_ptr ++;
//    if (*buf_ptr != IMEI_str[0]) return -1; buf_ptr ++;
//    if (*buf_ptr != IMEI_str[1]) return -1; buf_ptr ++;
//    if (*buf_ptr != IMEI_str[2]) return -1; buf_ptr ++;
//    if (*buf_ptr != IMEI_str[3]) return -1; buf_ptr ++;
//    if (*buf_ptr != IMEI_str[4]) return -1; buf_ptr ++;
//    if (*buf_ptr != IMEI_str[5]) return -1; buf_ptr ++;
//    if (*buf_ptr != IMEI_str[6]) return -1; buf_ptr ++;
//    if (*buf_ptr != IMEI_str[7]) return -1; buf_ptr ++;
//    if (*buf_ptr != IMEI_str[8]) return -1; buf_ptr ++;
//    if (*buf_ptr != IMEI_str[9]) return -1; buf_ptr ++;
//    if (*buf_ptr != IMEI_str[10]) return -1; buf_ptr ++;
//    if (*buf_ptr != IMEI_str[11]) return -1; buf_ptr ++;
//    if (*buf_ptr != IMEI_str[12]) return -1; buf_ptr ++;
//    if (*buf_ptr != IMEI_str[13]) return -1; buf_ptr ++;
//    if (*buf_ptr != IMEI_str[14]) return -1; buf_ptr ++;
    
    return 0;
}
int  send_through_udp1 ( int start ) {
    unsigned int temp; 
    static unsigned int length;
    static unsigned char *ptr_to_send;

    if (start == 1) GPRSSENDbits.start_sending = 1; // Запуск процесса передачи

        // Если AT+QISEND еще не отправлена в модем
        if ( GPRSSENDbits.start_sending == 1 && MODEMTASCKSbits.MODEMTASCKS == 0 ) {
                GPRSSENDbits.GPRSSEND = 0;
                GPRSSENDbits.at_qisend = 1;
                MODEMTASCKSbits.data_sending = 1; // Устанавливаем флаг занятости модема
                
                ptr_to_send = GPRS_nums_to_send_buf[GPRS_send_ptr_R]; //SMS_ptr_R GPRS_send_ptr_R
                length = *(ptr_to_send + 128);
                length = *(ptr_to_send + 129) + (length << 8);
                
                if ((length == 0)) {//||(length > 113)
                    Nop();Nop();Nop();
                    GPRS_send_ptr_R ++; GPRS_send_ptr_R %= 5; // Если длина ссобщения равна нулю - инкремент указателя отсылки
                } else {
//                if (check_udp_data_correctness ( ptr_to_send ) == -1 ) {
//                    Nop();Nop();Nop();
//                    GPRS_send_ptr_R ++; GPRS_send_ptr_R %= 5; // Если данные искажены - инкремент указателя отсылки
//                }
                
                    bin_2_bcd ((long ) length);
# if defined (UC15)
    volatile unsigned char i = 0, j = 0, k = 0, l = 0;
    
                for ( i = 6; i <= 8; i ++ ) {
                    if ( bin_2_bcd_buf[i] > 0x30 ) {j = i; break;}
                }
                k = 9 - j;
                for ( i = 0; i < k; i ++ ) {
                    l = i + 12;
                    AT_QISEND_LEN[l] = bin_2_bcd_buf[j];
                    j++;
                }
                l ++;
Nop();Nop();Nop();    
                AT_QISEND_LEN[l++] = '\r';
                AT_QISEND_LEN[l] = 0;
Nop();Nop();Nop();     
           
# else
                    AT_QISEND_LEN[10] = '0'; AT_QISEND_LEN[11] = bin_2_bcd_buf[6];
                    AT_QISEND_LEN[12] = bin_2_bcd_buf[7]; AT_QISEND_LEN[13] = bin_2_bcd_buf[8];
# endif
                    set_sgm_tasck_busy_timer (500);  // Таймаут сообщения модема об отсылке 2 секунды                
                    load_UART1_Tx_buf1 (AT_QISEND_LEN, 15);
                    start_UART1_transmission (WAITOFF, 15);
                }
        }
         // AT+QISEND уже отправлена в модем и от модема получено >
        if ( GPRSSENDbits.at_qisend && GPRSSENDbits.cntrlz ) {
                GPRSSENDbits.at_qisend = 0;
                ACK_timer = 1;               // Запуск таймера акноледжа
                GPRSSENDbits.waiting_send_ok = 1;
                
                load_UART1_Tx_buf1 (ptr_to_send, length);
                start_UART1_transmission (WAITOFF, length);
        }

//        if (ACK_timer > 0) {
//            if ( ACK_timer == 2 ) { clear_gsm_task_busy_timer (); }
//            if (GPRSSENDbits.received_ACK == 1) { // Пришел вовремя акноледж
//                ACK_timer = 0;
//            } else {
//                if (ACK_timer < 30) {ACK_timer ++;} // Таймер акноледжа 5 секунд
//                else { ACK_timer = 0; GPRSSENDbits.ACK_timeout_flag = 1; }
//             }
//        } // (ACK_timer > 0)


    if (GPRSSENDbits.GPRSSEND == 0b0000000000000000)     return GPRSSENDIDLE;   //
    if (GPRSSENDbits.GPRSSEND == 0b0000000000000001)     return GPRSSENDWAITING;//start_sending
    if (GPRSSENDbits.GPRSSEND == 0b0000000000000010)     return QISENDRUNNING;  //at_qisend
    if (GPRSSENDbits.GPRSSEND == 0b0000000000001100)     return WAITINGSENDOK;  //cntrlz && wating_send_ok
//    if (GPRSSENDbits.GPRSSEND == 0b0000000000101100) {                          //cntrlz && wating_ACK && send_ok 
////        MODEMTASCKSbits.data_sending = 0;
//                                                         return WAITINGACK;     
//    }
    if (GPRSSENDbits.GPRSSEND == 0b0000000000101100) {                          //cntrlz && wating_send_ok && send_ok 
        MODEMTASCKSbits.data_sending = 0;
        clear_gsm_task_busy_timer ();
                                                         return GPRSSENDSUCCESS;
    }     
    if (GPRSSENDbits.GPRSSEND == 0b0000000010000010) {                          //cntrlz && wating_send_ok && send_error
        MODEMTASCKSbits.data_sending = 0;
        clear_gsm_task_busy_timer ();
                                                         return SENDERROR;    
    }   
    if (GPRSSENDbits.GPRSSEND == 0b0000000001001100) {                          //cntrlz && wating_send_ok && send_faile
        MODEMTASCKSbits.data_sending = 0;
        clear_gsm_task_busy_timer ();
                                                         return SENDFAILE;    
    }   
    if (GPRSSENDbits.GPRSSEND == 0b0000000100000010) {                          //cntrlz && wating_send_ok && qisend_timeout
        MODEMTASCKSbits.data_sending = 0;
                                                         return QISENDTIMEOUT;    
    }   
//    if (GPRSSENDbits.GPRSSEND == 0b0000001000101100) {                          //cntrlz && wating_ACK && send_ok && ACK_timeout_flag
//        MODEMTASCKSbits.data_sending = 0;
//                                                         return GPRSACKTIMEOUT;    
//    }   
    
    return GPRSSENDEXCEPTION;

}  // Предача через UDP
int  send_through_udp_monitor (int send_through_udp_status, int server_connection_status) {

    
    if (send_through_udp_status == GPRSSENDIDLE && server_connection_status == 4) {
        Nop();Nop();Nop();
        if (FLASHBUSYbits.FLASHBUSY == 0) {
            if ( GPRS_send_ptr_R != GPRS_send_ptr_W ) send_through_udp1 (1); // Если задача свободна и есть данные для отправки - запуск отсылки SMS
        }
    }
    if (send_through_udp_status == GPRSSENDWAITING) {
        Nop();Nop();Nop();
    }
    if (send_through_udp_status == QISENDRUNNING) {
        Nop();Nop();Nop();
    }    
    if (send_through_udp_status == WAITINGSENDOK) {
        Nop();Nop();Nop();
    }
//    if (send_through_udp_status == WAITINGACK) {
//        Nop();Nop();Nop();
//    }    
    if (send_through_udp_status == GPRSSENDSUCCESS) {
        Nop();Nop();Nop();
        GPRSSENDbits.GPRSSEND = 0;
        GPRS_send_ptr_R ++; GPRS_send_ptr_R %= 5;             // Если GPRS отослана - инкремент указателя отсылки
    }
    if (send_through_udp_status == SENDERROR ) {
        Nop();Nop();Nop();
        GPRSSENDbits.GPRSSEND = 0;
        modem_on_off (MODEM_RESTART);
    }
    if (send_through_udp_status == SENDFAILE ) {
        Nop();Nop();Nop();
        GPRSSENDbits.GPRSSEND = 0;
    }
    if (send_through_udp_status == QISENDTIMEOUT ) {
        Nop();Nop();Nop();
        GPRSSENDbits.GPRSSEND = 0;
        modem_on_off (MODEM_RESTART);
    }    
//    if (send_through_udp_status == GPRSACKTIMEOUT ) {
//        Nop();Nop();Nop();
//        GPRSSENDbits.GPRSSEND = 0;
//        GPRS_send_ptr_R ++; GPRS_send_ptr_R %= 5; // Чтобы не ждать акноледж        
//    }
    if (send_through_udp_status == GPRSSENDEXCEPTION ) {
        Nop();Nop();Nop();
//        write_text_to_SMS_buf ( "GPRS send exception: ", PHONE_NUMBER );
        Nop();Nop();Nop();        
        GPRSSENDbits.GPRSSEND = 0;
        modem_on_off (MODEM_RESTART);
    }    
        
}
int  write_data_to_GPRS_buf (unsigned char *data_ptr, unsigned int length) {
// Возвращает 0 - если буфер FIFO не переполнен, -1 - если переполнен    
    int overflow, i;
    unsigned char *GPRS_data_buf_ptr;
    unsigned char *temp;
    unsigned int crc16;
    
        temp = data_ptr;
        Nop();Nop();Nop();
        crc16 = CRC16( data_ptr, length ); // рассчет контрольной суммы
        *(temp + length) = (unsigned char)(crc16 >> 8); *(temp + length + 1) = (unsigned char)crc16;
        Nop();Nop();Nop();    
        length = length + 2;
        
    GPRS_data_buf_ptr = GPRS_nums_to_send_buf[GPRS_send_ptr_W]; // Извлечение указателя на буфер, в который записываем текст SMS для отправки

    for ( i = 0; i < length; i ++ ) {
        *GPRS_data_buf_ptr = *data_ptr;
        GPRS_data_buf_ptr ++; data_ptr ++;
    }
    
    GPRS_data_buf_ptr = GPRS_nums_to_send_buf[GPRS_send_ptr_W];
    GPRS_data_buf_ptr = GPRS_data_buf_ptr + 128;
    *GPRS_data_buf_ptr = (unsigned char) (length >> 8);
    GPRS_data_buf_ptr ++; *GPRS_data_buf_ptr = *GPRS_data_buf_ptr << 8;
    *GPRS_data_buf_ptr = *GPRS_data_buf_ptr + (unsigned char) length;
    
    overflow = 0;
	if ((GPRS_send_ptr_W + 1) % 5 != GPRS_send_ptr_R) { GPRS_send_ptr_W ++; } // Инкремент указателя записи, если буфер не заполнен
    else { GPRS_send_ptr_R ++; GPRS_send_ptr_R %= 5; GPRS_send_ptr_W ++; overflow = -1;}    // иначе - инкремент буферов чтения и записи. Потеря самой старой SMS
	GPRS_send_ptr_W %= 5;

return overflow;     
}

/* ЗАПИСЬ, ЧТЕНИЕ ВО ФЛЕШ */
int  writeSPI2 ( int data ){
	SPI2BUF = data;
	while ( !SPI2STATbits.SPIRBF );
return SPI2BUF;
}	// writeSPI2()
int  read_SST25_status (void){
CS_at45 = 0;
	writeSPI2(0x05);
	writeSPI2(0x00);
CS_at45 = 1;
return SPI2BUF;
}	// Чтение регистра "STATUS"
long SST25_read_var_from_flash ( unsigned long addr, unsigned char num_of_bytes ) {

    int temp;
    unsigned char addr2, addr1, addr0;
long flash_data;

    if ( num_of_bytes == 0 || num_of_bytes > 4 ) return 0;

CS_at45 = 0;
   	SPI2BUF = 0x06; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда разрешения записи
CS_at45 = 1;

Nop();Nop();Nop();
Nop();Nop();Nop();
Nop();Nop();Nop();
Nop();Nop();Nop();


    flash_data = 0;
    addr2 = (unsigned char) (addr >> 16);
    addr1 = (unsigned char) (addr >> 8);    
    addr0 = (unsigned char)  addr;
    
CS_at45 = 0;

   	SPI2BUF = 0x03; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда чтения

   	SPI2BUF = addr2;  while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;   
   	SPI2BUF = addr1;  while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
   	SPI2BUF = addr0;  while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
    
//   	SPI2BUF = (unsigned char) ( addr >> 16); while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;   
//   	SPI2BUF = (unsigned char) ( addr >> 8);  while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
//   	SPI2BUF = (unsigned char)   addr;        while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
    
    if ( num_of_bytes == 1 ) {
        SPI2BUF = 0; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
        CS_at45 = 1;
        flash_data = (long) temp;
        return flash_data;
    } 

    if ( num_of_bytes == 2 ) {
        SPI2BUF = 0; while ( !SPI2STATbits.SPIRBF ); flash_data = ( long )SPI2BUF;        
        SPI2BUF = 0; while ( !SPI2STATbits.SPIRBF ); flash_data = ( flash_data << 8 ) + ( long )SPI2BUF;
        CS_at45 = 1;
        return flash_data;        
    }
        
    if ( num_of_bytes == 3 ) {
        SPI2BUF = 0; while ( !SPI2STATbits.SPIRBF ); flash_data = ( long )SPI2BUF;        
        SPI2BUF = 0; while ( !SPI2STATbits.SPIRBF ); flash_data = ( flash_data << 8 ) + ( long )SPI2BUF;
        SPI2BUF = 0; while ( !SPI2STATbits.SPIRBF ); flash_data = ( flash_data << 8 ) + ( long )SPI2BUF;
        CS_at45 = 1;
        return flash_data;        
    }
    
    if ( num_of_bytes == 4 ) {
        SPI2BUF = 0; while ( !SPI2STATbits.SPIRBF ); flash_data = ( long )SPI2BUF;        
        SPI2BUF = 0; while ( !SPI2STATbits.SPIRBF ); flash_data = ( flash_data << 8 ) + ( long )SPI2BUF;
        SPI2BUF = 0; while ( !SPI2STATbits.SPIRBF ); flash_data = ( flash_data << 8 ) + ( long )SPI2BUF;        
        SPI2BUF = 0; while ( !SPI2STATbits.SPIRBF ); flash_data = ( flash_data << 8 ) + ( long )SPI2BUF;
        CS_at45 = 1;
        return flash_data;        
    }            
            
CS_at45 = 1;

/*CS_at45 = 0;

   	SPI2BUF = 0x03; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда чтения

   	SPI2BUF = (unsigned char) ( addr >> 16); while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;   
   	SPI2BUF = (unsigned char) ( addr >> 8);  while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
   	SPI2BUF = (unsigned char)   addr;        while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
    
    if ( len == 1) {
        SPI2BUF = 0; while ( !SPI2STATbits.SPIRBF ); flash_1_byte = (char)SPI2BUF;
        return &flash_1_byte;
    }
    
    if ( len == 2) {
        SPI2BUF = 0; while ( !SPI2STATbits.SPIRBF ); flash_2_bytes = (int)SPI2BUF;
        SPI2BUF = 0; while ( !SPI2STATbits.SPIRBF ); flash_2_bytes = ( flash_2_bytes << 8 ) + (int)SPI2BUF;        
        return &flash_2_bytes;            
    }
    
    if ( len == 3 ) {
        SPI2BUF = 0; while ( !SPI2STATbits.SPIRBF ); flash_3_bytes = (long)SPI2BUF;
        SPI2BUF = 0; while ( !SPI2STATbits.SPIRBF ); flash_3_bytes = ( flash_3_bytes << 8 ) + (long)SPI2BUF;
        SPI2BUF = 0; while ( !SPI2STATbits.SPIRBF ); flash_3_bytes = ( flash_3_bytes << 8 ) + (long)SPI2BUF;
        return templ;                
    }
    
    if ( len == 4 ) {
        SPI2BUF = 0; while ( !SPI2STATbits.SPIRBF ); flash_4_bytes = (long)SPI2BUF;
        SPI2BUF = 0; while ( !SPI2STATbits.SPIRBF ); flash_4_bytes = ( flash_4_bytes << 8 ) + (long)SPI2BUF;
        SPI2BUF = 0; while ( !SPI2STATbits.SPIRBF ); flash_4_bytes = ( flash_4_bytes << 8 ) + (long)SPI2BUF;
        SPI2BUF = 0; while ( !SPI2STATbits.SPIRBF ); flash_4_bytes = ( flash_4_bytes << 8 ) + (long)SPI2BUF;        
        return &flash_4_bytes;                
    }
    
CS_at45 = 1;
*/

return 0;
}	// Чтение 1, 2, 3 или 4 байт из флэш SST25{
unsigned char SST25_read_byte_from_flash ( unsigned long addr ) {

    int temp;
    unsigned char addr2, addr1, addr0;
long flash_data;



CS_at45 = 0;
   	SPI2BUF = 0x06; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда разрешения записи
CS_at45 = 1;

Nop();Nop();Nop();
Nop();Nop();Nop();
Nop();Nop();Nop();
Nop();Nop();Nop();


    flash_data = 0;
    addr2 = (unsigned char) (addr >> 16);
    addr1 = (unsigned char) (addr >> 8);    
    addr0 = (unsigned char)  addr;
    
CS_at45 = 0;

   	SPI2BUF = 0x03; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда чтения

   	SPI2BUF = addr2;  while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;   
   	SPI2BUF = addr1;  while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
   	SPI2BUF = addr0;  while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
    
    SPI2BUF = 0; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
CS_at45 = 1;
        
return (unsigned char) temp;

}
long SST25_read_var_from_page ( unsigned int page_num, unsigned char addr_in_page, unsigned char len_to_read ) {

    unsigned long addr;
    long temp;
    
    addr = (unsigned long)page_num;
    addr = addr * 128 + (unsigned long)addr_in_page;

    if ( len_to_read == 0 || len_to_read > 4 ) return 0;

    temp = SST25_read_var_from_flash ( addr, len_to_read );
    return temp;

}
void SST25_read_page_to_buf ( unsigned int page_num, char *buf_to_read_ptr, unsigned int len ) {
long addr;
unsigned int i;

    addr = (long) page_num;
    addr = addr * 128;

CS_at45 = 0;

   	SPI2BUF = 0x03; while ( !SPI2STATbits.SPIRBF ); i = SPI2BUF; // команда чтения

   	SPI2BUF = (unsigned char) ( addr >> 16); while ( !SPI2STATbits.SPIRBF ); i = SPI2BUF;   
   	SPI2BUF = (unsigned char) ( addr >> 8);  while ( !SPI2STATbits.SPIRBF ); i = SPI2BUF;
   	SPI2BUF = (unsigned char)   addr;        while ( !SPI2STATbits.SPIRBF ); i = SPI2BUF;

    for (i = 0; i < len; i ++) {
        SPI2BUF = 0; while ( !SPI2STATbits.SPIRBF ); *buf_to_read_ptr = ( unsigned char )SPI2BUF;
        buf_to_read_ptr ++;
    }

CS_at45 = 1;

} 
void SST25_write_var_to_page  ( unsigned int page_num, unsigned char addr_in_page, long data, unsigned char len ) {

    unsigned long addr;
    
    addr = (unsigned long)page_num;
    addr = addr * 128 + (unsigned long)addr_in_page;
    
    SST25_write_var_to_flash ( addr, data, len );
    
}
void SST25_write_var_to_flash ( unsigned long addr, long data, unsigned char len ) {

int  temp;    
//long flash_data;




    if ( len == 1 ) {
        CS_at45 = 0; SPI2BUF = 0x06; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; CS_at45 = 1;// команда разрешения записи
        Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
        CS_at45 = 0;    
            SPI2BUF = 0x02; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда записи одного байта
            SPI2BUF = (unsigned char) ( addr >> 16); while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;   
            SPI2BUF = (unsigned char) ( addr >> 8);  while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
            SPI2BUF = (unsigned char)   addr;        while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
            SPI2BUF = (int) data; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
        CS_at45 = 1;
            __delay_us (11);    
        return;
    }
    
    if ( len == 2) {
        CS_at45 = 0; SPI2BUF = 0x06; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; CS_at45 = 1;// команда разрешения записи
        Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
        CS_at45 = 0;    
            SPI2BUF = 0x02; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда записи одного байта
            SPI2BUF = (unsigned char) ( addr >> 16); while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;   
            SPI2BUF = (unsigned char) ( addr >> 8);  while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
            SPI2BUF = (unsigned char)   addr;        while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
            SPI2BUF = (int) ( data >> 8 ); while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
        CS_at45 = 1;
            __delay_us (11);
            addr ++;
        CS_at45 = 0; SPI2BUF = 0x06; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; CS_at45 = 1;// команда разрешения записи
        Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
        CS_at45 = 0;    
            SPI2BUF = 0x02; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда записи одного байта
            SPI2BUF = (unsigned char) ( addr >> 16); while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;   
            SPI2BUF = (unsigned char) ( addr >> 8);  while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
            SPI2BUF = (unsigned char)   addr;        while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
            SPI2BUF = (int) data; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
        CS_at45 = 1;
            __delay_us (11);    
        return;    
    }
    
    if ( len == 3 ) {
        CS_at45 = 0; SPI2BUF = 0x06; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; CS_at45 = 1;// команда разрешения записи
        Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
        CS_at45 = 0;    
            SPI2BUF = 0x02; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда записи одного байта
            SPI2BUF = (unsigned char) ( addr >> 16); while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;   
            SPI2BUF = (unsigned char) ( addr >> 8);  while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
            SPI2BUF = (unsigned char)   addr;        while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
            SPI2BUF = (int) ( data >> 16 ); while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
        CS_at45 = 1;
            __delay_us (11);
            addr ++;
        CS_at45 = 0; SPI2BUF = 0x06; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; CS_at45 = 1;// команда разрешения записи
        Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
        CS_at45 = 0;    
            SPI2BUF = 0x02; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда записи одного байта
            SPI2BUF = (unsigned char) ( addr >> 16); while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;   
            SPI2BUF = (unsigned char) ( addr >> 8);  while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
            SPI2BUF = (unsigned char)   addr;        while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
            SPI2BUF = (int) ( data >> 8 ); while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
        CS_at45 = 1;
            __delay_us (11);
            addr ++;
        CS_at45 = 0; SPI2BUF = 0x06; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; CS_at45 = 1;// команда разрешения записи
        Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
        CS_at45 = 0;    
            SPI2BUF = 0x02; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда записи одного байта
            SPI2BUF = (unsigned char) ( addr >> 16); while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;   
            SPI2BUF = (unsigned char) ( addr >> 8);  while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
            SPI2BUF = (unsigned char)   addr;        while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
            SPI2BUF = (int) data; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
        CS_at45 = 1;
            __delay_us (11);
    }
    
    if ( len == 4 ) {
        CS_at45 = 0; SPI2BUF = 0x06; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; CS_at45 = 1;// команда разрешения записи
        Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
        CS_at45 = 0;    
            SPI2BUF = 0x02; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда записи одного байта
            SPI2BUF = (unsigned char) ( addr >> 16); while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;   
            SPI2BUF = (unsigned char) ( addr >> 8);  while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
            SPI2BUF = (unsigned char)   addr;        while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
            SPI2BUF = (int) ( data >> 24 ); while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
        CS_at45 = 1;
            __delay_us (11);
            addr ++;
        CS_at45 = 0; SPI2BUF = 0x06; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; CS_at45 = 1;// команда разрешения записи
        Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
        CS_at45 = 0;    
            SPI2BUF = 0x02; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда записи одного байта
            SPI2BUF = (unsigned char) ( addr >> 16); while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;   
            SPI2BUF = (unsigned char) ( addr >> 8);  while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
            SPI2BUF = (unsigned char)   addr;        while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
            SPI2BUF = (int) ( data >> 16 ); while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
        CS_at45 = 1;
            __delay_us (11);
            addr ++;
        CS_at45 = 0; SPI2BUF = 0x06; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; CS_at45 = 1;// команда разрешения записи
        Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
        CS_at45 = 0;    
            SPI2BUF = 0x02; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда записи одного байта
            SPI2BUF = (unsigned char) ( addr >> 16); while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;   
            SPI2BUF = (unsigned char) ( addr >> 8);  while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
            SPI2BUF = (unsigned char)   addr;        while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
            SPI2BUF = (int) ( data >> 8 ); while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
        CS_at45 = 1;
            __delay_us (11);
            addr ++;
        CS_at45 = 0; SPI2BUF = 0x06; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; CS_at45 = 1;// команда разрешения записи
        Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
        CS_at45 = 0;    
            SPI2BUF = 0x02; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда записи одного байта
            SPI2BUF = (unsigned char) ( addr >> 16); while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;   
            SPI2BUF = (unsigned char) ( addr >> 8);  while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
            SPI2BUF = (unsigned char)   addr;        while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
            SPI2BUF = (int) data; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
        CS_at45 = 1;
            __delay_us (11);            
    }

    Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
    CS_at45 = 0; 
        SPI2BUF = 0x04; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; 
    CS_at45 = 1;// команда запрещения записи

    
CS_at45 = 1;

return;
}	// Чтение 1, 2, 3 или 4 байт из флэш SST25
void SST25_write_page_to_flash ( unsigned int page_num, char *buf_to_save_ptr ) {

    unsigned int i, temp;
    unsigned long addr;
    
//    addr = page_num * 128;
    
    addr = (long) page_num;
    addr = addr * 128;
    
    CS_at45 = 0; SPI2BUF = 0x06; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; CS_at45 = 1;// команда разрешения записи
    Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();

        CS_at45 = 0;    
            SPI2BUF = 0xAD; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда записи одного байта
            SPI2BUF = (unsigned char) ( addr >> 16); while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;   
            SPI2BUF = (unsigned char) ( addr >> 8);  while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
            SPI2BUF = (unsigned char)   addr;        while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
            SPI2BUF = (int) *buf_to_save_ptr ++;     while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
            SPI2BUF = (int) *buf_to_save_ptr ++;     while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
        CS_at45 = 1;
            __delay_us (11);     
    
    for ( i = 2; i <= 112; i = i + 2 ) {
        CS_at45 = 0;
            SPI2BUF = 0xAD;                      while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда записи одного байта
            SPI2BUF = (int) *buf_to_save_ptr ++; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
            SPI2BUF = (int) *buf_to_save_ptr ++; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
        CS_at45 = 1;    
            __delay_us (11);
    }

    Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
    CS_at45 = 0; 
        SPI2BUF = 0x04; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;// команда зарещения записи  
    CS_at45 = 1;           
    
}
void SST25_write_status_reg ( int data ) {
    int temp;
CS_at45 = 0;
   	SPI2BUF = 0x50; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда разрешения записи
CS_at45 = 1;

Nop();Nop();Nop();
Nop();Nop();Nop();

CS_at45 = 0;
   	SPI2BUF = 0x01; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
    SPI2BUF = data; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
CS_at45 = 1;


}
void SST25_sector_erase ( unsigned int sector_num, int wait ) {
    
    unsigned long addr;
    int temp;
CS_at45 = 0;
   	SPI2BUF = 0x06; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда разрешения записи
CS_at45 = 1;

Nop();Nop();Nop();
Nop();Nop();Nop();

addr = (unsigned long)sector_num;
addr = addr * 4096;

CS_at45 = 0;
   	SPI2BUF = 0x20; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда стирания сектора
    SPI2BUF = (unsigned char)( addr >> 16 ); while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
    SPI2BUF = (unsigned char)( addr >> 8 );  while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
    SPI2BUF = (unsigned char)  addr;         while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
CS_at45 = 1;

if (wait == 1) {
    __delay_ms (50);
}
    
}
void SST25_chip_erase ( unsigned char wait ) {
    
    //unsigned long addr;
    int temp;
CS_at45 = 0;
   	SPI2BUF = 0x06; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда разрешения записи
CS_at45 = 1;

Nop();Nop();Nop();
Nop();Nop();Nop();
Nop();Nop();Nop();
Nop();Nop();Nop();

CS_at45 = 0;
   	SPI2BUF = 0x60; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда стирания всей памяти
CS_at45 = 1;

if (wait == 1) {
    __delay_ms (52);
}
    
}
//int  write_data_to_flash ( unsigned char *data_ptr, unsigned int length ) {
//unsigned int temp;   
//static unsigned long number_of_event_tmp;
//
//temp = (unsigned int) SST25_read_var_from_page ( flash_ptr_W, 0, 1 );
//
//    number_of_event ++;
//
//    SST25_write_page_to_flash ( flash_ptr_W, data_ptr );
//    SST25_write_var_to_page   ( flash_ptr_W, 114, (long)GPS_odometer, 4 );
//    SST25_write_var_to_page   ( flash_ptr_W, 119, (long)flash_ptr_R, 2 );
//    SST25_write_var_to_page   ( flash_ptr_W, 121, (long)flash_ptr_W, 2 );
//    SST25_write_var_to_page   ( flash_ptr_W, 123, number_of_event, 4 );
//    
//	if ((flash_ptr_W + 1) % 20000 != flash_ptr_R) { flash_ptr_W ++; } // Инкремент указателя записи, если буфер не заполнен
//    else { 
//        flash_ptr_R ++; flash_ptr_R %= 20000;
//        FM25_write_2( 67, (unsigned int) flash_ptr_R );
//        flash_ptr_W ++; // иначе - инкремент буферов чтения и записи. Потеря самой старой SMS
//    }    
//	flash_ptr_W %= 20000;
//    FM25_write_2( 69, (unsigned int) flash_ptr_W );
//
//// Проверка стертости следующей страницы    
///*    next_sector_addr = (ptr_W + 1) % 20000; */
//    temp = (unsigned int) SST25_read_var_from_page ( flash_ptr_W, 0, 1 );    
//    if ( temp != 0xFF ) {                                          // Страница не стерта
//        
//        if ( flash_ptr_R >= flash_ptr_W ) {
//            if ( ( flash_ptr_R - flash_ptr_W ) < 32 ) { // Указатель чтения принадлежит к стираемому сектору
//                flash_ptr_R = (flash_ptr_R + 32) % 20000;
//            }
//        }
//        
//        SST25_sector_erase (  (flash_ptr_W >> 5), 1 );
//        FM25_write_2( 67, (unsigned int) flash_ptr_R );
//        FM25_write_2( 69, (unsigned int) flash_ptr_W );
//    }
//}

unsigned long SST26_read_device_id (void) {
unsigned long temp;

    CS_at45 = 0;
    
        SPI2BUF = 0x9F; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; 
        temp = 0;
        SPI2BUF = 0; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;   
        SPI2BUF = 0; while ( !SPI2STATbits.SPIRBF ); temp = (temp << 8) + SPI2BUF;
        SPI2BUF = 0; while ( !SPI2STATbits.SPIRBF ); temp = (temp << 8) + SPI2BUF;
 
    CS_at45 = 1;
    
Nop();Nop();Nop();    
return temp;    
}
unsigned int SST26_read_configuration_register (void) {
unsigned int temp;

    CS_at45 = 0;
    
        SPI2BUF = 0x35; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; 
        temp = 0;
        SPI2BUF = 0; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;   

 
    CS_at45 = 1;
    
Nop();Nop();Nop();    
return temp;    
}
void SST26_Global_Block_Protection_Unlock (void) {
int temp;
    CS_at45 = 0; SPI2BUF = 0x06; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; CS_at45 = 1;// команда разрешения записи
    Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
    CS_at45 = 0;
        SPI2BUF = 0x98; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; 
    CS_at45 = 1;
    
}
void SST26_write_page_to_flash ( unsigned int page_num, char *buf_to_save_ptr ) {

    unsigned int i, temp;
    unsigned long addr;
    
    addr = 0;
    addr = (long) page_num;
    addr = addr * 256;

    CS_at45 = 0; SPI2BUF = 0x06; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; CS_at45 = 1;// команда разрешения записи
    Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
    
    CS_at45 = 0;
    
        SPI2BUF = 0x02; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; 

        SPI2BUF = (unsigned char) ( addr >> 16 ); while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;   
        SPI2BUF = (unsigned char) ( addr >> 8 );  while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
        SPI2BUF = (unsigned char)   addr;         while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
        
        for ( i = 0; i < 256; i ++ ) {
            SPI2BUF = (int) *buf_to_save_ptr ++; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
        }
 
    CS_at45 = 1;

    Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
    CS_at45 = 0; 
        SPI2BUF = 0x04; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;// команда зарещения записи  
    CS_at45 = 1;    
    
}
void SST26_write_page128_to_flash ( unsigned int page_num, char *buf_to_save_ptr ) {

    unsigned int i, temp;
    unsigned long addr;
    
    addr = 0;
    addr = (long) page_num;
    addr = addr * 128;

    CS_at45 = 0; SPI2BUF = 0x06; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; CS_at45 = 1;// команда разрешения записи
    Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
    
    CS_at45 = 0;
    
        SPI2BUF = 0x02; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; 

        SPI2BUF = (unsigned char) ( addr >> 16 ); while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;   
        SPI2BUF = (unsigned char) ( addr >> 8 );  while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
        SPI2BUF = (unsigned char)   addr;         while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
        
        for ( i = 0; i < 256; i ++ ) {
            SPI2BUF = (int) *buf_to_save_ptr ++; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
        }
 
    CS_at45 = 1;

    Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
    CS_at45 = 0; 
        SPI2BUF = 0x04; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;// команда зарещения записи  
    CS_at45 = 1;    
    
}
void SST26_write_page_to_flash2 ( unsigned long addr, char *buf_to_save_ptr ) {

    unsigned int i, temp;
//    unsigned long addr;
    
//    addr = 0;
//    addr = (long) page_num;
//    addr = addr * 256;

    CS_at45 = 0; SPI2BUF = 0x06; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; CS_at45 = 1;// команда разрешения записи
    Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
    
    CS_at45 = 0;
    
        SPI2BUF = 0x02; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; 

        SPI2BUF = (unsigned char) ( addr >> 16 ); while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;   
        SPI2BUF = (unsigned char) ( addr >> 8 );  while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
        SPI2BUF = (unsigned char)   addr;         while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
        
        for ( i = 0; i < 256; i ++ ) {
            SPI2BUF = (int) *buf_to_save_ptr ++; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
        }
 
    CS_at45 = 1;

    Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();
    CS_at45 = 0; 
        SPI2BUF = 0x04; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;// команда зарещения записи  
    CS_at45 = 1;    
    
}
void SST26_sector_erase_by_addr ( unsigned long sector_num, int wait ) {
    
    unsigned long addr;
    int temp;
CS_at45 = 0;
   	SPI2BUF = 0x06; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда разрешения записи
CS_at45 = 1;

Nop();Nop();Nop();
Nop();Nop();Nop();

addr = (unsigned long)sector_num;
addr = addr * 4096;

CS_at45 = 0;
   	SPI2BUF = 0x20; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда стирания сектора
    SPI2BUF = (unsigned char)( addr >> 16 ); while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
    SPI2BUF = (unsigned char)( addr >> 8 );  while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
    SPI2BUF = (unsigned char)  addr;         while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF;
CS_at45 = 1;

if (wait == 1) {
    __delay_ms (30);
}
    
}
void SST26_reset (void) {
int temp;    
CS_at45 = 0;
   	SPI2BUF = 0x06; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда разрешения записи
CS_at45 = 1;

Nop();Nop();Nop();
Nop();Nop();Nop();
Nop();Nop();Nop();
Nop();Nop();Nop();

CS_at45 = 0;
   	SPI2BUF = 0x66; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда разрешения записи
CS_at45 = 1;

Nop();Nop();Nop();
Nop();Nop();Nop();
Nop();Nop();Nop();
Nop();Nop();Nop();

CS_at45 = 0;
   	SPI2BUF = 0x99; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда разрешения записи
CS_at45 = 1;

Nop();Nop();Nop();
Nop();Nop();Nop();
Nop();Nop();Nop();
Nop();Nop();Nop();

CS_at45 = 0;
   	SPI2BUF = 0xFF; while ( !SPI2STATbits.SPIRBF ); temp = SPI2BUF; // команда разрешения записи
CS_at45 = 1;

Nop();Nop();Nop();
Nop();Nop();Nop();
Nop();Nop();Nop();
Nop();Nop();Nop();
}

void read_saved_parameters (void) {
/* Поиск и последнего сообщения в памяти и считывание параметров */        
unsigned long number_of_event_max;
unsigned int /*i,*/ j/*, k, flash_ptr_R_last*/;
        number_of_event_max = 0; j = 0;
        
//    SST25_read_page_to_buf ( i, command_temp_buf, 128 );       
//    Nop();Nop();Nop();
//    SST25_read_page_to_buf ( 32704, flash_sector_buf, 1024 );
//        
//    ign_frq_trh_min = (flash_sector_buf[0] - 0x30) * 1000 + (flash_sector_buf[1] - 0x30) * 100 + (flash_sector_buf[2] - 0x30) * 10 + (flash_sector_buf[3] - 0x30);
//    ign_frq_trh     = (flash_sector_buf[5] - 0x30) * 1000 + (flash_sector_buf[6] - 0x30) * 100 + (flash_sector_buf[7] - 0x30) * 10 + (flash_sector_buf[8] - 0x30);
//
//    ign_off_time = (flash_sector_buf[10] - 0x30) * 10 + (flash_sector_buf[11] - 0x30);
//    ign_on_time  = (flash_sector_buf[13] - 0x30) * 10 + (flash_sector_buf[14] - 0x30);
//    
//    ign_volt_trh_min = (flash_sector_buf[16] - 0x30) * 100 + (flash_sector_buf[17] - 0x30) * 10 + (flash_sector_buf[18] - 0x30);
//    ign_volt_trh     = (flash_sector_buf[20] - 0x30) * 100 + (flash_sector_buf[21] - 0x30) * 10 + (flash_sector_buf[22] - 0x30);        

    ign_frq_trh_min = 250;
    ign_frq_trh = 130;    
    ign_off_time = 5;
    ign_on_time = 15;
    ign_volt_trh_min = 970; 
//    ign_volt_trh = 930;
//    OC1R = ign_volt_trh;

// at$acel=032,20,038,06,045,03,051,03;    
/*
    ACELbits.trh1 = 32;
    ACELbits.dur1 = 20;
    ACELbits.trh2 = 38;
    ACELbits.dur2 =  6;
    ACELbits.trh3 = 45;
    ACELbits.dur3 =  3;
    ACELbits.trh4 = 51;
    ACELbits.dur4 =  3;
    
    DCELbits.trh1 = -32;
    DCELbits.dur1 =  30;
    DCELbits.trh2 = -51;
    DCELbits.dur2 =  20;
    DCELbits.trh3 = -64;
    DCELbits.dur3 =   5;
    DCELbits.trh4 = -77;
    DCELbits.dur4 =   3;

    LALLbits.trh1 = 38;
    LALLbits.dur1 = 30;
    LALLbits.trh2 = 51;
    LALLbits.dur2 = 20;
    LALLbits.trh3 = 64;
    LALLbits.dur3 = 10;
    LALLbits.trh4 = 77;
    LALLbits.dur4 =  5;
    
    LALRbits.trh1 = -1*LALLbits.trh1;
    LALRbits.dur1 =    LALLbits.dur1;
    LALRbits.trh2 = -1*LALLbits.trh2;
    LALRbits.dur2 =    LALLbits.dur2;
    LALRbits.trh3 = -1*LALLbits.trh3;
    LALRbits.dur3 =    LALLbits.dur3;
    LALRbits.trh4 = -1*LALLbits.trh4;
    LALRbits.dur4 =    LALLbits.dur4;
*/

    
}

/* ЗАПИСЬ ВО ФЛЕШ В ПРЕРЫВАНИЯХ */
void start_flash_data_write ( unsigned long start_addr_in_flash, int ptr, unsigned int length ) {
    //int temp;

        ptr_to_save = ptr; // указатель на буфер, который нужно сохранить во флэш
        flash_data_length = length;
        flash_data_start_addr = start_addr_in_flash;
        flash_write_end_flag = 0;
        
        IEC3bits.T7IE = 1;
        TMR7 = 0;
        T7CONbits.TON = 1;
//        IFS3bits.T7IF = 1;

    
}
unsigned long get_start_addr_of_page ( unsigned int page_num ) {
    unsigned long addr;
    
    addr = (unsigned long)page_num;
    addr = addr * 128;

return  addr;   
}
unsigned long get_start_addr_of_page2 ( unsigned int page_num ) {
    unsigned long addr;
    
    addr = (unsigned long)page_num;
    addr = addr * 256;
    addr = addr + 2621440; //128 * 20480;

return  addr;   
}
void save_page_to_flash (void) {
unsigned long addr_to_save;
static unsigned int flash_ptr_W_tmp, SST26_buf_full_flag = 0, flash_ptr_W_sst26, ptr_W, ptr_R, timeout_counter = 0;
static char first_entranse = -1, second_page_flag = 0, flash_W_wait_counter = 0;
int res, i;
unsigned int tmp;

# if defined (SST26)

    if (first_entranse == -1) {
        Nop(); Nop(); Nop();
    }
    first_entranse = 0;
    
// Мониторин таймаута единственного сообщения на странице
    if ((save_to_flash_ptr_R == save_to_flash_ptr_W) && second_page_flag == 1 ) {
        if (timeout_counter < 3000) timeout_counter++;
        else {
            Nop(); Nop(); Nop();
            timeout_counter = 0;
            command_temp_buf[113] = 5;
            command_temp_buf[0] = 0;
            write_data_into_save_to_flash_bufs ( command_temp_buf, 5 );            
        }
    } else timeout_counter = 0;    
    
// Мониторинг данных для сохранения во флеш
    while (save_to_flash_ptr_R != save_to_flash_ptr_W) {// Есть что сохранять
        Nop(); Nop(); Nop();
        
/*
 * функция save_page_to_flash (void) для SST26
 * Если  flash_ptr_W нечетное и second_page_flag == 0, то из цикла while (save_to_flash_ptr_R != save_to_flash_ptr_W)
 * не выйдет никогда. Такое может произойти если сбросится когда записалась только одна страница из пары,
 * вероятность большая!!!
 */        
        
//        if ( FLASHBUSYbits.FLASHBUSY != 0) {
            tmp = flash_ptr_W;
            if ( (tmp %= 2) == 0 && second_page_flag == 0 ) {
                Nop(); Nop(); Nop();
                memmove ( &SST26_buf[0], save_to_flash_ptrs_buf [save_to_flash_ptr_R], 128 );


                flash_ptr_W_sst26 = flash_ptr_W;

                ptr_W = flash_ptr_W; ptr_R = flash_ptr_R; // Временные указатели записи/чтения
                second_page_flag = 1;
                save_to_flash_ptr_R ++; save_to_flash_ptr_R %= 4;
                break;
            }        

            if ( second_page_flag == 1 ) {
                Nop(); Nop(); Nop();

                memmove ( &SST26_buf[128], save_to_flash_ptrs_buf [save_to_flash_ptr_R], 128 );

                SST26_buf_full_flag = 1;
                second_page_flag = 0;

                save_to_flash_ptr_R ++; save_to_flash_ptr_R %= 4;
                break;
            }
//        } else break;

    }
    
    

    if (SST26_buf_full_flag == 1) {// Есть что сохранять
        
        if (FLASHBUSYbits.FLASHBUSY == 0) {
            SST26_buf_full_flag = 0;
            FLASHBUSYbits.page_saving = 1;
            
            addr_to_save = get_start_addr_of_page ( flash_ptr_W_sst26 ); // адрес первого байта страницы для записи
            SST26_write_page128_to_flash ( flash_ptr_W_sst26, &SST26_buf );
            flash_ptr_W_tmp = flash_ptr_W_sst26;

        }
        
    }
    
    if (FLASHBUSYbits.page_saving == 1) {
        if ( flash_W_wait_counter < 2 ) flash_W_wait_counter ++; // Таймер окончания записи страницы во флэш
        else {
            flash_write_end_flag = 1;
            flash_W_wait_counter = 0;            
        }
    }

//Мониторинг процесса записи
    if ((FLASHBUSYbits.page_saving == 1)&&(flash_write_end_flag == 1)) {
        FLASHBUSYbits.page_saving = 0;
        flash_write_end_flag = 0;
Nop(); Nop(); Nop();
        res = verify_flash_page (flash_ptr_W_tmp);
Nop(); Nop(); Nop();
            for (i = 0; i < 2; i ++) {
                if ((flash_ptr_W + 1) % 20000 != flash_ptr_R) { flash_ptr_W ++; } // Инкремент указателя записи, если буфер не заполнен
                else { // иначе - инкремент буферов чтения и записи. Потеря самой старой SMS
                    flash_ptr_R ++; flash_ptr_R %= 20000;
                    FM25_write_2( 67, (unsigned int) flash_ptr_R );
                    flash_ptr_W ++;
                }    
                flash_ptr_W %= 20000;
            }
            FM25_write_2( 69, (unsigned int) flash_ptr_W );         

// Проверка стертости следующей страницы 
unsigned long temp;
unsigned long address;
        address = (unsigned long) (flash_ptr_W * 128);
        temp = address % 4096;
        if (temp == 0) {
            if ( flash_ptr_R >= flash_ptr_W ) {
                if ( ( flash_ptr_R - flash_ptr_W ) < 32 ) {   // Если указатель чтения принадлежит к стираемому сектору, то
                    flash_ptr_R = (flash_ptr_R + 32) % 20000; // перемещение указателя чтения на первую нестертую страницу
                    FM25_write_2( 67, (unsigned int) flash_ptr_R );
                }
            }
            FLASHBUSYbits.page_sector_erasing = 1;
            SST25_sector_erase (  (flash_ptr_W >> 5), 0 ); // Запуск стирания сектора        
        }
    }

// Мониторинг процесса стирания сектора
static unsigned char erase_counter = 0;
    if ( FLASHBUSYbits.page_sector_erasing == 1 ) { //&& FLASHBUSYbits.page_saving == 1 
        if (erase_counter <= 4) erase_counter ++; // Время стирания 40мс
        else {
            Nop();Nop();Nop();
            erase_counter = 0;
            FLASHBUSYbits.page_sector_erasing = 0;
        }
    }
    else {
        erase_counter = 0;
    }
# endif
# if defined (SST25)
// Мониторинг данных для сохранения во флеш
    if (save_to_flash_ptr_R != save_to_flash_ptr_W) {// Есть что сохранять
        if (FLASHBUSYbits.FLASHBUSY == 0) {
            
            FLASHBUSYbits.page_saving = 1;
            addr_to_save = get_start_addr_of_page ( flash_ptr_W ); // адрес первого байта страницы для записи
            
            start_flash_data_write ( addr_to_save, save_to_flash_ptrs_buf [save_to_flash_ptr_R], 127 );            
//            save_to_flash_ptr_R ++; save_to_flash_ptr_R %= 4;
            flash_ptr_W_tmp = flash_ptr_W;
            if ((flash_ptr_W + 1) % 20000 != flash_ptr_R) { flash_ptr_W ++; } // Инкремент указателя записи, если буфер не заполнен
            else { // иначе - инкремент буферов чтения и записи. Потеря самой старой SMS
                flash_ptr_R ++; flash_ptr_R %= 20000;
                FM25_write_2( 67, (unsigned int) flash_ptr_R );
                flash_ptr_W ++;
            }    
            flash_ptr_W %= 20000;
            FM25_write_2( 69, (unsigned int) flash_ptr_W );
        }
    }

//Мониторинг процесса записи
    if ((FLASHBUSYbits.page_saving == 1)&&(flash_write_end_flag == 1)) {
        FLASHBUSYbits.page_saving = 0;
        flash_write_end_flag = 0;
Nop(); Nop(); Nop();
        res = verify_flash_page (flash_ptr_W_tmp);
Nop(); Nop(); Nop();
/*если записалось успешно - инкремент указателя временных буферов. А если нет? Когда инкрементируется 
 указатель записи во флэшь, ведь эту страницу надо пропустить.*/
        if (res == 1) save_to_flash_ptr_R ++; save_to_flash_ptr_R %= 4;
            

// Проверка стертости следующей страницы 
unsigned long temp;
unsigned long address;
        address = (unsigned long) (flash_ptr_W * 128);
        temp = address % 4096;
        if (temp == 0) {
            if ( flash_ptr_R >= flash_ptr_W ) {
                if ( ( flash_ptr_R - flash_ptr_W ) < 32 ) {   // Если указатель чтения принадлежит к стираемому сектору, то
                    flash_ptr_R = (flash_ptr_R + 32) % 20000; // перемещение указателя чтения на первую нестертую страницу
                    FM25_write_2( 67, (unsigned int) flash_ptr_R );
                }
            }
            FLASHBUSYbits.page_sector_erasing = 1;
            SST25_sector_erase (  (flash_ptr_W >> 5), 0 ); // Запуск стирания сектора        
        }
    }

// Мониторинг процесса стирания сектора
static unsigned char erase_counter = 0;
    if ( FLASHBUSYbits.page_sector_erasing == 1 ) { //&& FLASHBUSYbits.page_saving == 1 
        if (erase_counter <= 4) erase_counter ++; // Время стирания 40мс
        else {
            Nop();Nop();Nop();
            erase_counter = 0;
            FLASHBUSYbits.page_sector_erasing = 0;
        }
    }
    else {
        erase_counter = 0;
    }
# endif

}
void save_page_to_flash2 (void) {
unsigned long addr_to_save;
static unsigned int flash2_ptr_W_tmp;
static char flash2_W_wait_counter = 0;
int res;
/* Для хранения очереди 2:
 * Сектора 640 - 790  
 * страницы 20480 - 25280
 * всего страниц 4800 SST25
 * всего страниц 2400 SST26
 */
# if defined (SST26)
// Мониторинг данных для сохранения во флеш
    if (save_to_flash2_ptr_R != save_to_flash2_ptr_W) {// Есть что сохранять
        if (FLASHBUSYbits.FLASHBUSY == 0) {
            
            FLASHBUSYbits.page2_saving = 1;
            addr_to_save = get_start_addr_of_page2 ( flash2_ptr_W ); // адрес первого байта страницы для записи
            
            SST26_write_page_to_flash2 ( addr_to_save, &save_to_flash2_buf [save_to_flash2_ptr_R][0] );
//            start_flash_data_write ( addr_to_save, &save_to_flash2_buf [save_to_flash2_ptr_R][0], 127 );            
            flash2_ptr_W_tmp = flash2_ptr_W;
            if ((flash2_ptr_W + 1) % 2400 != flash2_ptr_R) { flash2_ptr_W ++; } // Инкремент указателя записи, если буфер не заполнен
            else { // иначе - инкремент буферов чтения и записи. Потеря самой старой SMS
                flash2_ptr_R ++; flash2_ptr_R %= 2400;
                FM25_write_2( 75, (unsigned int) flash2_ptr_R ); // не 67!!!!!!!!!!!!!!!!!!!!!!!!!!!
                flash2_ptr_W ++;
            }    
            flash2_ptr_W %= 2400;
            FM25_write_2( 77, (unsigned int) flash2_ptr_W ); // Не 69 !!!!!!!!!!!!!!!!!!!!!!!!!!!!
        }
    }

    if (FLASHBUSYbits.page2_saving == 1) {
        if ( flash2_W_wait_counter < 2 ) flash2_W_wait_counter ++; // Таймер окончания записи страницы во флэш
        else {
            flash_write_end_flag = 1;
            flash2_W_wait_counter = 0;            
        }
    }

//Мониторинг процесса записи
    if ((FLASHBUSYbits.page2_saving == 1)&&(flash_write_end_flag == 1)) {
        FLASHBUSYbits.page2_saving = 0;
        flash_write_end_flag = 0;
Nop(); Nop(); Nop();
        res = verify_flash2_page ( (20480 + (flash2_ptr_W_tmp << 1)) );
Nop(); Nop(); Nop();
/*если записалось успешно - инкремент указателя временных буферов. А если нет? Когда инкрементируется 
 указатель записи во флэшь, ведь эту страницу надо пропустить.*/
        if (res == 1) save_to_flash2_ptr_R ++; save_to_flash2_ptr_R %= 4;
            

// Проверка стертости следующей страницы 
unsigned long temp;
unsigned long address;
        address = (unsigned long) flash2_ptr_W * 256 + 2621440;
        temp = address % 4096;
        if (temp == 0) {
            if ( flash2_ptr_R >= flash2_ptr_W ) {
                if ( ( flash_ptr_R - flash2_ptr_W ) < 16 ) {   // Если указатель чтения принадлежит к стираемому сектору, то
                    flash2_ptr_R = (flash2_ptr_R + 16) % 2400; // перемещение указателя чтения на первую нестертую страницу
                    FM25_write_2( 75, (unsigned int) flash2_ptr_R ); // не 67 !!!!!!!!!!!!!!!!!!!!!!!!!!!!1
                }
            }
            FLASHBUSYbits.page2_sector_erasing = 1;
            SST25_sector_erase (  (flash2_ptr_W >> 4) + 640, 0 ); // Запуск стирания сектора        
        }
    }

// Мониторинг процесса стирания сектора
static unsigned char erase_counter = 0;
    if ( FLASHBUSYbits.page2_sector_erasing == 1 ) { //
        if (erase_counter <= 4) erase_counter ++; // Время стирания 40мс
        else {
            Nop();Nop();Nop();
            erase_counter = 0;
            FLASHBUSYbits.page2_sector_erasing = 0;
        }
    }
    else {
        erase_counter = 0;
    }
# endif
# if defined (SST25)
// Мониторинг данных для сохранения во флеш
    if (save_to_flash2_ptr_R != save_to_flash2_ptr_W) {// Есть что сохранять
        if (FLASHBUSYbits.FLASHBUSY == 0) {
            
            FLASHBUSYbits.page2_saving = 1;
            addr_to_save = get_start_addr_of_page ( flash2_ptr_W + 20480 ); // адрес первого байта страницы для записи
            
            start_flash_data_write ( addr_to_save, &save_to_flash2_buf [save_to_flash2_ptr_R][0], 127 );            
            flash2_ptr_W_tmp = flash2_ptr_W;
            if ((flash2_ptr_W + 1) % 4800 != flash2_ptr_R) { flash2_ptr_W ++; } // Инкремент указателя записи, если буфер не заполнен
            else { // иначе - инкремент буферов чтения и записи. Потеря самой старой SMS
                flash2_ptr_R ++; flash2_ptr_R %= 4800;
                FM25_write_2( 75, (unsigned int) flash2_ptr_R ); // не 67!!!!!!!!!!!!!!!!!!!!!!!!!!!
                flash2_ptr_W ++;
            }    
            flash2_ptr_W %= 4800;
            FM25_write_2( 77, (unsigned int) flash2_ptr_W ); // Не 69 !!!!!!!!!!!!!!!!!!!!!!!!!!!!
        }
    }

//Мониторинг процесса записи
    if ((FLASHBUSYbits.page2_saving == 1)&&(flash_write_end_flag == 1)) {
        FLASHBUSYbits.page2_saving = 0;
        flash_write_end_flag = 0;
Nop(); Nop(); Nop();
        res = verify_flash2_page ( flash2_ptr_W_tmp + 20480 );
Nop(); Nop(); Nop();
/*если записалось успешно - инкремент указателя временных буферов. А если нет? Когда инкрементируется 
 указатель записи во флэшь, ведь эту страницу надо пропустить.*/
        if (res == 1) save_to_flash2_ptr_R ++; save_to_flash2_ptr_R %= 4;
            

// Проверка стертости следующей страницы 
unsigned long temp;
unsigned long address;
        address = (unsigned long) ((flash2_ptr_W + 20480) * 128);
        temp = address % 4096;
        if (temp == 0) {
            if ( flash2_ptr_R >= flash2_ptr_W ) {
                if ( ( flash_ptr_R - flash2_ptr_W ) < 32 ) {   // Если указатель чтения принадлежит к стираемому сектору, то
                    flash2_ptr_R = (flash2_ptr_R + 32) % 4800; // перемещение указателя чтения на первую нестертую страницу
                    FM25_write_2( 75, (unsigned int) flash2_ptr_R ); // не 67 !!!!!!!!!!!!!!!!!!!!!!!!!!!!1
                }
            }
            FLASHBUSYbits.page2_sector_erasing = 1;
            SST25_sector_erase (  (flash2_ptr_W >> 5) + 640, 0 ); // Запуск стирания сектора        
        }
    }

// Мониторинг процесса стирания сектора
static unsigned char erase_counter = 0;
    if ( FLASHBUSYbits.page2_sector_erasing == 1 ) { //
        if (erase_counter <= 4) erase_counter ++; // Время стирания 40мс
        else {
            Nop();Nop();Nop();
            erase_counter = 0;
            FLASHBUSYbits.page2_sector_erasing = 0;
        }
    }
    else {
        erase_counter = 0;
    }
# endif
}
int verify_flash_page (unsigned int flash_ptr_W_tmp) {
    
unsigned char len, /*temp,*/ check_summ, check_summ1, i;    

    len        = (unsigned char) SST25_read_var_from_page ( flash_ptr_W_tmp, 113, 1 );
    check_summ = (unsigned char) SST25_read_var_from_page ( flash_ptr_W_tmp, 123, 1 );
    SST25_read_page_to_buf ( flash_ptr_W_tmp, command_temp_buf, len );
    
// Расчет контрольной суммы
check_summ1 = 0;    
    for ( i = 0; i < len; i++) {
        check_summ1 = check_summ1 ^ command_temp_buf[i];
    }
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_W_tmp, 113, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_W_tmp, 114, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_W_tmp, 115, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_W_tmp, 116, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_W_tmp, 117, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_W_tmp, 118, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_W_tmp, 119, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_W_tmp, 120, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_W_tmp, 121, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_W_tmp, 122, 1 );
Nop();Nop();Nop();    
    if (check_summ1 != check_summ) return 0;



# if defined (SST26)

    len        = (unsigned char) SST25_read_var_from_page ( flash_ptr_W_tmp + 1, 113, 1 );
    check_summ = (unsigned char) SST25_read_var_from_page ( flash_ptr_W_tmp + 1, 123, 1 );
    SST25_read_page_to_buf ( flash_ptr_W_tmp + 1, command_temp_buf, len );
    
// Расчет контрольной суммы
check_summ1 = 0;    
    for ( i = 0; i < len; i++) {
        check_summ1 = check_summ1 ^ command_temp_buf[i];
    }
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_W_tmp, 113, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_W_tmp, 114, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_W_tmp, 115, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_W_tmp, 116, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_W_tmp, 117, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_W_tmp, 118, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_W_tmp, 119, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_W_tmp, 120, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_W_tmp, 121, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_W_tmp, 122, 1 );
Nop();Nop();Nop();    
    if (check_summ1 != check_summ) return 0;

# endif

    return 1;   
    
}
int verify_flash2_page (unsigned int flash2_ptr_W_tmp) {
    
unsigned char len, /*temp,*/ check_summ, check_summ1, i;    

    len        = (unsigned char) SST25_read_var_from_page ( (flash2_ptr_W_tmp), 113, 1 );
    check_summ = (unsigned char) SST25_read_var_from_page ( (flash2_ptr_W_tmp), 123, 1 );
    SST25_read_page_to_buf ( (flash2_ptr_W_tmp), command_temp_buf, len );
    
// Расчет контрольной суммы
check_summ1 = 0;    
    for ( i = 0; i < len; i++) {
        check_summ1 = check_summ1 ^ command_temp_buf[i];
    }
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( (flash2_ptr_W_tmp), 113, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( (flash2_ptr_W_tmp), 114, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( (flash2_ptr_W_tmp), 115, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( (flash2_ptr_W_tmp), 116, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( (flash2_ptr_W_tmp), 117, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( (flash2_ptr_W_tmp), 118, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( (flash2_ptr_W_tmp), 119, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( (flash2_ptr_W_tmp), 120, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( (flash2_ptr_W_tmp), 121, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( (flash2_ptr_W_tmp), 122, 1 );
Nop();Nop();Nop();    
    if (check_summ1 != check_summ) return 0;

    if (command_temp_buf[0] != TYPE0[0]) return 0;
    if (command_temp_buf[1] != TYPE0[1]) return 0;
    if (command_temp_buf[2] != TYPE0[2]) return 0;
    if (command_temp_buf[3] != TYPE0[3]) return 0;
    if (command_temp_buf[4] != TYPE0[4]) return 0;
    if (command_temp_buf[5] != TYPE0[5]) return 0;
    if (command_temp_buf[6] != TYPE0[6]) return 0;
    if (command_temp_buf[7] != TYPE0[7]) return 0;

    return 1;   
    
}
void save_crash_to_flash (void) {
static unsigned long addr_to_save_samples, addr_to_save_trek, addr_to_save_acc_point, addr_to_save_trek_point, addr_to_save_number_of_crash;
static unsigned char res, save_success_flag = 0, save_timer = 0;

# if defined (SST26)
// Мониторинг гтовности для сохранения во флеш отсчетов ускорения
        if (FLASHBUSYbits.FLASHBUSY == 0) { // Не сохраняются сообщения типа1 и не стирается сектор

            FLASHBUSYbits.acc_saving = 1;
            CRASHSAVETASKbits.samples_saving = 1;
            addr_to_save_samples = save_crash_to_flash_ptr_W + 625;
            addr_to_save_samples = addr_to_save_samples * 4096;
            addr_to_save_trek = addr_to_save_samples + 2400;
            addr_to_save_acc_point = addr_to_save_trek + 440;
            addr_to_save_trek_point = addr_to_save_acc_point + 2;
            addr_to_save_number_of_crash = addr_to_save_trek_point + 2;
        }

    if (FLASHBUSYbits.acc_saving == 1 && CRASHSAVETASKbits.samples_saving == 1 && 
        CRASHSAVETASKbits.samples_saving_done == 0 && flash_write_end_flag == 0) {
        
        if (save_timer <= 13) save_timer ++;
        else {
            Nop();Nop();Nop();
            save_timer = 0;
            flash_write_end_flag = 1;
            CRASHSAVETASKbits.samples_saving_done = 1; 
            CRASHSAVETASKbits.trek_saving_done = 1;              
        }
        
        switch ( save_timer ) {
            
            case 1:

                Nop();Nop();Nop();
                SST26_write_page_to_flash2 ( addr_to_save_samples,         &CRASH_ACC_buf [0][0] );
            break;
            case 2:
                Nop();Nop();Nop();
                SST26_write_page_to_flash2 ( (addr_to_save_samples + 256), &CRASH_ACC_buf [0][256 >> 2] );                
            break;
            case 3:
                Nop();Nop();Nop();
                SST26_write_page_to_flash2 ( (addr_to_save_samples + 512), &CRASH_ACC_buf [0][512 >> 2] );                
            break;
            case 4:
                Nop();Nop();Nop();
                SST26_write_page_to_flash2 ( (addr_to_save_samples + 768), &CRASH_ACC_buf [0][768 >> 2] );
            break;
            case 5:
                SST26_write_page_to_flash2 ( (addr_to_save_samples + 1024), &CRASH_ACC_buf [0][1024 >> 2] );                
            break;
            case 6:
                SST26_write_page_to_flash2 ( (addr_to_save_samples + 1280), &CRASH_ACC_buf [0][1280 >> 2] );
            break; 
            case 7:
                SST26_write_page_to_flash2 ( (addr_to_save_samples + 1536), &CRASH_ACC_buf [0][1536 >> 2] );                
            break;
            case 8:
                SST26_write_page_to_flash2 ( (addr_to_save_samples + 1792), &CRASH_ACC_buf [0][1792 >> 2] );                
            break;
            case 9:
                SST26_write_page_to_flash2 ( (addr_to_save_samples + 2048), &CRASH_ACC_buf [0][2048 >> 2] );                
            break;
            case 10:
                memmove ( &SST26_buf[0], &CRASH_ACC_buf [0][2304 >> 2],96 ); // Закончились графики ускорения
                memmove ( &SST26_buf[96],  &CRASH_TREK_buf[0][0], 22 ); // Превая точка траектории
                memmove ( &SST26_buf[118], &CRASH_TREK_buf[1][0], 22 );
                memmove ( &SST26_buf[140], &CRASH_TREK_buf[2][0], 22 );
                memmove ( &SST26_buf[162], &CRASH_TREK_buf[3][0], 22 );
                memmove ( &SST26_buf[184], &CRASH_TREK_buf[4][0], 22 );
                memmove ( &SST26_buf[206], &CRASH_TREK_buf[5][0], 22 );
                memmove ( &SST26_buf[228], &CRASH_TREK_buf[6][0], 22 );
                memmove ( &SST26_buf[250], &CRASH_TREK_buf[7][0],  6 );
                SST26_write_page_to_flash2 ( (addr_to_save_samples + 2304), SST26_buf );
            break;
            case 11:
                memmove ( &SST26_buf[0],   &CRASH_TREK_buf[7][6],  16 );
                memmove ( &SST26_buf[16],  &CRASH_TREK_buf[8][0],  22 );
                memmove ( &SST26_buf[38],  &CRASH_TREK_buf[9][0],  22 );
                memmove ( &SST26_buf[60],  &CRASH_TREK_buf[10][0], 22 );
                memmove ( &SST26_buf[82],  &CRASH_TREK_buf[11][0], 22 );
                memmove ( &SST26_buf[104], &CRASH_TREK_buf[12][0], 22 );
                memmove ( &SST26_buf[126], &CRASH_TREK_buf[13][0], 22 );
                memmove ( &SST26_buf[148], &CRASH_TREK_buf[14][0], 22 );
                memmove ( &SST26_buf[170], &CRASH_TREK_buf[15][0], 22 );
                memmove ( &SST26_buf[192], &CRASH_TREK_buf[16][0], 22 );
                memmove ( &SST26_buf[214], &CRASH_TREK_buf[17][0], 22 );
                memmove ( &SST26_buf[236], &CRASH_TREK_buf[18][0], 20 );
                
                SST26_write_page_to_flash2 ( (addr_to_save_samples + 2560), SST26_buf );
                                
            break;
            
            case 12:
                memmove ( &SST26_buf[0], &CRASH_TREK_buf[18][20], 2 );
                memmove ( &SST26_buf[2], &CRASH_TREK_buf[19][0], 22 );
                SST26_buf[24] = (unsigned char)(CRASH_ACC_point_ptr >> 8);  SST26_buf[25] = (unsigned char)CRASH_ACC_point_ptr;
                SST26_buf[26] = (unsigned char)(CRASH_TREK_point_ptr >> 8); SST26_buf[27] = (unsigned char)CRASH_TREK_point_ptr;
                SST26_buf[28] = (unsigned char)(number_of_crash >> 8);      SST26_buf[29] = (unsigned char)number_of_crash;
                SST26_write_page_to_flash2 ( (addr_to_save_samples + 2816), SST26_buf );
            break;
            
            default:
            break;
            
        }

    } else save_timer = 0;

/*
// Мониторинг окончания записи отсчетов ускорения во флэшь
    if (FLASHBUSYbits.acc_saving == 1 && CRASHSAVETASKbits.samples_saving == 1 && 
        CRASHSAVETASKbits.samples_saving_done == 0 && flash_write_end_flag == 1) {
        CRASHSAVETASKbits.samples_saving_done = 1;
        flash_write_end_flag = 0;
    }
// Мониторинг готовности записи во флэшь траектории вокруг аварии
        if (CRASHSAVETASKbits.samples_saving_done == 1 && CRASHSAVETASKbits.trek_saving == 0) {
            CRASHSAVETASKbits.trek_saving = 1;

            start_flash_data_write ( addr_to_save_trek, CRASH_TREK_buf, 440 );
        }
// Мониторинг окончания записи отсчетов ускорения во флэшь
    if (FLASHBUSYbits.acc_saving == 1 && CRASHSAVETASKbits.samples_saving_done == 1 && 
        CRASHSAVETASKbits.trek_saving == 1 && CRASHSAVETASKbits.trek_saving_done == 0 && flash_write_end_flag ==1 ) {
        SST25_write_var_to_flash ( (unsigned long) addr_to_save_acc_point,  (long)CRASH_ACC_point_ptr, 2 );
        SST25_write_var_to_flash ( (unsigned long) addr_to_save_trek_point, (long)CRASH_TREK_point_ptr, 2 );
        SST25_write_var_to_flash ( (unsigned long) addr_to_save_trek_point + 2, (long)number_of_crash, 2 );
        CRASHSAVETASKbits.trek_saving_done = 1;
        flash_write_end_flag = 0;
    }
*/

//Старт верификация записи
    if (FLASHBUSYbits.acc_saving == 1 && CRASHSAVETASKbits.samples_saving_done == 1 && 
            CRASHSAVETASKbits.trek_saving_done == 1 && CRASHSAVETASKbits.verification == 0 ) {
//        FLASHBUSYbits.acc_saving = 0;
        flash_write_end_flag = 0;
        CRASHSAVETASKbits.verification = 1;

    }

    if (CRASHSAVETASKbits.verification == 1) {
        Nop();Nop();Nop();
        res = crash_verification ();
        if (res == 1)  { // проверка на целостность данных завершена, данные корректны
            Nop();Nop();Nop(); 
            generate_content_of_message ( 50, 1 ); // ЗДЕСЬ СДЕЛАТЬ ГЕНЕРАЦИЮ СООБЩЕНИЯ О КРАШЕ 50
            number_of_crash ++;
            FM25_write_2( 65, (unsigned int) number_of_crash );
            save_crash_to_flash_ptr_W ++; save_crash_to_flash_ptr_W %= 10;
            FM25_write_2( 61, (unsigned int) save_crash_to_flash_ptr_W );
            FLASHBUSYbits.FLASHBUSY = 0;
            FLASHBUSYbits.acc_sector_erasing = 1;
            FLASHBUSYbits.acc_saving = 1;
            CRASHSAVETASKbits.CRASHSAVETASK = 0;
            save_success_flag = 1;
            SST25_sector_erase (  (save_crash_to_flash_ptr_W + 625), 0 ); // Запуск стирания следующего сектора
        }
        if (res == 0)  { // проверка на целостность данных завершена, данные некорректны
            Nop();Nop();Nop();
            FLASHBUSYbits.FLASHBUSY = 0;
            FLASHBUSYbits.acc_sector_erasing = 1;
            FLASHBUSYbits.acc_saving = 1;
            CRASHSAVETASKbits.CRASHSAVETASK = 0;
            save_success_flag = 0;
            SST25_sector_erase ( (save_crash_to_flash_ptr_W + 625), 0 ); // Запуск стирания этого же сектора
        }        
    }


// Мониторинг процесса стирания сектора
static unsigned char erase_counter1 = 0;
    if ( FLASHBUSYbits.acc_sector_erasing == 1) { // && FLASHBUSYbits.acc_saving == 1 
        if (erase_counter1 <= 4) erase_counter1 ++; // Время стирания 40мс
        else {
//            L_OUT = 0;
            Nop();Nop();Nop();
            erase_counter1 = 0;
            FLASHBUSYbits.acc_sector_erasing = 0;
            FLASHBUSYbits.FLASHBUSY = 0;
            if (save_success_flag == 1)CRASHTASKbits.CRASHTASK = 0;
            CRASHSAVETASKbits.CRASHSAVETASK = 0;
        }
    }
    else {
        erase_counter1 = 0;
    }
# endif

# if defined (SST25)
// Мониторинг гтовности для сохранения во флеш отсчетов ускорения
        if (FLASHBUSYbits.FLASHBUSY == 0) { // Не сохраняются сообщения типа1 и не стирается сектор
//            L_OUT = 1;
            FLASHBUSYbits.acc_saving = 1;
            CRASHSAVETASKbits.samples_saving = 1;
//            crash_to_send_ptr = save_crash_to_flash_ptr_W;
//            addr_to_save_samples = crash_to_send_ptr + 625;
            addr_to_save_samples = save_crash_to_flash_ptr_W + 625;
            addr_to_save_samples = addr_to_save_samples * 4096;
            addr_to_save_trek = addr_to_save_samples + 2400;//4800????????????????????
            addr_to_save_acc_point = addr_to_save_trek + 440;
            addr_to_save_trek_point = addr_to_save_acc_point + 2; 
            start_flash_data_write ( addr_to_save_samples, CRASH_ACC_buf, 2400 );//4800??????????????
        }
// Мониторинг окончания записи отсчетов ускорения во флэшь
    if (FLASHBUSYbits.acc_saving == 1 && CRASHSAVETASKbits.samples_saving == 1 && 
        CRASHSAVETASKbits.samples_saving_done == 0 && flash_write_end_flag == 1) {
        CRASHSAVETASKbits.samples_saving_done = 1;
        flash_write_end_flag = 0;
    }
// Мониторинг готовности записи во флэшь траектории вокруг аварии
        if (CRASHSAVETASKbits.samples_saving_done == 1 && CRASHSAVETASKbits.trek_saving == 0) {
            CRASHSAVETASKbits.trek_saving = 1;

            start_flash_data_write ( addr_to_save_trek, CRASH_TREK_buf, 440 );
        }
// Мониторинг окончания записи отсчетов ускорения во флэшь
    if (FLASHBUSYbits.acc_saving == 1 && CRASHSAVETASKbits.samples_saving_done == 1 && 
        CRASHSAVETASKbits.trek_saving == 1 && CRASHSAVETASKbits.trek_saving_done == 0 && flash_write_end_flag ==1 ) {
        SST25_write_var_to_flash ( (unsigned long) addr_to_save_acc_point,  (long)CRASH_ACC_point_ptr, 2 );
        SST25_write_var_to_flash ( (unsigned long) addr_to_save_trek_point, (long)CRASH_TREK_point_ptr, 2 );
        SST25_write_var_to_flash ( (unsigned long) addr_to_save_trek_point + 2, (long)number_of_crash, 2 );
        CRASHSAVETASKbits.trek_saving_done = 1;
        flash_write_end_flag = 0;
    }

//Старт верификация записи
    if (FLASHBUSYbits.acc_saving == 1 && CRASHSAVETASKbits.samples_saving_done == 1 && 
            CRASHSAVETASKbits.trek_saving_done == 1 && CRASHSAVETASKbits.verification == 0 ) {
//        FLASHBUSYbits.acc_saving = 0;
        flash_write_end_flag = 0;
        CRASHSAVETASKbits.verification = 1;

    }

    if (CRASHSAVETASKbits.verification == 1) {
        res = crash_verification ();
        if (res == 1)  { // проверка на целостность данных завершена, данные корректны
            Nop();Nop();Nop();
            generate_content_of_message ( 50, 1 ); // ЗДЕСЬ СДЕЛАТЬ ГЕНЕРАЦИЮ СООБЩЕНИЯ О КРАШЕ 50
            number_of_crash ++;
            FM25_write_2( 65, (unsigned int) number_of_crash );
            save_crash_to_flash_ptr_W ++; save_crash_to_flash_ptr_W %= 10;
            FM25_write_2( 61, (unsigned int) save_crash_to_flash_ptr_W );
            FLASHBUSYbits.FLASHBUSY = 0;
            FLASHBUSYbits.acc_sector_erasing = 1;
            FLASHBUSYbits.acc_saving = 1;
            CRASHSAVETASKbits.CRASHSAVETASK = 0;
            save_success_flag = 1;
            SST25_sector_erase (  (save_crash_to_flash_ptr_W + 625), 0 ); // Запуск стирания следующего сектора
        }
        if (res == 0)  { // проверка на целостность данных завершена, данные некорректны
            Nop();Nop();Nop();
            FLASHBUSYbits.FLASHBUSY = 0;
            FLASHBUSYbits.acc_sector_erasing = 1;
            FLASHBUSYbits.acc_saving = 1;
            CRASHSAVETASKbits.CRASHSAVETASK = 0;
            save_success_flag = 0;
            SST25_sector_erase ( (save_crash_to_flash_ptr_W + 625), 0 ); // Запуск стирания этого же сектора
        }        
    }


// Мониторинг процесса стирания сектора
static unsigned char erase_counter1 = 0;
    if ( FLASHBUSYbits.acc_sector_erasing == 1) { // && FLASHBUSYbits.acc_saving == 1 
        if (erase_counter1 <= 4) erase_counter1 ++; // Время стирания 40мс
        else {
//            L_OUT = 0;
            Nop();Nop();Nop();
            erase_counter1 = 0;
            FLASHBUSYbits.acc_sector_erasing = 0;
            FLASHBUSYbits.FLASHBUSY = 0;
            if (save_success_flag == 1)CRASHTASKbits.CRASHTASK = 0;
            CRASHSAVETASKbits.CRASHSAVETASK = 0;
        }
    }
    else {
        erase_counter1 = 0;
    }
# endif

}
int crash_verification ( void ) {
static unsigned int i, j, first_entrans_flag = 0;
static unsigned char data,  *acc_ptr, *trek_ptr, res;
static unsigned long acc_addr, trek_addr, addr_to_save_acc_point, addr_to_save_trek_point;

    if (first_entrans_flag == 0) {
        first_entrans_flag = 1;
        acc_addr = save_crash_to_flash_ptr_W;
        acc_addr = acc_addr + 625;
        acc_addr = acc_addr * 4096;
        trek_addr = acc_addr + 2400;
        addr_to_save_acc_point = trek_addr + 440;
        addr_to_save_trek_point = addr_to_save_acc_point + 2;        
        acc_ptr = CRASH_ACC_buf;
        trek_ptr = CRASH_TREK_buf;
        i = 0; j = 0;
    }
        res = 1;
        i = 0;
        while ( i < 10 ) {    
            if (j < 2400) {
                data = SST25_read_byte_from_flash ( (unsigned long)acc_addr ++ );
                if ( data != *acc_ptr ++) { res = 0; break; }                
            } else {
                data = SST25_read_byte_from_flash ( (unsigned long)trek_addr ++ );
                if ( data != *trek_ptr ++) { res = 0; break; }                
            }
            j ++;
            i ++;
        }
        
        
if ( res == 1 && j == 2840 ) {
    
//    CRASH_ACC_point_ptr // ВЕРИФИКАЦИЯ!!!!!!!!!!!!!!
//    CRASH_TREK_point_ptr // ВЕРИФИКАЦИЯ!!!!!!!!!!!!!!        
    first_entrans_flag = 0;
    i = SST25_read_var_from_flash ( (unsigned long)addr_to_save_acc_point, 2 );
    j = SST25_read_var_from_flash ( (unsigned long)addr_to_save_trek_point, 2 );
    if (i != CRASH_ACC_point_ptr)  return 0;
    if (j != CRASH_TREK_point_ptr) return 0;
    j = SST25_read_var_from_flash ( (unsigned long)addr_to_save_trek_point + 2, 2 );
    if (j != number_of_crash) return 0;
    return 1; 
} 
if ( res == 0 ) { 
    first_entrans_flag = 0; return 0; }
return -1;        
}
void save_fw_to_flash (void) {
static unsigned long addr_to_save_fw;
static unsigned char res, save_success_flag = 0, save_timer = 0;

# if defined (SST26)
// Мониторинг гтовности для сохранения во флеш сектора прошивки
    if (FLASHBUSYbits.FLASHBUSY == 0) { // Не сохраняются сообщения типа1 и не стирается сектор
        FLASHBUSYbits.fw_saving = 1;
        FWSAVETASKbits.fw_saving = 1;
        addr_to_save_fw = save_fw_to_flash_ptr_W + 800;
        addr_to_save_fw = addr_to_save_fw * 4096;
//        start_flash_data_write ( addr_to_save_fw, fw_sector_buf, 4096 );
    }
// Мониторинг окончания записи сектора прошивки во флэшь
    if (FLASHBUSYbits.fw_saving == 1 && FWSAVETASKbits.fw_saving == 1 && 
        FWSAVETASKbits.fw_saving_done == 0) { //&& flash_write_end_flag == 1

        flash_write_end_flag = 0;
        
        if (save_timer <= 17) save_timer ++;
        else {
            Nop();Nop();Nop();
            save_timer = 0;
            flash_write_end_flag = 1;
            FWSAVETASKbits.fw_saving_done = 1;             
        }
        
        switch ( save_timer ) {
            
            case 1:
                Nop();Nop();Nop();
                SST26_write_page_to_flash2 ( addr_to_save_fw, &fw_sector_buf[0] );
            break;
            case 2:
                SST26_write_page_to_flash2 ( addr_to_save_fw + 256, &fw_sector_buf[256] );                
            break;
            case 3:
                SST26_write_page_to_flash2 ( addr_to_save_fw + 512, &fw_sector_buf[512] );                
            break;
            case 4:
                SST26_write_page_to_flash2 ( addr_to_save_fw + 768, &fw_sector_buf[768] );
            break;
            case 5:
                SST26_write_page_to_flash2 ( addr_to_save_fw + 1024, &fw_sector_buf[1024] );                
            break;
            case 6:
                SST26_write_page_to_flash2 ( addr_to_save_fw + 1280, &fw_sector_buf[1280] );
            break; 
            case 7:
                SST26_write_page_to_flash2 ( addr_to_save_fw + 1536, &fw_sector_buf[1536] );                
            break;
            case 8:
                SST26_write_page_to_flash2 ( addr_to_save_fw + 1792, &fw_sector_buf[1792] );                
            break;
            case 9:
                SST26_write_page_to_flash2 ( addr_to_save_fw + 2048, &fw_sector_buf[2048] );               
            break;
            case 10:
                SST26_write_page_to_flash2 ( addr_to_save_fw + 2304, &fw_sector_buf[2304] );
            break;
            case 11:
                SST26_write_page_to_flash2 ( addr_to_save_fw + 2560, &fw_sector_buf[2560] );                
            break;
            case 12:
                SST26_write_page_to_flash2 ( addr_to_save_fw + 2816, &fw_sector_buf[2816] );
            break;
            case 13:
                SST26_write_page_to_flash2 ( addr_to_save_fw + 3072, &fw_sector_buf[3072] );
            break;
            case 14:
                SST26_write_page_to_flash2 ( addr_to_save_fw + 3328, &fw_sector_buf[3328] );
            break;
            case 15:
                SST26_write_page_to_flash2 ( addr_to_save_fw + 3584, &fw_sector_buf[3584] );
            break;
            case 16:
                SST26_write_page_to_flash2 ( addr_to_save_fw + 3840, &fw_sector_buf[3840] );
            break;
            
            default:
            break;
            
        }

    } else save_timer = 0;
        
       


//Старт верификация записи
    if (FLASHBUSYbits.fw_saving == 1 && FWSAVETASKbits.fw_saving_done == 1 && 
        FWSAVETASKbits.verification == 0 ) {
        flash_write_end_flag = 0;
        FWSAVETASKbits.verification = 1;
    }

    if (FWSAVETASKbits.verification == 1) {
        res = fw_sector_verification ();
        if (res == 1)  { // проверка на целостность данных завершена, данные корректны
            Nop();Nop();Nop();
            FLASHBUSYbits.FLASHBUSY = 0;
            FLASHBUSYbits.fw_sector_erasing = 1;
            FLASHBUSYbits.fw_saving = 1;
            FWSAVETASKbits.FWSAVETASK = 0;
            save_success_flag = 1;
            save_fw_to_flash_ptr_W ++;
            SST25_sector_erase (  (save_fw_to_flash_ptr_W + 800), 0 ); // Запуск стирания следующего сектора
        }
        if (res == 0)  { // проверка на целостность данных завершена, данные некорректны
            Nop();Nop();Nop();
            FLASHBUSYbits.FLASHBUSY = 0;
            FLASHBUSYbits.fw_sector_erasing = 1;
            FLASHBUSYbits.fw_saving = 1;
            FWSAVETASKbits.FWSAVETASK = 0;
            save_success_flag = 0;
            SST25_sector_erase ( (save_fw_to_flash_ptr_W + 800), 0 ); // Запуск стирания этого же сектора
        }        
    }


// Мониторинг процесса стирания сектора
static unsigned char erase_counter1 = 0;
    if ( FLASHBUSYbits.fw_sector_erasing == 1 ) { //&& FLASHBUSYbits.fw_saving == 1 
        if (erase_counter1 <= 4) erase_counter1 ++; // Время стирания 40мс
        else {
            Nop();Nop();Nop();
            erase_counter1 = 0;
            FLASHBUSYbits.fw_sector_erasing = 0;
            FLASHBUSYbits.FLASHBUSY = 0;
            FWSAVETASKbits.FWSAVETASK = 0;
            if (save_success_flag == 1){
                FWDTASCKbits.sector_downloaded = 0;
            }
            
        }
    }
    else {
        erase_counter1 = 0;
    }
# endif
# if defined (SST25)
// Мониторинг гтовности для сохранения во флеш сектора прошивки
    if (FLASHBUSYbits.FLASHBUSY == 0) { // Не сохраняются сообщения типа1 и не стирается сектор
        FLASHBUSYbits.fw_saving = 1;
        FWSAVETASKbits.fw_saving = 1;
        addr_to_save_fw = save_fw_to_flash_ptr_W + 800;
        addr_to_save_fw = addr_to_save_fw * 4096;
        start_flash_data_write ( addr_to_save_fw, fw_sector_buf, 4096 );
    }
// Мониторинг окончания записи сектора прошивки во флэшь
    if (FLASHBUSYbits.fw_saving == 1 && FWSAVETASKbits.fw_saving == 1 && 
        FWSAVETASKbits.fw_saving_done == 0 && flash_write_end_flag == 1) {
        FWSAVETASKbits.fw_saving_done = 1;
        flash_write_end_flag = 0;
    }


//Старт верификация записи
    if (FLASHBUSYbits.fw_saving == 1 && FWSAVETASKbits.fw_saving_done == 1 && 
        FWSAVETASKbits.verification == 0 ) {
        flash_write_end_flag = 0;
        FWSAVETASKbits.verification = 1;
    }

    if (FWSAVETASKbits.verification == 1) {
        res = fw_sector_verification ();
        if (res == 1)  { // проверка на целостность данных завершена, данные корректны
            Nop();Nop();Nop();
            FLASHBUSYbits.FLASHBUSY = 0;
            FLASHBUSYbits.fw_sector_erasing = 1;
            FLASHBUSYbits.fw_saving = 1;
            FWSAVETASKbits.FWSAVETASK = 0;
            save_success_flag = 1;
            save_fw_to_flash_ptr_W ++;
            SST25_sector_erase (  (save_fw_to_flash_ptr_W + 800), 0 ); // Запуск стирания следующего сектора
        }
        if (res == 0)  { // проверка на целостность данных завершена, данные некорректны
            Nop();Nop();Nop();
            FLASHBUSYbits.FLASHBUSY = 0;
            FLASHBUSYbits.fw_sector_erasing = 1;
            FLASHBUSYbits.fw_saving = 1;
            FWSAVETASKbits.FWSAVETASK = 0;
            save_success_flag = 0;
            SST25_sector_erase ( (save_fw_to_flash_ptr_W + 800), 0 ); // Запуск стирания этого же сектора
        }        
    }


// Мониторинг процесса стирания сектора
static unsigned char erase_counter1 = 0;
    if ( FLASHBUSYbits.fw_sector_erasing == 1 ) { //&& FLASHBUSYbits.fw_saving == 1 
        if (erase_counter1 <= 4) erase_counter1 ++; // Время стирания 40мс
        else {
            Nop();Nop();Nop();
            erase_counter1 = 0;
            FLASHBUSYbits.fw_sector_erasing = 0;
            FLASHBUSYbits.FLASHBUSY = 0;
            FWSAVETASKbits.FWSAVETASK = 0;
            if (save_success_flag == 1){
                FWDTASCKbits.sector_downloaded = 0;
            }
            
        }
    }
    else {
        erase_counter1 = 0;
    }
# endif
}
int  fw_sector_verification ( void ) {
static unsigned int i, j, first_entrans_flag = 0;
static unsigned char data,  *fw_ptr, res;
static unsigned long fw_addr;

    if (first_entrans_flag == 0) {
        first_entrans_flag = 1;
        fw_addr = save_fw_to_flash_ptr_W;
        fw_addr = fw_addr + 800;
        fw_addr = fw_addr * 4096;
        fw_ptr = fw_sector_buf;
        i = 0; j = 0;
    }
        res = 1;
        i = 0;
        while ( i < 16 ) {    
            data = SST25_read_byte_from_flash ( (unsigned long)fw_addr ++ );
            if ( data != *fw_ptr ++) { res = 0; break; }                
            i ++;
            j ++;
        }
        
        
if ( res == 1 && j == 4096 ) {
    first_entrans_flag = 0;
    return 1; 
} 
if ( res == 0 ) { 
    first_entrans_flag = 0; 
    return 0; 
}
        
return -1;        
}


int  write_data_into_save_to_flash_bufs ( unsigned char *data_ptr, unsigned int length ) {
//unsigned int temp;
unsigned char *ptr_to_write, i, check_summ, *check_summ_ptr, *temp_ptr;   
//static unsigned long number_of_event_tmp;

number_of_event ++;

    ptr_to_write = save_to_flash_ptrs_buf [save_to_flash_ptr_W]; // извлечение указателя буфера для записи
    temp_ptr = ptr_to_write;
    check_summ_ptr = ptr_to_write + 123;
//    SST25_write_page_to_flash ( flash_ptr_W, data_ptr );
//    SST25_write_var_to_page   ( flash_ptr_W, 114, (long)GPS_odometer, 4 );
//    SST25_write_var_to_page   ( flash_ptr_W, 119, (long)flash_ptr_R, 2 );
//    SST25_write_var_to_page   ( flash_ptr_W, 121, (long)flash_ptr_W, 2 );
//    SST25_write_var_to_page   ( flash_ptr_W, 123, number_of_event, 4 );
    
    memmove ( ptr_to_write, data_ptr, 113 );
    *(ptr_to_write + 113) = (unsigned char) length;    
    *(ptr_to_write + 114) = (unsigned char)(GPS_odometer >> 24);
    *(ptr_to_write + 115) = (unsigned char)(GPS_odometer >> 16);
    *(ptr_to_write + 116) = (unsigned char)(GPS_odometer >> 8);
    *(ptr_to_write + 117) = (unsigned char)(GPS_odometer);
    *(ptr_to_write + 118) = 0x00;    
    *(ptr_to_write + 119) = (unsigned char)(flash_ptr_R >> 8);
    *(ptr_to_write + 120) = (unsigned char)(flash_ptr_R);
    *(ptr_to_write + 121) = (unsigned char)(flash_ptr_W >> 8);
    *(ptr_to_write + 122) = (unsigned char)(flash_ptr_W);

// Расчет контрольной суммы
check_summ = 0;    
    for ( i = 0; i < length; i++) {
        check_summ = check_summ ^ *temp_ptr;
        temp_ptr ++;
    }
    check_summ = check_summ ^ *(ptr_to_write + 113);
    check_summ = check_summ ^ *(ptr_to_write + 114);
    check_summ = check_summ ^ *(ptr_to_write + 115);
    check_summ = check_summ ^ *(ptr_to_write + 116);
    check_summ = check_summ ^ *(ptr_to_write + 117);
    check_summ = check_summ ^ *(ptr_to_write + 118);
    check_summ = check_summ ^ *(ptr_to_write + 119);
    check_summ = check_summ ^ *(ptr_to_write + 120);
    check_summ = check_summ ^ *(ptr_to_write + 121);
    check_summ = check_summ ^ *(ptr_to_write + 122);    
//    for ( i = 113; i < 123; i++) {
//        check_summ = check_summ ^ *ptr_to_write;
//        ptr_to_write ++;
//    }
    
    *check_summ_ptr = check_summ;//check_summ
//    *(ptr_to_write + 124) = (unsigned char)(number_of_event >> 16);
//    *(ptr_to_write + 125) = (unsigned char)(number_of_event >> 8);
//    *(ptr_to_write + 126) = (unsigned char)(number_of_event);
    
	if ((save_to_flash_ptr_W + 1) % 4 != save_to_flash_ptr_R) { save_to_flash_ptr_W++; } // Инкремент указателя записи, если буфер не заполнен
    else { save_to_flash_ptr_R ++; save_to_flash_ptr_R %= 4; save_to_flash_ptr_W ++;}    // иначе - инкремент буферов чтения и записи. Потеря самой старой SMS
	save_to_flash_ptr_W %= 4;


}
int  write_data_into_save_to_flash2_bufs ( unsigned char *data_ptr, unsigned int length, unsigned char sms_sent ) {
//unsigned int temp;
unsigned char *ptr_to_write, i, check_summ, *check_summ_ptr, *temp_ptr;   
//static unsigned long number_of_event_tmp;

number_of_event ++;

    ptr_to_write = &save_to_flash2_buf [save_to_flash2_ptr_W][0]; // извлечение указателя на буфер для записи
    temp_ptr = ptr_to_write;
    check_summ_ptr = ptr_to_write + 123;

    
    memmove ( ptr_to_write, data_ptr, 113 );
    save_to_flash2_buf [save_to_flash2_ptr_W][113] = (unsigned char) length;
    save_to_flash2_buf [save_to_flash2_ptr_W][122] = sms_sent;
    
/*    
    *(ptr_to_write + 113) = (unsigned char) length; 
    *(ptr_to_write + 114) = (unsigned char)(GPS_odometer >> 24);
    *(ptr_to_write + 115) = (unsigned char)(GPS_odometer >> 16);
    *(ptr_to_write + 116) = (unsigned char)(GPS_odometer >> 8);
    *(ptr_to_write + 117) = (unsigned char)(GPS_odometer);
    *(ptr_to_write + 118) = 0x00;    
    *(ptr_to_write + 119) = (unsigned char)(flash_ptr_R >> 8);
    *(ptr_to_write + 120) = (unsigned char)(flash_ptr_R);
    *(ptr_to_write + 121) = (unsigned char)(flash_ptr_W >> 8);
    *(ptr_to_write + 122) = (unsigned char)(flash_ptr_W);
*/
    
// Расчет контрольной суммы
check_summ = 0;    
    for ( i = 0; i < length; i++) {
        check_summ = check_summ ^ *temp_ptr;
        temp_ptr ++;
    }
    check_summ = check_summ ^ *(ptr_to_write + 113);
    check_summ = check_summ ^ *(ptr_to_write + 114);
    check_summ = check_summ ^ *(ptr_to_write + 115);
    check_summ = check_summ ^ *(ptr_to_write + 116);
    check_summ = check_summ ^ *(ptr_to_write + 117);
    check_summ = check_summ ^ *(ptr_to_write + 118);
    check_summ = check_summ ^ *(ptr_to_write + 119);
    check_summ = check_summ ^ *(ptr_to_write + 120);
    check_summ = check_summ ^ *(ptr_to_write + 121);
    check_summ = check_summ ^ *(ptr_to_write + 122);    
    
    *check_summ_ptr = check_summ;//check_summ
    
	if ((save_to_flash2_ptr_W + 1) % 4 != save_to_flash2_ptr_R) { save_to_flash2_ptr_W++; } // Инкремент указателя записи, если буфер не заполнен
    else { save_to_flash2_ptr_R ++; save_to_flash2_ptr_R %= 4; save_to_flash2_ptr_W ++;}    // иначе - инкремент буферов чтения и записи. Потеря самой старой SMS
	save_to_flash2_ptr_W %= 4;
    Nop();Nop();Nop();

}
//void write_ACK_flag_into_page (void) {
//    
//    if (FLASHBUSYbits.FLASHBUSY == 0) {
//        
//        if ( ACK_ptr_R != ACK_ptr_W ) {
//            Nop(); Nop(); Nop();
//            SST25_write_var_to_page   ( ACK_ptrs_buf [ ACK_ptr_R ], 127, 1, 1 );
//            ACK_ptr_R ++; ACK_ptr_R %= 5;
//        }
//        
//    }
//    
//    
//}
void save_data_to_flash (void) {
//static int flash_busy_counter = 0;
//int fail = 0;

// Сохранение данных аварии
        if (CRASHTASKbits.crash_record_done == 1 && CRASHTASKbits.trek_record_done == 1) {
            if ((flash_write_monitor_flag == 1)||(flash_write_end_flag == 1)) {
//                flash_write_monitor_flag = 0;
                save_crash_to_flash ();
            }
        }

// Сохранение данных Type 1 и 2 очереди 1 и 2
        if ((flash_write_monitor_flag == 1)||(flash_write_end_flag == 1)) {

            save_page_to_flash2 ();
            save_page_to_flash ();

//            if (FLASHBUSYbits.FLASHBUSY != 0) {
//
//                Nop(); Nop(); Nop();
//                if (flash_busy_counter < 10) {flash_busy_counter ++;}
//                else {
//                    flash_busy_counter = 0;
////                    Nop(); Nop(); Nop();
////                    if (FLASHBUSYbits.page_saving == 1)    fail = 1;
////                    if (FLASHBUSYbits.sector_erasing == 1) fail = 2;
////                    if (FLASHBUSYbits.acc_saving == 1)     fail = 3;
////                    FM25_write_1 ( 511, fail);
////                    asm ("reset");
//                }
//            } else {flash_busy_counter = 0;}

        }

// Сохранение прошивки
        if (FWDTASCKbits.sector_downloaded == 1) {
            if ((flash_write_monitor_flag == 1)||(flash_write_end_flag == 1)) {

                flash_write_monitor_flag = 0;
                save_fw_to_flash ();

            }
        }

flash_write_monitor_flag = 0;
}
/*
void waiting_button (char beeps) {
char counter;
    counter = 0;
    while (1) {
        __delay_ms (10);
        if (BUTTON == 0) counter ++;
        else if (counter > 0) counter --; 
        if (counter >= 10) break;
    }
    
//IGN_LED = 1;
__delay_ms (250);
//IGN_LED = 0;

while (BUTTON == 0) {};

    
}
*/

/*
int  voltage_freq_calibration (void) {
int i;

    if (BUTTON == 1) return;
    while (BUTTON == 0) {
        if (i < 10) i++;
        else break;
        __delay_ms(10);    
    }
    if ( i < 9 ) return;

    BUZZ = 1;
    __delay_ms(100);
    BUZZ = 0;

start_frq_calibr = 0;

    for (i = 10; i <= 870; i = i + 10 ) {
        OC1R = i;        
        __delay_ms(50);
        start_frequency_mesuare ();
        while (frequency_ready == 0);
            bin_2_bcd ((long) frequency);
            load_UART4_Tx_buf (bin_2_bcd_buf);
            UART4_Tx_buf[9] = '\r';UART4_Tx_buf[10] = '\n';UART4_Tx_buf[11] = 0;
            start_UART4_transmission(WAITON);
        if (frequency > 150) break;
        Nop();Nop();Nop();
        frequency = 0;
        Nop();Nop();Nop();
    }
    OC1R = (ign_volt_trh_min + i) >> 1;
    ign_volt_trh = OC1R;
    
    bin_2_bcd ( (long)ign_volt_trh );
    SST25_read_page_to_buf ( 32704, flash_sector_buf, 1024 );
    flash_sector_buf[20] = bin_2_bcd_buf[6]; flash_sector_buf[21] = bin_2_bcd_buf[7]; flash_sector_buf[22] = bin_2_bcd_buf[8];
    SST25_sector_erase ( 1022, 1 );
    SST25_write_page_to_flash ( 32704, flash_sector_buf );
    
//    ign_frq_trh_min    
    
    
    BUZZ = 1;
    __delay_ms(100);
    BUZZ = 0;
    __delay_ms(200);    
    BUZZ = 1;
    __delay_ms(100);
    BUZZ = 0;    
Nop();Nop();Nop();    


}
*/
int  check_enjine_running (void) {
static unsigned int freq_mesuare_counter = 0;//, freq_average_counter = 0;
static unsigned int /*freq_average = 0,*/ ignition_on_flag = 0;
//static unsigned char ign_on_off_counter = 0;

    if ( FIXFLAGSbits.ready == 1 ) {
        if ( (IGNEVENTSFLAGSbits.trigg_on == 1) && (IGNEVENTSFLAGSbits.trigg_off == 0) ) {
            if (( Navi_bin[17] >= 5 ) && (Navi_str [62] == 'A')) {
                ign_on_off_counter = ign_on_time + 5;
            }
        }
    }

    if (freq_mesuare_counter < 10) {
        freq_mesuare_counter ++;
    } else {
        freq_mesuare_counter = 0;
        start_frequency_mesuare ();
    }

    if (frequency_ready == 1) {
        frequency_ready = 0;
            freq_average_to_send = frequency;
//            bin_2_bcd ((long) frequency);
//            load_UART4_Tx_buf (bin_2_bcd_buf);
//            UART4_Tx_buf[9] = '\r';UART4_Tx_buf[10] = '\n';UART4_Tx_buf[11] = 0;
//            start_UART4_transmission(WAITOFF);
        
        if (frequency > ign_frq_trh) {
            if ( ign_on_off_counter < ign_on_time ) ign_on_off_counter ++;
        }
        else {
            if ( ign_on_off_counter > 0 ) ign_on_off_counter --;
        }
        
        if ( ign_on_off_counter >= ign_on_time ) {
            if (IGNPULSVFALLTSETbits.enable == 0) { // Просадка напряжения при старте не учитывается
                if (ignition_on_flag == 0) { ignition_on_flag = 1; max_speed = 0;}
                ignition_by_pulse = 1;
                STATUSFLAGS1bits.engine_running = 1;
                if (CANIGNPRMSbits.can_number == 0 && CANIGNPRMS2bits.can_number == 0 && fisical_input_enable != 1) ignition = 1;            
            }
            else {
                if (IGNPULSVFALLTASCKbits.timer > 0) { // Если была просадка в течение IGNPULSVFAULTSETbits.timer_value
                    if (ignition_on_flag == 0) { ignition_on_flag = 1; max_speed = 0;}
                    ignition_by_pulse = 1;
                    STATUSFLAGS1bits.engine_running = 1;
                    if (CANIGNPRMSbits.can_number == 0 && CANIGNPRMS2bits.can_number == 0 && fisical_input_enable != 1) ignition = 1;            
                }
            }
            Nop(); Nop(); Nop();            
        }
        if ( ign_on_off_counter <= ign_off_time ) {
            if (ignition_on_flag == 1) { ignition_on_flag = 0; max_speed = 0;}
            ignition_by_pulse = 0;
            STATUSFLAGS1bits.engine_running = 0;
            if (CANIGNPRMSbits.can_number == 0 && CANIGNPRMS2bits.can_number == 0 && fisical_input_enable != 1) {
                ignition = 0; 
                if (start_engine_success_flag == 1) { // 
                    if (ignition == 0) {
                        start_engine_success_flag = 0;
                        dd_intrusion_off_timer = dd_intrusion_off_setting; // 5 секундный таймер игнорирования вторжения по дверям
                    }

                }                
            }

        }    
        
//        if (freq_average_counter  < 5) {
//            freq_average_counter ++;
//            freq_average = freq_average + frequency;
//            bin_2_bcd ((long) frequency);
//            load_UART4_Tx_buf (bin_2_bcd_buf);
//            UART4_Tx_buf[9] = '\r';UART4_Tx_buf[10] = '\n';UART4_Tx_buf[11] = 0;
//            start_UART4_transmission(WAITOFF);
//        }
//        else {
//            Nop(); Nop(); Nop();
//            freq_average_counter = 0;
//            freq_average = freq_average / 5;
//            if (freq_average > ign_frq_trh) {
//                if (ignition_on_flag == 0) { ignition_on_flag = 1; max_speed = 0;}
//                freq_average_to_send = freq_average;
//                freq_average = 0;
//                ignition = 1;
//                IGN_LED = 1;
//                Nop(); Nop(); Nop();
//            }
//            else {
//                if (ignition_on_flag == 1) { ignition_on_flag = 0; max_speed = 0;}
//                freq_average_to_send = freq_average;
//                freq_average = 0;
//                ignition = 0;
//                IGN_LED = 0;
//            }
//        }

    } //if (frequency_ready == 1)
    
return -1;    
}
int  check_power_event (void) {
    
    if ((PWREVENTSFLAGSbits.trigg_on== 0)&&(power == 1)) {
        PWREVENTSFLAGSbits.trigg_on = 1; PWREVENTSFLAGSbits.trigg_off = 0;
        PWREVENTSFLAGSbits.event_on_flag = 1;
//        generate_content_of_message ( 6, 1 );
    }
    if ((PWREVENTSFLAGSbits.trigg_off== 0)&&(power == 0)) {
        PWREVENTSFLAGSbits.trigg_on = 0; PWREVENTSFLAGSbits.trigg_off = 1;
        PWREVENTSFLAGSbits.event_off_flag = 1;
//        generate_content_of_message ( 7, 1 );
        if ((ignition == 1)) {
            ignition = 0;
        }        
        
    }
if ((PWREVENTSFLAGSbits.event_on_flag == 1)||(PWREVENTSFLAGSbits.event_off_flag == 1)) return 1;
return 0;    
}

int  check_fix_condition (void) {
unsigned int delta_course;
unsigned long delta_time;
static unsigned char counter = 0, idle_counter = 0, speed_off_counter = 0;
static unsigned char current_speed = 0, delta_speed = 0;

    FIXFLAGSbits.ready = 0;

    FIXFLAGSbits.distance = 0; //distans_fix_flag = 0;
    FIXFLAGSbits.course = 0; //course_fix_flag = 0;
    FIXFLAGSbits.time = 0; //time_fix_flag = 0;
    FIXFLAGSbits.speed = 0;
    delta_time = 0;
    
    if (speed_off_counter < SPEEDSETbits.time) speed_off_counter ++;
    
    if ( (IGNEVENTSFLAGSbits.trigg_on == 1) && (IGNEVENTSFLAGSbits.trigg_off == 0) ) {
        
//        if (swt == 1) Navi_bin[17] = 4;
//        else Navi_bin[17] = 6;
        
        if ( Navi_bin[17] <= 5 ) {
            if ( idle_counter < 180 ) idle_counter ++;
            if ( idle_counter >= 180 )  idle = 1;     
        }

    }
    else {
        idle = 0; idle_counter = 0;
    }
    
    if ( Navi_bin[17] > 5 ) { idle = 0; idle_counter = 0; }
    
    if ((IDLEEVENTSFLAGSbits.trigg_on== 0)&&(idle == 1)) {
        IDLEEVENTSFLAGSbits.trigg_on = 1; IDLEEVENTSFLAGSbits.trigg_off = 0;
        IDLEEVENTSFLAGSbits.event_on_flag = 1;
        fix_to_fix_mileage = 0;
        time1 = time2;
        course1 = course2;
        max_speed_to_send = max_speed;
        max_speed = 0;        
    }
    if ((IDLEEVENTSFLAGSbits.trigg_off== 0)&&(idle == 0)) {
        IDLEEVENTSFLAGSbits.trigg_on = 0; IDLEEVENTSFLAGSbits.trigg_off = 1;
        IDLEEVENTSFLAGSbits.event_off_flag = 1;
        fix_to_fix_mileage = 0;
        time1 = time2;
        course1 = course2;
        max_speed_to_send = max_speed;
        max_speed = 0;        
    }
    
    
    if (IGNEVENTSFLAGSbits.trigg_off == 1) {
        fix_to_fix_mileage = 0;
        time1 = time2;
        course1 = course2;
        max_speed_to_send = max_speed;
        max_speed = 0;
        IDLEEVENTSFLAGSbits.event_off_flag = 0;
        idle = 0; idle_counter = 0;
        speed_off_counter = 0;
        current_speed = Navi_bin[17];
    }
    
    if (PWREVENTSFLAGSbits.trigg_off == 1) {
        fix_to_fix_mileage = 0;
        time1 = time2;
        course1 = course2;
        max_speed_to_send = max_speed;
        max_speed = 0;
        speed_off_counter = 0;
        current_speed = Navi_bin[17];
    }

// HEADING
if (HEADINGDATbits.queue != 0) { 
    if ( counter >= 2 ) {
        counter = 0;
        
        if (course2 >= course1) delta_course = course2 - course1;
        else  delta_course = course1 - course2;
        course1 = course2;
        
            if ((delta_course >= 5) && (Navi_bin[17] >= 7)) {
                FIXFLAGSbits.course = 1; 
                fix_to_fix_mileage = 0;
                time1 = time2;
                max_speed_to_send = max_speed;
                max_speed = 0;
                speed_off_counter = 0;
                current_speed = Navi_bin[17];
            }
        
    }
    else counter ++;
}
// DISTANCE
if (DISTDATbits.queue != 0) {    
	if (fix_to_fix_mileage >= 1000.0) {
        FIXFLAGSbits.distance = 1; //distans_fix_flag = 1; 
        fix_to_fix_mileage = 0;
        time1 = time2;
        course1 = course2;
        max_speed_to_send = max_speed;
        max_speed = 0;
        speed_off_counter = 0;
        current_speed = Navi_bin[17];
	}
}    
// TIMED
if (TIMEDDATbits.queue != 0) {   
	if (time2 > time1) delta_time = time2 - time1;
    else { time2 = time1; delta_time = 0; }
	if (delta_time >= timed_period) { //60
        FIXFLAGSbits.time = 1; //time_fix_flag = 1;
        time1 = time2;
        fix_to_fix_mileage = 0;
        course1 = course2;
        max_speed_to_send = max_speed;
        max_speed = 0;
        speed_off_counter = 0;
        current_speed = Navi_bin[17];
	}
}
// SPEED
if (SPEEDDATbits.queue != 0) {
    
    if ( current_speed >= Navi_bin[17] ) delta_speed =  current_speed - Navi_bin[17];
    else delta_speed = Navi_bin[17] - current_speed;
    
        if (speed_off_counter >= SPEEDSETbits.time) {
            Nop();Nop();Nop();
            if (delta_speed >= SPEEDSETbits.speed) {
                FIXFLAGSbits.speed = 1;
                time1 = time2;
                fix_to_fix_mileage = 0;
                course1 = course2;
                max_speed_to_send = max_speed;
                max_speed = 0;                
                current_speed = Navi_bin[17];
                speed_off_counter = 0;               
            }
        }
    

}
    
return 0;

}
void speed_treshold_task (void) {
//static unsigned int counter = 0, trigger = 0;

    if ( SPEEDTRHDATbits.queue == 0 ) { SPEEDTRHTASKbits.SPEEDTRHTASK = 0; return;}    

//if (trigger == 0) {
//    if (counter < 150) {
//        counter ++;
//        Navi_bin[17] = counter;
//    }
//}
//if (trigger == 1) {
//    if (counter > 0) {
//        counter --;
//        Navi_bin[17] = counter;
//    }
//} 
//if (counter == 150) trigger = 1;
//if (counter == 0)   trigger = 0;



    if ( Navi_bin[17] >= SPEEDTRHSET1bits.treshold && SPEEDTRHTASKbits.trh1_trigg == 0 ) {
        SPEEDTRHTASKbits.trh1_trigg = 1;
        generate_content_of_message ( 66, 1 );
    }
    if ( (Navi_bin[17] <= (SPEEDTRHSET1bits.treshold - SPEEDTRHSET1bits.histeresis)) && SPEEDTRHTASKbits.trh1_trigg == 1 ) {
        SPEEDTRHTASKbits.trh1_trigg = 0;
        generate_content_of_message ( 67, 1 );
    }

    if ( Navi_bin[17] >= SPEEDTRHSET2bits.treshold && SPEEDTRHTASKbits.trh2_trigg == 0 ) {
        SPEEDTRHTASKbits.trh2_trigg = 1;
        generate_content_of_message ( 68, 1 );
    }
    if ( (Navi_bin[17] <= (SPEEDTRHSET2bits.treshold - SPEEDTRHSET2bits.histeresis)) && SPEEDTRHTASKbits.trh2_trigg == 1 ) {
        SPEEDTRHTASKbits.trh2_trigg = 0;
        generate_content_of_message ( 69, 1 );
    }

    if ( Navi_bin[17] >= SPEEDTRHSET3bits.treshold && SPEEDTRHTASKbits.trh3_trigg == 0 ) {
        SPEEDTRHTASKbits.trh3_trigg = 1;
        generate_content_of_message ( 70, 1 );
    }
    if ( (Navi_bin[17] <= (SPEEDTRHSET3bits.treshold - SPEEDTRHSET3bits.histeresis)) && SPEEDTRHTASKbits.trh3_trigg == 1 ) {
        SPEEDTRHTASKbits.trh3_trigg = 0;
        generate_content_of_message ( 71, 1 );
    }


}
void arm_function (void) {
    
    if (arm_enable == 0) {
        ARMFLAGSbits.arm_timer = 0;
        ARMFLAGSbits.intrusion_timer = 0;
    }

    if (ARMFLAGSbits.arm_status == 0) {
        ARMFLAGSbits.arm_timer ++;
            if (ARMFLAGSbits.arm_timer > 600) { // Таймер постановки в охрану
                OUTbits.arm_flag = 1;
//                disarmed_by_button_flag = 0;
                fire_rel_transaction_flag = 1;
                RELTRANSFLGSbits.rel_arm = 1;
//                RF_freezed_monitor_flag = 1;
//                if (ARMFLAGSbits.arm_status == 0) start_beep_task ( 300, 10, 1); // Писк 3 секунды
                ARMFLAGSbits.arm_status = 1;
                ARMFLAGSbits.arm_on_event = 1;
                ARMFLAGSbits.arm_off_event = 0;
                ARMFLAGSbits.arm_off_event_sent = 0;
# if defined (WIRED_ENJINE_BLOKING)
    # if defined (MCP23S08)

    # else
                if (OUTFUNCbits.pin15 == 3) { L_OUT = 1; } 
    # endif
# endif                
            }
            else {
                if ((ignition == 1)||(SERVFLAGSbits.serv_status == 1)) ARMFLAGSbits.arm_timer = 0;
            }
    }

    
        
        if ( ignition != ignition_tmp ) {
            ignition_tmp = ignition;
            if (ARMFLAGSbits.arm_status == 1) {
                // Запуск вторжения по зажиганию только если не работает автозапуск
                if (IGNINTROFFAUTORUNbits.start == 0 && STARTENGINESbits.start == 0 && STARTENGINEDLbits.start == 0 ) {
                    if ((INTRREASONbits.INTRREASON == 0) && ( ignition == 1 )) {
                        ARMFLAGSbits.intr_event_trigg = 1;
                        if (INTRREASONbits.INTRREASON == 0) { INTRREASONbits.ign = 1; }
                    }
                }
                if (intrusion_off_by_input_flag == 1) {
                    ARMFLAGSbits.intr_event_trigg = 0;
                    INTRREASONbits.ign = 0;                    
                } 
            }
        }
    
    

    if (ARMFLAGSbits.intr_event_trigg == 1) {
        if (ARMFLAGSbits.intrusion_timer < 600) {
            if (ARMFLAGSbits.intrusion_timer == 1) RF_freezed_monitor_flag = 1;
            ARMFLAGSbits.intrusion_timer ++; 
            // если реле не ответило на первые запросы и метка не считалась, развешивание радиоканала
            if ( ARMFLAGSbits.intrusion_timer == 65 && RF_freezed_monitor_flag == 1 ) {
                RFRESETbits.start = 1;
                convert_N1_N2_to_hexstr ();
                load_answer ( 2, "reset rf due freezed", 0, 0 );
                Nop();Nop();Nop();
            }
             // проверка наличия реле
            if (ARMFLAGSbits.intrusion_timer == 55  || ARMFLAGSbits.intrusion_timer == 60 || 
                ARMFLAGSbits.intrusion_timer == 105 || ARMFLAGSbits.intrusion_timer == 110 || ARMFLAGSbits.intrusion_timer == 115) {
                Nop();Nop();Nop();
                if ( relay_enable == 1 ) fire_rel_transaction_flag = 1;     
            } 
        }
        else {
            ARMFLAGSbits.intr_event = 1;

        }
        
    }
    
}
void wired_relay_disarm_function (void) {
    
# if defined (WIRED_ENJINE_BLOKING)
    # if defined (MCP23S08)

    # else    
        if (OUTFUNCbits.pin15 == 3) {
            if (wired_block == 0) {
                if (SECONDAUTHORbits.on == 0) {
                    if (OUTbits.arm_flag == 0) L_OUT = 0;
                }
            } else L_OUT = 1;

        } 
    # endif
# endif 
        
}

void robbery_servoff_function (void) {
//static unsigned char speed_temp = 31;
static unsigned int servoff_timer = 0;

//        Navi_bin[17] = speed_temp; // ДЛЯ СИМУЛЯЦИИ РАЗБОЯ
        
    if ( ROBBFLAGSbits.robb_status == 0 && ignition == 1 && ARMFLAGSbits.arm_status == 0 && SERVFLAGSbits.serv_status == 0) { // && SERVFLAGSbits.serv_status == 0
        
        if (arm_enable == 0) {ROBBFLAGSbits.robb_timer = 0;}
        
        if ( Navi_bin[17] > ROBBERYSETbits.speed ){ // 20
            
            if (ROBBFLAGSbits.robb_timer < ROBBERYSETbits.duration) ROBBFLAGSbits.robb_timer ++; // 200
            else {
                ROBBFLAGSbits.robb_timer = 0;
                ROBBFLAGSbits.robb_status = 1;
                ROBBFLAGSbits.robb_on_event = 1;
            }

        } else {
//            ROBBFLAGSbits.robb_timer = 0;
        }
        
    }

    if (SERVFLAGSbits.serv_status == 1 && ignition == 1 && ( Navi_bin[17] > 30 && Navi_bin[17] < 250) ) {
        
        if (servoff_timer < 600) servoff_timer ++;
        else {
            servoff_timer = 0;
            service_OFF ();
            serv_off_by_speed_flag = 1;
            RELTRANSFLGSbits.rel_serv_off = 1;
        }

    }
    else {
        servoff_timer = 0;
    }
    
}
void svr_events_generation (void) {
    
// Формирование сообщения о включении/выключении сервисного режима 
    if ((SERVFLAGSbits.serv_on_event == 1)&&(SERVFLAGSbits.serv_on_event_sent ==  0)) {
        SERVFLAGSbits.serv_on_event_sent = 1;
        FM25_write_1( 1586, (unsigned int) SERVFLAGSbits.SERVFLAGS );  
        generate_content_of_message ( 30, 1 );
    }
    if ((SERVFLAGSbits.serv_off_event == 1)&&(SERVFLAGSbits.serv_off_event_sent == 0)) {
        SERVFLAGSbits.serv_off_event_sent = 1;
      
        FM25_write_1( 1586, (unsigned int) SERVFLAGSbits.SERVFLAGS );
        
        if (serv_off_by_speed_flag == 0) {
            generate_content_of_message ( 31, 1 );
        }
        else {
            serv_off_by_speed_flag = 0;
            generate_content_of_message ( 32, 1 );
        }
    }
// Формирование сообщения о постановке/снятии с охраны 
    if ((ARMFLAGSbits.arm_on_event == 1)&&(ARMFLAGSbits.arm_on_event_sent ==  0)) {
        ARMFLAGSbits.arm_on_event_sent = 1;
            if ((hands_free_enable == 1)) {
                LOCKUNLOCKbits.LOCKUNLOCK = 0;
                LOCKUNLOCKbits.start = 1; // Закрытие замков
                LOCKUNLOCKbits.lock = 1; // Закрытие замков
            }
#if defined (MAZDA_CX5)
                blink_arm_event_flag = 1;
#endif        
           
            generate_content_of_message ( 27, 1 );
    }
    if ((ARMFLAGSbits.arm_off_event == 1)&&(ARMFLAGSbits.arm_off_event_sent ==  0)) {
        ARMFLAGSbits.arm_off_event_sent = 1;
            if ((hands_free_enable == 1)) {
                LOCKUNLOCKbits.LOCKUNLOCK = 0;
                LOCKUNLOCKbits.start = 1; // Открытие замков
                LOCKUNLOCKbits.unlock = 1; // Открытие замков
            }
#if defined (MAZDA_CX5)
            blink_disarm_event_flag = 1;
#endif 
          
            generate_content_of_message ( 28, 1 );
    }
// Формирование сообщения вторжение по зажиганию 
    if ((ARMFLAGSbits.intr_event == 1)&&(ARMFLAGSbits.intr_event_sent ==  0)) {
        ARMFLAGSbits.intr_event_sent = 1;
        
        if (INTRREASONbits.ign == 1) {
            if (IGNINTROFFAUTORUNbits.start == 1) { // Если вторжение по зажиганию возникло
                Nop();Nop();Nop();                                                                    // пока идет автозапуск - оно не формируется
            } else {
                generate_content_of_message ( 29, 1 );
            }
        } else {
            generate_content_of_message ( 29, 1 );
        }
            
            ARMFLAGSbits.intr_event = 0; ARMFLAGSbits.intr_event_trigg = 0;
            ARMFLAGSbits.intr_event_sent = 0; ARMFLAGSbits.intrusion_timer = 0;
            INTRREASONbits.INTRREASON = 0;            
    }
//Формирование сообщения о разбое    
    if ((ROBBFLAGSbits.robb_on_event== 1)&&(ROBBFLAGSbits.robb_on_event_sent ==  0)) {
        ROBBFLAGSbits.robb_on_event_sent = 1;
          
            generate_content_of_message ( 39, 1 );           
    } 

    
}
void periodic_tascks (void) {

static int gsm_status, context_status, server_connection_status, gps_wdt_counter = 0;
static int close_connection_status;
static unsigned int gsm_wdt = 0;//, freq_mesuare_counter = 0, freq_average_counter = 0;
//static unsigned int freq_average = 0;
//unsigned long GPS_odometer_to_send;
//unsigned long long data_flags;
static unsigned int flash2_ptr_R_tmp = 0xFFFF, send_sms_flag = 0, sms_enable = 0;
//static unsigned int ack_tmp;
static unsigned char name, n, sms_sent;

/*
//СДЕЛАТЬ монитор UDP соединения - если CONNECT OK eсть, а акноледжей нет - перегрузить модем 
//(на изменение настройки сервера - модем не отреагировал)!
*/
    
    voltage_fall_detection ();
    check_enjine_running ();
    
//    voltage_freq_calibration (); // Раскомментировать для калибровки пульсаций

/*
if (IGN == 1) {
	if (ignition_counter < 20) {
	ignition_counter ++;
		if (ignition_counter == 20) {
            ignition = 1;
		}
	}
} else {
		if (ignition_counter > 0) {
		ignition_counter --;
			if (ignition_counter == 0) {
                ignition = 0;
			}
		}
}
*/
    
//// Таймер состояния SIM карты, рестарт модема, если SIM недоступна 10 секунд
//    if (sim_presence_timer != 0) {
//        sim_presence_timer ++;
//        if (GSMSTATUSbits.cpin == 1) sim_presence_timer = 0;
//        if (sim_presence_timer >= 100) {
//            sim_presence_timer = 0;
//            modem_on_off (MODEM_RESTART);
//        }
//    }

    if (nav_trigger == 0) {
        if (gps_wdt_counter > 100) {
            gps_wdt_counter = 0;
# if defined (MCP23S08)
//            gps_reset_flag = 1;
# else            
            GPS_RST = 0;
            __delay_ms (20);
            GPS_RST = 1;
# endif
        } else gps_wdt_counter ++;
    } else gps_wdt_counter = 0;
    
    apply_setting ();
    
    gsm_status = check_gsm_status ();
    if (gsm_status < 0) {
        Nop(); Nop(); Nop();
        modem_on_off (MODEM_EMERG_RST);
    } 
    else {
        // Если модем включен и не зарегестрировался в сети за минуту - рестарт модема
        if (gsm_status == 1) {
            if ( NETWORKSTATUSbits.cgreg != 1 && NETWORKSTATUSbits.cgreg != 5 ) {
                if ( gsm_wdt < 600 ) { gsm_wdt ++; }
                else {
                    Nop(); Nop(); Nop();
                    gsm_wdt = 0;
                    modem_on_off (MODEM_EMERG_RST); // ################################
                }
            } else { gsm_wdt = 0; }
        }
    }

    context_status = set_gprs_context ();
    if (context_status < 0) {
        Nop(); Nop(); Nop();
    }

// #############################
    if ( gsm_status == 1 && context_status == 3 ) get_gprs_status ( gsm_status, context_status ); // Проверка регистрации в сети и GPRS

    server_connection_status = start_udp_tcp_connection (context_status);
    if (server_connection_status < 0) {
        Nop(); Nop(); Nop();
    }
    if (context_status == 3 && server_connection_status == 0) GPRSSTATUSbits.start = 1; // Запуск процесса соединения с сервером
    server_connection_monitor (server_connection_status);

    close_connection_status = close_udp_tcp_connection (0);
    close_udp_tcp_connection_monitor (close_connection_status);


// Индикация состояния GSM
    if (GSMSTATUSbits.power == 1) {gsm_LED_blinking ();}
    else { 
# if defined (MCP23S08)
        if ( io_reset_flag == 0 && gps_reset_flag == 0 ) {
            GSM_LED = 0;
        }
# else        
        GSM_LED = 0; 
# endif        
    }
// Индикация состояния GPS
    gnss_LED_blinking ();
    
/*    
    static unsigned int type0_counter = 0;
    static unsigned int ACK0_counter;
    if (server_connection_status == 4 ) {
        
        if ( type0_counter > 200 ) {
           type0_counter = 0;
           write_data_to_GPRS_buf ( TYPE0, 9 );
           TYPE0SENDbits.received_ACK = 1;
           ACK0_counter = 0;
        } else type0_counter ++;
    
            if (ACK0_counter < 50) {
                ACK0_counter ++;
                if (( TYPE0SENDbits.waiting_ACK == 1 )&&( TYPE0SENDbits.ACK == 1 )) {

                    if (TYPE0SENDbits.received_ACK == 0xFFFF) { //
                        ACK0_counter = 0;
                        TYPE0SENDbits.TYPE0SEND = 0;                        
                    }
                    
                }
            } else {
                ACK0_counter = 0;
                TYPE0SENDbits.TYPE0SEND = 0;
            }        
    }    
*/
    
    if ((IGNEVENTSFLAGSbits.trigg_on== 0)&&(ignition == 1)) {
        IGNEVENTSFLAGSbits.trigg_on = 1; IGNEVENTSFLAGSbits.trigg_off = 0;
        IGNEVENTSFLAGSbits.event_on_flag = 1;
    }
    if ((IGNEVENTSFLAGSbits.trigg_off== 0)&&(ignition == 0)) {
        IGNEVENTSFLAGSbits.trigg_on = 0; IGNEVENTSFLAGSbits.trigg_off = 1;
        IGNEVENTSFLAGSbits.event_off_flag = 1;
        
        IDLEEVENTSFLAGSbits.trigg_on = 0; IDLEEVENTSFLAGSbits.trigg_off = 1;
    }

    check_power_event ();
    
    if ( FIXFLAGSbits.ready == 1 ) {
        check_fix_condition ();
        speed_treshold_task ();
    }
//    static unsigned int ACK_counter;
    int sending_status;    
//    static unsigned int datasend_counter = 0;
//    unsigned char fuel_tmp;
    
   
//    if (server_connection_status == 4 && nav_trigger) {
        

        if (( FIXFLAGSbits.FIXFLAGS )||( IGNEVENTSFLAGSbits.event_on_flag == 1 )||( IGNEVENTSFLAGSbits.event_off_flag == 1 )||
            ( PWREVENTSFLAGSbits.event_on_flag == 1)||(PWREVENTSFLAGSbits.event_off_flag == 1)||(IDLEEVENTSFLAGSbits.event_off_flag == 1)||
            ( IDLEEVENTSFLAGSbits.event_on_flag == 1)) 
        {
            if (FIXFLAGSbits.time == 1)      name = 1;
            if (FIXFLAGSbits.distance == 1)  name = 2;
            if (FIXFLAGSbits.course == 1)    name = 3;
            if (FIXFLAGSbits.speed == 1)     name = 63;
//            if (FIXFLAGSbits.idlestart == 1) name = 6;
//            if (FIXFLAGSbits.idleend == 1)   name = 7;
            FIXFLAGSbits.FIXFLAGS = 0;
//            if ( IGNEVENTSFLAGSbits.event_on_flag == 1 )  { name = 4; IGNEVENTSFLAGSbits.event_on_flag = 0; }
//            if ( IGNEVENTSFLAGSbits.event_off_flag == 1 ) { name = 5; IGNEVENTSFLAGSbits.event_off_flag = 0; }
            
            if ( PWREVENTSFLAGSbits.event_on_flag == 1 )  { name = 6; PWREVENTSFLAGSbits.event_on_flag = 0; }
            if ( PWREVENTSFLAGSbits.event_off_flag == 1 ) { name = 7; PWREVENTSFLAGSbits.event_off_flag = 0; }
            
            if ( IDLEEVENTSFLAGSbits.event_on_flag == 1 )  { name = 8; IDLEEVENTSFLAGSbits.event_on_flag = 0; }
            if ( IDLEEVENTSFLAGSbits.event_off_flag == 1 ) { name = 9; IDLEEVENTSFLAGSbits.event_off_flag = 0; }
            
            if ( IGNEVENTSFLAGSbits.event_on_flag == 1 )  { name = 4; IGNEVENTSFLAGSbits.event_on_flag = 0; }
            if ( IGNEVENTSFLAGSbits.event_off_flag == 1 ) { name = 5; IGNEVENTSFLAGSbits.event_off_flag = 0; }
            
            
/*            
            reload_GPRS_header ( 4, name, 0x0015); // N = 4, name = 1, type = 1, ACK = 1, CRC = 1
            memmove ( command_temp_buf, GPRS_header_buf, 12 );
            ACK_counter = 0xFFFF;
            command_temp_buf[12] = (unsigned char) (ACK_counter >> 8); command_temp_buf[13] = (unsigned char) ACK_counter; // ACK
            command_temp_buf[14] = 0xFF; command_temp_buf[15] = 0x77; command_temp_buf[16] = 0x02; // Dataflags
            memmove  ( &command_temp_buf[17], Navi_bin, 22 );

            command_temp_buf[39] = max_speed_to_send;
            
            GPS_odometer_to_send = ( GPS_odometer + 5 )/10;

            command_temp_buf[40] = (unsigned char)(GPS_odometer_to_send >> 24);
            command_temp_buf[41] = (unsigned char)(GPS_odometer_to_send >> 16);
            command_temp_buf[42] = (unsigned char)(GPS_odometer_to_send >> 8);
            command_temp_buf[43] = (unsigned char)(GPS_odometer_to_send);

            command_temp_buf[44] = (unsigned char)(car_voltage);
            fuel_tmp = fuel_level;
# if defined (NISSAN)
            fuel_level = (fuel_tmp * 100 + 127)/255;
#endif
# if defined (INFINITY_FX35)
            fuel_level = (fuel_tmp * 100 + 127)/255;
#endif
# if defined (INFINITY_FX37)
            fuel_level = (fuel_tmp * 100 + 127)/255;
#endif            
            command_temp_buf[45] = (unsigned char)(fuel_level);
            command_temp_buf[46] = (unsigned char)(STATUSFLAGS1bits.STATUSFLAGS1);
            GPS_odometer_to_send = 0;
            GPS_odometer_to_send = 1000 * CANODObits.CANODO;
            command_temp_buf[47] = (unsigned char)(GPS_odometer_to_send >> 24);
            command_temp_buf[48] = (unsigned char)(GPS_odometer_to_send >> 16);
            command_temp_buf[49] = (unsigned char)(GPS_odometer_to_send >> 8);
            command_temp_buf[50] = (unsigned char)(GPS_odometer_to_send);
            
            command_temp_buf[113] = 51; //38
*/

unsigned char result, length;            
            result = generate_content_of_message ( name, 1 );
/*            
            if (result == 1) {
                length = command_temp_buf[113];
                write_data_into_save_to_flash_bufs ( command_temp_buf, length );
            }
*/

// SMS-ки о событиях            
/*            
            bin_2_bcd ( (long)GPS_odometer_to_send );
            
            if (name == 4 && SMSENbits.ign_on == 1) {
                memmove ( command_temp_buf, "IgnitionON,  ", 13 );
                memmove ( command_temp_buf + 13, Navi_str, 16 );
                memmove ( command_temp_buf + 29, bin_2_bcd_buf, 9 );
                command_temp_buf [19] = ','; command_temp_buf [20] = ' ';
                command_temp_buf [21] = ' '; command_temp_buf [29] = ' ';
                command_temp_buf [38] = 0;
                Nop(); Nop(); Nop();
                write_text_to_SMS_buf ( command_temp_buf, "\"+79269524636\"\0" ); //"\"+79269524636\"\0"
//                write_text_to_SMS_buf ( command_temp_buf, "\"+79032559788\"\0" );
            }
            if (name == 5 && SMSENbits.ign_off == 1) {
                memmove ( command_temp_buf, "IgnitionOFF,  ", 14 );
                memmove ( command_temp_buf + 14, Navi_str, 16 );
                memmove ( command_temp_buf + 30, bin_2_bcd_buf, 9 );
                command_temp_buf [20] = ','; command_temp_buf [21] = ' ';
                command_temp_buf [22] = ' '; command_temp_buf [30] = ' ';                
                command_temp_buf [39] = 0;
                Nop(); Nop(); Nop();
                write_text_to_SMS_buf ( command_temp_buf, "\"+79269524636\"\0" );
//                write_text_to_SMS_buf ( command_temp_buf, "\"+79032559788\"\0" );
            }

            if (name == 6 && SMSENbits.pwr_on == 1) {
                memmove ( command_temp_buf, "PowerON,  ", 10 );
                memmove ( command_temp_buf + 10, Navi_str, 16 );
                command_temp_buf [16] = ','; command_temp_buf [17] = ' ';
                command_temp_buf [18] = ' ';                
                command_temp_buf [25] = 0;
                Nop(); Nop(); Nop();
                write_text_to_SMS_buf ( command_temp_buf, "\"+79269524636\"\0" );
//                write_text_to_SMS_buf ( command_temp_buf, "\"+79032559788\"\0" );
            }
            if (name == 7 && SMSENbits.pwr_off == 1) {
                memmove ( command_temp_buf, "PowerOFF,  ", 11 );
                memmove ( command_temp_buf + 11, Navi_str, 16 );
                command_temp_buf [17] = ','; command_temp_buf [18] = ' ';
                command_temp_buf [19] = ' ';                
                command_temp_buf [26] = 0;
                Nop(); Nop(); Nop();
                write_text_to_SMS_buf ( command_temp_buf, "\"+79269524636\"\0" );
//                write_text_to_SMS_buf ( command_temp_buf, "\"+79032559788\"\0" );
            }
*/ 
            
        }
        
        static unsigned int flash_to_send_counter = 0;//, flash_to_send_counter_max = 10;
        static unsigned int flash_send_ACK_counter = 0, retry_counter = 0;
        volatile unsigned int len, res, ack;//, crc16;

        if ( flash_to_send_counter > 5 ) { //10flash_to_send_counter_max
            flash_to_send_counter = 0;
            if ((server_connection_status == 4)&&( crash_to_send_ptr != save_crash_to_flash_ptr_W )&&(FLASHDATASENDbits.waiting_ACK == 0)) {
                if (FLASHBUSYbits.FLASHBUSY == 0) {
                    Nop();Nop();Nop();
                    generate_crash_message ( curent_acc_ack - 20000 );
                    FLASHDATASENDbits.FLASHDATASEND = 0;
                    FLASHDATASENDbits.waiting_ACK = 1;
                    flash_send_ACK_counter = 0;                    
                }
            }
char t;
            if ((server_connection_status == 4)&&( flash2_ptr_R != flash2_ptr_W )&&(FLASHDATASENDbits.waiting_ACK == 0)) { //&&( MODEMTASCKSbits.MODEMTASCKS == 0 )
                if (FLASHBUSYbits.FLASHBUSY == 0) { // Флеш не находится в процессе записи/стирания
# if defined (SST26)                     
                    GPRS_SEND_WDT = 0;
static unsigned int ack_tmp;                    
                    Nop();Nop();Nop();
                    res = check_flash2_consistency ();
                    for ( t = 0; t < 2; t ++ ) {
                        res = check_flash2_consistency ();
                        if ( res == 1 ) break;
                    }                    
                    ack = (unsigned int) SST25_read_var_from_page ( flash2_ptr_R, 127, 1 );
                    if (res == 1) {
                        Nop();Nop();Nop();
                        ack_tmp = (flash2_ptr_R << 1) + 20480;
                        len = (unsigned int) SST25_read_var_from_page ( ((flash2_ptr_R << 1) + 20480), 113, 1 );
                        SST25_read_page_to_buf ( ((flash2_ptr_R << 1) + 20480), command_temp_buf, len );
                        command_temp_buf[12] = (unsigned char) (ack_tmp >> 8); command_temp_buf[13] = (unsigned char) ack_tmp;
                        write_data_to_GPRS_buf ( command_temp_buf, len );
                        FLASHDATASENDbits.FLASHDATASEND = 0;
                        FLASHDATASENDbits.waiting_ACK = 1;
                        flash_send_ACK_counter = 0;
                        
                        // генерация текста смс для этого сообщения
                        name = command_temp_buf[9];
                        sms_enable = check_sms_enable_by_name ( name );
                        if (sms_enable == 1) {
                            sms_sent = (unsigned int) SST25_read_var_from_page ( (flash2_ptr_R + 20480), 122, 1 );
                            if ( sms_sent == 0 && flash2_ptr_R_tmp != flash2_ptr_R ) {
                                send_sms_flag = 1;
                                flash2_ptr_R_tmp = flash2_ptr_R;
                                
                                n = command_temp_buf[8] & 0x0F; // количество байт в dataflags
                                n = n - 1 + 14; // Указатель на начало навигационных данных
                                load_content_event_by_sms ( name, &command_temp_buf[n], &sms_temp_buf2 );
                                Nop();Nop();Nop();
                            }
                        }                        
                        
                    } else { // Если контрольная сумма страницы во флэш неверна, страница не отсылается
                        flash2_ptr_R ++; flash2_ptr_R %= 2400;
                        FM25_write_2( 75, (unsigned int) flash2_ptr_R );
                    }
# endif
# if defined (SST25) 
                    GPRS_SEND_WDT = 0;
//static unsigned int ack_tmp, flash2_ptr_R_tmp = 0xFFFF;
//static unsigned char name, n, sms_sent;                    
                    Nop();Nop();Nop();
                    
                    for ( t = 0; t < 2; t ++ ) {
                        res = check_flash2_consistency ();
                        if ( res == 1 ) break;
                    }
                    ack = (unsigned int) SST25_read_var_from_page ( flash2_ptr_R, 127, 1 );
                    if (res == 1) {
                        Nop();Nop();Nop();
                        ack_tmp = flash2_ptr_R + 20480;
                        len = (unsigned int) SST25_read_var_from_page ( (flash2_ptr_R + 20480), 113, 1 );
                        SST25_read_page_to_buf ( (flash2_ptr_R + 20480), command_temp_buf, len );
                        command_temp_buf[12] = (unsigned char) (ack_tmp >> 8); command_temp_buf[13] = (unsigned char) ack_tmp;
                        write_data_to_GPRS_buf ( command_temp_buf, len );
                        FLASHDATASENDbits.FLASHDATASEND = 0;
                        FLASHDATASENDbits.waiting_ACK = 1;
                        flash_send_ACK_counter = 0;
                        
                        // генерация текста смс для этого сообщения
                        name = command_temp_buf[9];
                        sms_enable = check_sms_enable_by_name ( name );
                        if (sms_enable == 1) {
                            sms_sent = (unsigned int) SST25_read_var_from_page ( (flash2_ptr_R + 20480), 122, 1 );
                            if ( sms_sent == 0 && flash2_ptr_R_tmp != flash2_ptr_R ) {
                                send_sms_flag = 1;
                                flash2_ptr_R_tmp = flash2_ptr_R;
                                
                                n = command_temp_buf[8] & 0x0F; // количество байт в dataflags
                                n = n - 1 + 14; // Указатель на начало навигационных данных
                                load_content_event_by_sms ( name, &command_temp_buf[n], &sms_temp_buf2 );
                                Nop();Nop();Nop();
                            }
                        }
                        
                    } else { // Если контрольная сумма страницы во флэш неверна, страница не отсылается
                        flash2_ptr_R ++; flash2_ptr_R %= 4800;
                        FM25_write_2( 75, (unsigned int) flash2_ptr_R );
                    }
                
# endif                    
                }

            }            
            if ((server_connection_status == 4)&&( flash_ptr_R != flash_ptr_W )&&(FLASHDATASENDbits.waiting_ACK == 0)) { //&&( MODEMTASCKSbits.MODEMTASCKS == 0 )
                if (FLASHBUSYbits.FLASHBUSY == 0) { // Флеш не находится в процессе записи/стирания
                    
                    GPRS_SEND_WDT = 0;
                    
                    Nop();Nop();Nop();
                    res = check_flash_consistency ();
                    for ( t = 0; t < 2; t ++ ) {
                        res = check_flash_consistency ();
                        if ( res == 1 ) break;
                    }                    
                    ack = (unsigned int) SST25_read_var_from_page ( flash_ptr_R, 127, 1 );
                    if (res == 1) {
                        Nop();Nop();Nop();
                        len = (unsigned int) SST25_read_var_from_page ( flash_ptr_R, 113, 1 );
                        SST25_read_page_to_buf ( flash_ptr_R, command_temp_buf, len );
                        command_temp_buf[12] = (unsigned char) (flash_ptr_R >> 8); command_temp_buf[13] = (unsigned char) flash_ptr_R;
                        write_data_to_GPRS_buf ( command_temp_buf, len );
                        FLASHDATASENDbits.FLASHDATASEND = 0;
                        FLASHDATASENDbits.waiting_ACK = 1;
                        flash_send_ACK_counter = 0;
                    } else { // Если контрольная сумма страницы во флэш неверна, страница не отсылается
                        flash_ptr_R ++; flash_ptr_R %= 20000;
                        FM25_write_2( 67, (unsigned int) flash_ptr_R );
                    }    
                }
            }
            
        } else flash_to_send_counter ++;
        
            if (FLASHDATASENDbits.waiting_ACK == 1) {
                if (flash_send_ACK_counter < 550) {
                    flash_send_ACK_counter ++;
                    
//                    FLASHDATASENDbits.ACK = 1;//////@@@@@@@@@@@@
//                    FLASHDATASENDbits.received_ACK = 0xFFFE;//////@@@@@@@@@@@@
                    
                    if ( FLASHDATASENDbits.ACK == 1 ) {
                        if ( curent_acc_ack == FLASHDATASENDbits.received_ACK ) {
                            gsm_data_link_wdt = 0;
                            Nop();Nop();Nop();
                            curent_acc_ack ++;
                            if (curent_acc_ack > 20028) {// весь краш успешно отослан
                                curent_acc_ack = 20000;
                                crash_to_send_ptr ++; crash_to_send_ptr %= 10;
                                FM25_write_2( 63, (unsigned int) crash_to_send_ptr );
                            }
                            flash_send_ACK_counter = 0;
                            FLASHDATASENDbits.FLASHDATASEND = 0;
                            flash_to_send_counter = 0;
                            retry_counter = 0;                            
                        }
                        if ((FLASHDATASENDbits.received_ACK == 0xFFFE)||(flash_ptr_R == FLASHDATASENDbits.received_ACK)) { //
                            gsm_data_link_wdt = 0;
                            // Помечаем страницу как подтвержденную акноледжем
                            flash_ptr_R ++; flash_ptr_R %= 20000;                    // Если отослано - инкремент указателя отсылки
                            FM25_write_2( 67, (unsigned int) flash_ptr_R );
                            flash_send_ACK_counter = 0;
                            FLASHDATASENDbits.FLASHDATASEND = 0;
                            flash_to_send_counter = 0;
                            retry_counter = 0;
                        }
# if defined (SST26)
                        if ((FLASHDATASENDbits.received_ACK == 0xFFFD)||(( (flash2_ptr_R << 1) + 20480) == FLASHDATASENDbits.received_ACK)) { //
                            send_sms_flag = 0;
                            gsm_data_link_wdt = 0;
                            flash2_ptr_R ++; flash2_ptr_R %= 2400;                    // Если отослано - инкремент указателя отсылки
                            FM25_write_2( 75, (unsigned int) flash2_ptr_R );
                            flash_send_ACK_counter = 0;
                            FLASHDATASENDbits.FLASHDATASEND = 0;
                            flash_to_send_counter = 0;
                            retry_counter = 0;
                        } 
#endif                        
# if defined (SST25)
                        if ((FLASHDATASENDbits.received_ACK == 0xFFFD)||(( flash2_ptr_R + 20480) == FLASHDATASENDbits.received_ACK)) { //
                            send_sms_flag = 0;
                            gsm_data_link_wdt = 0;
                            flash2_ptr_R ++; flash2_ptr_R %= 4800;                    // Если отослано - инкремент указателя отсылки
                            FM25_write_2( 75, (unsigned int) flash2_ptr_R );
                            flash_send_ACK_counter = 0;
                            FLASHDATASENDbits.FLASHDATASEND = 0;
                            flash_to_send_counter = 0;
                            retry_counter = 0;
                            
                        } 
#endif
                        if (FLASHDATASENDbits.received_ACK == 0xFFFF) { //
                            gsm_data_link_wdt = 0;
                        }

                    }
                } else { // Таймаут лтправки сообщения по GPRS

                    Nop();Nop();Nop();
                    FLASHDATASENDbits.FLASHDATASEND = 0;

                    if (send_sms_flag == 1) { // Отправка смс с сообщением по истечению таймаута отправки по GPRS
                        send_sms_flag = 0;
                        write_text_to_SMS_buf ( &sms_temp_buf2, &PHONE_to_send_buf );
                    }

                }
            } else {
//                if (FLASHDATASENDbits.FLASHDATASEND != 0) {
//                    Nop();Nop();Nop();
//                }
//                FLASHDATASENDbits.FLASHDATASEND = 0;
            }        
/*
    if ( GPRS_SEND_WDT < 6000 ) {
        GPRS_SEND_WDT ++;
        
    } else {
        GPRS_SEND_WDT = 0;
        if (flash_ptr_R == flash_ptr_W) {FM25_write_1 ( 511, 4); asm ("reset");}
        if (server_connection_status != 4) {FM25_write_1 ( 511, 5); asm ("reset");}
        if (FLASHDATASENDbits.waiting_ACK != 0) {FM25_write_1 ( 511, 6); asm ("reset");}
    }
*/
        
/*       
        datasend_counter ++;
        if (datasend_counter >= 150) {
            datasend_counter = 0;
            
//        write_data_to_GPRS_buf (telit_buf, 90);

            reload_GPRS_header ( 3, 0x01, 0x0011); // N = 3, name = 1, type = 1, ACK = 1
            memmove ( command_temp_buf, GPRS_header_buf, 12 );
            command_temp_buf[12] = (unsigned char) (ACK_counter >> 8); command_temp_buf[13] = (unsigned char) ACK_counter; // ACK
            command_temp_buf[14] = 0xFF; command_temp_buf[15] = 0x01; // Dataflags
            memmove  ( &command_temp_buf[16], Navi_bin, 22 );
            write_data_to_GPRS_buf ( command_temp_buf, 38 );
            ACK_counter ++;
        }
*/        
//    }
//gsm_data_link_wdt

//        if (server_connection_status == 4) {
            
            if (gsm_data_link_wdt < 9000) gsm_data_link_wdt ++;
            else {
                gsm_data_link_wdt = 0;
                modem_on_off (MODEM_RESTART);
            }
            
//        }
        
    fw_download_function ( server_connection_status );
    arm_function ();
    wired_relay_disarm_function ();
    robbery_servoff_function ();
    svr_events_generation ();
    RF_freezed_monitor ();
    
    sending_status = send_through_udp1 ( 0 );
    send_through_udp_monitor ( sending_status, server_connection_status );    


    uart_at_connand_to_modem ();
    
int send_sms_status;   
    send_sms_status = send_sms (0);
    send_sms_monitor ( send_sms_status );
    
int read_sms_status;
    read_sms_status = read_SMS_from_modem ( 0 );
    read_SMS_monitor ( read_sms_status );

unsigned int sms_del_result; 



    sms_del_result = delete_SMS ( 0, 0 );
////    if (sms_del_result == SMSDELEXCEPTION) {
////        Nop();Nop();Nop();
////    }
////    if ( sms_del_result == SMSDELOK ) {
////        Nop();Nop();Nop();
////    }   

    get_IMEI ();

    check_fisical_doors ();
    fisical_ignition_detection ();
    
    start_engine ();
    start_engine_s ();
    start_engine_p ();
#ifdef RUN_O
    start_engine_runo ();
    start_engine_runo1();
    request_obd_rpm ();
#endif
    start_funcontrol ();
    start_engine_dlink ();
    dd_intrusion_off_timer_function ();
    stop_autorun_engine ( 0, 0 );
    delayd_wired_bloking_during_autorun ( 0 );
    
    fire_lock_close_during_autorun ();
    fire_door_open_during_autorun ();
    fire_door_open_during_autorun_o ();
//    voltage_mesuare ();
    
    generate_fwversion_dowloaded_message ();
    
    generate_fw_request_message ();
    
//    generate_bad_message ();
    
    generate_type0_message ();
    
    generate_reset_reason_message (server_connection_status);
    
    periodic_relay_transaction ();
    fire_relay_transaction ();
    
    generate_panic_message ();
    
    send_arm_blink_thru_can ();
    send_disarm_blink_thru_can ();
    
    disable_ignition_intrusion_during_autorun ();
    
    transponder_and_power_presence_monitor ();
    generate_status_message_responce ( server_connection_status );
    
    generate_message_during_ignition_off ();
    short_period_of_reports_timer ();
    generate_message_during_power_off ();
    launch_auto_calibration_process ();
    generate_test_message ();
    generate_car_battery_low_message ();
    
    request_can_data ();
    
    lock_bytes_learn_tasck ( 0 );
    delayed_beep ();
    fisical_boot_detection ();
    check_gprs_connection ();
    
    Si4461_temperature_mesuare ( 0 );
    charge_battery_task ( 0 );
    blinkrptr_task ();
    RF_tasck_monitor ();
    rf_reset_monitor ();
    unlock_message_off_during_autorun ();
    
# if defined (LIN)    
    second_ettempt_lin_unlock ();
# endif    
# if defined (WBUS)
    webasto_wbus_task ();
    webasto_wbus_errorreq_task();
    webasto_wbus_errorclr_task();
# endif 
    
    send_message_from_memory ( server_connection_status );
    start_webasto_analog ();
    start_webasto_analog2 ();
    generate_puls_after_autorun_off ( 0 );
    
    get_IMSI ();
    temperatura_correct_after_sleep ();
    
    generate_turn_lights_message ( 0 );
    
    stop_engine_during_autorun_due_intrusion ();
    
    modem_reset_due_sim_not_ready_during_sleep ( server_connection_status );
    generate_message_during_webasto_running ();
    generate_dflt_message ( server_connection_status );
    generate_transponder_list_message ( server_connection_status );
    send_transponder_not_valid_message ( 0, 0, server_connection_status );
    generate_visible_transponders_list_message ( server_connection_status );
    generate_canbus_sleep_message ( 0 );
    check_engine_rpm_status ();
    hands_free_2_tasck ();
    second_autorisation_warnings_tasck ();
    arm_second_authorisation (); 
    delayed_message_during_ignition_off ();
    
    
# if defined ( PRODUCTION_MODE )
    post_production_test ();
    beep_after_test ();
# endif
    
# if defined (SELFPROGR)
    periodic_self_prog_fw ();
    send_fw_refresh_counter ( server_connection_status );
# endif    
    
//    destroy_keys_flags ( server_connection_status );
                                                  
//    send_59 ();
    
// Генерация тестового сообщения
/*
static unsigned char test_counter = 0;

if (test_counter < 30) test_counter ++;
else {
    test_counter = 0;
    load_test_message (1);
}
*/
}

/*
void generate_bad_message (void) {
static unsigned char flag = 0;

Nop();Nop();Nop();
if (flag == 0) return;
flag = 0;    

unsigned char bad_buf[] = { 0x26, 0x86, 0x57, 0x33, 0x02, 0x03, 0x91, 0x18, 0x11,  0x1E,  0x00, 0x16,  0x00, 0x0F,  0xFF, 0x01, 0x01,  0x14, 0x12, 0x50,  0x12, 0x07, 0x16,  0x21, 0x3D, 0x45, 0x4F, 0x16, 0x5F, 0x32, 0x5F, 0x50, 0xFF, 0xF5, 0x00, 0x01, 0x66, 0x13, 0x00, 0x58, 0x54, 0x41, 0x47, 0x46, 0x4C, 0x31, 0x32, 0x30, 0x47, 0x59, 0x30, 0x30, 0x31, 0x39, 0x32, 0x34 };   

    memmove  ( &command_temp_buf, &bad_buf, 56 );
    
    command_temp_buf[113] = 56;
    
    write_data_into_save_to_flash_bufs ( &command_temp_buf, 56 ); 
    
}
*/

unsigned int pagestr_to_pagehex (void) {
    
unsigned int temp;
    
    temp = 0;
    temp = fw_page_buf[14] - 0x30;
    temp = temp * 10;
    temp = temp + (fw_page_buf[15] - 0x30);
    temp = temp * 10;    
    temp = temp + (fw_page_buf[16] - 0x30);
    temp = temp * 10;    
    temp = temp + (fw_page_buf[17] - 0x30);
    temp = temp * 10;
    temp = temp + (fw_page_buf[18] - 0x30);
    
return temp;    
}
char check_intel_crc (char *ptr) {
    int i;
    char crc;
    crc = 0;
//    if (ptr == 0x3cef) {
//        Nop();Nop();Nop();        
//    }
    
    for ( i = 0; i < 21; i ++ ) {
        crc = crc + *ptr;
        ptr ++;
    }
Nop();Nop();Nop();    
return crc;    
}
int  check_page_consistancy(void) {

    unsigned int i;
    
    if ( FWDTASCKbits.page_counter == Num_of_pages ) { // Последняя страница 
        Nop();Nop();Nop();        
        
    } else {
        if ( fw_page_buf[20]  == ':' && fw_page_buf[42]  == ':' && fw_page_buf[64]  == ':' &&
             fw_page_buf[86]  == ':' && fw_page_buf[108] == ':' && fw_page_buf[130] == ':' &&
             fw_page_buf[152] == ':' && fw_page_buf[174] == ':' && fw_page_buf[196] == ':' &&
             fw_page_buf[218] == ':' && fw_page_buf[240] == ':' && fw_page_buf[262] == ':' && 
             fw_page_buf[284] == ':' && fw_page_buf[306] == ':' && fw_page_buf[328] == ':' && 
             fw_page_buf[350] == ':' && fw_page_buf[372] == ':' && fw_page_buf[394] == ':' &&
             fw_page_buf[416] == ':' && fw_page_buf[438] == ':' && fw_page_buf[460] == ';' ) 
        {
            Nop();Nop();Nop();
            for ( i = 20; i <= 438; i = i + 22) {
                if ( check_intel_crc ( &fw_page_buf[i + 1] ) != 0 ) {
                    Nop();Nop();Nop();
                    return 0;
                }
            }
            Nop();Nop();Nop();
        } else {
            Nop();Nop();Nop();
            return 0;
        }
    }
return 1;    
}
void fw_download_function (int gprs_connection_status) {
    unsigned int page_tmp; 
    static unsigned int fw_sector_buf_W_ptr = 0;

    
    if (FWDTASCKbits.start != 1) return;
    Nop();Nop();Nop();
    
// Запрос очередной страницы
    if ( gprs_connection_status == 4 ) {
        if (FWDTASCKbits.waiting_page == 0 && FWDTASCKbits.page_counter != Num_of_pages && FWDTASCKbits.sector_downloaded == 0) {
            sleep_counter = 0;
            Nop();Nop();Nop();
            FWDTASCKbits.waiting_page = 1;
            bin_2_bcd ( (long) FWDTASCKbits.page_counter );
            fw_req_buf[14] = bin_2_bcd_buf[4];fw_req_buf[15] = bin_2_bcd_buf[5];fw_req_buf[16] = bin_2_bcd_buf[6];
            fw_req_buf[17] = bin_2_bcd_buf[7];fw_req_buf[18] = bin_2_bcd_buf[8];fw_req_buf[19] = ';';
            Nop();Nop();Nop();
            fw_request_flag = 1;
//            load_answer ( 2, fw_req_buf, 0, 0 );
        }
    }
    
// Получена очередная страница     
    if (FWDTASCKbits.waiting_page == 1 && FWDTASCKbits.page_received == 1) {
        Nop();Nop();Nop();
        gsm_data_link_wdt = 0;
        page_tmp = pagestr_to_pagehex ();
        if (page_tmp == FWDTASCKbits.page_counter) {
            if ( check_page_consistancy() ) {
                
                FWDTASCKbits.page_counter ++;
                memmove ( &fw_sector_buf[fw_sector_buf_W_ptr], fw_page_buf, 512 );
                fw_sector_buf_W_ptr = fw_sector_buf_W_ptr + 512;
                if (fw_sector_buf_W_ptr == 4096) {
                    
                    Nop();Nop();Nop();
                    fw_sector_buf_W_ptr = 0;
                    FWDTASCKbits.sector_downloaded = 1;
                    
                }
int page_remanes, received_strings;                
                if (FWDTASCKbits.page_counter == Num_of_pages) {
                    Nop();Nop();Nop();
                    page_remanes = check_eof ();
                    received_strings = FWDTASCKbits.page_counter * 10 - (10 - page_remanes);
                    fw_sector_buf_W_ptr = 0;
                    FWDTASCKbits.sector_downloaded = 1;
                    FWDTASCKbits.download_complete = 1;
                }                
            }
            
        }

        FWDTASCKbits.waiting_page = 0; 
        FWDTASCKbits.page_received = 0;
        FWDTASCKbits.timeout_counter = 0;
        
    }
// Прошивка скачана и сохранена    
    if (FWDTASCKbits.download_complete == 1 && FWDTASCKbits.sector_downloaded == 0) {
        Nop();Nop();Nop();
        FWDTASCKbits.FWDTASCK = 0;
        fw_dowloaded_flag = 1;
        FM25_write_1 (2025, 1);
//        load_answer ( 2, "fw dowload completed", 0, 0 );
// Здесь сообщение об успешной закачке        
    } 
    
    if (FWDTASCKbits.waiting_page == 1) {
        if ( FWDTASCKbits.timeout_counter < 1200 )FWDTASCKbits.timeout_counter ++;
        else {
            
            FWDTASCKbits.timeout_counter = 0;
            if (gprs_connection_status == 4) {
                FWDTASCKbits.waiting_page = 0; 
                FWDTASCKbits.page_received = 0;
            }            
        }
    } else FWDTASCKbits.timeout_counter = 0;
    
//current_num_of_page    
}
int check_eof (void) {
    int temp, i;//, j;
    temp = 0;
    for ( i = 24; i <= 442; i = i + 22 ) {
        temp ++;
        if ( fw_page_buf [i] == 0x01 && fw_page_buf [i + 1] == 0xFF ) return temp;
    }
return -1;    
}
void write_page_to_fw_sector_buf (int save_ptr){

    memmove ( &fw_sector_buf[save_ptr], fw_page_buf, 512 );
    
}

void generate_crash_message ( unsigned char number_of_mesage ) 
{
int i;
static unsigned int j = 0;// number_of_mesage;
unsigned int check_sum;
static unsigned long addr_to_read_samples, addr_to_read_trek, addr_to_read_acc_point, addr_to_read_trek_point;
    
//    number_of_mesage = curent_acc_ack - 20000;
static unsigned int number_of_crash_to_send;    
    if (number_of_mesage < 24) { // 24 сообщения по 100 байт -> по 25 точек
        
        addr_to_read_samples = crash_to_send_ptr + 625;
        addr_to_read_samples = addr_to_read_samples * 4096;
        addr_to_read_samples = addr_to_read_samples + 100 * number_of_mesage;
        
        addr_to_read_acc_point = crash_to_send_ptr + 625;
        addr_to_read_acc_point = addr_to_read_acc_point * 4096;
        addr_to_read_acc_point = addr_to_read_acc_point + 2840;

        addr_to_read_trek_point = crash_to_send_ptr + 625;
        addr_to_read_trek_point = addr_to_read_trek_point * 4096;
        addr_to_read_trek_point = addr_to_read_trek_point + 2840 + 2;
        
        CRASH_ACC_point_ptr     = SST25_read_var_from_flash ( (unsigned long)addr_to_read_acc_point, 2 ); // чтение точки краша
        number_of_crash_to_send = SST25_read_var_from_flash ( (unsigned long)addr_to_read_trek_point + 2, 2 ); // чтение номера краша
        
            reload_GPRS_header ( 1, 30, 0x0016); // N = 1, name = 30, type = 2, ACK = 1, CRC = 1
            memmove ( command_temp_buf, GPRS_header_buf, 12 );
            command_temp_buf[12] = (unsigned char)(curent_acc_ack >> 8);      command_temp_buf[13] = (unsigned char)curent_acc_ack; // ACK
            command_temp_buf[14] = (unsigned char)(number_of_crash_to_send >> 8);     command_temp_buf[15] = (unsigned char)number_of_crash_to_send; // номер аварии сквозная нумерация за время жизни блока
            command_temp_buf[16] = (unsigned char)(CRASH_ACC_point_ptr >> 8); command_temp_buf[17] = (unsigned char)CRASH_ACC_point_ptr; // указатель точки аварии        
            command_temp_buf[18] = (unsigned char)number_of_mesage; // номер порции данных

            Nop();Nop();Nop();
            for (i = 0; i < 100; i ++) {
                command_temp_buf[i + 19] = SST25_read_byte_from_flash((unsigned long)addr_to_read_samples ++);
            }
            check_sum = 0;
            
            check_sum = CRC16( &command_temp_buf, 119);
            command_temp_buf[119] = (unsigned char) check_sum;
            command_temp_buf[120] = (unsigned char)(check_sum >> 8);
            
            Nop(); Nop(); Nop();
            write_data_to_GPRS_buf ( &command_temp_buf, 121);
        
    }
    else { // 24 сообщения по 100 байт -> по 25 точек
        
        addr_to_read_trek = crash_to_send_ptr + 625;
        addr_to_read_trek = addr_to_read_trek * 4096;
        addr_to_read_trek = addr_to_read_trek + 2400;
        j = number_of_mesage - 24;
        addr_to_read_trek = addr_to_read_trek + 88 * j;
        
        addr_to_read_trek_point = crash_to_send_ptr + 625;
        addr_to_read_trek_point = addr_to_read_trek_point * 4096;
        addr_to_read_trek_point = addr_to_read_trek_point + 2840 + 2;
        
        CRASH_TREK_point_ptr = SST25_read_var_from_flash ( (unsigned long)addr_to_read_trek_point, 2 ); // чтение точки краша
        
            reload_GPRS_header ( 1, 31, 0x0016 ); // N = 1, name = 30, type = 2, ACK = 1, CRC = 1
            memmove ( command_temp_buf, GPRS_header_buf, 12 );
            command_temp_buf[12] = (unsigned char)(curent_acc_ack >> 8); command_temp_buf[13] = (unsigned char)curent_acc_ack; // ACK
            command_temp_buf[14] = (unsigned char)(number_of_crash_to_send >> 8); command_temp_buf[15] = (unsigned char)number_of_crash_to_send; // номер аварии сквозная нумерация за время жизни блока
            command_temp_buf[16] = (unsigned char)(CRASH_TREK_point_ptr >> 8); command_temp_buf[17] = (unsigned char)CRASH_TREK_point_ptr; // указатель точки аварии        
            command_temp_buf[18] = (unsigned char)number_of_mesage; // номер порции данных

            Nop();Nop();Nop();
            for (i = 0; i < 88; i ++) {
                command_temp_buf[i + 19] = SST25_read_byte_from_flash((unsigned long)addr_to_read_trek ++);
            }
            check_sum = 0;
            
            check_sum = CRC16( &command_temp_buf, 107);
            command_temp_buf[107] = (unsigned char) check_sum;
            command_temp_buf[108] = (unsigned char)(check_sum >> 8);            
            Nop(); Nop(); Nop();
            
            write_data_to_GPRS_buf ( command_temp_buf, 109);
        
    }

}
/*
void load_test_message (unsigned char name) {
unsigned long GPS_odometer_to_send;

generate_content_of_message ( 29, 1 );  

}
*/
int  check_flash_consistency (void) {
    
unsigned char len, temp, check_summ, check_summ1, i;    

    len        = (unsigned char) SST25_read_var_from_page ( flash_ptr_R, 113, 1 );
    check_summ = (unsigned char) SST25_read_var_from_page ( flash_ptr_R, 123, 1 );
    SST25_read_page_to_buf ( flash_ptr_R, command_temp_buf, len );
    
// Расчет контрольной суммы
check_summ1 = 0;    
    for ( i = 0; i < len; i++) {
        check_summ1 = check_summ1 ^ command_temp_buf[i];
    }
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_R, 113, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_R, 114, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_R, 115, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_R, 116, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_R, 117, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_R, 118, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_R, 119, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_R, 120, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_R, 121, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( flash_ptr_R, 122, 1 );
/*Когда страница оказывается пустая - все 0хFF, то контрольная сумма совпадает при нечетном к-ве байт
 а прочитанная длина 255!!! Будет отослано, а сервер не распознает и возникает зацикливание.*/
    
Nop();Nop();Nop();    
    if (check_summ1 != check_summ) return 0;

    if (command_temp_buf[0] != TYPE0[0]) return 0;
    if (command_temp_buf[1] != TYPE0[1]) return 0;
    if (command_temp_buf[2] != TYPE0[2]) return 0;
    if (command_temp_buf[3] != TYPE0[3]) return 0;
    if (command_temp_buf[4] != TYPE0[4]) return 0;
    if (command_temp_buf[5] != TYPE0[5]) return 0;
    if (command_temp_buf[6] != TYPE0[6]) return 0;
    if (command_temp_buf[7] != TYPE0[7]) return 0;

    return 1;

}
int  check_flash2_consistency (void) {
    
unsigned char len, /*temp,*/ check_summ, check_summ1, i;    

# if defined (SST25)
    len        = (unsigned char) SST25_read_var_from_page ( (flash2_ptr_R + 20480), 113, 1 );
    check_summ = (unsigned char) SST25_read_var_from_page ( (flash2_ptr_R + 20480), 123, 1 );
    SST25_read_page_to_buf ( (flash2_ptr_R + 20480), command_temp_buf, len );
    
// Расчет контрольной суммы
check_summ1 = 0;    
    for ( i = 0; i < len; i++) {
        check_summ1 = check_summ1 ^ command_temp_buf[i];
    }
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( (flash2_ptr_R + 20480), 113, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( (flash2_ptr_R + 20480), 114, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( (flash2_ptr_R + 20480), 115, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( (flash2_ptr_R + 20480), 116, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( (flash2_ptr_R + 20480), 117, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( (flash2_ptr_R + 20480), 118, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( (flash2_ptr_R + 20480), 119, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( (flash2_ptr_R + 20480), 120, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( (flash2_ptr_R + 20480), 121, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( (flash2_ptr_R + 20480), 122, 1 );
/*Когда страница оказывается пустая - все 0хFF, то контрольная сумма совпадает при нечетном к-ве байт
 а прочитанная длина 255!!! Будет отослано, а сервер не распознает и возникает зацикливание.*/
# endif
# if defined (SST26)
    len        = (unsigned char) SST25_read_var_from_page ( ((flash2_ptr_R << 1) + 20480), 113, 1 );
    check_summ = (unsigned char) SST25_read_var_from_page ( ((flash2_ptr_R << 1) + 20480), 123, 1 );
    SST25_read_page_to_buf ( ((flash2_ptr_R << 1) + 20480), command_temp_buf, len );
    
// Расчет контрольной суммы
check_summ1 = 0;    
    for ( i = 0; i < len; i++) {
        check_summ1 = check_summ1 ^ command_temp_buf[i];
    }
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( ((flash2_ptr_R << 1) + 20480), 113, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( ((flash2_ptr_R << 1) + 20480), 114, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( ((flash2_ptr_R << 1) + 20480), 115, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( ((flash2_ptr_R << 1) + 20480), 116, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( ((flash2_ptr_R << 1) + 20480), 117, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( ((flash2_ptr_R << 1) + 20480), 118, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( ((flash2_ptr_R << 1) + 20480), 119, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( ((flash2_ptr_R << 1) + 20480), 120, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( ((flash2_ptr_R << 1) + 20480), 121, 1 );
    check_summ1 = check_summ1 ^ (unsigned char) SST25_read_var_from_page ( ((flash2_ptr_R << 1) + 20480), 122, 1 );
/*Когда страница оказывается пустая - все 0хFF, то контрольная сумма совпадает при нечетном к-ве байт
 а прочитанная длина 255!!! Будет отослано, а сервер не распознает и возникает зацикливание.*/
# endif    
Nop();Nop();Nop();    
    if (check_summ1 != check_summ) return 0;

    if (command_temp_buf[0] != TYPE0[0]) return 0;
    if (command_temp_buf[1] != TYPE0[1]) return 0;
    if (command_temp_buf[2] != TYPE0[2]) return 0;
    if (command_temp_buf[3] != TYPE0[3]) return 0;
    if (command_temp_buf[4] != TYPE0[4]) return 0;
    if (command_temp_buf[5] != TYPE0[5]) return 0;
    if (command_temp_buf[6] != TYPE0[6]) return 0;
    if (command_temp_buf[7] != TYPE0[7]) return 0;

    return 1;

}
void start_engine (void) {
    
# if defined (SOBR) 
    
    static unsigned int gear_check_counter = 0;    
    
    if (STARTENGINEDLbits.start == 1) return;
    if (STARTENGINESbits.start == 1) return;
    if (STARTENGINEPbits.start == 1) return;
    
    if (STARTENGINEbits.start == 0) {
//        AUTO_START = 0;
        gear_check_counter = 0;
        return;
    }
    
# if defined (WIRED_ENJINE_BLOKING)
    # if defined (MCP23S08)

    # else    
            if (OUTFUNCbits.pin15 == 3) {
                if (STARTENGINEbits.wait_duration == 0) {
                    if (OUTFUNCbits.pin15 == 3) {    
                        if (OUTbits.arm_flag == 1) {
                            L_OUT = 0;
                        }
                    }    
                }
            }
    # endif    
# endif // Разблокировка на время старта при автозапуске     

// Ипульс автозапуска задержан на 2 секунды для того, чтобы реле успело снизить чувствительность   
    if ((STARTENGINEbits.wait_duration > 20) && (STARTENGINEbits.wait_duration < (STARTENGINEbits.pulse_duration + 20))) {
        Nop();Nop();Nop();
# if defined (MCP23S08)

# else        
        if (OUTFUNCbits.pin9 == 6) { AUTO_START = 1; }
# endif
    }
    else 
    {
        generate_content_of_message ( 87, 1 );
# if defined (MCP23S08)

# else        
        if (OUTFUNCbits.pin9 == 6) { AUTO_START = 0; }
# endif
    }
    
    if (GEARBOXSTATPRMS2bits.can_number == 0) gearbox2_status = 1;
    
 // если в момент времени 500 мс после фронта импульса запуска коробка не в нейтрали - остановка автозапуска
    if (STARTENGINEbits.wait_duration > 20) { 
        
        if (ignition == 1 && start_engine_success_flag == 0)  {
            if (gear_check_counter < 5) gear_check_counter ++;
        } else gear_check_counter = 0; 
        
            if (gearbox2_status == 0 && gear_check_counter >= 5) {
                delayd_wired_bloking_during_autorun ( 1 );
                generate_content_of_message ( 59, 1 ); 
                generate_content_of_message ( 33, 1 );
                STARTENGINEbits.STARTENGINE = 0;
                stop_autorun_engine ( 1, 4 );
                gear_check_counter = 0;
                return;            
            }
            
    }    
    
    
    if (STARTENGINEbits.wait_duration < 600) STARTENGINEbits.wait_duration ++;
    else {
        delayd_wired_bloking_during_autorun ( 1 );
//# if defined (WIRED_ENJINE_BLOKING)
//    # if defined (MCP23S08)
//
//    # else        
//                if (OUTFUNCbits.pin15 == 3) {
//                    if (OUTbits.arm_flag == 1) {
//                        L_OUT = 1;
//                    }
//                } 
//    # endif            
//# endif // Разблокировка на время старта при автозапуске 

            generate_content_of_message ( 33, 1 );
        
        STARTENGINEbits.STARTENGINE = 0;
    }
    
    if (ignition_by_pulse == 1) { //ignition, ignition_by_pulse
        STARTENGINEbits.running_duration ++;
        if (STARTENGINEbits.running_duration > 150 && car_voltage > start_engine_volt_trh) {
            Nop();Nop();Nop();
//            delayd_wired_bloking_during_autorun ( 1 );
//# if defined (WIRED_ENJINE_BLOKING)
//    # if defined (MCP23S08)
//
//    # else
//                if (OUTFUNCbits.pin15 == 3) {
//                    if (OUTbits.arm_flag == 1) L_OUT = 1;
//                }
//    # endif
//# endif // Разблокировка на время старта при автозапуске

            LOCKAUTORUNbits.LOCKAUTORUN = 0;
            LOCKAUTORUNbits.start = 1;
            DOORAUTORUNbits.DOORAUTORUN = 0;
            DOORAUTORUNbits.start = 1;
            generate_content_of_message ( 34, 1 );
            
            STARTENGINEbits.STARTENGINE = 0;
            start_engine_success_flag = 1;
        }
        
    } else STARTENGINEbits.running_duration = 0;
#endif    

}
void start_engine_s (void) {

    
# if defined (SOBR)

    static unsigned int gear_check_counter = 0;
    
    if (STARTENGINEDLbits.start == 1) return;
    if (STARTENGINEbits.start == 1) return;
    if (STARTENGINEPbits.start == 1) return;    
    
    if (STARTENGINESbits.start == 0) {
//        AUTO_START = 0;
        gear_check_counter = 0;
        return;
    }
    
# if defined (WIRED_ENJINE_BLOKING)
    # if defined (MCP23S08)

    # else
        if (OUTFUNCbits.pin15 == 3) {
            if (STARTENGINEbits.wait_duration == 0) {
                if (OUTbits.arm_flag == 1) {
                    L_OUT = 0;
                }
            }
        }
    # endif    
# endif // Разблокировка на время старта при автозапуске     

// Ипульс автозапуска задержан на 2 секунды для того, чтобы реле успело снизить чувствительность   
    if (STARTENGINESbits.wait_duration > 20) {

# if defined (MCP23S08)

# else        
        if (OUTFUNCbits.pin9 == 6) AUTO_START = 1;
# endif        
    }

    if (GEARBOXSTATPRMS2bits.can_number == 0) gearbox2_status = 1;    
    
 // если в момент времени 500 мс после фронта импульса запуска коробка не в нейтрали - остановка автозапуска
    if (STARTENGINESbits.wait_duration > 20) { 
        
        if (ignition == 1 && STARTENGINESbits.start_success == 0 )  {
            if (gear_check_counter < 5) gear_check_counter ++;
        } else gear_check_counter = 0; 
        
            if (gearbox2_status == 0 && gear_check_counter >= 5) {
                generate_content_of_message ( 59, 1 ); 
                generate_content_of_message ( 33, 1 );
                STARTENGINESbits.pulse_duration = 0;
                STARTENGINESbits.running_duration = 0;
                STARTENGINESbits.source_of_command = 0;
                STARTENGINESbits.start = 0;
                STARTENGINESbits.start_success = 0;
                STARTENGINESbits.wait_duration = 0;
                gear_check_counter = 0;
# if defined (MCP23S08)

# else                
                if (OUTFUNCbits.pin9 == 6) AUTO_START = 0;
# endif 
                delayd_wired_bloking_during_autorun ( 1 );
//# if defined (WIRED_ENJINE_BLOKING)
//    # if defined (MCP23S08)
//
//    # else        
//            if (OUTFUNCbits.pin15 == 3) {
//                    if (OUTbits.arm_flag == 1) L_OUT = 1;
//            }
//    # endif        
//# endif // Блокировка при неудачном автозапуске                  
                generate_puls_after_autorun_off ( 1 );
                return;            
            }
            
    }

    if (STARTENGINESbits.wait_duration < STARTENGINESbits.pulse_duration) STARTENGINESbits.wait_duration ++;
    else { // Окончание автозапуска
        Nop();Nop();Nop();
        
# if defined (MCP23S08)

# else        
        if (OUTFUNCbits.pin9 == 6) AUTO_START = 0;
# endif
        delayd_wired_bloking_during_autorun ( 1 );
//# if defined (WIRED_ENJINE_BLOKING)
//    # if defined (MCP23S08)
//
//    # else        
//            if (OUTFUNCbits.pin15 == 3) {
//                    if (OUTbits.arm_flag == 1) L_OUT = 1;
//            }
//    # endif        
//# endif // Блокировка окончании автозапуска         
        generate_content_of_message ( 87, 1 );
        generate_puls_after_autorun_off ( 1 );
        STARTENGINESbits.pulse_duration = 0;
        STARTENGINESbits.running_duration = 0;
        STARTENGINESbits.source_of_command = 0;
        STARTENGINESbits.start = 0;
        STARTENGINESbits.start_success = 0;
        STARTENGINESbits.wait_duration = 0;
        dd_intrusion_off_timer = dd_intrusion_off_setting; // 5 секундный таймер игнорирования вторжения по дверям
    }

    
    if (STARTENGINESbits.wait_duration >= 600 && STARTENGINESbits.start_success == 0 ) { //
    delayd_wired_bloking_during_autorun ( 1 );    
//# if defined (WIRED_ENJINE_BLOKING)
//    # if defined (MCP23S08)
//
//    # else        
//            if (OUTFUNCbits.pin15 == 3) {
//                    if (OUTbits.arm_flag == 1) L_OUT = 1;
//            }
//    # endif        
//# endif // Блокировка при неудачном автозапуске 

        generate_content_of_message ( 33, 1 );
        Nop();Nop();Nop();
        
# if defined (MCP23S08)

# else        
        if (OUTFUNCbits.pin9 == 6) { AUTO_START = 0; }
# endif
        
//        generate_puls_after_autorun_off ( 1 );
        STARTENGINESbits.pulse_duration = 0;
        STARTENGINESbits.running_duration = 0;
        STARTENGINESbits.source_of_command = 0;
        STARTENGINESbits.start = 0;
        STARTENGINESbits.start_success = 0;
        STARTENGINESbits.wait_duration = 0;
    }
    
//if (ignition == 1) ignition_by_pulse = 1; // Для имитации успешного запуска
//car_voltage = 112; // Для имитации успешного запуска
////ignition_by_pulse = 1; // Для имитации успешного запуска

    if (ignition_by_pulse == 1) { //ignition, ignition_by_pulse
        if ( STARTENGINESbits.start_success == 0 ) { 
            STARTENGINESbits.running_duration ++;
            if (STARTENGINESbits.running_duration > 150 && car_voltage > start_engine_volt_trh ) {
                Nop();Nop();Nop();
                
                LOCKAUTORUNbits.LOCKAUTORUN = 0;
                LOCKAUTORUNbits.start = 1;
                DOORAUTORUNbits.DOORAUTORUN = 0;
                DOORAUTORUNbits.start = 1;                

                STARTENGINESbits.start_success = 1;
                generate_content_of_message ( 34, 1 );
            }
        }
        
    } else STARTENGINESbits.running_duration = 0;
    
// Если автозапуск был успешен, но зажигание выключилось, сброс задачи и деактивация выхода

    if (STARTENGINESbits.start == 1 && STARTENGINESbits.start_success == 1) {
        if (ignition == 0) {
            Nop();Nop();Nop();
# if defined (MCP23S08)

# else            
            if (OUTFUNCbits.pin9 == 6) AUTO_START = 0;
# endif 
            delayd_wired_bloking_during_autorun ( 1 );
//# if defined (WIRED_ENJINE_BLOKING)
//    # if defined (MCP23S08)
//
//    # else                
//                    if (OUTFUNCbits.pin15 == 3) {
//                        if (OUTbits.arm_flag == 1) L_OUT = 1;
//                    }
//    # endif                
//# endif // Блокировка при завершении АЗ по зажиганию            
            generate_content_of_message ( 87, 1 );
            generate_puls_after_autorun_off ( 1 );
            STARTENGINESbits.pulse_duration = 0;
            STARTENGINESbits.running_duration = 0;
            STARTENGINESbits.source_of_command = 0;
            STARTENGINESbits.start = 0;
            STARTENGINESbits.start_success = 0;
            STARTENGINESbits.wait_duration = 0;           
        }
    }    
    
#endif    

}
void start_engine_dlink (void) {
    
static unsigned int engine_running_counter = 0, engine_not_running_counter = 0;

# if defined (DATALINK)
    if (STARTENGINEbits.start == 1) return;
    if (STARTENGINESbits.start == 1) return;
    if (STARTENGINEPbits.start == 1) return;

    if (STARTENGINEDLbits.start == 0) {
# if defined (MCP23S08)
    
# else
        if (OUTFUNCbits.pin15 == 5) {
            L_OUT = 0;
        }
# endif
        engine_running_counter = 0;
        engine_not_running_counter = 0;
        STARTENGINEDLbits.pulse_delay = 0;
        STARTENGINEDLbits.pulse_duration = 0;
        STARTENGINEDLbits.run_duration = 0;
        STARTENGINEDLbits.source_of_command = 0;
        STARTENGINEDLbits.start = 0;
        STARTENGINEDLbits.success_message_generated = 0;
        return;
    }
    
//if (ignition == 1) ignition_by_pulse = 1; // Для имимтации успешного запуска
//car_voltage = 112;

    if (STARTENGINEDLbits.run_duration > 0) {
# if defined (MCP23S08)

# else        
        if (OUTFUNCbits.pin9 == 5) { AUTO_START = 1; }
# endif        
        STARTENGINEDLbits.run_duration --; 
    } // Управляющий импульс
    else {
        Nop();Nop();Nop();

# if defined (MCP23S08)

# else        
        if (OUTFUNCbits.pin9 == 5 && OUTFUNCbits.pin15 == 5) { AUTO_START = 0; L_OUT = 0; }
# endif

        generate_content_of_message ( 87, 1 );
        engine_running_counter = 0;
        STARTENGINEDLbits.pulse_delay = 0;
        STARTENGINEDLbits.pulse_duration = 0;
        STARTENGINEDLbits.run_duration = 0;
        STARTENGINEDLbits.source_of_command = 0;
        STARTENGINEDLbits.start = 0;
        STARTENGINEDLbits.success_message_generated = 0;
        dd_intrusion_off_timer = dd_intrusion_off_setting; // 5 секундный таймер игнорирования вторжения по дверям
    }
    
    if (STARTENGINEDLbits.pulse_delay > 0) STARTENGINEDLbits.pulse_delay --; // Задержка запускающего импульса
    
    if (STARTENGINEDLbits.pulse_duration > 0 && STARTENGINEDLbits.pulse_delay == 0) {
# if defined (MCP23S08)
    
# else        
        if (OUTFUNCbits.pin15 == 5) {
        L_OUT = 1; 
        }
# endif
        STARTENGINEDLbits.pulse_duration --;
    } // Запускающий импульс
    else {
# if defined (MCP23S08)
    
# else        
        if (OUTFUNCbits.pin15 == 5) {
        L_OUT = 0;
        }
# endif        
    }
//ignition_by_pulse = 1;  car_voltage = 0xfa;  
    if (ignition_by_pulse == 1 ) { 
        if (engine_running_counter < 300 && STARTENGINEDLbits.success_message_generated == 0) engine_running_counter ++;
        else {
            Nop();Nop();Nop();
            if (STARTENGINEDLbits.success_message_generated == 0 && car_voltage > start_engine_volt_trh) {
                
                LOCKAUTORUNbits.LOCKAUTORUN = 0;
                LOCKAUTORUNbits.start = 1;
                DOORAUTORUNbits.DOORAUTORUN = 0;
                DOORAUTORUNbits.start = 1;                
                STARTENGINEDLbits.success_message_generated = 1;
                generate_content_of_message ( 34, 1 );
            }
        }
        
    } else 
    {
        if (STARTENGINEDLbits.success_message_generated == 0) {
            engine_running_counter = 0;
            if (engine_not_running_counter < 600) engine_not_running_counter ++;
            else 
            {
                engine_not_running_counter = 0;
                engine_running_counter = 0;
# if defined (MCP23S08)

# else                
                if (OUTFUNCbits.pin9 == 5 && OUTFUNCbits.pin15 == 5) { AUTO_START = 0; L_OUT = 0; }
# endif                
                STARTENGINEDLbits.pulse_delay = 0;
                STARTENGINEDLbits.pulse_duration = 0;
                STARTENGINEDLbits.run_duration = 0;
                STARTENGINEDLbits.source_of_command = 0;
                STARTENGINEDLbits.start = 0;
                STARTENGINEDLbits.success_message_generated = 0;
                generate_content_of_message ( 33, 1 );
            }
        }
    }

// Если автозапуск был успешен, но зажигание выключилось, сброс задачи и деактивация выхода

    if (STARTENGINEDLbits.start == 1 && STARTENGINEDLbits.success_message_generated == 1) {
        if (ignition == 0) {
            Nop();Nop();Nop();
# if defined (MCP23S08)

# else            
            if ( OUTFUNCbits.pin9 == 5 && OUTFUNCbits.pin15 == 5 ) { AUTO_START = 0; L_OUT = 0; }
# endif            
            generate_content_of_message ( 87, 1 );
            engine_running_counter = 0;
            STARTENGINEDLbits.pulse_delay = 0;
            STARTENGINEDLbits.pulse_duration = 0;
            STARTENGINEDLbits.run_duration = 0;
            STARTENGINEDLbits.source_of_command = 0;
            STARTENGINEDLbits.start = 0;
            STARTENGINEDLbits.success_message_generated = 0;            
        }
    }

# endif

}
void start_engine_p (void) {


    static unsigned int gear_check_counter = 0;    
    static unsigned int engine_running_counter = 0, engine_not_running_counter = 0, delay_counter = 0;

# if defined (PANDORA)
    if (STARTENGINEbits.start == 1) return;
    if (STARTENGINESbits.start == 1) return;
    if (STARTENGINEDLbits.start == 1) return;

    if (STARTENGINEPbits.start == 0) {
        gear_check_counter = 0;
        delay_counter = 0;
        engine_running_counter = 0;
        engine_not_running_counter = 0;
        STARTENGINEPbits.run_duration = 0;
        STARTENGINEPbits.start_pulse_duration = 0;
        STARTENGINEPbits.stop_pulse_duration = 0;
        STARTENGINEPbits.source_of_command = 0;
        STARTENGINEPbits.start = 0;
        STARTENGINEPbits.success_message_generated = 0;
        return;
    }
/**/    
# if defined (WIRED_ENJINE_BLOKING)
    # if defined (MCP23S08)

    # else
        if (OUTFUNCbits.pin15 == 3) {
                if (OUTbits.arm_flag == 1) { L_OUT = 0; }
        }
    # endif    
# endif // Разблокировка на время старта при автозапуске      
    
//if (ignition == 1) ignition_by_pulse = 1; // Для имитации успешного запуска
//car_voltage = 112; // Для имитации успешного запуска

    if (delay_counter < 20) {
        delay_counter ++;
        return;
    }

    if (GEARBOXSTATPRMS2bits.can_number == 0) gearbox2_status = 1;    
 // если в момент времени 500 мс после включения зажигания коробка не в нейтрали - остановка автозапуска
        if (ignition == 1  && STARTENGINEPbits.success_message_generated == 0 )  {
            if (gear_check_counter < 5) gear_check_counter ++;
        } else gear_check_counter = 0; 
        
            if (gearbox2_status == 0 && gear_check_counter >= 5) {
                generate_content_of_message ( 59, 1 ); 
                generate_content_of_message ( 33, 1 );
                STARTENGINEPbits.run_duration = 0;
                STARTENGINEPbits.source_of_command = 0;
                STARTENGINEPbits.start = 0;
                STARTENGINEPbits.start_pulse_duration = 0;
                STARTENGINEPbits.stop_pulse_duration = 0;
                STARTENGINEPbits.success_message_generated = 0;
                gear_check_counter = 0;
# if defined (MCP23S08)

# else                
                if (OUTFUNCbits.pin9 == 7) AUTO_START = 0;
# endif
                delayd_wired_bloking_during_autorun ( 1 );
//# if defined (WIRED_ENJINE_BLOKING)
//    # if defined (MCP23S08)
//
//    # else
//        if (OUTFUNCbits.pin15 == 3) {
//                if (OUTbits.arm_flag == 1) { L_OUT = 1; }
//        }
//    # endif    
//# endif // Блокировка если коробка не в паркинге                  
                return;            
            }

    if (STARTENGINEPbits.run_duration > 0) {
        
            if (STARTENGINEPbits.start_pulse_duration > 0) { // Управляющий импульс
                STARTENGINEPbits.start_pulse_duration --;
# if defined (MCP23S08)
                
# else                
                if (OUTFUNCbits.pin9 == 7) AUTO_START = 1;
# endif
            } else {
# if defined (MCP23S08)

# else                
                if (OUTFUNCbits.pin9 == 7) AUTO_START = 0;
# endif
            }
            
        STARTENGINEPbits.run_duration --;
    }
    else {// успешное окончание автозапуска
        Nop();Nop();Nop();
        generate_content_of_message ( 87, 1 );
        stop_autorun_engine ( 1, STARTENGINEPbits.stop_pulse_duration ); // запуск импульса стоп
        engine_running_counter = 0;
        STARTENGINEPbits.start_pulse_duration = 0;
        STARTENGINEPbits.stop_pulse_duration = 0;
        STARTENGINEPbits.run_duration = 0;
        STARTENGINEPbits.source_of_command = 0;
        STARTENGINEPbits.start = 0;
        STARTENGINEPbits.success_message_generated = 0;
        dd_intrusion_off_timer = dd_intrusion_off_setting; // 5 секундный таймер игнорирования вторжения по дверям
    }
    
    if (ignition_by_pulse == 1 ) { 
        if (engine_running_counter < 300 && STARTENGINEPbits.success_message_generated == 0) engine_running_counter ++;
        else {
            Nop();Nop();Nop();
            if (STARTENGINEPbits.success_message_generated == 0 && car_voltage > start_engine_volt_trh) {
                
                LOCKAUTORUNbits.LOCKAUTORUN = 0;
                LOCKAUTORUNbits.start = 1;
                DOORAUTORUNbits.DOORAUTORUN = 0;
                DOORAUTORUNbits.start = 1;                
                STARTENGINEPbits.success_message_generated = 1;
                generate_content_of_message ( 34, 1 );
            }
        }
        
    } else {
        if (STARTENGINEPbits.success_message_generated == 0) {
            engine_running_counter = 0;
            if (engine_not_running_counter < 600) engine_not_running_counter ++;
            else 
            {
                delayd_wired_bloking_during_autorun ( 1 );
//# if defined (WIRED_ENJINE_BLOKING)
//    # if defined (MCP23S08)
//
//    # else
//        if (OUTFUNCbits.pin15 == 3) { if (OUTbits.arm_flag == 1) { L_OUT = 1; } }
//    # endif    
//# endif // Блокировка при неуспешном запуске                
                engine_not_running_counter = 0;
                engine_running_counter = 0;
                STARTENGINEPbits.start_pulse_duration = 0;
                STARTENGINEPbits.stop_pulse_duration = 0;
                STARTENGINEPbits.run_duration = 0;
                STARTENGINEPbits.source_of_command = 0;
                STARTENGINEPbits.start = 0;
                STARTENGINEPbits.success_message_generated = 0;
                generate_content_of_message ( 33, 1 );
            }
        }
    }

// Если автозапуск был успешен, но зажигание выключилось, сброс задачи и деактивация выхода
/**/
    if (STARTENGINEPbits.start == 1 &&STARTENGINEPbits.success_message_generated == 1) {
        if (ignition == 0) {
            Nop();Nop();Nop();
# if defined (MCP23S08)

# else            
            if (OUTFUNCbits.pin9 == 7) AUTO_START = 0;
# endif 
            delayd_wired_bloking_during_autorun ( 1 );
//# if defined (WIRED_ENJINE_BLOKING)
//    # if defined (MCP23S08)
//
//    # else
//        if (OUTFUNCbits.pin15 == 3) { if (OUTbits.arm_flag == 1) { L_OUT = 1; } }
//    # endif    
//# endif // Блокировка успешного запуска если выключилось зажигание   
            
            generate_content_of_message ( 87, 1 );
            engine_running_counter = 0;
            STARTENGINEPbits.start_pulse_duration = 0;
            STARTENGINEPbits.stop_pulse_duration = 0;
            STARTENGINEPbits.run_duration = 0;
            STARTENGINEPbits.source_of_command = 0;
            STARTENGINEPbits.start = 0;
            STARTENGINEPbits.success_message_generated = 0;
            
        }
    }

# endif

}

void start_engine_can (void) {
    static unsigned char delay_counter = 0;
    static unsigned long running_counter = 0;
    
    if ( STARTENGINECbits.start_tasck == 0 ) {
        delay_counter = 0;
        running_counter = 0;        
        return;
    }
    
    if ( delay_counter == 0 ) { // задержка для разблокировки реле
        fire_rel_transaction_flag = 1;
    }

    if ( delay_counter < 200 ) { // задержка для разблокировки реле
        delay_counter ++;
        return;
    }

    if ( running_counter < STARTENGINECbits.run_duration ) running_counter ++;
    else {
        Nop();Nop();Nop();
        STARTENGINECbits.STARTENGINEC = 0;
        fire_rel_transaction_flag = 1;
        delay_counter = 0;
        running_counter = 0;        
    }
    
    if ( running_counter == 1 ) {
        Nop();Nop();Nop();
        STARTENGINECbits.start = 1;
    }
    
    if ( STARTENGINECbits.stop_tasck == 1 ) {
        STARTENGINECbits.stop_tasck = 0;
        running_counter = STARTENGINECbits.run_duration - 1000;
    }
    
    if ( running_counter == ( STARTENGINECbits.run_duration - 1000 ) ) {
//        fire_rel_transaction_flag = 1;
        if ( OBDRPMREQbits.start == 1 ) OBDRPMREQbits.stop = 1;
        STARTENGINECbits.stop = 1;
        generate_content_of_message ( 87, 1 );
    }
//    engine_status = 1;

    if ( running_counter == 1500 ) { // через 15 секунд от начала принятие решения об успешности запуска
        if ( engine_status == 1 ) {
            Nop();Nop();Nop();
            STARTENGINECbits.success_message_generated = 1;
            if ( OBDRPMREQbits.start == 1 ) OBDRPMREQbits.stop = 1;
            generate_content_of_message ( 34, 1 );
        } else {
            if ( RPM_status == 1 ) {
                STARTENGINECbits.success_message_generated = 1;
                if ( OBDRPMREQbits.start == 1 ) OBDRPMREQbits.stop = 1;
                generate_content_of_message ( 34, 1 );
            } else {
                if ( OBDRPMREQbits.start == 1 ) OBDRPMREQbits.stop = 1;
                STARTENGINECbits.STARTENGINEC = 0;
                fire_rel_transaction_flag = 1;
                generate_content_of_message ( 33, 1 ); // не завелась
            }          
        }
    }
    
// Если автозапуск был успешен, но зажигание выключилось не по команде блока
/**/
    if (STARTENGINECbits.start_tasck == 1 && STARTENGINECbits.success_message_generated == 1 && STARTENGINECbits.stop == 0 ) {
        if (ignition == 0) {
            Nop();Nop();Nop();
//# if defined (MCP23S08)
//
//# else            
//            if (OUTFUNCbits.pin9 == 7) AUTO_START = 0;
//# endif 
//            delayd_wired_bloking_during_autorun ( 1 );

            generate_content_of_message ( 87, 1 );
            STARTENGINECbits.STARTENGINEC = 0;
            fire_rel_transaction_flag = 1;
            delay_counter = 0;
            running_counter = 0;            
        }
    }
    
} 
void run_start_engine_can (void) {
    static unsigned int counter = 0, counter1 = 0, can1_flag = 0, can2_flag = 0;


    if (STARTENGINECbits.start == 0 && STARTENGINECbits.stop == 0) { counter1 = 0; counter = 0; return; }


        if ( STARTENGINECbits.start == 1 ) {

                if ( counter1 != 0 ) {
                    if (STRTENGCSTARTSET1bits.can_number != 0) {
                        if ( STRTENGCSTARTTIME1bits.B0 == counter1 || STRTENGCSTARTTIME1bits.B1 == counter1 || STRTENGCSTARTTIME1bits.B2 == counter1 || STRTENGCSTARTTIME1bits.B3 == counter1 ||
                             STRTENGCSTARTTIME1bits.B4 == counter1 || STRTENGCSTARTTIME1bits.B5 == counter1 || STRTENGCSTARTTIME1bits.B6 == counter1 || STRTENGCSTARTTIME1bits.B7 == counter1 ) 
                        {
                            if (STRTENGCSTARTSET1bits.can_number == 1) can1_flag = 1; if (STRTENGCSTARTSET1bits.can_number == 2) can2_flag = 1;
                             send_start_engine_can_command (1);
                        }
                    }
                    if (STRTENGCSTARTSET2bits.can_number != 0) {
                        if ( STRTENGCSTARTTIME2bits.B0 == counter1 || STRTENGCSTARTTIME2bits.B1 == counter1 || STRTENGCSTARTTIME2bits.B2 == counter1 || STRTENGCSTARTTIME2bits.B3 == counter1 ||
                             STRTENGCSTARTTIME2bits.B4 == counter1 || STRTENGCSTARTTIME2bits.B5 == counter1 || STRTENGCSTARTTIME2bits.B6 == counter1 || STRTENGCSTARTTIME2bits.B7 == counter1 ) 
                        {
                            if (STRTENGCSTARTSET2bits.can_number == 1) can1_flag = 1; if (STRTENGCSTARTSET2bits.can_number == 2) can2_flag = 1;
                             send_start_engine_can_command (2);
                        }
                    }
                    if (STRTENGCSTARTSET3bits.can_number != 0) {
                        if ( STRTENGCSTARTTIME3bits.B0 == counter1 || STRTENGCSTARTTIME3bits.B1 == counter1 || STRTENGCSTARTTIME3bits.B2 == counter1 || STRTENGCSTARTTIME3bits.B3 == counter1 ||
                             STRTENGCSTARTTIME3bits.B4 == counter1 || STRTENGCSTARTTIME3bits.B5 == counter1 || STRTENGCSTARTTIME3bits.B6 == counter1 || STRTENGCSTARTTIME3bits.B7 == counter1 ) 
                        {
                            if (STRTENGCSTARTSET3bits.can_number == 1) can1_flag = 1; if (STRTENGCSTARTSET3bits.can_number == 2) can2_flag = 1;
                             send_start_engine_can_command (3);
                        }
                    }
                    if (STRTENGCSTARTSET4bits.can_number != 0) {
                        if ( STRTENGCSTARTTIME4bits.B0 == counter1 || STRTENGCSTARTTIME4bits.B1 == counter1 || STRTENGCSTARTTIME4bits.B2 == counter1 || STRTENGCSTARTTIME4bits.B3 == counter1 ||
                             STRTENGCSTARTTIME4bits.B4 == counter1 || STRTENGCSTARTTIME4bits.B5 == counter1 || STRTENGCSTARTTIME4bits.B6 == counter1 || STRTENGCSTARTTIME4bits.B7 == counter1 ) 
                        {
                            if (STRTENGCSTARTSET4bits.can_number == 1) can1_flag = 1; if (STRTENGCSTARTSET4bits.can_number == 2) can2_flag = 1;
                             send_start_engine_can_command (4);
                        }
                    }
                    if (STRTENGCSTARTSET5bits.can_number != 0) {
                        if ( STRTENGCSTARTTIME5bits.B0 == counter1 || STRTENGCSTARTTIME5bits.B1 == counter1 || STRTENGCSTARTTIME5bits.B2 == counter1 || STRTENGCSTARTTIME5bits.B3 == counter1 ||
                             STRTENGCSTARTTIME5bits.B4 == counter1 || STRTENGCSTARTTIME5bits.B5 == counter1 || STRTENGCSTARTTIME5bits.B6 == counter1 || STRTENGCSTARTTIME5bits.B7 == counter1 ) 
                        {
                            if (STRTENGCSTARTSET5bits.can_number == 1) can1_flag = 1; if (STRTENGCSTARTSET5bits.can_number == 2) can2_flag = 1;
                             send_start_engine_can_command (5);
                        }
                    }
                   
                }
                
                
        }//if ( LOCKUNLOCKbits.lock == 1 )
        if ( STARTENGINECbits.stop == 1 ) {

                if ( counter1 != 0 ) {
                    if (STRTENGCSTOPSET1bits.can_number != 0) {
                        if ( STRTENGCSTOPTIME1bits.B0 == counter1 || STRTENGCSTOPTIME1bits.B1 == counter1 || STRTENGCSTOPTIME1bits.B2 == counter1 || STRTENGCSTOPTIME1bits.B3 == counter1 ||
                             STRTENGCSTOPTIME1bits.B4 == counter1 || STRTENGCSTOPTIME1bits.B5 == counter1 || STRTENGCSTOPTIME1bits.B6 == counter1 || STRTENGCSTOPTIME1bits.B7 == counter1 ) 
                        {
                            if (STRTENGCSTOPSET1bits.can_number == 1) can1_flag = 1; if (STRTENGCSTOPSET1bits.can_number == 2) can2_flag = 1;
                             send_start_engine_can_command (7);
                        }
                    }
                    if (STRTENGCSTOPSET2bits.can_number != 0) {
                        if ( STRTENGCSTOPTIME2bits.B0 == counter1 || STRTENGCSTOPTIME2bits.B1 == counter1 || STRTENGCSTOPTIME2bits.B2 == counter1 || STRTENGCSTOPTIME2bits.B3 == counter1 ||
                             STRTENGCSTOPTIME2bits.B4 == counter1 || STRTENGCSTOPTIME2bits.B5 == counter1 || STRTENGCSTOPTIME2bits.B6 == counter1 || STRTENGCSTOPTIME2bits.B7 == counter1 ) 
                        {
                            if (STRTENGCSTOPSET2bits.can_number == 1) can1_flag = 1; if (STRTENGCSTOPSET2bits.can_number == 2) can2_flag = 1;
                             send_start_engine_can_command (8);
                        }
                    }
                    if (STRTENGCSTOPSET3bits.can_number != 0) {
                        if ( STRTENGCSTOPTIME3bits.B0 == counter1 || STRTENGCSTOPTIME3bits.B1 == counter1 || STRTENGCSTOPTIME3bits.B2 == counter1 || STRTENGCSTOPTIME3bits.B3 == counter1 ||
                             STRTENGCSTOPTIME3bits.B4 == counter1 || STRTENGCSTOPTIME3bits.B5 == counter1 || STRTENGCSTOPTIME3bits.B6 == counter1 || STRTENGCSTOPTIME3bits.B7 == counter1 ) 
                        {
                            if (STRTENGCSTOPSET3bits.can_number == 1) can1_flag = 1; if (STRTENGCSTOPSET3bits.can_number == 2) can2_flag = 1;
                             send_start_engine_can_command (9);
                        }
                    }
                    if (STRTENGCSTOPSET4bits.can_number != 0) {
                        if ( STRTENGCSTOPTIME4bits.B0 == counter1 || STRTENGCSTOPTIME4bits.B1 == counter1 || STRTENGCSTOPTIME4bits.B2 == counter1 || STRTENGCSTOPTIME4bits.B3 == counter1 ||
                             STRTENGCSTOPTIME4bits.B4 == counter1 || STRTENGCSTOPTIME4bits.B5 == counter1 || STRTENGCSTOPTIME4bits.B6 == counter1 || STRTENGCSTOPTIME4bits.B7 == counter1 ) 
                        {
                            if (STRTENGCSTOPSET4bits.can_number == 1) can1_flag = 1; if (STRTENGCSTOPSET4bits.can_number == 2) can2_flag = 1;
                             send_start_engine_can_command (10);
                        }
                    }
                    if (STRTENGCSTOPSET5bits.can_number != 0) {
                        if ( STRTENGCSTOPTIME5bits.B0 == counter1 || STRTENGCSTOPTIME5bits.B1 == counter1 || STRTENGCSTOPTIME5bits.B2 == counter1 || STRTENGCSTOPTIME5bits.B3 == counter1 ||
                             STRTENGCSTOPTIME5bits.B4 == counter1 || STRTENGCSTOPTIME5bits.B5 == counter1 || STRTENGCSTOPTIME5bits.B6 == counter1 || STRTENGCSTOPTIME5bits.B7 == counter1 ) 
                        {
                            if (STRTENGCSTOPSET5bits.can_number == 1) can1_flag = 1; if (STRTENGCSTOPSET5bits.can_number == 2) can2_flag = 1;
                             send_start_engine_can_command (11);
                        }
                    } 
                   
                }
                
                
        }
    

    
    if (counter1 < 700) {counter1 ++;}
    else {
    Nop();Nop();Nop();
    
        counter1 = 0;
        //if (WBSTRSET1bits.can_number == 1 || WBSTRSET1bits.can_number == 2)
        if (can1_flag == 1) {can1_flag = 0; C1TR23CONbits.TXREQ3 = 0; }
        if (can2_flag == 1) {can2_flag = 0; C2TR23CONbits.TXREQ3 = 0; }
        if ( STARTENGINECbits.start == 1 ) { STARTENGINECbits.start = 0; } //send_lock_comand_status (1);
        if ( STARTENGINECbits.stop  == 1 ) { STARTENGINECbits.stop = 0;  } //send_lock_comand_status (0);
        
    }


}
void send_start_engine_can_command ( int command_number ) {
    
    unsigned int temp1 = 0, temp2 = 0, temp3 = 0, temp4 = 0; 

    unsigned long ID        = 0x0;
    unsigned int len        = 0x0;
    unsigned int can_number = 0x0;
    
        switch (command_number)
        {
            case 1://STRTENGCSTARTSET1
                can_number = STRTENGCSTARTSET1bits.can_number;
                ID = STRTENGCSTARTSET1bits.id;
                len = STRTENGCSTARTSET1bits.len;
                temp1 = STRTENGCSTARTDAT1bits.B1; temp1 = (temp1 << 8) + STRTENGCSTARTDAT1bits.B0; temp2 = STRTENGCSTARTDAT1bits.B3; temp2 = (temp2 << 8) + STRTENGCSTARTDAT1bits.B2;
                temp3 = STRTENGCSTARTDAT1bits.B5; temp3 = (temp3 << 8) + STRTENGCSTARTDAT1bits.B4; temp4 = STRTENGCSTARTDAT1bits.B7; temp4 = (temp4 << 8) + STRTENGCSTARTDAT1bits.B6;
                break;
            case 2:
                can_number = STRTENGCSTARTSET2bits.can_number;
                ID = STRTENGCSTARTSET2bits.id;
                len = STRTENGCSTARTSET2bits.len;
                temp1 = STRTENGCSTARTDAT2bits.B1; temp1 = (temp1 << 8) + STRTENGCSTARTDAT2bits.B0; temp2 = STRTENGCSTARTDAT2bits.B3; temp2 = (temp2 << 8) + STRTENGCSTARTDAT2bits.B2;
                temp3 = STRTENGCSTARTDAT2bits.B5; temp3 = (temp3 << 8) + STRTENGCSTARTDAT2bits.B4; temp4 = STRTENGCSTARTDAT2bits.B7; temp4 = (temp4 << 8) + STRTENGCSTARTDAT2bits.B6;
                break;
            case 3:
                can_number = STRTENGCSTARTSET3bits.can_number;
                ID = STRTENGCSTARTSET3bits.id;
                len = STRTENGCSTARTSET3bits.len;
                temp1 = STRTENGCSTARTDAT3bits.B1; temp1 = (temp1 << 8) + STRTENGCSTARTDAT3bits.B0; temp2 = STRTENGCSTARTDAT3bits.B3; temp2 = (temp2 << 8) + STRTENGCSTARTDAT3bits.B2;
                temp3 = STRTENGCSTARTDAT3bits.B5; temp3 = (temp3 << 8) + STRTENGCSTARTDAT3bits.B4; temp4 = STRTENGCSTARTDAT3bits.B7; temp4 = (temp4 << 8) + STRTENGCSTARTDAT3bits.B6;
                break;
            case 4:
                can_number = STRTENGCSTARTSET4bits.can_number;
                ID = STRTENGCSTARTSET4bits.id;
                len = STRTENGCSTARTSET4bits.len;
                temp1 = STRTENGCSTARTDAT4bits.B1; temp1 = (temp1 << 8) + STRTENGCSTARTDAT4bits.B0; temp2 = STRTENGCSTARTDAT4bits.B3; temp2 = (temp2 << 8) + STRTENGCSTARTDAT4bits.B2;
                temp3 = STRTENGCSTARTDAT4bits.B5; temp3 = (temp3 << 8) + STRTENGCSTARTDAT4bits.B4; temp4 = STRTENGCSTARTDAT4bits.B7; temp4 = (temp4 << 8) + STRTENGCSTARTDAT4bits.B6;
                break;
            case 5:
                can_number = STRTENGCSTARTSET5bits.can_number;
                ID = STRTENGCSTARTSET5bits.id;
                len = STRTENGCSTARTSET5bits.len;
                temp1 = STRTENGCSTARTDAT5bits.B1; temp1 = (temp1 << 8) + STRTENGCSTARTDAT5bits.B0; temp2 = STRTENGCSTARTDAT5bits.B3; temp2 = (temp2 << 8) + STRTENGCSTARTDAT5bits.B2;
                temp3 = STRTENGCSTARTDAT5bits.B5; temp3 = (temp3 << 8) + STRTENGCSTARTDAT5bits.B4; temp4 = STRTENGCSTARTDAT5bits.B7; temp4 = (temp4 << 8) + STRTENGCSTARTDAT5bits.B6;
                break;
            case 6:
//                can_number = STRTENGCSTARTSET6bits.can_number;
//                ID = STRTENGCSTARTSET6bits.id;
//                len = STRTENGCSTARTSET6bits.len;
//                temp1 = STRTENGCSTARTDAT6bits.B1; temp1 = (temp1 << 8) + STRTENGCSTARTDAT6bits.B0; temp2 = STRTENGCSTARTDAT6bits.B3; temp2 = (temp2 << 8) + STRTENGCSTARTDAT6bits.B2;
//                temp3 = STRTENGCSTARTDAT6bits.B5; temp3 = (temp3 << 8) + STRTENGCSTARTDAT6bits.B4; temp4 = STRTENGCSTARTDAT6bits.B7; temp4 = (temp4 << 8) + STRTENGCSTARTDAT6bits.B6;
                break;                
            case 7:
                can_number = STRTENGCSTOPSET1bits.can_number;
                ID  = STRTENGCSTOPSET1bits.id;
                len = STRTENGCSTOPSET1bits.len;                
                temp1 = STRTENGCSTOPDAT1bits.B1; temp1 = (temp1 << 8) + STRTENGCSTOPDAT1bits.B0; temp2 = STRTENGCSTOPDAT1bits.B3; temp2 = (temp2 << 8) + STRTENGCSTOPDAT1bits.B2;
                temp3 = STRTENGCSTOPDAT1bits.B5; temp3 = (temp3 << 8) + STRTENGCSTOPDAT1bits.B4; temp4 = STRTENGCSTOPDAT1bits.B7; temp4 = (temp4 << 8) + STRTENGCSTOPDAT1bits.B6;
                break;
            case 8:
                can_number = STRTENGCSTOPSET2bits.can_number;
                ID  = STRTENGCSTOPSET2bits.id;
                len = STRTENGCSTOPSET2bits.len;                
                temp1 = STRTENGCSTOPDAT2bits.B1; temp1 = (temp1 << 8) + STRTENGCSTOPDAT2bits.B0; temp2 = STRTENGCSTOPDAT2bits.B3; temp2 = (temp2 << 8) + STRTENGCSTOPDAT2bits.B2;
                temp3 = STRTENGCSTOPDAT2bits.B5; temp3 = (temp3 << 8) + STRTENGCSTOPDAT2bits.B4; temp4 = STRTENGCSTOPDAT2bits.B7; temp4 = (temp4 << 8) + STRTENGCSTOPDAT2bits.B6;
                break;
            case 9:
                can_number = STRTENGCSTOPSET3bits.can_number;
                ID  = STRTENGCSTOPSET3bits.id;
                len = STRTENGCSTOPSET3bits.len;                
                temp1 = STRTENGCSTOPDAT3bits.B1; temp1 = (temp1 << 8) + STRTENGCSTOPDAT3bits.B0; temp2 = STRTENGCSTOPDAT3bits.B3; temp2 = (temp2 << 8) + STRTENGCSTOPDAT3bits.B2;
                temp3 = STRTENGCSTOPDAT3bits.B5; temp3 = (temp3 << 8) + STRTENGCSTOPDAT3bits.B4; temp4 = STRTENGCSTOPDAT3bits.B7; temp4 = (temp4 << 8) + STRTENGCSTOPDAT3bits.B6;
                break;
            case 10:
                can_number = STRTENGCSTOPSET4bits.can_number;
                ID  = STRTENGCSTOPSET4bits.id;
                len = STRTENGCSTOPSET4bits.len;                
                temp1 = STRTENGCSTOPDAT4bits.B1; temp1 = (temp1 << 8) + STRTENGCSTOPDAT4bits.B0; temp2 = STRTENGCSTOPDAT4bits.B3; temp2 = (temp2 << 8) + STRTENGCSTOPDAT4bits.B2;
                temp3 = STRTENGCSTOPDAT4bits.B5; temp3 = (temp3 << 8) + STRTENGCSTOPDAT4bits.B4; temp4 = STRTENGCSTOPDAT4bits.B7; temp4 = (temp4 << 8) + STRTENGCSTOPDAT4bits.B6;
                break;
            case 11:
                can_number = STRTENGCSTOPSET5bits.can_number;
                ID  = STRTENGCSTOPSET5bits.id;
                len = STRTENGCSTOPSET5bits.len;                
                temp1 = STRTENGCSTOPDAT5bits.B1; temp1 = (temp1 << 8) + STRTENGCSTOPDAT5bits.B0; temp2 = STRTENGCSTOPDAT5bits.B3; temp2 = (temp2 << 8) + STRTENGCSTOPDAT5bits.B2;
                temp3 = STRTENGCSTOPDAT5bits.B5; temp3 = (temp3 << 8) + STRTENGCSTOPDAT5bits.B4; temp4 = STRTENGCSTOPDAT5bits.B7; temp4 = (temp4 << 8) + STRTENGCSTOPDAT5bits.B6;

                break;
            case 12:
//                can_number = STRTENGCSTOPSET6bits.can_number;
//                ID  = STRTENGCSTOPSET6bits.id;
//                len = STRTENGCSTOPSET6bits.len;                
//                temp1 = STRTENGCSTOPDAT6bits.B1; temp1 = (temp1 << 8) + STRTENGCSTOPDAT6bits.B0; temp2 = STRTENGCSTOPDAT6bits.B3; temp2 = (temp2 << 8) + STRTENGCSTOPDAT6bits.B2;
//                temp3 = STRTENGCSTOPDAT6bits.B5; temp3 = (temp3 << 8) + STRTENGCSTOPDAT6bits.B4; temp4 = STRTENGCSTOPDAT6bits.B7; temp4 = (temp4 << 8) + STRTENGCSTOPDAT6bits.B6;

                break;
//            case 13:
//                can_number = STRTENGCRSET1bits.can_number;
//                ID = STRTENGCRSET1bits.id;
//                len = STRTENGCRSET1bits.len;
//                temp1 = STRTENGCRDAT1bits.B1; temp1 = (temp1 << 8) + STRTENGCRDAT1bits.B0; temp2 = STRTENGCRDAT1bits.B3; temp2 = (temp2 << 8) + STRTENGCRDAT1bits.B2;
//                temp3 = STRTENGCRDAT1bits.B5; temp3 = (temp3 << 8) + STRTENGCRDAT1bits.B4; temp4 = STRTENGCRDAT1bits.B7; temp4 = (temp4 << 8) + STRTENGCRDAT1bits.B6;
//                break;
            default:
                break;
        }
    

    if (can_number == 1) {
        ecan1WriteTxMsgBufId ( 3, (long) ID, (unsigned int) CAN1SETTINGSbits.ide, (unsigned int) 0 );
        ecan1WriteTxMsgBufData( 3, (unsigned int) len, temp1, temp2, temp3, temp4 );
        settxtransmit( 3 );                                
    }
    if (can_number == 2) {
        ecan2WriteTxMsgBufId ( 3, (long) ID, (unsigned int) CAN2SETTINGSbits.ide, (unsigned int) 0 );
        ecan2WriteTxMsgBufData( 3, (unsigned int) len, temp1, temp2, temp3, temp4 );
        settxtransmit2( 3 );                                
    }    

        
}

#ifdef RUN_O
void start_engine_runo (void) { //remote start algorithm on Element OBD Unit with Ignition\Brake\StartStop lines control
//    ignition_1();         //ignition line ofun10 output to HI level
//    brakepedal_1();       //brake line ofun11 output to HI level
//    startstop_button_1(); //startstop line ofun12 output to HI level
//    ignition_0();         //ignition line ofun10 output to LOW level
//    brakepedal_0();       //break line ofun11 output to LOW level    
//    startstop_button_0(); //startstop line ofun12 output to LOW level
    #define pauseP 10 //1sec, pause between pedal push/release, etc.
    #define pauseENGINEST 60 //10sec, pause for engine start
    volatile static unsigned char pauseP_cnt = 0;
    volatile static unsigned char startstop_pause_cnt = 0;
    volatile static unsigned char pulse_cnt = 0;
    static unsigned char pauseStop_cnt = 0; //counter for stop pulse
//    static unsigned char brake_status = 0; //remove after CAN func insertion
//    static unsigned char RPM_status = 1;
       
    if (STARTENGINEObits.start == 0 ) return; //no start command from check_setting() func 
    if ((STARTENGINEObits.stop == 1) || (STARTENGINEObits.run_duration == 0)) {
        if ( OBDRPMREQbits.start == 1 ) OBDRPMREQbits.stop = 1;
        //Start-Stop button
        if (pauseStop_cnt < STARTENGINEObits.pulse_duration) { //delay for startstop pulse duration
                startstop_button_1(); //push startstop button
                pauseStop_cnt++;
                return;
            } else {
                pauseStop_cnt = 0;
                startstop_button_0();
            }
        ///////////////////
        ignition_0();
        brakepedal_0();
        startstop_button_0();
        STARTENGINEObits.STARTENGINEO = 0;
        DOORAUTORUNbits.start = 1;
        pauseP_cnt = 0;
        startstop_pause_cnt = 0;
        pulse_cnt = 0;
        pauseStop_cnt = 0;
//        load_UART4_Tx_buf ("Timeout, task stoped");
//        start_UART4_transmission (WAITOFF);
        //CAN- door open-close for light off
        //generate_msg_to server// autostart is complete Успешно завершен
        generate_content_of_message ( 87, 1 );
        if ( OBDRPMREQbits.start == 1 ) OBDRPMREQbits.stop = 1;
        Nop();Nop();Nop();
        return;
    }
    if (STARTENGINEbits.start == 1) return;
    if (STARTENGINESbits.start == 1) return;
    if (STARTENGINEPbits.start == 1) return;
    if (STARTENGINEObits.run_duration > 0) STARTENGINEObits.run_duration--; //timer of remotestart work
    sleep_counter = 0; // reset sleep cnt to disable sleep while task is active
    Nop();Nop();Nop();
    if (STARTENGINEObits.attempts_cnt >= 3) { //check if attempts >3 - end task with error
        
if (ignition) { //push start-stop for engine OFF, if error with RPM reading occurs
           //Start-Stop button
           if (pauseStop_cnt < STARTENGINEObits.pulse_duration) { //delay for startstop pulse duration
               startstop_button_1(); //push startstop button
               pauseStop_cnt++;
               return;
           } else {
               pauseStop_cnt = 0;
               startstop_button_0();
           }
           ///////////////////
}        
        
        STARTENGINEObits.STARTENGINEO = 0;
        pauseP_cnt = 0;
        startstop_pause_cnt = 0;
        pulse_cnt = 0;
        ignition_0();
        brakepedal_0();
        startstop_button_0();
//        load_UART4_Tx_buf ("More than 3 start attempts, task stoped");
//        start_UART4_transmission (WAITOFF);
        //CAN- door open-close for light off
        //generate_msg_to server// engine start FAIL
        generate_content_of_message ( 33, 1 );
        DOORAUTORUNbits.start = 1;
        DOORAUTORUNbits.engine_start_fail = 1;
        if ( OBDRPMREQbits.start == 1 ) OBDRPMREQbits.stop = 1;
        Nop();Nop();Nop();
        return;
    }
    ///Main Algorithm///
    switch (STARTENGINEObits.stage) {
        case 0:
            if (pauseP_cnt < pauseP)  { //delay before next step
                pauseP_cnt++;
                 return;
            } else { //delay ended
                pauseP_cnt = 0;
                STARTENGINEObits.stage++;
            }   
            break;
        case 1:
            Nop();Nop();Nop();
            ignition_1(); //enable ignition 
            if (pauseP_cnt < pauseP)  { //delay before next step
                pauseP_cnt++;
                 return;
            } else { //delay ended
                pauseP_cnt = 0;
                STARTENGINEObits.stage++;
            }   
            Nop();Nop();Nop();
            break;
        case 2:
            Nop();Nop();Nop();
            brakepedal_1(); //enable brakepedal simulation 
            if (pauseP_cnt < pauseP) { //delay before next step
                pauseP_cnt++;
                return;
            } else {
                pauseP_cnt = 0;
                STARTENGINEObits.stage++;
            }
            Nop();Nop();Nop();
            break;
        case 3:
            Nop();Nop();Nop();
            if (pauseP_cnt < STARTENGINEObits.pulse_duration) { //delay for startstop pulse duration
                startstop_button_1(); //push startstop button
                pauseP_cnt++;
                return;
            } else {
                pauseP_cnt = 0;
                startstop_button_0();
            }                
            pulse_cnt++;
            STARTENGINEObits.stage++;
            Nop();Nop();Nop();

            break;
        case 4:
            Nop();Nop();Nop();
            if (pauseP_cnt < STARTENGINEObits.pulse_delay - 2) { //delay between pulses (-2) - so we drop 2 tact (by 0.1s)
                    pauseP_cnt++;
                    return;
                } else {
                    pauseP_cnt = 0;
                    if (pulse_cnt < STARTENGINEObits.pulse_count) {
                        STARTENGINEObits.stage--;
                        return;
                    }
                }
            if (pulse_cnt >= STARTENGINEObits.pulse_count) {
                brakepedal_0();
                pulse_cnt = 0;
                STARTENGINEObits.stage++;
//                load_UART4_Tx_buf ("Engine starts, delay 10sec");
//                start_UART4_transmission (WAITOFF);
            }    
            Nop();Nop();Nop();
            
            break;
        case 5: //pause before engine starts
            Nop();Nop();Nop();
            if (pauseP_cnt < pauseENGINEST) { //delay before check engine RPM
            pauseP_cnt++;
            return;
            } else {
            pauseP_cnt = 0;
            STARTENGINEObits.stage++;
//            load_UART4_Tx_buf ("Engine start delay finished");
            start_UART4_transmission (WAITOFF);
            }            
            break;
        case 6: //check engine RPMs via CAN and control auto-pickup function by brakepedal(CAN)
            Nop();Nop();Nop();
            if (RPM_status) {     //check if (RPM CAN) >0
//                load_UART4_Tx_buf ("Engine work!");
                Nop();Nop();Nop();
                Nop();Nop();Nop();
                Nop();Nop();Nop();
//                start_UART4_transmission (WAITOFF);
                // Автозапуск успешен
                if ( STARTENGINEObits.success == 0 ) {
                    STARTENGINEObits.success = 1;
                    generate_content_of_message ( 34, 1 );
                    DOORAUTORUNbits.start = 1;
                    if ( OBDRPMREQbits.start == 1 ) OBDRPMREQbits.stop = 1;
                }
                if (brake_status) { //check if (Brake push CAN) >0
                    //auto-pickup activated
//                    load_UART4_Tx_buf ("Auto-pickup ON, task stoped");
//                    start_UART4_transmission (WAITOFF);
                    STARTENGINEObits.STARTENGINEO = 0; //end task
                    pauseP_cnt = 0;
                    startstop_pause_cnt = 0;
                    pulse_cnt = 0;
                    pauseStop_cnt = 0;
                    ignition_0();
                    //generate_msg_to server// autostart is complete Завершен успешно потому что машину завел клиент
                    generate_content_of_message ( 87, 1 );
                    if ( OBDRPMREQbits.start == 1 ) OBDRPMREQbits.stop = 1;
                    Nop();Nop();Nop();
                    return;
                }
            } else // engine start fault, try again
            {   
//                load_UART4_Tx_buf ("Engine start FAULT!");
//                start_UART4_transmission (WAITOFF);
                STARTENGINEObits.attempts_cnt++;
                ignition_0();
                brakepedal_0();
                startstop_button_0();
                STARTENGINEObits.stage = 0;
                Nop();Nop();Nop();
                return;
            }
            break;
                           
    }
    ///Main Algorithm///
}

void start_engine_runo1 (void) { //remote start algorithm on Element OBD Unit with Ignition\Brake\StartStop lines control
//    ignition_1();         //ignition line ofun10 output to HI level
//    brakepedal_1();       //brake line ofun11 output to HI level
//    startstop_button_1(); //startstop line ofun12 output to HI level
//    ignition_0();         //ignition line ofun10 output to LOW level
//    brakepedal_0();       //break line ofun11 output to LOW level    
//    startstop_button_0(); //startstop line ofun12 output to LOW level
    #define pauseP 10 //1sec, pause between pedal push/release, etc.
    #define pauseENGINEST 60 //6sec, pause for engine start before starting check RPM
    #define pauseBrakePedal 50//5sec, pause for brake pedal before engine start
    volatile static unsigned char pauseP_cnt = 0;
    volatile static unsigned char startstop_pause_cnt = 0;
    volatile static unsigned char pulse_cnt = 0;
    static unsigned char pauseStop_cnt = 0; //counter for stop pulse
    //static unsigned char brake_status_emu = 0;
    //static unsigned char RPM_status_emu = 1;
    //static unsigned char ignition_emu = 0;
    static unsigned char delay_counter = 0;
       
    if (STARTENGINEO1bits.start == 0 ) {
        delay_counter = 0;
        return; //no start command from check_setting() func    
    }
    
    if (delay_counter < 20) {
        delay_counter ++;
        return;
    }
    
    if ((arm_enable == 1) && (ARMFLAGSbits.intr_event_trigg == 1) && (INTRREASONbits.ign == 0 && (INTRREASONbits.INTRREASON != 0))) {
        if ( OBDRPMREQbits.start == 1 ) OBDRPMREQbits.stop = 1;
        //Start-Stop button
        if (pauseStop_cnt < STARTENGINEO1bits.pulse_duration) { //delay for startstop pulse duration
                startstop_button_1(); //push startstop button
                pauseStop_cnt++;
                return;
            } else {
                pauseStop_cnt = 0;
                startstop_button_0();
            }
        ///////////////////
        ignition_0();
        brakepedal_0();
        startstop_button_0();
        STARTENGINEO1bits.STARTENGINEO1 = 0;
//        DOORAUTORUNbits.start = 1;
        pauseP_cnt = 0;
        startstop_pause_cnt = 0;
        pulse_cnt = 0;
        pauseStop_cnt = 0;
        //generate_msg_to server// автозапуск завершен по вторжению без метки
        //generate_content_of_message ( 87, 1 ); - изменить сообщение, если надо
        if ( OBDRPMREQbits.start == 1 ) OBDRPMREQbits.stop = 1;
        Nop();Nop();Nop();
        return;
    }
    
    if ((STARTENGINEO1bits.stop == 1) || (STARTENGINEO1bits.run_duration == 0)) {
        if ( OBDRPMREQbits.start == 1 ) OBDRPMREQbits.stop = 1;
        //Start-Stop button
        if (pauseStop_cnt < STARTENGINEO1bits.pulse_duration) { //delay for startstop pulse duration
                startstop_button_1(); //push startstop button
                pauseStop_cnt++;
                return;
            } else {
                pauseStop_cnt = 0;
                startstop_button_0();
            }
        ///////////////////
        ignition_0();
        brakepedal_0();
        startstop_button_0();
        STARTENGINEO1bits.STARTENGINEO1 = 0;
//        DOORAUTORUNbits.start = 1;
        pauseP_cnt = 0;
        startstop_pause_cnt = 0;
        pulse_cnt = 0;
        pauseStop_cnt = 0;
//        load_UART4_Tx_buf ("Timeout, task stoped");
//        start_UART4_transmission (WAITOFF);
        //CAN- door open-close for light off
        //generate_msg_to server// autostart is complete Успешно завершен
        generate_content_of_message ( 87, 1 );
        if ( OBDRPMREQbits.start == 1 ) OBDRPMREQbits.stop = 1;
        Nop();Nop();Nop();
        return;
    }
    if (STARTENGINEbits.start == 1) return;
    if (STARTENGINESbits.start == 1) return;
    if (STARTENGINEPbits.start == 1) return;
    if (STARTENGINEObits.start == 1) return;
    if (STARTENGINEO1bits.run_duration > 0) STARTENGINEO1bits.run_duration--; //timer of remotestart work
    sleep_counter = 0; // reset sleep cnt to disable sleep while task is active
    Nop();Nop();Nop();

    ///Main Algorithm///
    switch (STARTENGINEO1bits.stage) {
        case 0:
            if (pauseP_cnt < pauseP)  { //delay before next step
                pauseP_cnt++;
                 return;
            } else { //delay ended
                pauseP_cnt = 0;
                STARTENGINEO1bits.stage++;
            }   
            break;
        case 1:
            Nop();Nop();Nop();
            ignition_1(); //enable ignition 
            if (pauseP_cnt < pauseP)  { //delay before next step
                pauseP_cnt++;
                 return;
            } else { //delay ended
                pauseP_cnt = 0;
                STARTENGINEO1bits.stage++;
            }   
            Nop();Nop();Nop();
            break;
        case 2:
            Nop();Nop();Nop();
            if (pauseP_cnt < STARTENGINEO1bits.pulse_duration) { //delay for startstop pulse duration
                startstop_button_1(); //push startstop button
                pauseP_cnt++;
                return;
            } else {
                pauseP_cnt = 0;
                startstop_button_0();
            }        
            pulse_cnt++;
            STARTENGINEO1bits.stage++;
            Nop();Nop();Nop();
            break;
        case 3:
            if (pauseP_cnt < 60)  { //20delay before BRAKE pedal press
                pauseP_cnt++;
                 return;
            } else { //delay ended
                pauseP_cnt = 0;
                STARTENGINEO1bits.stage++;
            }   
            break;    
        case 4:
            Nop();Nop();Nop();
            brakepedal_1(); //enable brakepedal simulation 
            if (pauseP_cnt < pauseBrakePedal) { //delay before next step
                pauseP_cnt++;
                return;
            } else {
                pauseP_cnt = 0;
                STARTENGINEO1bits.stage++;
            }
            Nop();Nop();Nop();

            break;
        case 5:
            Nop();Nop();Nop();
            if (pauseP_cnt < STARTENGINEO1bits.pulse_duration) { //delay for startstop pulse duration
                startstop_button_1(); //push startstop button
                pauseP_cnt++;
                return;
            } else {
                pauseP_cnt = 0;
                startstop_button_0();
            } 
                STARTENGINEO1bits.stage++;
//                load_UART4_Tx_buf ("Engine starts (ALG1), delay 10sec");
//                start_UART4_transmission (WAITOFF);
                
            Nop();Nop();Nop();
            
            break;
        case 6: //pause before engine starts
            Nop();Nop();Nop();
            if (pauseP_cnt < pauseENGINEST) { //delay before check engine RPM
            pauseP_cnt++;
            return;
            } else {
            pauseP_cnt = 0;
            STARTENGINEO1bits.stage++;
//            load_UART4_Tx_buf ("Engine start delay finished");
            //start_UART4_transmission (WAITOFF);
            }            
            break;
        case 7: //check engine RPMs via CAN and control auto-pickup function by brakepedal(CAN)
            Nop();Nop();Nop();
//            RPM_status = 1;
            if (RPM_status) {     //check if (RPM CAN) >0
            // Автозапуск успешен
                if ( STARTENGINEO1bits.success == 0 ) {
                    brakepedal_0();
                    if (pauseP_cnt < pauseP)  { //delay before next step
                        pauseP_cnt++;
                        return;
                    } else { //delay ended
                        pauseP_cnt = 0;
                    }
//                    load_UART4_Tx_buf ("Engine work!");
//                    start_UART4_transmission (WAITOFF);
                    STARTENGINEO1bits.success = 1;
                    generate_content_of_message ( 34, 1 );
                    if ( OBDRPMREQbits.start == 1 ) OBDRPMREQbits.stop = 1;
//                    DOORAUTORUNbits.start = 1;
                    ignition_0();  
                }
                if (brake_status) { //check if (Brake push CAN) >0
                    //auto-pickup activated
//                    load_UART4_Tx_buf ("Auto-pickup ON, task stoped");
//                    start_UART4_transmission (WAITOFF);
                    STARTENGINEO1bits.STARTENGINEO1 = 0; //end task
                    pauseP_cnt = 0;
                    startstop_pause_cnt = 0;
                    pulse_cnt = 0;
                    pauseStop_cnt = 0;
                    ignition_0();
                    brakepedal_0();
                    //generate_msg_to server// autostart is complete Завершен успешно потому что машину завел клиент
                    generate_content_of_message ( 87, 1 );
                    if ( OBDRPMREQbits.start == 1 ) OBDRPMREQbits.stop = 1;
                    Nop();Nop();Nop();
                    return;
                }
            } else // engine start fault, STOP RUNO task or Client push StartStop button for engine stop
            {   
                if (STARTENGINEO1bits.success == 1) { //client stopped engine
                    //load_UART4_Tx_buf ("Client pushed StartStop button, task stoped");
                    //start_UART4_transmission (WAITOFF);
                    STARTENGINEO1bits.STARTENGINEO1 = 0; //end task
                    pauseP_cnt = 0;
                    startstop_pause_cnt = 0;
                    pulse_cnt = 0;
                    pauseStop_cnt = 0;
                    ignition_0();
                    brakepedal_0();
                    //generate_msg_to server// autostart is complete Завершен успешно потому что машину завел клиент
                    generate_content_of_message ( 87, 1 );
                    if ( OBDRPMREQbits.start == 1 ) OBDRPMREQbits.stop = 1;
                    Nop();Nop();Nop();
                    return;
                }
                //STARTENGINEO1bits.attempts_cnt++;
                ignition_0();
                brakepedal_0();
                if ((pauseP_cnt < pauseP) && (pauseStop_cnt == 0))  { //delay before next step
                        pauseP_cnt++;
                        return;
                    } else { //delay ended
                        pauseP_cnt = 0;
                    }
                if (ignition) { //push start-stop for IGNITION OFF, if IGN is active
                    //Start-Stop button
                    if (pauseStop_cnt < STARTENGINEO1bits.pulse_duration) { //delay for startstop pulse duration
                        startstop_button_1(); //push startstop button
                        pauseStop_cnt++;
                        return;
                    } else {
                        pauseStop_cnt = 0;
                        startstop_button_0();
                    }
                    ///////////////////
                }  
//                load_UART4_Tx_buf ("Engine start FAULT!");
//                start_UART4_transmission (WAITOFF);
                startstop_button_0();
                STARTENGINEO1bits.STARTENGINEO1 = 0;
//                DOORAUTORUNbits.start = 1;
                pauseP_cnt = 0;
                startstop_pause_cnt = 0;
                pulse_cnt = 0;
                pauseStop_cnt = 0;
                generate_content_of_message ( 33, 1 ); // remotestart error msg
                if ( OBDRPMREQbits.start == 1 ) OBDRPMREQbits.stop = 1;
                Nop();Nop();Nop();
                return;
            }
            break;
                           
    }
    ///Main Algorithm///
}
void fire_door_open_during_autorun_o (void) {

//# if defined (HYUDAI_I40)
    
    static unsigned char ign_tmp = 0, start_delay = 0;
    
    if ( DOPENSET1bits.can_number == 0 ) {
        DOORAUTORUNObits.DOORAUTORUNO = 0;
        ign_tmp = 0;
        start_delay = 0;
        return;        
    }
    
//LOCKAUTORUNbits
    if (DOORAUTORUNObits.start == 0) {
        DOORAUTORUNObits.DOORAUTORUNO = 0;
        ign_tmp = 0;
        start_delay = 0;
        return;
    }
        if (ign_tmp == 1 && ignition == 0) {
            Nop();Nop();Nop();
            start_delay = 1;
        }
        ign_tmp = ignition;
        
    if ( STARTENGINEObits.start == 1 || STARTENGINEO1bits.start == 1 ) {
        DOORAUTORUNObits.counter = 60;
    }


    if (DOORAUTORUNObits.counter > 0) {
        DOORAUTORUNObits.counter --;
        
        if (start_delay == 1) {
            start_delay = 0;
            DOOROPENbits.start = 1;
        }
        
//        if (start_delay == 1) {
//            if (DOORAUTORUNbits.delay_counter < 25) DOORAUTORUNbits.delay_counter ++;
//            else {
//                start_delay = 0;
//                DOORAUTORUNbits.delay_counter = 0;
//                
//                DOORAUTORUNbits.DOORAUTORUN = 0;
//                DOOROPENbits.start = 1;
//                
//            }
//        } else {
//            start_delay = 0;
//            DOORAUTORUNbits.delay_counter = 0;            
//        }
//        
        
    }
    else {
        Nop();Nop();Nop();
        DOORAUTORUNObits.DOORAUTORUNO = 0;
        ign_tmp = 0;
        return;
    }


//# endif
    
}
#endif

void request_obd_rpm (void) {
    
    if ( (OBDRPMREQbits.start == 0 && OBDRPMREQbits.stop == 0) || OBDREQENbits.rpm_req == 0 ) {
        OBDRPMREQbits.OBDRPMREQ = 0;
        return;
    }
    
unsigned long OBD_ID;

    if ( OBDRPMREQbits.stop == 1 ) {
        OBDRPMREQbits.OBDRPMREQ = 0;
        C1TR01CONbits.TXREQ1 = 0;
        return;
    }
    if ( CAN1SETTINGSbits.ide == 0 ) OBD_ID = 0x7DF;
    else OBD_ID = 0x18DB33F1;
    
    if ( OBDRPMREQbits.counter < 3000 ) OBDRPMREQbits.counter ++;
    else {
        C1TR01CONbits.TXREQ1 = 0;
        OBDRPMREQbits.OBDRPMREQ = 0;
        return;
    }
    if ( (OBDRPMREQbits.counter % 2) == 0 ) {
        if ( ignition == 1 ) {
            ecan1WriteTxMsgBufId  ( 1, (long) OBD_ID, CAN1SETTINGSbits.ide, 0 ); ecan1WriteTxMsgBufData( 1, 8, 0x0102, 0x000C, 0, 0 ); settxtransmit( 1 );
        }
    }
//    if ( (OBDRPMREQbits.counter % 12) == 0 ) {
//        C1TR01CONbits.TXREQ1 = 0;
//    }


}

void start_funcontrol (void) {


    
static unsigned int fun_running_counter = 0, fun_not_running_counter = 0, delay_counter = 0;

# if defined (FUNCONTRL)
//    if (STARTENGINEbits.start == 1) return;
//    if (STARTENGINESbits.start == 1) return;
//    if (STARTENGINEDLbits.start == 1) return;

    if (FUNCONTROLbits.start == 0) {
//        AUTO_START = 0; 
//        L_OUT = 0;
        delay_counter = 0;
        fun_running_counter = 0;
        fun_not_running_counter = 0;
        FUNCONTROLbits.run_duration = 0;
        FUNCONTROLbits.start_pulse_duration = 0;
        FUNCONTROLbits.stop_pulse_duration = 0;
        FUNCONTROLbits.source_of_command = 0;
        FUNCONTROLbits.start = 0;
        FUNCONTROLbits.success_message_generated = 0;
        return;
    }
    
//if (ignition == 1) ignition_by_pulse = 1; // Для имитации успешного запуска

//    if (delay_counter < 20) {
//        delay_counter ++;
//        return;
//    }

    if (FUNCONTROLbits.run_duration > 0) {
        
            if (FUNCONTROLbits.start_pulse_duration > 0) { // Управляющий импульс
                FUNCONTROLbits.start_pulse_duration --;
# if defined (MCP23S08)

# else                
                if (OUTFUNCbits.pin9 == 8) { AUTO_START = 1; }
# endif                
            } else {
# if defined (MCP23S08)

# else                
                if (OUTFUNCbits.pin9 == 8) { AUTO_START = 0; }
# endif                
            }
            
        FUNCONTROLbits.run_duration --;
    }
    else {
        Nop();Nop();Nop();
//        AUTO_START = 0;
        generate_content_of_message ( 52, 1 );
        stop_autorun_engine ( 1, FUNCONTROLbits.stop_pulse_duration ); // запуск импульса стоп
        fun_running_counter = 0;
        FUNCONTROLbits.start_pulse_duration = 0;
        FUNCONTROLbits.stop_pulse_duration = 0;
        FUNCONTROLbits.run_duration = 0;
        FUNCONTROLbits.source_of_command = 0;
        FUNCONTROLbits.start = 0;
        FUNCONTROLbits.success_message_generated = 0;
//        dd_intrusion_off_timer = dd_intrusion_off_setting; // 5 секундный таймер игнорирования вторжения по дверям
    }

    unsigned char tmp;
# if defined (MCP23S08)
    unsigned char number_of_input;
    
    number_of_input = get_number_of_input ( 3 ); // с какого входа читать?
    tmp = get_input_status_MCP23S08 ( number_of_input );
# else    
    tmp = read_inputs ( 1 );
# endif 

    if ( tmp == 1 ) { 
        if (fun_running_counter < 100 && FUNCONTROLbits.success_message_generated == 0) fun_running_counter ++;
        else {
            Nop();Nop();Nop();
            if (FUNCONTROLbits.success_message_generated == 0 ) {
                FUNCONTROLbits.success_message_generated = 1;
                
                generate_content_of_message ( 51, 1 );
            }
        }
        
    }
    else 
    {
        if (FUNCONTROLbits.success_message_generated == 0) {
            fun_running_counter = 0;
            if (fun_not_running_counter < 163) fun_not_running_counter ++;
            else 
            {
                fun_not_running_counter = 0;
                fun_running_counter = 0;
//                AUTO_START = 0;
//                L_OUT = 0; 
                FUNCONTROLbits.start_pulse_duration = 0;
                FUNCONTROLbits.stop_pulse_duration = 0;
                FUNCONTROLbits.run_duration = 0;
                FUNCONTROLbits.source_of_command = 0;
                FUNCONTROLbits.start = 0;
                FUNCONTROLbits.success_message_generated = 0;
//                generate_content_of_message ( 52, 1 );
            }
        }
    }

// Если автозапуск был успешен, но зажигание выключилось, сброс задачи и деактивация выхода
/*
    if (STARTENGINEDLbits.start == 1 && STARTENGINEDLbits.success_message_generated == 1) {
        if (ignition == 0) {
            Nop();Nop();Nop();
            AUTO_START = 0;
            L_OUT = 0;
            engine_running_counter = 0;
            STARTENGINEDLbits.pulse_delay = 0;
            STARTENGINEDLbits.pulse_duration = 0;
            STARTENGINEDLbits.run_duration = 0;
            STARTENGINEDLbits.source_of_command = 0;
            STARTENGINEDLbits.start = 0;
            STARTENGINEDLbits.success_message_generated = 0;            
        }
    }
*/
# endif

}

void stop_autorun_engine ( int start, unsigned int pulse_duration ) {

    static unsigned int counter = 0;
    
    if (start == 1) {
        counter = pulse_duration;
# if defined (MCP23S08)

# else        
        if (OUTFUNCbits.pin9 == 6 || OUTFUNCbits.pin9 == 7 || OUTFUNCbits.pin9 == 8 ) { AUTO_START = 1; }
# endif        
    }
    
    if ( counter > 0 ) {
        Nop();Nop();Nop();
        counter --;
        if (counter == 0) {
# if defined (MCP23S08)

# else            
            if (OUTFUNCbits.pin9 == 6 || OUTFUNCbits.pin9 == 7 || OUTFUNCbits.pin9 == 8 ) { AUTO_START = 0; }
# endif 
            delayd_wired_bloking_during_autorun ( 1 );
//# if defined (WIRED_ENJINE_BLOKING)
//    # if defined (MCP23S08)
//
//    # else
//        if (OUTFUNCbits.pin15 == 3) { if (OUTbits.arm_flag == 1) { L_OUT = 1; } }
//    # endif    
//# endif // Блокировка если на данный момент в охране            
            Nop();Nop();Nop();
        }
    }
    
     

}
void delayd_wired_bloking_during_autorun ( int start ) {
static unsigned char start_flag = 0;


Nop();Nop();Nop();
    if ( start == 1 ) start_flag = 1;
    if ( start_flag == 0 ) return;
    
    if ( ignition == 0 ) {
        start_flag = 0;
        # if defined (WIRED_ENJINE_BLOKING)
            # if defined (MCP23S08)

            # else
                if (OUTFUNCbits.pin15 == 3) { 
                    if (OUTbits.arm_flag == 1) { L_OUT = 1; } 
                }
            # endif    
        # endif  
    }

//    if (start == 1) counter = 100;

//    if (counter > 0) counter --;
//    else return;
//Nop();Nop();Nop();
//    if (counter == 1) {
//        # if defined (WIRED_ENJINE_BLOKING)
//            # if defined (MCP23S08)
//
//            # else
//                if (OUTFUNCbits.pin15 == 3) { 
//                    if (OUTbits.arm_flag == 1 && ignition == 0) { L_OUT = 1; } 
//                }
//            # endif    
//        # endif // Блокировка успешного запуска если выключилось зажигание  
//    }
}

void dd_intrusion_off_timer_function (void) {
    
//    if (start_engine_success_flag == 1) { // 
//        if (ignition == 0) {
//            start_engine_success_flag = 0;
//            dd_intrusion_off_timer = 50; // 5 секундный таймер игнорирования вторжения по дверям
//        }
//        
//    }
    
    if (dd_intrusion_off_timer > 0) dd_intrusion_off_timer --;
    
} 

int  to_sleep_mode (void) {
    
const unsigned char set_standby_sentence[] = "$PMTK161,0*2D\r\n";    
unsigned char z, check_summ, check_summ1, check_summ2, periodic_messege_flag, periodic_power_off_messege_flag, fisical_boot_flag;
volatile unsigned int temperatura_counter = 0;

    if (ignition == 0) sleep_counter ++;
    else {
        fake_serv_flag = 0;
        sleep_counter = 0;
    }

    if ( sleep_counter == (sleep_timer - 1250) && OUTbits.arm_flag == 0 && arm_enable == 1 ) { //16750
        if ( OUTbits.serv_flag == 0 ) {
            fake_serv_flag = 1;
            generate_content_of_message ( 72, 1 );
        }
    }

    if ( sleep_counter == (sleep_timer - 200) && fake_serv_flag != 0 ) { //17800
//        if ( fake_serv_flag == 1 ) {
            fire_rel_transaction_flag = 1;
            RELTRANSFLGSbits.rel_serv_fake = 1;
            fake_serv_flag = 2;
//        }
    }

    if ( sleep_counter < sleep_timer ) return 0; // 3000
    Nop();Nop();Nop();

    
    nav_trigger = 0;
//    GPS_PW = GPS_OFF;
    
    GNSSLED_green = 0;
//    GNSSLED_red = 0;
    GSM_LED = 0;
/*    
    modem_on_off (MODEM_OFF);
    while (MODEMTASCKSbits.onoff == 1);
    MODEMVBATT_out = 1;
*/
//   start_UART1_transmission ( WAITON, (unsigned int)load_UART1_Tx_buf ("at+qsclk=1\r\0") ); 
//   while (Rx1_DataAvailable == 0);
//   Rx1_DataAvailable = 0;
//   while (Rx1_DataAvailable == 0);
// Перевод GPS модуля в спящий режим
    check_summ = 0; check_summ1 = 0; check_summ2 = 0;
    for (z = 1; z <= 9; z ++) {
        check_summ = check_summ ^ set_standby_sentence[z];
    }
    Nop();Nop();Nop();
    check_summ1 = (check_summ & 0xF0) >> 4;
    check_summ2 = check_summ & 0x0F;
    memmove ( UART2_Tx_buf, set_standby_sentence, 16 );
    if (check_summ1 >= 0 && check_summ1 <= 9) {UART2_Tx_buf[11] = check_summ1 + 0x30;}
    else {UART2_Tx_buf[11] = check_summ1 + 0x37;}
    if (check_summ2 >= 0 && check_summ2 <= 9) {UART2_Tx_buf[12] = check_summ2 + 0x30;}
    else {UART2_Tx_buf[12] = check_summ2 + 0x37;}
    Nop();Nop();Nop();
    start_UART2_transmission (1);
    __delay_ms (250);
    __delay_ms (250);
    __delay_ms (250);
    __delay_ms (250);
    __delay_ms (250);
    __delay_ms (250);
    __delay_ms (250);
    __delay_ms (250);
   
    
    Nop();Nop();Nop();
//battery_charge_type 
    
    if ( battery_charge_type == 0 ) CHARGE_ONOFF = 0;    
    Rx2_DataAvailable = 0;
    restart_navdata_receiving();

//    PMD1bits.U1MD   = 1;
//    PMD1bits.U2MD   = 1;
//    PMD1bits.SPI2MD = 1;    
    Nop();Nop();Nop();
    
    sleep_counter = 0;
    
    switch_off_periferals_during_sleep ();
    
    load_UART4_Tx_buf ("Sleep mode entered");
    start_UART4_transmission(WAITOFF);    
    
    TILTFLAGSbits.TILTFLAGS = 0;
//CAN1_STB = 1;
//CAN2_STB = 1;
    while (1) {    
        asm("PWRSAV #0x1");         // Put the device into sleep mode
        if (periodic_flag == 1) periodic_break_flag = 1;
        if (periodic_10ms_flag == 1) periodic_10ms_break_flag = 1;
        
        if (periodic_flag == 1 && periodic_break_flag == 1) {
//            AUTO_START = !AUTO_START;
            asm("clrwdt"); 
//            periodic_flag = 0;
            voltage_fall_detection ();
            check_enjine_running ();
            doors_status_changed = 0;
            check_fisical_doors ();
            if ( doors_status_changed == 1 ) break;
            fisical_ignition_detection ();
            fisical_boot_flag = fisical_boot_detection ();
            if ( fisical_boot_flag ) break;
            periodic_messege_flag = generate_message_during_ignition_off ();
            short_period_of_reports_timer ();
            periodic_power_off_messege_flag = generate_message_during_power_off ();
            if (periodic_messege_flag == 1 || periodic_power_off_messege_flag == 1) { 
//                sleep_counter = 15000;
                sleep_counter = sleep_timer - 3000;
                break; 
            }
            if ( generate_canbus_sleep_message ( 0 ) ) { 
//                sleep_counter = 15000;
                sleep_counter = sleep_timer - 3000;
                break; 
            }            
            if (generate_car_battery_low_message ()) { 
//                sleep_counter = 15000;
                sleep_counter = sleep_timer - 3000;
                break; 
            }
            if ( PERIFSLEEPSETbits.rf == 0 ) {
                temperaturaC_in_sleep = Si4461_temperature_mesuare ( 1 );
            }
            charge_battery_task ( 1 );
            blinkrptr_task ();
        }
        if (periodic_10ms_flag == 1 && periodic_10ms_break_flag == 1) {
//            OUT2 = ! OUT2;
                if ( PERIFSLEEPSETbits.rf == 1 )  {
                
                if ( temperatura_counter < 6000 ) temperatura_counter ++;
                else {
                    temperatura_counter = 0;
                    RF_turn_on_start = 0;
                }
                if ( temperatura_counter == 5930 ) {
                    Nop();Nop();Nop();
                    RF_turn_on_start = 1;
                }
                Si4461_turn_ON ();
                if ( temperatura_counter == 5950 ) {
                    temperaturaC_in_sleep = Si4461_temperature_mesuare_during_sleep ( 1 );
                    Nop();Nop();Nop();
                }
            }            
        }
        lock_status_changed = 0;
        doors_status_changed = 0;
        check_can_data ();
        if ( lock_status_changed == 1 ) break;
        if ( doors_status_changed == 1 ) break;
#if defined (LIN)
        if (Rx3_DataAvailable == 1) {
            lock_status_changed = 0;
            apply_LIN_data ();
            if ( lock_status_changed == 1 ) break;
        }
#endif
        if ( lock_status_changed == 1 ) break;
        if ( ignition == 1 ) break;
        if ( ARMFLAGSbits.intr_event_trigg == 1 ) break;
        if ( check_power_event () ) break;
        if (RF_DataAvailable == 1) {
            if ( PERIFSLEEPSETbits.rf == 0 ) break;
        }
/*        
        if (PERIFSLEEPSETbits.modem == 0) { 
            if (Rx1_DataAvailable == 1) {
                break;
            }
        }
*/        
        if (PERIFSLEEPSETbits.modem == 0) { 
            if (Rx1_DataAvailable == 1) {
                UART1_buf_to_UART1_copy_buf (U1_num_W);
                sms_during_sleep_flag = check_UART1_command_during_sleep();
                transmit_GSMdata_to_debug ();
                            
                if ( sms_during_sleep_flag == 1 ) { // Анализ данных от модема, полученных в режиме сна
                    Nop();Nop();Nop();
                    break;
                }
                if ( sms_during_sleep_flag == 2 ) { // Анализ данных от модема, полученных в режиме сна
                    Nop();Nop();Nop();
                    if ( sim_status_in_sleep == 2 ) {
                        Nop();Nop();Nop();
                        if (MODEMRESINSLEEPbits.start == 0) {
                            MODEMRESINSLPMSGTASCKbits.start = 1;
                            MODEMRESINSLPMSGTASCKbits.counter ++;
                            MODEM_SLEEP = 0;
                            
                            modem_on_off_finished_flag = 0;
                            modem_on_off (MODEM_RESTART);
                            MODEMRESINSLEEPbits.start = 1;
                        }
                    }
                }
                if ( sms_during_sleep_flag == 3 ) { // Звонок во сне
                    Nop();Nop();Nop();
                    status_mesage_flag = 2;
                    break;
                }                
                Rx1_DataAvailable = 0;
            }
            
            if ( periodic_flag == 1 && periodic_break_flag == 1 ) {
                if ( MODEMRESINSLEEPbits.start == 1 ) {

                        if ( MODEMRESINSLEEPbits.counter < 700 ) MODEMRESINSLEEPbits.counter ++;
                        else {
                            MODEMRESINSLPMSGTASCKbits.counter ++;
                            MODEM_SLEEP = 0;
                            
                            MODEMRESINSLEEPbits.MODEMRESINSLEEP = 0;
                            modem_on_off_finished_flag = 0;
                            modem_on_off (MODEM_RESTART);
                            MODEMRESINSLEEPbits.start = 1;
                        }
                    
                    if ( modem_on_off_finished_flag == 1 ) {
                        if (sim_status_in_sleep == 1) { // Модем развесился, сим работает
                            modem_on_off_finished_flag = 0;
//                            sim_status_in_sleep = 0;
                            MODEMRESINSLEEPbits.MODEMRESINSLEEP = 0;
                            if (PERIFSLEEPSETbits.modem_sleep_off == 0) {
                                start_UART1_transmission ( WAITON, (unsigned int)load_UART1_Tx_buf ("at+qsclk=1\r\0") ); 
                                while (Rx1_DataAvailable == 0);
                                Rx1_DataAvailable = 0;
                                MODEM_SLEEP = 1;
                            }
                            Nop();Nop();Nop();                            
                            
                        } 
                    }

                }
            }
        }

        if (periodic_10ms_flag == 1 && periodic_10ms_break_flag == 1) { // Чтение ускорений Gx, Gy, Gz
            periodic_10ms_flag = 0;
            periodic_10ms_break_flag = 0;
        }
        if (acc_data_redy_flag == 1) {
            acc_data_redy_flag = 0;            
            
            Read_G_all ();
            Filt_crash ( Gx, Gy, Gz );
            Gx = Gxif2; Gy = Gyif2; Gz = Gzif2;
            if (AUTOCALSTATUSbits.staticcal == 1) {
                recalculation_to_XiYiZi ((float) Gx, (float) Gy, (float) Gz); 
                if (AUTOCALSTATUSbits.finished == 1 && CRASHDATbits.queue != 0) { //!!!!!не забыть вернуть!
                    plane_recalculation ( Gxi, Gyi ); 
                    crash_detection ( Gxp, Gyp, Gzi );
                    if (CRASHTASKbits.crash_trigger == 1) break;
                }
                if (TILTDATbits.queue != 0) tilt_detection ( 0 );
            }
    //        tilt_message_generator ();
            if (TILTFLAGSbits.tilt_on_event == 1) break;
            
            voltage_mesuare ();
# if defined (MCP23S08)            
            INPUTbits.INPUT = (unsigned char)read_MCP23S08 ( 0x09 );
# endif            
        }
        if (periodic_flag == 1 && periodic_break_flag == 1) {periodic_flag = 0; periodic_break_flag = 0;}
    }

//CAN1_STB = 0;
//CAN2_STB = 0;
/*    sleep_counter = 0; */
    MODEM_SLEEP = 0; 
    
    fake_serv_flag = 0;
    
    if ( PERIFSLEEPSETbits.rf == 1 ) SDN_SI4461 = 1;// Если
    Nop();Nop();Nop();
    
    if ( battery_charge_type == 0 ) CHARGE_ONOFF = 1;
    switch_on_periferals_after_sleep (); 
    
    UART2_Tx_buf[0] = 0x0A; UART2_Tx_buf[1] = 0;
    Nop();Nop();Nop();
    start_UART2_transmission (1);
    __delay_ms (20);
    __delay_ms (250);
    __delay_ms (250);
    __delay_ms (250);
    __delay_ms (250);
    __delay_ms (250);
    __delay_ms (250);
    __delay_ms (250);
    __delay_ms (250);
    
    while ( 1 ) {
        while (Rx2_DataAvailable == 0);
        Rx2_DataAvailable = 0;
        if (get_navigation_data ()) break;
    }
    Nop();Nop();Nop();
 
    temperatura_correct_timer = 600 * temperatura_correct_timer_setting;
    
   
    
}
void switch_off_periferals_during_sleep (void) {

// Снижение тактовой частоты
//    PERIFSLEEPSETbits.low_freq = 0;
    if (PERIFSLEEPSETbits.low_freq == 1) {
        Fp1 = 10; Fp2 = 10;
        pll_switch_to_10MHz ();
        re_init_UART1_to_10MHz ();
        re_init_UART4_to_10MHz ();
# if defined (LIN)        
        re_init_UART3_to_10MHz ();
# endif        
        re_init_timer6_to_10MHz ();
        re_init_timer3_to_10MHz ();
        re_init_timer4_to_10MHz ();
        re_init_timer8_to_10MHz ();       
        can1start();
        can2start();     
        init_CAN_filters ();
        
    }    
    
// выкл модема 
    if ( PERIFSLEEPSETbits.modem_sleep_off == 0 ) {
        if (PERIFSLEEPSETbits.modem == 1) {
            modem_on_off (MODEM_OFF);
        } 
        else {
    //        start_UART1_transmission ( WAITON, (unsigned int)load_UART1_Tx_buf ("AT+QICLOSE\r\0") ); 
    //        while (Rx1_DataAvailable == 0);
            Rx1_DataAvailable = 0;
            Nop();Nop();Nop();
            start_UART1_transmission ( WAITON, (unsigned int)load_UART1_Tx_buf ("at+qsclk=1\r\0") ); 
            while (Rx1_DataAvailable == 0);
            Rx1_DataAvailable = 0;
            MODEM_SLEEP = 1;
            Nop();Nop();Nop();

            Nop();Nop();Nop();
        }
    }
//выкл радиоканала    
    if (PERIFSLEEPSETbits.rf == 1) {
        SDN_SI4461 = 1;
    } 
//выкл дебажного уарта
//    PMD4bits.U4MD = 1;
//выкл CAN    
    if (PERIFSLEEPSETbits.can1 == 1) {
        CAN1_STB = 1;
    } 
    if (PERIFSLEEPSETbits.can2 == 1) {
        CAN2_STB = 1;
    }

    
}
void switch_on_periferals_after_sleep (void) {

// Восстановление тактовой частоты
    if (PERIFSLEEPSETbits.low_freq == 1) {
        Fp1 = 20; Fp2 = 20;
        pll_switch_to_10MHz ();
        re_init_UART1_to_10MHz ();
        re_init_timer6_to_10MHz ();
        re_init_timer3_to_10MHz ();
        re_init_timer4_to_10MHz ();
        re_init_timer8_to_10MHz ();
        can1start();
        can2start();     
        init_CAN_filters ();
        
    }    
    if ( PERIFSLEEPSETbits.modem_sleep_off == 0 ) {
        if (PERIFSLEEPSETbits.modem == 0) {
            if (Rx1_DataAvailable == 1) {
                if (sms_during_sleep_flag == 0) {
                    close_udp_tcp_connection ( 1 ); 
                } else {
                    GPRSCHECKbits.start = 1;
                }

            } else {
                modem_on_off (MODEM_RESTART);
            } 
        } else {
            modem_on_off (MODEM_RESTART);    
        }
    }
    if (PERIFSLEEPSETbits.rf == 1) {
//        SDN_SI4461 = 0;
        RFRESETbits.start = 1;
    }

//вкл дебажного уарта
    PMD4bits.U4MD = 0;    
    init_uart4 ();
# if defined (LIN)    
    init_uart3 ();
# endif    
//вкл CAN    
    if (PERIFSLEEPSETbits.can1 == 1) {
        CAN1_STB = 0;
    } 
    if (PERIFSLEEPSETbits.can2 == 1) {
        CAN2_STB = 0;
    }


//    configure_RP_RPI();
}
void re_init_UART1_to_10MHz (void) {
    
    if (Fp1 == 10) {
        U1BRG =  21;
    } else {
        U1BRG =  42;
    }
    
}

void re_init_UART4_to_10MHz (void) {
    
    if (Fp1 == 10) {
        U4BRG =  21;
    } else {
        U4BRG =  42;
    }
    
}

# if defined (LIN) 
void re_init_UART3_to_10MHz (void) {
    
    if (Fp1 == 10) {
        U3BRG =  64;
    } else {
        U3BRG =  129;
    }
    
}
void init_uart3 (void) {
	U3BRG =  129; // 9600 
	U3MODE = 0;
	U3MODEbits.BRGH = 0;
	U3MODEbits.UARTEN = 1;
//    U3MODEbits.WAKE = 1;
//    U3MODEbits.ABAUD = 1;
	asm ("nop");
	asm ("nop");
	U3STA = 0;
	U3STAbits.UTXINV = 0;
	U3STAbits.UTXEN = 1;
	U3STAbits.URXISEL1 = 0;
	U3STAbits.URXISEL0 = 0;
//	IPC20bits.U3RXIP2 = 0; //Set Uart RX Interrupt Priority = 3
//	IPC20bits.U3RXIP1 = 1;
//	IPC20bits.U3RXIP0 = 1;
        IPC20bits.U3RXIP = 4; //UART2 RX Interrupt Priority, mid-range
        IPC20bits.U3TXIP = 4; //UART2 TX Interrupt Priority, mid-range
        IPC20bits.U3EIP = 5; //UART2 Error Interrupt Priority set higher 
        IEC5bits.U3EIE = 1;
        IEC5bits.U3RXIE  = 1; //Enable Receive Interrupt
        U3STAbits.UTXISEL0 = 1;
        U3STAbits.UTXISEL1 = 0;
//	IPC20bits.U3TXIP2 = 0; //Set Uart RX Interrupt Priority = 3
//	IPC20bits.U3TXIP1 = 1;
//	IPC20bits.U3TXIP0 = 1;
	IEC5bits.U3TXIE  = 0; //Enable Transmit Interrupt     
}
# endif
//#if defined (WBUS)
//void switch_on_off_u3tx_output (int on_off) {
//    
//    // Unlock Registers
//    asm volatile (
//                "MOV #OSCCON, w1 \n"
//                "MOV #0x46, w2 \n"
//                "MOV #0x57, w3 \n"
//                "MOV.b w2, [w1] \n"
//                "MOV.b w3, [w1] \n"
//                "BCLR OSCCON,#6");
//          
//    //Configure Output Functions
//        if (on_off == 1)  RPOR1bits.RP67R = 27;   // Assign U3TX To Pin RP67  
//        else RPOR1bits.RP67R = 0; 
//
//          
//    // Lock Registers
//    asm volatile (
//                "MOV #OSCCON, w1 \n"
//                "MOV #0x46, w2 \n"
//                "MOV #0x57, w3 \n"
//                "MOV.b w2, [w1] \n"
//                "MOV.b w3, [w1] \n"
//                "BSET OSCCON, #6");
//    
//}
//void start_UART3_transmission ( int length ) {
//// Data transmit the data using interrupts
//    U3_Tx_length = length;
//    Tx3_DataAvailable = 0;
//    IEC5bits.U3TXIE = 1;
//    IFS5bits.U3TXIF = 1;
//}
//void webasto_wbus_task (void) { //func that manage start_stop WEBASTO by WBUS
//    
//    if ( WBSWTASKbits.start == 0 ) return; //no start command from check_setting() func 
//    #define send_pause 10 // pause between send start packet before ACK will be received (1sec)
//    #define start_attemp 3 // try to send 3 start_packet, if no answer with ACK - stop and generate error msg
//    static unsigned char send_pause_cnt = 0;
//    static unsigned char start_attemp_cnt = 0;
//    static unsigned int  send_packet_timer = 150; // timer for packet sending in different time
//    unsigned int wtime = WBSWTASKbits.counter / 600; //convert time to Minutes for wbus start packet generation
//    sleep_counter = 0; // reset sleep cnt to disable sleep while task is active
//    if ( WBSWTASKbits.stop == 1 ) {         //stop cmd from check_setting()
//        WBSWTASKbits.WBSWTASK = 0;          //reset all bits to 0
//        WEBASTOSTATUSbits.WEBASTOSTATUS = 0;//reset temp&flame to 0
//        generate_content_of_message ( 52, 1 );
//        send_wbus_stop();
//        return;
//    }    
//            
//    if ( WBSWTASKbits.counter > 0 ) WBSWTASKbits.counter --;
//       
//    //send BREAK wbus packet & start wbus packet if not ACK response received every 1s
//    if ((WBSWTASKbits.start_ack == 0) && (send_pause_cnt == 0)) {
//        start_attemp_cnt++; // increment cnt of attemps
//        if (start_attemp_cnt > start_attemp + 1) {
//            WBSWTASKbits.WBSWTASK = 0;          //reset all bits to 0
//            WEBASTOSTATUSbits.WEBASTOSTATUS = 0;//reset temp&flame to 0
//            start_attemp_cnt = 0;
//            send_packet_timer = 150;
//            send_pause_cnt = 0;
//            //generate_content_of_message ( 52, 1 );
//            //CHANGE TO ERROR OF WBUS CONNECT
//            return;
//        }
//        //send_break in uart_timeout func//
//        if (WBSWTASKbits.break_done == 0) {
//            WBSWTASKbits.break_start = 1;
//            return;
//        }
//        //send_break in uart_timeout func//
//        if ((WBSWTASKbits.break_start == 0) && (WBSWTASKbits.break_done == 1) ) {
//            if (send_pause_cnt == 0) send_wbus_start(wtime);
//            //WBSWTASKbits.break_done = 0;
//        }
//    }
//    send_pause_cnt++; //pause between send wbus_start
//    if ( send_pause_cnt > send_pause) send_pause_cnt = 0; //reset pause counter every 1secs
//    //send wake-up message every 15sec to support webasto working
//    //if ((WBSWTASKbits.counter % 150) == 0) send_wbus_wakeup();
//    send_packet_timer--;
//    if ((send_packet_timer) == 0) send_wbus_wakeup();
//    //send temp&flame request every 10sec
//    //if ((WBSWTASKbits.counter % 100) == 0) send_wbus_temp_status_request();
//    if ((send_packet_timer) == 75) send_wbus_temp_status_request();
//    if (send_packet_timer == 0) send_packet_timer = 150;
//    
//    if ( WBSWTASKbits.counter == 0 ) {
//        WBSWTASKbits.WBSWTASK = 0;           //reset all bits to 0
//        WEBASTOSTATUSbits.WEBASTOSTATUS = 0; //reset temp&flame to 0
//        generate_content_of_message ( 52, 1 );
//        send_pause_cnt = 0;
//        send_packet_timer = 150;
//        start_attemp_cnt = 0;
//        send_wbus_stop();
//        Nop();Nop();Nop();
//    }
//    
////    
    
//}
//#endif


void re_init_timer6_to_10MHz (void) {
    unsigned int tmp;
    
    IEC2bits.T6IE = 0;
        T6CONbits.TON = 0;
        if (Fp1 == 10) {
            tmp = TMR6 >> 1;
            TMR6 = tmp;
            PR6 = 10000;
        } else {
            tmp = TMR6 << 1;
//            if (tmp >= 20000) tmp = 19999;
            TMR6 = tmp;
            PR6 = 20000;            
        }
        T6CONbits.TON = 1;
	IEC2bits.T6IE = 1;
}
void re_init_timer3_to_10MHz (void) {
unsigned int tmp; 

    IEC0bits.T3IE = 1;
        T3CONbits.TON = 0;
        if (Fp1 == 10) {
            tmp = TMR3 >> 1;
            TMR3 = tmp;
            PR3 = 5000;
        } else {
            tmp = TMR3 << 1;
            TMR3 = tmp;
            PR3 = 10000;            
        }
        T3CONbits.TON = 1;
	IEC0bits.T3IE = 1;
}
void re_init_timer4_to_10MHz (void) {
unsigned int tmp;

    IEC1bits.T4IE = 0;
        T4CONbits.TON = 0;
        if (Fp1 == 10) {
            tmp = TMR4 >> 1;
            PR4 = 12500;    // 10 ms interrupts
            TMR4 = tmp;
        } else {
            tmp = TMR4 << 1;
            PR4 = 25000;    // 10 ms interrupts
            TMR4 = tmp;            
        }
        T4CONbits.TON = 1;
	IEC1bits.T4IE = 1;
}
void re_init_timer8_to_10MHz (void) {
    
    IPC12bits.T8IP = 5;
        T8CONbits.TON = 0;
        
        if (Fp1 == 10) {
            
            switch (acc_sampling_frequency) {
                case 1: // 100Hz
                    PR8 = 12500;
                    break;
                case 2: // 400Hz
                    PR8 = 3125; //6250 2.5ms
                    break;
                case 3: // 1000Hz
                    PR8 = 1250; //2500 1ms
                    break;
                default:
                    break;
            }

            
        } else {
            
            switch (acc_sampling_frequency) {
                case 1: // 100Hz
                    PR8 = 25000; //25000 10ms; 6250 2.5ms  2500 1ms
                    break;
                case 2: // 400Hz
                    PR8 = 6250; //6250 2.5ms
                    break;
                case 3: // 1000Hz
                    PR8 = 2500; //2500 1ms
                    break;
                default:
                    break;
            } 
            
        }
        
        T8CONbits.TON = 1;
    IEC3bits.T8IE = 1;    
    
}
/*
void re_init_timer5_to_10MHz (void) {
    T5CON = 0x8000;
    PR5 = 3704;
//	IEC1bits.T5IE = 1;
}
void re_init_timer7_to_10MHz (void) {
// прерывания через 12 мкс
    IPC12bits.T7IP = 6;
    T7CON = 0x0000;
    PR7 = 728;

}
*/
void init_uart4 (void) {
    U4BRG =  42; // 16 (8MHz) 115200
	U4MODE = 0;
	U4MODEbits.BRGH = 1;
	U4MODEbits.UARTEN = 1;
	asm ("nop");
	asm ("nop");
	U4STA = 0;
	U4STAbits.UTXINV = 0;
	U4STAbits.UTXEN = 1;
	U4STAbits.URXISEL1 = 0;
	U4STAbits.URXISEL0 = 0;
	IPC22bits.U4RXIP2 = 1; //Set Uart RX Interrupt Priority = 5
	IPC22bits.U4RXIP1 = 0;
	IPC22bits.U4RXIP0 = 1;
	IEC5bits.U4RXIE  = 1; //Enable Receive Interrupt
        U4STAbits.UTXISEL0 = 1;
        U4STAbits.UTXISEL1 = 0;
	IPC22bits.U4TXIP2 = 1; //Set Uart RX Interrupt Priority = 5
	IPC22bits.U4TXIP1 = 0;
	IPC22bits.U4TXIP0 = 1;
	IEC5bits.U4TXIE  = 0; //Enable Transmit Interrupt
}

int check_UART1_command_during_sleep (void) {
    
int temp;
unsigned char *ptr;

//    temp = strstr(UART_Rx_copy_buf, CMTI_SM);
//	if (temp != 0) {
//        return 1;
//    }
/**/
// Пришла СМС, запись ее номера в буфер номеров принятых СМС
# if defined (UC15)
    temp = strstr(UART_Rx_copy_buf, CMTI_ME);        
# else
    temp = strstr(UART_Rx_copy_buf, CMTI_SM);
# endif

	if (temp != 0) {
// Здесь никак не проверяется корректность цифр номеров СМС, а так же что номер цифровой (сделать?).          
            ptr = temp + 14; 
            if (*(ptr + 1) == '\r') { 
                temp = 0x3000; 
                temp = temp + *ptr; 
                write_SMS_number_to_buf ( temp ); 
            } 
            else {  
                temp = 0; 
                temp = *ptr; 
                temp = temp << 8; 
                temp = temp + *(ptr +1); write_SMS_number_to_buf ( temp ); 
            }
            Nop();Nop();Nop();
            return 1;
	}
    
//CPIN    
// Пришла СМС, запись ее номера в буфер номеров принятых СМС
    temp = strstr(UART_Rx_copy_buf, CPIN);
	if (temp != 0) {

            sim_status_in_sleep = 0;
            temp = strstr(UART_Rx_copy_buf, "NOT READY");
            if (temp != 0) {
                sim_status_in_sleep = 2;
            } else {
                temp = strstr(UART_Rx_copy_buf, "READY");
                if (temp != 0) {
                    sim_status_in_sleep = 1;
                }
            } 

            Nop();Nop();Nop();
            return 2;
	}

    temp = strstr(UART_Rx_copy_buf, RING);
	if (temp != 0) {
        return 3;
    }
    
    return 0;
}

void start_frequency_mesuare (void) {
    IEC2bits.T6IE = 0;
    frequency_ready = 0;
    frequency = 0;
    IEC2bits.T6IE = 1; 
}


int writeSPI1(int data){
	SPI1BUF = data;
	while (!SPI1STATbits.SPIRBF);
return SPI1BUF;
}	// writeSPI1()
/*
int read_AT45_status(void){
CS_SPI1 = 0;
Nop();
Nop();
Nop();
	writeSPI1(0xD7);
	writeSPI1(0x00);

CS_SPI1 = 1;
return SPI1BUF;
}	// writeSPI1()
void AT45_page_to_buf(int buf_num, int page_num){
unsigned int comand;

page_num = page_num << 2;
if (buf_num == 1) comand = 0x53;
else comand = 0x55;

CS_SPI1 = 0;
	writeSPI1(comand);//0x55
	writeSPI1(page_num >> 8);
	writeSPI1(page_num);
	writeSPI1(0);
CS_SPI1 = 1;

	__delay_us (180);
	while ((read_AT45_status() >> 7) == 0) {
		__delay_us (15);
        Nop();Nop();Nop();
	}


}	// write_AT45_buf1
int AT45_read_from_buf(int buf_num, int length, int addr){
int opcode, res;

res = 0; res4 = 0;

if (buf_num == 1) opcode = 0xD4;
else opcode = 0xD6;

	CS_SPI1 = 0;
		writeSPI1(opcode); // Команда чтения буфера 2
		writeSPI1(0x00);
		writeSPI1(addr >> 8);
		writeSPI1(addr);
		writeSPI1(0x00);

	if (length == 1) {
		res = writeSPI1(0);
	}
	if (length == 2) {
		res = writeSPI1(0);
		res = (res << 8) + writeSPI1(0);
	}
	if (length == 4) {
		res4 = writeSPI2(0);
		res4 = (res4 << 8) + writeSPI1(0);
		res4 = (res4 << 8) + writeSPI1(0);
		res4 = (res4 << 8) + writeSPI1(0);
	}

	CS_SPI1 = 1;

//if (length == 4) return res4;
return res;
}	// AT45_read_from_buf2
int AT45_page_read( int length, int page, int addr){
int res;
unsigned char byte0, byte1, byte2;
res = 0;

byte0 = addr;
byte1 = addr >> 8;
byte1 = (page << 2) + byte1;
byte2 = page >> 6;

	CS_SPI1 = 0;
		writeSPI1(0xD2); // Команда чтения из флеши
		writeSPI1(byte2);
		writeSPI1(byte1);
		writeSPI1(byte0);
		writeSPI1(0);
		writeSPI1(0);
		writeSPI1(0);
		writeSPI1(0);

	if (length == 1) {
		res = writeSPI1(0);
	}
	if (length == 2) {
		res = writeSPI1(0);
		res = (res << 8) + writeSPI1(0);
	}

	CS_SPI1 = 1;

return res;
}	// AT45_read_from_flash
*/
/*Расширитель портов*/
//int read_MCP23S17 (unsigned char addr ) {
//int temp; 
//L_OUT = 0;
//    SPI1BUF = 0x41;	while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
//	SPI1BUF = addr;	while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
//	SPI1BUF = 0x00;	while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
//L_OUT = 1;
//
//    return temp;    
//
//    
//}
//int wright_MCP23S17 (unsigned char addr, unsigned char data ) {
// 
//L_OUT = 0;
//    writeSPI1( 0x40 );
//    writeSPI1( (int) addr );
//    writeSPI1( (int) data );    
//L_OUT = 1;
//    
//}
//int init_MCP23S17 (void) {
//    
////    wright_MCP23S17 ( 0x0A, 0x20 ); // IOCON     
//    wright_MCP23S17 ( 0x14, 0x00 ); // IOLATA
//    wright_MCP23S17 ( 0x15, 0x00 ); // IOLATB    
//    wright_MCP23S17 ( 0x00, 0x00 ); // IODIRA
//    wright_MCP23S17 ( 0x01, 0x00 ); // IODIRB
//    
//}

int  ACC_spi_R_W ( int ACC_adress, int ACC_data ) {

	CS_SPI1 = 0;
  
        writeSPI1(ACC_adress);
        writeSPI1(ACC_data);

	CS_SPI1 = 1;

	asm ("nop");
return SPI1BUF;
} // //Вызывать только до момента разрешения прерываний TMR8
void init_ACC (void) {
    unsigned char buffer;
    
    buffer = 0;
    Nop();Nop();Nop();    
	buffer = ACC_spi_R_W (0x80 | 0x00 | 0x0F, 0x00); //Who am I? 0x32 => LIS331DH
    Nop();Nop();Nop();
             ACC_spi_R_W (0x00 | 0x00 | 0x20, 0x37); //write cntrl_reg1 0x27 - 50Hz, 0x2F - 100Hz, 0x37 - 400Hz, 0x3F - 1000Hz
	buffer = 0;
	buffer = ACC_spi_R_W (0x80 | 0x00 | 0x20, 0x00); //read interrupt cntrl_reg1
             ACC_spi_R_W (0x00 | 0x00 | 0x21, 0x00); //write cntrl_reg2
             ACC_spi_R_W (0x00 | 0x00 | 0x22, 0x06); //write cntrl_reg3
             ACC_spi_R_W (0x00 | 0x00 | 0x23, 0xB0); //write cntrl_reg4 0x00 - 2g, 0x90 - 4g, 0xB0 - 8g
             ACC_spi_R_W (0x00 | 0x00 | 0x24, 0x00); //write cntrl_reg5
             ACC_spi_R_W (0x00 | 0x00 | 0x30, 0x00); //write cntrl_reg5
             ACC_spi_R_W (0x00 | 0x00 | 0x34, 0x00); //write cntrl_reg5
    
}//Вызывать только до момента разрешения прерываний TMR8
void Read_G_all ( char source ) {
unsigned char Gx_L, Gx_H, Gy_L, Gy_H, Gz_L, Gz_H ;
//int Gout;
//float Gxyz_tmp, Gx_tmp, Gy_tmp, Gz_tmp;

if ( source == 0 ) {
	CS_SPI1 = 0;  
        writeSPI1(0x80 | 0x40 | 0x28);
        Gx_L = writeSPI1(0x00);
        Gx_H = writeSPI1(0x00);
        Gy_L = writeSPI1(0x00);
        Gy_H = writeSPI1(0x00);
        Gz_L = writeSPI1(0x00);
        Gz_H = writeSPI1(0x00);
	CS_SPI1 = 1;
	asm ("nop");

	Gx = Gx_H; Gx = (Gx << 8) + Gx_L;
	Gy = Gy_H; Gy = (Gy << 8) + Gy_L;
	Gz = Gz_H; Gz = (Gz << 8) + Gz_L;
} else {
    
    Gx = Gx_400; Gy = Gy_400; Gz = Gz_400;
    
}
	Gx = (Gx + 32768) >> 4; // Приведение к 12 бит
	Gy = (Gy + 32768) >> 4;
	Gz = (Gz + 32768) >> 4;

    Gx = Gx - 2047; 
	Gy = Gy - 2047;
	Gz = Gz - 2047;

    if (invertion_flag == 1) {
        Gz = -1 * Gz;
        Gy = -1 * Gy;
    }
    
//	Gx_tmp = Gx - 2048.0;
//	Gx_tmp = Gx_tmp * Gx_tmp;
//
//	Gy_tmp = Gy - 2048.0;
//	Gy_tmp = Gy_tmp * Gy_tmp;
//
//	Gz_tmp = Gz - 2048.0;
//	Gz_tmp = Gz_tmp * Gz_tmp;
//
//	Gxyz_tmp = Gx_tmp + Gy_tmp + Gz_tmp;
//	Gxyz_tmp = sqrt (Gxyz_tmp);
//
//	Gxyz = Gxyz_tmp;


}
int  Filter_behavior (int sampl_X, int sampl_Y, int sampl_Z) {
int /*i,*/ *tmp_ptr, data_flag;
static unsigned char filter_counter_b = 0, filter_counter_b1 = 0;

data_flag = 0;

			// по оси Х
			Gxf0b = 0;
			Gxi_buf0_b[0] = sampl_X;
			Gxf0b = Gxf0b + (Gxi_buf0_b[0]  + Gxi_buf0_b[32])  * Coeff_0_b[0];
			Gxf0b = Gxf0b + (Gxi_buf0_b[1]  + Gxi_buf0_b[31])  * Coeff_0_b[1];
			Gxf0b = Gxf0b + (Gxi_buf0_b[2]  + Gxi_buf0_b[30])  * Coeff_0_b[2];
			Gxf0b = Gxf0b + (Gxi_buf0_b[3]  + Gxi_buf0_b[29])  * Coeff_0_b[3];
			Gxf0b = Gxf0b + (Gxi_buf0_b[4]  + Gxi_buf0_b[28])  * Coeff_0_b[4];
			Gxf0b = Gxf0b + (Gxi_buf0_b[5]  + Gxi_buf0_b[27])  * Coeff_0_b[5];
			Gxf0b = Gxf0b + (Gxi_buf0_b[6]  + Gxi_buf0_b[26])  * Coeff_0_b[6];
			Gxf0b = Gxf0b + (Gxi_buf0_b[7]  + Gxi_buf0_b[25])  * Coeff_0_b[7];
			Gxf0b = Gxf0b + (Gxi_buf0_b[8]  + Gxi_buf0_b[24])  * Coeff_0_b[8];
			Gxf0b = Gxf0b + (Gxi_buf0_b[9]  + Gxi_buf0_b[23])  * Coeff_0_b[9];
			Gxf0b = Gxf0b + (Gxi_buf0_b[10] + Gxi_buf0_b[22])  * Coeff_0_b[10];
			Gxf0b = Gxf0b + (Gxi_buf0_b[11] + Gxi_buf0_b[21])  * Coeff_0_b[11];
			Gxf0b = Gxf0b + (Gxi_buf0_b[12] + Gxi_buf0_b[20])  * Coeff_0_b[12];
			Gxf0b = Gxf0b + (Gxi_buf0_b[13] + Gxi_buf0_b[19])  * Coeff_0_b[13];
			Gxf0b = Gxf0b + (Gxi_buf0_b[14] + Gxi_buf0_b[18])  * Coeff_0_b[14];
			Gxf0b = Gxf0b + (Gxi_buf0_b[15] + Gxi_buf0_b[17])  * Coeff_0_b[15];
			Gxf0b = Gxf0b +  Gxi_buf0_b[16]                    * Coeff_0_b[16];

			tmp_ptr = Gxi_buf0_b;
			tmp_ptr ++;
			memmove (tmp_ptr, Gxi_buf0_b, 64);
			Gxif0b = (int) Gxf0b;
	
			// по оси Y
			Gyf0b = 0;
			Gyi_buf0_b[0] = sampl_Y;
			Gyf0b = Gyf0b + (Gyi_buf0_b[0]  + Gyi_buf0_b[32])  * Coeff_0_b[0];
			Gyf0b = Gyf0b + (Gyi_buf0_b[1]  + Gyi_buf0_b[31])  * Coeff_0_b[1];
			Gyf0b = Gyf0b + (Gyi_buf0_b[2]  + Gyi_buf0_b[30])  * Coeff_0_b[2];
			Gyf0b = Gyf0b + (Gyi_buf0_b[3]  + Gyi_buf0_b[29])  * Coeff_0_b[3];
			Gyf0b = Gyf0b + (Gyi_buf0_b[4]  + Gyi_buf0_b[28])  * Coeff_0_b[4];
			Gyf0b = Gyf0b + (Gyi_buf0_b[5]  + Gyi_buf0_b[27])  * Coeff_0_b[5];
			Gyf0b = Gyf0b + (Gyi_buf0_b[6]  + Gyi_buf0_b[26])  * Coeff_0_b[6];
			Gyf0b = Gyf0b + (Gyi_buf0_b[7]  + Gyi_buf0_b[25])  * Coeff_0_b[7];
			Gyf0b = Gyf0b + (Gyi_buf0_b[8]  + Gyi_buf0_b[24])  * Coeff_0_b[8];
			Gyf0b = Gyf0b + (Gyi_buf0_b[9]  + Gyi_buf0_b[23])  * Coeff_0_b[9];
			Gyf0b = Gyf0b + (Gyi_buf0_b[10] + Gyi_buf0_b[22])  * Coeff_0_b[10];
			Gyf0b = Gyf0b + (Gyi_buf0_b[11] + Gyi_buf0_b[21])  * Coeff_0_b[11];
			Gyf0b = Gyf0b + (Gyi_buf0_b[12] + Gyi_buf0_b[20])  * Coeff_0_b[12];
			Gyf0b = Gyf0b + (Gyi_buf0_b[13] + Gyi_buf0_b[19])  * Coeff_0_b[13];
			Gyf0b = Gyf0b + (Gyi_buf0_b[14] + Gyi_buf0_b[18])  * Coeff_0_b[14];
			Gyf0b = Gyf0b + (Gyi_buf0_b[15] + Gyi_buf0_b[17])  * Coeff_0_b[15];
			Gyf0b = Gyf0b +  Gyi_buf0_b[16]                    * Coeff_0_b[16];

			tmp_ptr = Gyi_buf0_b;
			tmp_ptr ++;
			memmove (tmp_ptr, Gyi_buf0_b, 64);
			Gyif0b = (int) Gyf0b;
	
			// по оси Z
			Gzf0b = 0;
			Gzi_buf0_b[0] = sampl_Z;
			Gzf0b = Gzf0b + (Gzi_buf0_b[0]  + Gzi_buf0_b[32])  * Coeff_0_b[0];
			Gzf0b = Gzf0b + (Gzi_buf0_b[1]  + Gzi_buf0_b[31])  * Coeff_0_b[1];
			Gzf0b = Gzf0b + (Gzi_buf0_b[2]  + Gzi_buf0_b[30])  * Coeff_0_b[2];
			Gzf0b = Gzf0b + (Gzi_buf0_b[3]  + Gzi_buf0_b[29])  * Coeff_0_b[3];
			Gzf0b = Gzf0b + (Gzi_buf0_b[4]  + Gzi_buf0_b[28])  * Coeff_0_b[4];
			Gzf0b = Gzf0b + (Gzi_buf0_b[5]  + Gzi_buf0_b[27])  * Coeff_0_b[5];
			Gzf0b = Gzf0b + (Gzi_buf0_b[6]  + Gzi_buf0_b[26])  * Coeff_0_b[6];
			Gzf0b = Gzf0b + (Gzi_buf0_b[7]  + Gzi_buf0_b[25])  * Coeff_0_b[7];
			Gzf0b = Gzf0b + (Gzi_buf0_b[8]  + Gzi_buf0_b[24])  * Coeff_0_b[8];
			Gzf0b = Gzf0b + (Gzi_buf0_b[9]  + Gzi_buf0_b[23])  * Coeff_0_b[9];
			Gzf0b = Gzf0b + (Gzi_buf0_b[10] + Gzi_buf0_b[22])  * Coeff_0_b[10];
			Gzf0b = Gzf0b + (Gzi_buf0_b[11] + Gzi_buf0_b[21])  * Coeff_0_b[11];
			Gzf0b = Gzf0b + (Gzi_buf0_b[12] + Gzi_buf0_b[20])  * Coeff_0_b[12];
			Gzf0b = Gzf0b + (Gzi_buf0_b[13] + Gzi_buf0_b[19])  * Coeff_0_b[13];
			Gzf0b = Gzf0b + (Gzi_buf0_b[14] + Gzi_buf0_b[18])  * Coeff_0_b[14];
			Gzf0b = Gzf0b + (Gzi_buf0_b[15] + Gzi_buf0_b[17])  * Coeff_0_b[15];
			Gzf0b = Gzf0b +  Gzi_buf0_b[16]                    * Coeff_0_b[16];

			tmp_ptr = Gzi_buf0_b;
			tmp_ptr ++;
			memmove (tmp_ptr, Gzi_buf0_b, 64);
			Gzif0b = (int) Gzf0b;

		filter_counter_b++;
		if (filter_counter_b == 2) {
		filter_counter_b = 0;
/*		data_flag = 1; // Готовы данные от фильтра с полосой 5.7 Гц по уровню -45Дб, 10 отсчетов в секунду */

					// по оси Х
					Gxf1b = 0;
					Gxi_buf1_b[0] = Gxif0b;
					Gxf1b = Gxf1b + (Gxi_buf1_b[0]  + Gxi_buf1_b[32])  * Coeff_1_b[0];
					Gxf1b = Gxf1b + (Gxi_buf1_b[1]  + Gxi_buf1_b[31])  * Coeff_1_b[1];
					Gxf1b = Gxf1b + (Gxi_buf1_b[2]  + Gxi_buf1_b[30])  * Coeff_1_b[2];
					Gxf1b = Gxf1b + (Gxi_buf1_b[3]  + Gxi_buf1_b[29])  * Coeff_1_b[3];
					Gxf1b = Gxf1b + (Gxi_buf1_b[4]  + Gxi_buf1_b[28])  * Coeff_1_b[4];
					Gxf1b = Gxf1b + (Gxi_buf1_b[5]  + Gxi_buf1_b[27])  * Coeff_1_b[5];
					Gxf1b = Gxf1b + (Gxi_buf1_b[6]  + Gxi_buf1_b[26])  * Coeff_1_b[6];
					Gxf1b = Gxf1b + (Gxi_buf1_b[7]  + Gxi_buf1_b[25])  * Coeff_1_b[7];
					Gxf1b = Gxf1b + (Gxi_buf1_b[8]  + Gxi_buf1_b[24])  * Coeff_1_b[8];
					Gxf1b = Gxf1b + (Gxi_buf1_b[9]  + Gxi_buf1_b[23])  * Coeff_1_b[9];
					Gxf1b = Gxf1b + (Gxi_buf1_b[10] + Gxi_buf1_b[22])  * Coeff_1_b[10];
					Gxf1b = Gxf1b + (Gxi_buf1_b[11] + Gxi_buf1_b[21])  * Coeff_1_b[11];
					Gxf1b = Gxf1b + (Gxi_buf1_b[12] + Gxi_buf1_b[20])  * Coeff_1_b[12];
					Gxf1b = Gxf1b + (Gxi_buf1_b[13] + Gxi_buf1_b[19])  * Coeff_1_b[13];
					Gxf1b = Gxf1b + (Gxi_buf1_b[14] + Gxi_buf1_b[18])  * Coeff_1_b[14];
					Gxf1b = Gxf1b + (Gxi_buf1_b[15] + Gxi_buf1_b[17])  * Coeff_1_b[15];
					Gxf1b = Gxf1b +  Gxi_buf1_b[16]                    * Coeff_1_b[16];
		
					tmp_ptr = Gxi_buf1_b;
					tmp_ptr ++;
					memmove (tmp_ptr, Gxi_buf1_b, 64);
					Gxif1b = (int) Gxf1b;
			
					// по оси Y
					Gyf1b = 0;
					Gyi_buf1_b[0] = Gyif0b;
					Gyf1b = Gyf1b + (Gyi_buf1_b[0]  + Gyi_buf1_b[32])  * Coeff_1_b[0];
					Gyf1b = Gyf1b + (Gyi_buf1_b[1]  + Gyi_buf1_b[31])  * Coeff_1_b[1];
					Gyf1b = Gyf1b + (Gyi_buf1_b[2]  + Gyi_buf1_b[30])  * Coeff_1_b[2];
					Gyf1b = Gyf1b + (Gyi_buf1_b[3]  + Gyi_buf1_b[29])  * Coeff_1_b[3];
					Gyf1b = Gyf1b + (Gyi_buf1_b[4]  + Gyi_buf1_b[28])  * Coeff_1_b[4];
					Gyf1b = Gyf1b + (Gyi_buf1_b[5]  + Gyi_buf1_b[27])  * Coeff_1_b[5];
					Gyf1b = Gyf1b + (Gyi_buf1_b[6]  + Gyi_buf1_b[26])  * Coeff_1_b[6];
					Gyf1b = Gyf1b + (Gyi_buf1_b[7]  + Gyi_buf1_b[25])  * Coeff_1_b[7];
					Gyf1b = Gyf1b + (Gyi_buf1_b[8]  + Gyi_buf1_b[24])  * Coeff_1_b[8];
					Gyf1b = Gyf1b + (Gyi_buf1_b[9]  + Gyi_buf1_b[23])  * Coeff_1_b[9];
					Gyf1b = Gyf1b + (Gyi_buf1_b[10] + Gyi_buf1_b[22])  * Coeff_1_b[10];
					Gyf1b = Gyf1b + (Gyi_buf1_b[11] + Gyi_buf1_b[21])  * Coeff_1_b[11];
					Gyf1b = Gyf1b + (Gyi_buf1_b[12] + Gyi_buf1_b[20])  * Coeff_1_b[12];
					Gyf1b = Gyf1b + (Gyi_buf1_b[13] + Gyi_buf1_b[19])  * Coeff_1_b[13];
					Gyf1b = Gyf1b + (Gyi_buf1_b[14] + Gyi_buf1_b[18])  * Coeff_1_b[14];
					Gyf1b = Gyf1b + (Gyi_buf1_b[15] + Gyi_buf1_b[17])  * Coeff_1_b[15];
					Gyf1b = Gyf1b +  Gyi_buf1_b[16]                    * Coeff_1_b[16];
		
					tmp_ptr = Gyi_buf1_b;
					tmp_ptr ++;
					memmove (tmp_ptr, Gyi_buf1_b, 64);
					Gyif1b = (int) Gyf1b;
			
					// по оси Z
					Gzf1b = 0;
					Gzi_buf1_b[0] = Gzif0b;
					Gzf1b = Gzf1b + (Gzi_buf1_b[0]  + Gzi_buf1_b[32])  * Coeff_1_b[0];
					Gzf1b = Gzf1b + (Gzi_buf1_b[1]  + Gzi_buf1_b[31])  * Coeff_1_b[1];
					Gzf1b = Gzf1b + (Gzi_buf1_b[2]  + Gzi_buf1_b[30])  * Coeff_1_b[2];
					Gzf1b = Gzf1b + (Gzi_buf1_b[3]  + Gzi_buf1_b[29])  * Coeff_1_b[3];
					Gzf1b = Gzf1b + (Gzi_buf1_b[4]  + Gzi_buf1_b[28])  * Coeff_1_b[4];
					Gzf1b = Gzf1b + (Gzi_buf1_b[5]  + Gzi_buf1_b[27])  * Coeff_1_b[5];
					Gzf1b = Gzf1b + (Gzi_buf1_b[6]  + Gzi_buf1_b[26])  * Coeff_1_b[6];
					Gzf1b = Gzf1b + (Gzi_buf1_b[7]  + Gzi_buf1_b[25])  * Coeff_1_b[7];
					Gzf1b = Gzf1b + (Gzi_buf1_b[8]  + Gzi_buf1_b[24])  * Coeff_1_b[8];
					Gzf1b = Gzf1b + (Gzi_buf1_b[9]  + Gzi_buf1_b[23])  * Coeff_1_b[9];
					Gzf1b = Gzf1b + (Gzi_buf1_b[10] + Gzi_buf1_b[22])  * Coeff_1_b[10];
					Gzf1b = Gzf1b + (Gzi_buf1_b[11] + Gzi_buf1_b[21])  * Coeff_1_b[11];
					Gzf1b = Gzf1b + (Gzi_buf1_b[12] + Gzi_buf1_b[20])  * Coeff_1_b[12];
					Gzf1b = Gzf1b + (Gzi_buf1_b[13] + Gzi_buf1_b[19])  * Coeff_1_b[13];
					Gzf1b = Gzf1b + (Gzi_buf1_b[14] + Gzi_buf1_b[18])  * Coeff_1_b[14];
					Gzf1b = Gzf1b + (Gzi_buf1_b[15] + Gzi_buf1_b[17])  * Coeff_1_b[15];
					Gzf1b = Gzf1b +  Gzi_buf1_b[16]                    * Coeff_1_b[16];
		
					tmp_ptr = Gzi_buf1_b;
					tmp_ptr ++;
					memmove (tmp_ptr, Gzi_buf1_b, 64);
					Gzif1b = (int) Gzf1b;

						filter_counter_b1++;
						if (filter_counter_b1 == 5) {
                            filter_counter_b1 = 0;
                            data_flag = 1; // Готовы данные от фильтра с полосой 2 Гц 5 отсчетов в секунду
//                            GSM_LED = !GSM_LED;
						}
		
		}

return data_flag;
}
/*
int  Filt (int sampl_X, int sampl_Y) {
int i, *tmp_ptr, data_flag;
static char filter_counter2 = 0;
data_flag = 0;

			// Фильтрация 10 Гц по оси Х
			Gxf2 = 0;
			Gxi_buf2[0] = sampl_X;
			Gxf2 = Gxf2 + (Gxi_buf2[0]  + Gxi_buf2[24]) * Coeff_2[0];
			Gxf2 = Gxf2 + (Gxi_buf2[1]  + Gxi_buf2[23]) * Coeff_2[1];
			Gxf2 = Gxf2 + (Gxi_buf2[2]  + Gxi_buf2[22]) * Coeff_2[2];
			Gxf2 = Gxf2 + (Gxi_buf2[3]  + Gxi_buf2[21]) * Coeff_2[3];
			Gxf2 = Gxf2 + (Gxi_buf2[4]  + Gxi_buf2[20]) * Coeff_2[4];
			Gxf2 = Gxf2 + (Gxi_buf2[5]  + Gxi_buf2[19]) * Coeff_2[5];
			Gxf2 = Gxf2 + (Gxi_buf2[6]  + Gxi_buf2[18]) * Coeff_2[6];
			Gxf2 = Gxf2 + (Gxi_buf2[7]  + Gxi_buf2[17]) * Coeff_2[7];
			Gxf2 = Gxf2 + (Gxi_buf2[8]  + Gxi_buf2[16]) * Coeff_2[8];
			Gxf2 = Gxf2 + (Gxi_buf2[9]  + Gxi_buf2[15]) * Coeff_2[9];
			Gxf2 = Gxf2 + (Gxi_buf2[10] + Gxi_buf2[14]) * Coeff_2[10];
			Gxf2 = Gxf2 + (Gxi_buf2[11] + Gxi_buf2[13]) * Coeff_2[11];
			Gxf2 = Gxf2 +  Gxi_buf2[12]                 * Coeff_2[12];
			tmp_ptr = Gxi_buf2;
			tmp_ptr ++;
			memmove (tmp_ptr, Gxi_buf2, 48);
			Gxif2 = (int)Gxf2;
			// Фильтрация 10 Гц по оси Y
			Gyf2 = 0;
			Gyi_buf2[0] = sampl_Y;
			Gyf2 = Gyf2 + (Gyi_buf2[0]  + Gyi_buf2[24]) * Coeff_2[0];
			Gyf2 = Gyf2 + (Gyi_buf2[1]  + Gyi_buf2[23]) * Coeff_2[1];
			Gyf2 = Gyf2 + (Gyi_buf2[2]  + Gyi_buf2[22]) * Coeff_2[2];
			Gyf2 = Gyf2 + (Gyi_buf2[3]  + Gyi_buf2[21]) * Coeff_2[3];
			Gyf2 = Gyf2 + (Gyi_buf2[4]  + Gyi_buf2[20]) * Coeff_2[4];
			Gyf2 = Gyf2 + (Gyi_buf2[5]  + Gyi_buf2[19]) * Coeff_2[5];
			Gyf2 = Gyf2 + (Gyi_buf2[6]  + Gyi_buf2[18]) * Coeff_2[6];
			Gyf2 = Gyf2 + (Gyi_buf2[7]  + Gyi_buf2[17]) * Coeff_2[7];
			Gyf2 = Gyf2 + (Gyi_buf2[8]  + Gyi_buf2[16]) * Coeff_2[8];
			Gyf2 = Gyf2 + (Gyi_buf2[9]  + Gyi_buf2[15]) * Coeff_2[9];
			Gyf2 = Gyf2 + (Gyi_buf2[10] + Gyi_buf2[14]) * Coeff_2[10];
			Gyf2 = Gyf2 + (Gyi_buf2[11] + Gyi_buf2[13]) * Coeff_2[11];
			Gyf2 = Gyf2 +  Gyi_buf2[12]                 * Coeff_2[12];
			tmp_ptr = Gyi_buf2;
			tmp_ptr ++;
			memmove (tmp_ptr, Gyi_buf2, 48);
			Gyif2 = (int)Gyf2;
			// Фильтрация 10 Гц по оси Y
//			Gzf2 = 0;
//			Gzi_buf2[0] = sampl_Z;
//			Gzf2 = Gzf2 + (Gzi_buf2[0]  + Gzi_buf2[24]) * Coeff_2[0];
//			Gzf2 = Gzf2 + (Gzi_buf2[1]  + Gzi_buf2[23]) * Coeff_2[1];
//			Gzf2 = Gzf2 + (Gzi_buf2[2]  + Gzi_buf2[22]) * Coeff_2[2];
//			Gzf2 = Gzf2 + (Gzi_buf2[3]  + Gzi_buf2[21]) * Coeff_2[3];
//			Gzf2 = Gzf2 + (Gzi_buf2[4]  + Gzi_buf2[20]) * Coeff_2[4];
//			Gzf2 = Gzf2 + (Gzi_buf2[5]  + Gzi_buf2[19]) * Coeff_2[5];
//			Gzf2 = Gzf2 + (Gzi_buf2[6]  + Gzi_buf2[18]) * Coeff_2[6];
//			Gzf2 = Gzf2 + (Gzi_buf2[7]  + Gzi_buf2[17]) * Coeff_2[7];
//			Gzf2 = Gzf2 + (Gzi_buf2[8]  + Gzi_buf2[16]) * Coeff_2[8];
//			Gzf2 = Gzf2 + (Gzi_buf2[9]  + Gzi_buf2[15]) * Coeff_2[9];
//			Gzf2 = Gzf2 + (Gzi_buf2[10] + Gzi_buf2[14]) * Coeff_2[10];
//			Gzf2 = Gzf2 + (Gzi_buf2[11] + Gzi_buf2[13]) * Coeff_2[11];
//			Gzf2 = Gzf2 +  Gzi_buf2[12]                 * Coeff_2[12];
//			tmp_ptr = Gzi_buf2;
//			tmp_ptr ++;
//			memmove (tmp_ptr, Gzi_buf2, 48);
//			Gzif2 = (int)Gzf2;

	filter_counter2++;
	if (filter_counter2 == 2) {
        filter_counter2 = 0;
        return 1;
    }
return 0;    
}
*/
int  Filt_crash (int sampl_X, int sampl_Y, int sampl_Z) {
int i, *tmp_ptr, data_flag;
//static char filter_counter2 = 0;
static float Coeff[9];
data_flag = 0;

if ( filt_crash_first_entrance == 0 ) {
    filt_crash_first_entrance = 1;
    if ( crash_filt_cutoff_frq == 4 ) {
        for ( i = 0; i < 9; i++ ) {
            Coeff[i] = (float)Coeff_8Hz[i];
        }
    } else {    
        if ( crash_filt_cutoff_frq == 3 ) {
            for ( i = 0; i < 9; i++ ) {
                Coeff[i] = (float)Coeff_15Hz[i];
            }
        } else {
            if ( crash_filt_cutoff_frq == 2 ) {
                for ( i = 0; i < 9; i++ ) {
                    Coeff[i] = (float)Coeff_25Hz[i];
                }            
            } else {
                for ( i = 0; i < 9; i++ ) {
                    Coeff[i] = (float)Coeff_37Hz[i];
                }            
            } 
        }
    }
//    load_coeffitients ();
}

			// Фильтрация 10 Гц по оси Х
			Gxf2 = 0;
			Gxi_buf2[0] = sampl_X;
			Gxf2 = Gxf2 + (Gxi_buf2[0]  + Gxi_buf2[16]) * Coeff[0];
			Gxf2 = Gxf2 + (Gxi_buf2[1]  + Gxi_buf2[15]) * Coeff[1];
			Gxf2 = Gxf2 + (Gxi_buf2[2]  + Gxi_buf2[14]) * Coeff[2];
			Gxf2 = Gxf2 + (Gxi_buf2[3]  + Gxi_buf2[13]) * Coeff[3];
			Gxf2 = Gxf2 + (Gxi_buf2[4]  + Gxi_buf2[12]) * Coeff[4];
			Gxf2 = Gxf2 + (Gxi_buf2[5]  + Gxi_buf2[11]) * Coeff[5];
			Gxf2 = Gxf2 + (Gxi_buf2[6]  + Gxi_buf2[10]) * Coeff[6];
			Gxf2 = Gxf2 + (Gxi_buf2[7]  + Gxi_buf2[9])  * Coeff[7];
			Gxf2 = Gxf2 +  Gxi_buf2[8]                  * Coeff[8];
			tmp_ptr = Gxi_buf2;
			tmp_ptr ++;
			memmove (tmp_ptr, Gxi_buf2, 32);
			Gxif2 = (int)Gxf2;
			// Фильтрация 10 Гц по оси Y
			Gyf2 = 0;
			Gyi_buf2[0] = sampl_Y;
			Gyf2 = Gyf2 + (Gyi_buf2[0]  + Gyi_buf2[16]) * Coeff[0];
			Gyf2 = Gyf2 + (Gyi_buf2[1]  + Gyi_buf2[15]) * Coeff[1];
			Gyf2 = Gyf2 + (Gyi_buf2[2]  + Gyi_buf2[14]) * Coeff[2];
			Gyf2 = Gyf2 + (Gyi_buf2[3]  + Gyi_buf2[13]) * Coeff[3];
			Gyf2 = Gyf2 + (Gyi_buf2[4]  + Gyi_buf2[12]) * Coeff[4];
			Gyf2 = Gyf2 + (Gyi_buf2[5]  + Gyi_buf2[11]) * Coeff[5];
			Gyf2 = Gyf2 + (Gyi_buf2[6]  + Gyi_buf2[10]) * Coeff[6];
			Gyf2 = Gyf2 + (Gyi_buf2[7]  + Gyi_buf2[9])  * Coeff[7];
			Gyf2 = Gyf2 +  Gyi_buf2[8]                  * Coeff[8];
			tmp_ptr = Gyi_buf2;
			tmp_ptr ++;
			memmove (tmp_ptr, Gyi_buf2, 32);
			Gyif2 = (int)Gyf2;
			// Фильтрация 10 Гц по оси Y
			Gzf2 = 0;
			Gzi_buf2[0] = sampl_Z;
			Gzf2 = Gzf2 + (Gzi_buf2[0]  + Gzi_buf2[16]) * Coeff[0];
			Gzf2 = Gzf2 + (Gzi_buf2[1]  + Gzi_buf2[15]) * Coeff[1];
			Gzf2 = Gzf2 + (Gzi_buf2[2]  + Gzi_buf2[14]) * Coeff[2];
			Gzf2 = Gzf2 + (Gzi_buf2[3]  + Gzi_buf2[13]) * Coeff[3];
			Gzf2 = Gzf2 + (Gzi_buf2[4]  + Gzi_buf2[12]) * Coeff[4];
			Gzf2 = Gzf2 + (Gzi_buf2[5]  + Gzi_buf2[11]) * Coeff[5];
			Gzf2 = Gzf2 + (Gzi_buf2[6]  + Gzi_buf2[10]) * Coeff[6];
			Gzf2 = Gzf2 + (Gzi_buf2[7]  + Gzi_buf2[9])  * Coeff[7];
			Gzf2 = Gzf2 +  Gzi_buf2[8]                  * Coeff[8];
			tmp_ptr = Gzi_buf2;
			tmp_ptr ++;
			memmove (tmp_ptr, Gzi_buf2, 32);
			Gzif2 = (int)Gzf2;

//	filter_counter2++;
//	if (filter_counter2 == 2) {
//        filter_counter2 = 0;
//        return 1;
//    }
//return 0;    
}
//*/
int angle_histogram3 ( int n ) {
int i, /*m,*/ min, max, /*m1, m2, m3,*/ j, angle;//, angle1, angle2, angle3;
//int i, j, min, max;
int /*imax1, Pmax1, imax2, Pmax2,*/ Pmax180, imax180;

if ( n == -1 ) return -1;

//if ( n <= 2 ) return 0; // если слишком малый интервал времени


/* Гистограмма 1 градус*/
for ( j = 0; j < n; j++ ) {
angle = gamma2_diff [j];
if (angle == 3600) angle = 0;
		min = 0; max = min + 10;	
		for (i = 0; i < 360; i = i ++) {
			if ((angle >= min)&&(angle < max)) {
			gamma2_buf1 [i] = gamma2_buf1 [i] + 1;
			break;
			}
		min = min + 10; max = min + 10;
		}
}

		for (j = 0; j < 180; j ++) {
			gamma2_buf_tmp [j] = gamma2_buf1 [j] + gamma2_buf1 [j + 180];
		}

/*
		min = 359; max = 0;	
		for (i = 0; i < 360; i = i ++) {

			gamma2_buf_tmp [i] = gamma2_buf1 [min] + gamma2_buf1 [max];

			min = min + 1; max = min + 1;
			if (min == 360) {
			min = 0; max = 1; 
			}
		}
*/
/*
// Гистограмма 4 градуса
		gamma2_buf_tmp4 [0] = gamma2_buf1 [358] + gamma2_buf1 [359] + gamma2_buf1 [0] + gamma2_buf1 [1];
		gamma2_buf_tmp4 [1] = gamma2_buf1 [359] + gamma2_buf1 [0]   + gamma2_buf1 [1] + gamma2_buf1 [2];
		min = 0;	
		for (i = 2; i < 359; i = i ++) {
			gamma2_buf_tmp4 [i] = gamma2_buf1 [min] + gamma2_buf1 [min + 1] + gamma2_buf1 [min + 2] + gamma2_buf1 [min + 3];
			min = min ++; 
		}
		gamma2_buf_tmp4 [359] = gamma2_buf1 [357] + gamma2_buf1 [358] + gamma2_buf1 [359] + gamma2_buf1 [0];
*/        
Nop();Nop();Nop();
// Гистограмма 4 градуса
		gamma2_buf_tmp10 [0] = gamma2_buf_tmp [178] + gamma2_buf_tmp [179] + gamma2_buf_tmp [0] + gamma2_buf_tmp [1];
		gamma2_buf_tmp10 [1] = gamma2_buf_tmp [179] + gamma2_buf_tmp [0]   + gamma2_buf_tmp [1] + gamma2_buf_tmp [2];
		min = 0;	
		for (i = 2; i < 179; i = i ++) {
			gamma2_buf_tmp10 [i] = gamma2_buf_tmp [min] + gamma2_buf_tmp [min + 1] + gamma2_buf_tmp [min + 2] + gamma2_buf_tmp [min + 3];
			min = min ++; 
		}
		gamma2_buf_tmp10 [179] = gamma2_buf_tmp [177] + gamma2_buf_tmp [178] + gamma2_buf_tmp [179] + gamma2_buf_tmp [0];

// Гистограмма 10 градусов
/*
		gamma2_buf_tmp10 [0] = gamma2_buf1 [355] + gamma2_buf1 [356] + gamma2_buf1 [357] + gamma2_buf1 [358] + gamma2_buf1 [359]
                             + gamma2_buf1 [0]   + gamma2_buf1 [1]   + gamma2_buf1 [2]   + gamma2_buf1 [3]   + gamma2_buf1 [4];
		gamma2_buf_tmp10 [1] = gamma2_buf1 [356] + gamma2_buf1 [357] + gamma2_buf1 [358] + gamma2_buf1 [359] + gamma2_buf1 [0]
                             + gamma2_buf1 [1]   + gamma2_buf1 [2]   + gamma2_buf1 [3]   + gamma2_buf1 [4]   + gamma2_buf1 [5];
		gamma2_buf_tmp10 [2] = gamma2_buf1 [357] + gamma2_buf1 [358] + gamma2_buf1 [359] + gamma2_buf1 [0]   + gamma2_buf1 [1]
                             + gamma2_buf1 [2]   + gamma2_buf1 [3]   + gamma2_buf1 [4]   + gamma2_buf1 [5]   + gamma2_buf1 [6];
		gamma2_buf_tmp10 [3] = gamma2_buf1 [358] + gamma2_buf1 [359] + gamma2_buf1 [0]   + gamma2_buf1 [1]   + gamma2_buf1 [2]
                             + gamma2_buf1 [3]   + gamma2_buf1 [4]   + gamma2_buf1 [5]   + gamma2_buf1 [6]   + gamma2_buf1 [7];
		gamma2_buf_tmp10 [4] = gamma2_buf1 [359] + gamma2_buf1 [0]   + gamma2_buf1 [1]   + gamma2_buf1 [2]   + gamma2_buf1 [3]
                             + gamma2_buf1 [4]   + gamma2_buf1 [5]   + gamma2_buf1 [6]   + gamma2_buf1 [7]   + gamma2_buf1 [8];
		min = 0;	
		for (i = 5; i < 356; i = i ++) {

		gamma2_buf_tmp10 [i] = gamma2_buf1 [min]     + gamma2_buf1 [min + 1] + gamma2_buf1 [min + 2] + gamma2_buf1 [min + 3]
							 + gamma2_buf1 [min + 4] + gamma2_buf1 [min + 5] + gamma2_buf1 [min + 6] + gamma2_buf1 [min + 7]
							 + gamma2_buf1 [min + 8] + gamma2_buf1 [min + 9];
if ( i == 355 ) {
Nop();
Nop();
Nop();
}
		min = min ++; 
			}
		gamma2_buf_tmp10 [356] = gamma2_buf1 [351] + gamma2_buf1 [352] + gamma2_buf1 [353] + gamma2_buf1 [354] + gamma2_buf1 [355]
                               + gamma2_buf1 [356] + gamma2_buf1 [357] + gamma2_buf1 [358] + gamma2_buf1 [359] + gamma2_buf1 [0];
		gamma2_buf_tmp10 [357] = gamma2_buf1 [352] + gamma2_buf1 [353] + gamma2_buf1 [354] + gamma2_buf1 [355] + gamma2_buf1 [356]
                               + gamma2_buf1 [357] + gamma2_buf1 [358] + gamma2_buf1 [359] + gamma2_buf1 [0]   + gamma2_buf1 [1];
		gamma2_buf_tmp10 [358] = gamma2_buf1 [353] + gamma2_buf1 [354] + gamma2_buf1 [355] + gamma2_buf1 [356] + gamma2_buf1 [357]
                               + gamma2_buf1 [358] + gamma2_buf1 [359] + gamma2_buf1 [0]   + gamma2_buf1 [1]   + gamma2_buf1 [2];
		gamma2_buf_tmp10 [359] = gamma2_buf1 [354] + gamma2_buf1 [355] + gamma2_buf1 [356] + gamma2_buf1 [357] + gamma2_buf1 [358]
                               + gamma2_buf1 [359] + gamma2_buf1 [0]   + gamma2_buf1 [1]   + gamma2_buf1 [2]   + gamma2_buf1 [3];
*/
Nop();Nop();Nop();
/*
for ( j = 0; j < n; j++ ) {

angle = gamma2_diff [j];
if (angle == 3600) angle = 0;
		min = 0; max = min + 100;	
		for (i = 0; i < 36; i = i ++) {
			if ((angle >= min)&&(angle < max)) {
			gamma2_buf10 [i] = gamma2_buf10 [i] + 1;
			break;
			}
		min = min + 100; max = min + 100;
		}

}

// Поиск первого максимума
	imax1 = 0;
	Pmax1 = 0; 	
	for (i = 0; i < 17; i++) {
		if (gamma2_buf10 [i] > Pmax1) {Pmax1 = gamma2_buf10 [i]; imax1 = i;}
	}
// Поиск второго максимума
	imax2 = 0;
	Pmax2 = 0; 	
	for (i = 17; i < 36; i++) {
		if (gamma2_buf10 [i] > Pmax2) {Pmax2 = gamma2_buf10 [i]; imax2 = i;}
	}
*/    

// Поиск максимума
	imax180 = 0; Pmax180 = 0; 	
	for (i = 0; i < 180; i++) {
		if (gamma2_buf_tmp [i] > Pmax180) {Pmax180 = gamma2_buf_tmp [i]; imax180 = i;}
	}
    return Pmax180;
//    max_of_gist = Pmax180;
//    if (Pmax180 >= 100) {
//        Nop();Nop();Nop();
//        return imax180;
//    }

Nop();Nop();Nop();

return -1;
}
int get_angle ( int x, int y, int trh ) {

float modul, X, Y, ksi, TRH;
int ksi_deg;

	TRH = (float) trh;
	X = (float) x;
	Y = (float) y;


//X = X / 10.0;
//Y = Y / 10.0
        
	modul = X * X;
	modul = modul + Y * Y;
	modul = sqrt (modul);

	if (modul < TRH) return -1; //33.0
//	if (Gzif4 < 0) return -1;

	if (X == 0) {
		if (Y > 0) {
		ksi = 0.5 * 3.141593;
		}
		if (Y < 0) {
		ksi = 1.5 * 3.141593;
		}
	} else {
	ksi = X / modul;
	ksi = acosf (ksi);
	if (Y < 0) ksi = 6.283185 - ksi;

	}
	ksi = ksi * 57.29578;
	ksi_deg = (int) (ksi * 10.0);

return ksi_deg;
}
int range_of_angles (int start1, int stop1) {
static unsigned int count = 0;
int tmp, i, max, min, delta;

	if ((start1 == 0)&&(stop1 == 0)) return -1;
	
	
	if ((start1 == 1)&&(stop1 == 0)) {
		gamma2_diff [count] = gamma2;
		count ++;
	}
	if (count >= 75) { count = 0; start = 0; stop = 0; return -1; } //150
	
	if ((start1 == 1)&&(stop1 == 1)) {
	start = 0; stop = 0;
	if (count == 1) { count = 0; return -1; }


min = gamma2_diff [0];
max = gamma2_diff [0];

for (i = 0; i < count; i++) {
if (min > gamma2_diff [i]) min = gamma2_diff [i];
if (max < gamma2_diff [i]) max = gamma2_diff [i];
}

if (max >= min)  delta = max - min; 
if (max < min) delta = min - max;

/*if (delta > 179) { count = 0; start = 0; stop = 0; return -1; }*/ //20 408

	
//		for (i = 0; i < count; i++) {
//		tmp = tmp + gamma2_diff [i];
//		}
//		tmp = tmp / count;
//	Nop();
//	Nop();
//	Nop();
//	count = 0;
//	return tmp;
	Nop();
	Nop();
	Nop();
	tmp = count;
	count = 0;
	return tmp;
	}

return -1;
}
int looking_for_plane_angle (void) {

int Pmax1;//, Pmax2, temp1;
unsigned int i, imax1;//, imax2, temp;

Nop();Nop();Nop();


// Поиск первого максимума
	imax1 = 0;
	Pmax1 = 0; 	
	for (i = 0; i < 180; i++) {
		if (gamma2_buf_tmp10 [i] > Pmax1) { Pmax1 = gamma2_buf_tmp10 [i]; imax1 = i; }
	}
//    imax1 = imax1 + 180;
	gamma = (float) imax1; //gamma1; //40.0
	gammadeg = imax1;
	gamma = gamma / 57.29578;
	sing = sinf (gamma);
	cosg = cosf (gamma);

}
/*
void read_matrix ( int page ) {

Nop();
Nop();
Nop();
	AT45_page_to_buf( 2, page );

	Gx0   = AT45_read_from_buf( 2, 2, 0 );
	Gy0   = AT45_read_from_buf( 2, 2, 2 );
	Gz0   = AT45_read_from_buf( 2, 2, 4 );
	Gxyz0 = AT45_read_from_buf( 2, 2, 6 );

	AT45_read_from_buf( 2, 4, 10 );	m11 = (float) res4;	m11 = m11 / 1000000000.0;
	AT45_read_from_buf( 2, 4, 14 );	m12 = (float) res4;	m12 = m12 / 1000000000.0;
	AT45_read_from_buf( 2, 4, 18 );	m13 = (float) res4;	m13 = m13 / 1000000000.0;

	AT45_read_from_buf( 2, 4, 22 );	m21 = (float) res4;	m21 = m21 / 1000000000.0;
	AT45_read_from_buf( 2, 4, 26 );	m22 = (float) res4;	m22 = m22 / 1000000000.0;
	AT45_read_from_buf( 2, 4, 30 );	m23 = (float) res4;	m23 = m23 / 1000000000.0;

	AT45_read_from_buf( 2, 4, 34 );	m31 = (float) res4;	m31 = m31 / 1000000000.0;
	AT45_read_from_buf( 2, 4, 38 );	m32 = (float) res4;	m32 = m32 / 1000000000.0;
	AT45_read_from_buf( 2, 4, 42 );	m33 = (float) res4;	m33 = m33 / 1000000000.0;

	AT45_read_from_buf( 2, 4, 46 );	i1 =  (float) res4;	i1  = i1  / 1000000000.0;
	AT45_read_from_buf( 2, 4, 50 );	i2 =  (float) res4;	i2  = i2  / 1000000000.0;
	AT45_read_from_buf( 2, 4, 54 );	i3 =  (float) res4;	i3  = i3  / 1000000000.0;
	AT45_read_from_buf( 2, 4, 58 );	i4 =  (float) res4;	i4  = i4  / 1000000000.0;
	AT45_read_from_buf( 2, 4, 62 );	i5 =  (float) res4;	i5  = i5  / 1000000000.0;

	AT45_read_from_buf( 2, 4, 66 );	j1 =  (float) res4;	j1  = j1  / 1000000000.0;
	AT45_read_from_buf( 2, 4, 70 );	j2 =  (float) res4;	j2  = j2  / 1000000000.0;
	AT45_read_from_buf( 2, 4, 74 );	j3 =  (float) res4;	j3  = j3  / 1000000000.0;
	AT45_read_from_buf( 2, 4, 78 );	j4 =  (float) res4;	j4  = j4  / 1000000000.0;
	AT45_read_from_buf( 2, 4, 82 );	j5 =  (float) res4;	j5  = j5  / 1000000000.0;

	AT45_read_from_buf( 2, 4, 86 );	k1 =  (float) res4;	k1  = k1  / 1000000000.0;
	AT45_read_from_buf( 2, 4, 90 );	k2 =  (float) res4;	k2  = k2  / 1000000000.0;
	AT45_read_from_buf( 2, 4, 94 );	k3 =  (float) res4;	k3  = k3  / 1000000000.0;

	matrix_number = AT45_read_from_buf( 2, 2, 98 );

Nop();
Nop();
Nop();
}
*/
void calculation_plane_angle ( int gamma1 ) {
float gamma;

	gamma = (float) gamma1; 
	gammadeg = gamma1;
	gamma = gamma / 57.29578;
	sing = sinf (gamma);
	cosg = cosf (gamma);

}
void calculation_matrix () {
float temp, Gx_, Gy_, Gz_, Gx2, Gy2, Gz2;//, gzgx, gzgy, ggxy;


//	Gx_ = Gx - 2048.0;
//	Gy_ = Gy - 2048.0;
//	Gz_ = Gz - 2048.0;

	Gx_ = Gx0;
	Gy_ = Gy0;
	Gz_ = Gz0;


	Gx2 = Gx_ * Gx_;
	Gy2 = Gy_ * Gy_;
	Gz2 = Gz_ * Gz_;

	temp = Gx2 + Gy2 + Gz2;
	mod_g = sqrt(temp);
	temp = Gx2 + Gy2;
	mod_g_xy = sqrt(temp);


if (mod_g_xy == 0) {		// Датчик расположен строго горизонтально
	if (Gz_ > 0) alfa = 0;
	else alfa = 3.141593;
	beta = 0;
} else {					// mod_g_xy != 0 Датчик расположен не горизонтально

if (Gz_ == 0) {
alfa = 0.5 * 3.141593;
temp = Gx_ / mod_g_xy;
beta = acos ( temp );

} else {
	temp = Gz_ / mod_g;
	alfa = acosf (temp);

	temp = Gx_ / mod_g_xy;
	beta = acosf (temp);
	if (Gy_ < 0) beta = 6.283185 - beta;
}

}// else


	alfa_deg = alfa * 57.29578;
	beta_deg = beta * 57.29578;

	sina = sinf (alfa);
	cosa = cosf (alfa);
	sinb = sinf (beta);
	cosb = cosf (beta);


	i1 = sinb;
	i2 = cosa * cosb;
	i3 = -1.0 * cosb;
	i4 = cosa * sinb;
	i5 = -1.0 * sina;

	j1 = -1.0 * sinb;
	j2 = cosa * cosb;
	j3 = cosb;
	j4 = cosa * sinb;
	j5 = -1.0 * sina;

	k1 = sina * cosb;
	k2 = sina * sinb;
	k3 = cosa;

}
void calculation_matrix_2 (float cosfi, float sinfi) {

	m11 = i1 * eps * cosfi;
	m11 = m11 + i2 * eps * sinfi;
	m12 = i3 * eps * cosfi;
	m12 = m12 + i4 * eps * sinfi;
	m13 = i5 * eps * sinfi;

	m21 = j1 * sinfi;
	m21 = m21 + j2 * cosfi;
	m22 = j3 * sinfi;
	m22 = m22 + j4 * cosfi;
	m23 = j5 * cosfi;

	m31 = k1;
	m32 = k2;
	m33 = k3;

}
void search_fi (void) {

int i       = 0x0;
int tmp     = 0x0;
float delta = 0x0;

	for (i = 0; i < 1440; i ++) { // Поиск возможных значений угла Фи
	
		fi = (6.2831853 / 1440.0)  * i;
		sinfi = sinf (fi);
		cosfi = cosf (fi);
		calculation_matrix_2 (cosfi, sinfi);
		//eps = 1.0;
		recalculation (0);
		delta = Gxout - 2048.0;
		if (i == 0) {if (delta > 0) {tmp = 1;} else {tmp = 0;}};
		if ((delta < 1.0)&&(delta > - 1.0)) {fi1 = fi; break;};
//		chart_out();
	}
	
	
	if(tmp == 1) {
		fi1 = fi;
			if (fi1 <= 3.14159265) fi2 = fi1 + 3.14159265;
			else fi2 = fi1 - 3.141592653;
	} else {
		fi2 = fi;
			if (fi2 <= 3.14159265) fi1 = fi2 + 3.14159265;
			else fi2 = fi - 3.141592653;
	}

	fi1deg = fi1 * (180.0 / 3.14159265);
	fi2deg = fi2 * (180.0 / 3.14159265);
	fideg =  fi  * (180.0 / 3.14159265);

}
void recalculation (int c) {
float temp, temp1, temp_x, temp_y, temp_z, Gx_, Gy_, Gz_;

//	Gx_ = Gx - GX0fl; //514.0;
//	Gy_ = Gy - GY0fl;  //540.0;
//	Gz_ = Gz - GZ0fl;  //523.0;

	Gx_ = Gx0; //514.0;
	Gy_ = Gy0;  //540.0;
	Gz_ = Gz0;  //523.0;

	temp = m11 * Gx_;
	temp_x = temp + m12 * Gy_;
	temp_x = temp + m13 * Gz_;

	temp = m21 * Gx_;
	temp = temp + m22 * Gy_;
	temp_y = temp + m23 * Gz_;	
	
	temp = m31 * Gx_;
	temp = temp + m32 * Gy_;
	temp_z = temp + m33 * Gz_;

	Gxy = temp_x * temp_x + temp_y * temp_y;
	Gxy = sqrt (Gxy);

// Поворот осей X, Y в горизонтальной плоскости на угол gamma
if (c == 1) {
//	temp = temp_x * cosg;
//	temp = temp - temp_y * sing;
//	temp1 = temp_x * sing;
//	temp1 = temp1 + temp_y * cosg;

	temp = temp_x * cosg;
	temp = temp + temp_y * sing;
	temp1 = temp_x * sing;
	temp1 = temp_y * cosg - temp1;

	temp_x = temp;
	temp_y = temp1;

}
	Gx_ = temp_x + 2048.0;
	Gy_ = temp_y + 2048.0;
	Gz_ = temp_z + 2048.0;
	Gxout = Gx_;

	Gxi = Gx_;
	Gyi = Gy_;
	Gzi = Gz_;
	Gxyi = Gxy;
}
/*
void load_chart_U3_Tx_buf (int axis1,int axis2,int axis3,int axis4,int axis5,int axis6,
int axis7, int axis8, int axis9, int num_of_axis) {

int i;

UART3_Tx_buf[0] = 0x0D;
UART3_Tx_buf[1] = 0x0A;

	if (num_of_axis >= 1) {UART3_Tx_buf[2]  = axis1 >> 8; UART3_Tx_buf[3]  = axis1; i = 4;};
	if (num_of_axis >= 2) {UART3_Tx_buf[4]  = axis2 >> 8; UART3_Tx_buf[5]  = axis2; i = 6;};
	if (num_of_axis >= 3) {UART3_Tx_buf[6]  = axis3 >> 8; UART3_Tx_buf[7]  = axis3; i = 8;};
	if (num_of_axis >= 4) {UART3_Tx_buf[8]  = axis4 >> 8; UART3_Tx_buf[9]  = axis4; i = 10;};
	if (num_of_axis >= 5) {UART3_Tx_buf[10] = axis5 >> 8; UART3_Tx_buf[11] = axis5; i = 12;};
	if (num_of_axis >= 6) {UART3_Tx_buf[12] = axis6 >> 8; UART3_Tx_buf[13] = axis6; i = 14;};
	if (num_of_axis >= 7) {UART3_Tx_buf[14] = axis7 >> 8; UART3_Tx_buf[15] = axis7; i = 16;};
	if (num_of_axis >= 8) {UART3_Tx_buf[16] = axis8 >> 8; UART3_Tx_buf[17] = axis8; i = 18;};
	if (num_of_axis >= 9) {UART3_Tx_buf[18] = axis9 >> 8; UART3_Tx_buf[19] = axis9; i = 20;};

UART3_Tx_buf[i] = 0x00;
UART3_Tx_buf[i + 1] = 0xFF;
UART3_Tx_buf[i + 2] = 0xFF;

U3_Tx_length = i + 3;

} //transmit_U1_Tx_buf
*/
/*
void start_UART3_transmission (int wait) {
// Data Transmit and receiving the data using interrupts
    Tx3_DataAvailable = 0;
    IEC5bits.U3TXIE = 1;
    IFS5bits.U3TXIF = 1;
    if (wait == 1) {
        while(Tx3_DataAvailable != 1); //wait till data is transmitted
        Tx3_DataAvailable = 0;
    }
}
*/
/*
void gamma_hist_out_3 (void) {
	int e, q1, q2, q3, axis1, axis2, axis3, axis4, axis5, axis6, counter1, counter2, counter3;
	q1 = 0;	q2 = 0, q3 = 0;
	counter1 = 0; counter2 = 0; counter3 = 0;

	for (e = 0; e < 360; e++) {

if (counter1 == 0) {
		counter1 = 4;	
//		axis1 = gamma2_buf [q1];
		axis1 = 0;
		q1 = q1 + 1;
}
if (counter2 == 0) {
		counter2 = 2;
//		axis2 = gamma2_buf2 [q2];
		axis2 = 0;
		q2 = q2 + 1;
}
if (counter3 == 0) {
		counter3 = 10;
		axis3 = gamma2_buf_tmp [q3];
		q3 = q3 + 1;
}
counter1 --;
counter2 --;
counter3 --;

        axis3 = gamma2_buf_tmp [e];
		axis4 = gamma2_buf1 [e];
//		axis5 = gamma2_buf_tmp4 [e];
		axis6 = gamma2_buf_tmp10 [e];

        
//        load_chart_U3_Tx_buf (axis4, axis3, axis5, axis6, 0, 0, 0, 0, 0, 6);
//        start_UART3_transmission ( 1 );

//			putU1 (0x0D); putU1 (0x0A);
//
//			putU1 (axis4 >> 8);	putU1 (axis4);
//			putU1 (axis5 >> 8);	putU1 (axis5);
//			putU1 (axis6 >> 8);	putU1 (axis6);
//	
//			putU1 (axis1 >> 8);	putU1 (axis1);
//			putU1 (axis2 >> 8);	putU1 (axis2);
//			putU1 (axis3 >> 8);	putU1 (axis3);
//
//			putU1 (0);	putU1 (0);
//			putU1 (0);	putU1 (0);
//			putU1 (0);	putU1 (0);
//	
//			putU1 (0x00); putU1 (0xFF);	putU1 (0xFF);

	}
}
*/
void recalculation_to_XiYiZi (float X, float Y, float Z) {
float temp, temp1, temp_x, temp_y, temp_z, Gxyz, temp_xyi;
int n;

	temp = m11 * X;	temp   = temp + m12 * Y;	temp_x = temp + m13 * Z; //temp = m11 * X;	temp_x = temp + m12 * Y;	temp_x = temp + m13 * Z;
	temp = m21 * X;	temp   = temp + m22 * Y;	temp_y = temp + m23 * Z;	
	temp = m31 * X;	temp   = temp + m32 * Y;	temp_z = temp + m33 * Z;

	temp_xyi = temp_x * temp_x + temp_y * temp_y;	
    temp_xyi = sqrt (temp_xyi);
    Gxyi = (int) temp_xyi;
//	Gxyi = temp_x * temp_x + temp_y * temp_y;	
//    Gxyi = sqrt (Gxyi);
	Gxyz = temp_x * temp_x + temp_y * temp_y + temp_z * temp_z; 
    Gxyz = sqrt (Gxyz);

	Gxi = (int) temp_x; Gyi = (int) temp_y; Gzi = (int) temp_z; Gxyzi = (int) Gxyz;

}
void plane_recalculation (int X, int Y) {
float temp, temp1, temp_x, temp_y, temp_xy;

// Поворот осей X, Y в горизонтальной плоскости на угол gamma

	temp_x = (float) X;
	temp_y = (float) Y;

	temp = temp_x * cosg;
	temp = temp + temp_y * sing;
	temp1 = temp_x * sing;
	temp1 = temp_y * cosg - temp1;

	temp_x = temp;
	temp_y = temp1;

	temp_xy = temp_x * temp_y;
	temp_xy = sqrt (temp_xy);

//if ( temp_xy <= 100.0 ) {
//
//	if ( temp_y >= 50.0 ) {
//		temp = temp_x / temp_xy;
//		gamma_p = acos ( temp );
//	} else gamma_p = 0;
//}
    Gxyp = (int) temp_xy;
	Gxp = (int) temp_x;
	Gyp = (int) temp_y;
}
volatile void fill_buffers (void) {
volatile int p = 0;
//    while (1) {
//        while (1) {
//            if (periodic_10ms_flag == 1)        break;
//        }
//        periodic_10ms_flag = 0;
//        Read_G_all ( 0 );
//        Filter_behavior ( Gx, Gy, Gz );
//        Filt_crash ( Gx, Gy, Gz );
//        if (p == 85) break;
//        p++;
//    }
    while (p < 85) {
//        while (1) {
//            if (acc_data_redy_flag == 1)        break;
//        }
        __delay_ms (10);
        acc_data_redy_flag = 0;
        Read_G_all ( 0 );
        Filter_behavior ( Gx, Gy, Gz );
        Filt_crash ( Gx, Gy, Gz );
//        if (p == 85) break;
        p++;
    }    
}

/*АВТОКАЛИБРОВКА АКСЕЛЕРОМЕТРА*/
void launch_auto_calibration_process (void) {
    
    return; // ОТКЛЮЧЕНО
    
    static unsigned int counter = 0;
    
    if (ignition == 0) {
        counter = 0;
        return;
    }
// Запуск автокалибровки через 5 секунд после включения зажигания, если акселерометр не откалиброван
    if (AUTOCALbits.AUTOCAL == 0 && AUTOCALSTATUSbits.AUTOCALSTATUS == 0) { 
        if (counter < 50) counter ++;
        else {
            counter = 0;
            reset_calibration ();
        }
    }
    
}
int  reset_calibration (void) {
//unsigned char counter;

    AUTOCALbits.AUTOCAL = 0;
    AUTOCALSTATUSbits.AUTOCALSTATUS = 0;
    AUTOCALbits.staticcal = 1;
    tilt_overage_counter = 0;
    tilt_detection ( 1 );
    
    max_of_gist = 0;
    direction_counter = 0;
    gammadeg = 0;
	gamma = gamma / 57.29578;
	sing = sinf (gamma);
	cosg = cosf (gamma);

unsigned int i;    
    for (i = 0; i < 360; i++) {
        gamma2_buf1[i] = 0;
        gamma2_buf_tmp[i] = 0;
        if (i < 180) gamma2_buf_tmp10[i] = 0;
    }
    FM25_write_1 ( 1384, 0 ); // стираем признак полной калибровки
}
void static_calibration (void) {
static int p = 0;
static long x0 = 0, y0 = 0, z0 = 0, x = 0, y = 0, z = 0;

if ( AUTOCALbits.staticcal == 0 ) return; //автокалибровка не запущена или завершена.

/*#############################################################################*/
/* Раскомментировать для реальной работы*/
        x0 = x0 + Gx; y0 = y0 + Gy; z0 = z0 + Gz;        
        x = x + Gxif1b; y = y + Gyif1b; z = z + Gzif1b;
        p++;
    
    if (p >= 1024) {
        p = 0;
        x0 = (x0 + 512)/1024; y0 = (y0 + 512)/1024; z0 = (z0 + 512)/1024;
        x  = (x + 512)/1024;  y  = (y + 512)/1024;  z  = (z + 512)/1024;
        Gx0 = (int) x0; Gy0 = (int) y0; Gz0 = (int) z0;
        Gx0filt = (int) x; Gy0filt = (int) y; Gz0filt = (int) z;
        
                bin_2_bcd ((long) Gx0);
                memmove ( command_temp_buf, bin_2_bcd_buf, 9 );
                bin_2_bcd ((long) Gy0);
                memmove ( command_temp_buf + 9, bin_2_bcd_buf, 9 );                
                bin_2_bcd ((long) Gz0);
                memmove ( command_temp_buf + 18, bin_2_bcd_buf, 9 );                
                command_temp_buf [27] = 0;
                Nop(); Nop(); Nop();
// Формирование сообщения статической калибровки 
/*                
                    reload_GPRS_header ( 3, 47, 0x0011); // N = 3, name = 30, type = 1, ACK = 1
                    memmove ( command_temp_buf, GPRS_header_buf, 12 );
                    unsigned int ACK_counter = 0xFFFF;
                    command_temp_buf[12] = (unsigned char) (ACK_counter >> 8); command_temp_buf[13] = (unsigned char) ACK_counter; // ACK
                    command_temp_buf[14] = 0xFF; command_temp_buf[15] = 0x01; // Dataflags
                    memmove  ( &command_temp_buf[16], Navi_bin, 22 );

                    command_temp_buf[113] = 38; //38
                    write_data_into_save_to_flash_bufs ( command_temp_buf, 38 );
*/                    
                    generate_content_of_message ( 47, 1 );
                
//                if (SMSENbits.static_compl == 1) write_text_to_SMS_buf ( "Static calibration completed\0", "\"+79269524636\"\0" );
//                write_text_to_SMS_buf ( command_temp_buf, "\"+79032559788\"\0" );
                
                start_beep_task ( 50, 50, 1);
        if ( Gz0 < 0 ) {
            
            Gz0 = -1 * Gz0; Gy0 = -1 * Gy0;
            invertion_flag = 1;
            
        }
        
        Nop();Nop();Nop();
        calculation_matrix ();
        eps = 1.0;
        calculation_matrix_2 (0.70710678,0.70710678); //cosf (alfa)sinf (alfa)0.70710678
        search_fi ();
        cosfi = cosf (fi);
        sinfi = sinf (fi);
        calculation_matrix_2 (cosfi, sinfi);
        
        save_autocal_results (2);
        
        AUTOCALbits.staticcal = 0;
        AUTOCALbits.orientation = 1;
        AUTOCALSTATUSbits.staticcal = 1;
        
    }
/*#############################################################################*/

/*#############################################################################*/ 
/* закомментировать для реальной работы*/        
//        read_G0_from_ACCMEM (); 
//        Nop();Nop();Nop();
//        calculation_matrix ();
//        eps = 1.0;
//        calculation_matrix_2 (0.70710678,0.70710678); //cosf (alfa)sinf (alfa)0.70710678
//        search_fi ();
//        cosfi = cosf (fi);
//        sinfi = sinf (fi);
//        calculation_matrix_2 (cosfi, sinfi);
//        AUTOCALbits.staticcal = 0;
//        AUTOCALbits.orientation = 1;
//        AUTOCALSTATUSbits.staticcal = 1;
/*#############################################################################*/
        
    
}
void orientation (void) {

    if (AUTOCALbits.orientation == 0) return;
        
        gamma2 = get_angle (Gxi, Gyi, 40);
        if (gamma2 >= 0) { gamma2_diff [0] = gamma2;max_of_gist = angle_histogram3 ( 1 ); }
        if ( max_of_gist >= 150) {
            Nop();Nop();Nop();
            looking_for_plane_angle ();
            AUTOCALbits.AUTOCAL = 0;
            AUTOCALbits.direction = 1;
            AUTOCALSTATUSbits.orientation = 1;
        }
}
void direction (void) {
//    long temp;
//    static int direction_counter;
    int derivative;
    
    if (AUTOCALbits.direction == 0) return;
    
        GPSSPEEDbits.GPSSPEED = GPSSPEEDbits.GPSSPEED << 8;        
//        GPSSPEEDbits.V = speed_from_memory; derivative = (int) (GPSSPEEDbits.V - GPSSPEEDbits.V0);        
        GPSSPEEDbits.V = Navi_bin[17]; derivative = (int) (GPSSPEEDbits.V - GPSSPEEDbits.V0); // #########################
        
        if (derivative != 0) {
                if ((derivative < 0 && Gxp < -25) || (derivative > 0 && Gxp >  25)) { direction_counter ++; }
                if ((derivative < 0 && Gxp >  25) || (derivative > 0 && Gxp < -25)) { direction_counter --; }
        }
        
        if (direction_counter > 50) {
            AUTOCALbits.AUTOCAL = 0;
            AUTOCALSTATUSbits.direction = 1;
            AUTOCALSTATUSbits.finished = 1;
        }
        if (direction_counter < -50) {
            gammadeg = gammadeg + 180;
        	gamma = (float) gammadeg; gamma = gamma / 57.29578;
            sing = sinf (gamma); cosg = cosf (gamma);
            AUTOCALbits.AUTOCAL = 0;
            AUTOCALSTATUSbits.direction = 1;
            AUTOCALSTATUSbits.finished = 1;
        }
        
        if (AUTOCALSTATUSbits.finished == 1) {
            save_autocal_results (1);
            generate_content_of_message ( 26, 1 );
        }

}
void save_autocal_results ( unsigned char cal_status ) {
    
    long temp;
    
    temp = (long) (m11 * 100000000);
    FM25_write_4_signed ( 1334, temp );
    temp = (long) (m12 * 100000000);
    FM25_write_4_signed ( 1338, temp );
    temp = (long) (m13 * 100000000);
    FM25_write_4_signed ( 1342, temp );
    
    temp = (long) (m21 * 100000000);
    FM25_write_4_signed ( 1346, temp );
    temp = (long) (m22 * 100000000);
    FM25_write_4_signed ( 1350, temp );
    temp = (long) (m23 * 100000000);
    FM25_write_4_signed ( 1354, temp ); 

    temp = (long) (m31 * 100000000);
    FM25_write_4_signed ( 1358, temp );
    temp = (long) (m32 * 100000000);
    FM25_write_4_signed ( 1362, temp );
    temp = (long) (m33 * 100000000);
    FM25_write_4_signed ( 1366, temp );
    
    temp = (long) (sing * 100000000);
    FM25_write_4_signed ( 1370, temp );
    temp = (long) (cosg * 100000000);
    FM25_write_4_signed ( 1374, temp );
    
    FM25_write_2_signed ( 1378, Gx0);
    FM25_write_2_signed ( 1380, Gy0);
    FM25_write_2_signed ( 1382, Gz0);
    
    FM25_write_1 ( 1384, cal_status ); // 1 - признак полной калибровки, 2 - признак статической калибровки
    
    FM25_write_1 ( 1516, invertion_flag ); // признак направления оси Z
    
}
void read_autocal_results (void) {
    
    m11 = (float)FM25_read_4_signed ( 1334 );
    m11 = m11 / 100000000.0;
    m12 = (float)FM25_read_4_signed ( 1338 );
    m12 = m12 / 100000000.0;
    m13 = (float)FM25_read_4_signed ( 1342 );
    m13 = m13 / 100000000.0;

    m21 = (float)FM25_read_4_signed ( 1346 );
    m21 = m21 / 100000000.0;
    m22 = (float)FM25_read_4_signed ( 1350 );
    m22 = m22 / 100000000.0;
    m23 = (float)FM25_read_4_signed ( 1354 );
    m23 = m23 / 100000000.0;

    m31 = (float)FM25_read_4_signed ( 1358 );
    m31 = m31 / 100000000.0;
    m32 = (float)FM25_read_4_signed ( 1362 );
    m32 = m32 / 100000000.0;
    m33 = (float)FM25_read_4_signed ( 1366 );
    m33 = m33 / 100000000.0;

    sing = (float)FM25_read_4_signed ( 1370 );
    sing = sing / 100000000.0;
    cosg = (float)FM25_read_4_signed ( 1374 ); 
    cosg = cosg / 100000000.0;
    
    Gx0 = FM25_read_2_signed ( 1378 );
    Gy0 = FM25_read_2_signed ( 1380 );
    Gz0 = FM25_read_2_signed ( 1382 );
    
    invertion_flag = (char) FM25_read_1 ( 1516 );
    
}

/*РЕГИСТРАЦИЯ МАНЕВРОВ И АВАРИЙ*/
int check_acceleration_events (int GX, int GY) {

static unsigned char lowest_accel_trigger = 0, lowest_decel_trigger = 0;
//static unsigned char lowest_right_trigger = 0, lowest_left_trigger = 0;
static unsigned char lowest_lalr_trigger, lowest_lall_trigger;

static unsigned char  decel_duration_1 = 0, decel_duration_2 = 0;
static unsigned char  decel_duration_3 = 0, decel_duration_4 = 0;

static unsigned char  accel_duration_1 = 0, accel_duration_2 = 0;
static unsigned char  accel_duration_3 = 0, accel_duration_4 = 0;

static unsigned char  lalr_duration_1 = 0, lalr_duration_2 = 0;
static unsigned char  lalr_duration_3 = 0, lalr_duration_4 = 0;

static unsigned char  lall_duration_1 = 0, lall_duration_2 = 0;
static unsigned char  lall_duration_3 = 0, lall_duration_4 = 0;

char max_acceleration, max_deceleration, max_lateralr, max_laterall;
unsigned char i;
char *ptr;

unsigned char name = 0, name1 = 0;

unsigned char len;
unsigned long long temp;

if (GX < 0) GX = (GX - 1)/2;
else GX = (GX + 1)/2;

if (GY < 0) GY = (GY - 1)/2;
else GY = (GY + 1)/2;

if (GX > 127) GX = 127; if (GX < -127) GX = -127;
if (GY > 127) GY = 127; if (GY < -127) GY = -127;

Gxp_buf[0] = GX; Gyp_buf[0] = GY;

// ТОРМОЖЕНИЕ
if (( Gxp_buf[0] <= DCELbits.trh1) && ( lowest_decel_trigger == 0 )) lowest_decel_trigger = 1;// Превзойден минимальный порог торможения

if ( lowest_decel_trigger == 1 ) {
    
    if ( GX <= DCELbits.trh1 ) { // 300 mg
        if (decel_duration_1 < 120) decel_duration_1 ++;
    }
    else {
        max_deceleration = 0;
        for (i = 0; i < decel_duration_1; i++ ) {
            if ( Gxp_buf[i] <= DCELbits.trh2) decel_duration_2 ++; // 400 mg
            if ( Gxp_buf[i] <= DCELbits.trh3) decel_duration_3 ++; // 500 mg
            if ( Gxp_buf[i] <= DCELbits.trh4) decel_duration_4 ++; // 600 mg
            if ( Gxp_buf[i] < max_deceleration) max_deceleration = Gxp_buf[i];
        } 
        Nop();Nop();Nop();
        
            if ( decel_duration_1 > DCELbits.dur1 ) { // 3000ms
                DECELEVENTbits.flag1 = 1;
                name = 10;
            }
            if ( decel_duration_2 > DCELbits.dur2 ) { // 2000ms
                DECELEVENTbits.flag1 = 0;
                DECELEVENTbits.flag2 = 1;
                name = 11;
            }
            if ( decel_duration_3 > DCELbits.dur3 ) { // 600ms
                DECELEVENTbits.flag1 = 0;
                DECELEVENTbits.flag2 = 0;
                DECELEVENTbits.flag3 = 1;
                name = 12;
            }
            if ( decel_duration_4 > DCELbits.dur4 ) { // 300ms
                DECELEVENTbits.flag1 = 0;
                DECELEVENTbits.flag2 = 0;
                DECELEVENTbits.flag3 = 0;
                DECELEVENTbits.flag4 = 1;
                name = 13;
            }
                DECELEVENTbits.duration1 = decel_duration_1;
                DECELEVENTbits.duration2 = decel_duration_2;
                DECELEVENTbits.duration3 = decel_duration_3;
                DECELEVENTbits.duration4 = decel_duration_4;                
                DECELEVENTbits.max_decel = (unsigned char) -1 * max_deceleration;
        lowest_decel_trigger = 0;
        decel_duration_1 = 0;decel_duration_2 = 0;decel_duration_3 = 0;decel_duration_4 = 0;
    }
    
}

// УСКОРЕНИЕ
if (( Gxp_buf[0] >= ACELbits.trh1)  && ( lowest_accel_trigger == 0 )) lowest_accel_trigger = 1;// Превзойден минимальный порог ускорения

if ( lowest_accel_trigger == 1 ) {
    
    if ( GX >= ACELbits.trh1 ) { // 300 mg
        if (accel_duration_1 < 120) accel_duration_1 ++;
    }
    else {
        max_acceleration = 0;
        for (i = 0; i < accel_duration_1; i++ ) {
            if ( Gxp_buf[i] >= ACELbits.trh2 ) accel_duration_2 ++; // 300 mg
            if ( Gxp_buf[i] >= ACELbits.trh3 ) accel_duration_3 ++; // 350 mg
            if ( Gxp_buf[i] >= ACELbits.trh4 ) accel_duration_4 ++; // 450 mg
            if ( Gxp_buf[i] > max_acceleration ) max_acceleration = Gxp_buf[i];
        } 
        Nop();Nop();Nop();
        
            if ( accel_duration_1 > ACELbits.dur1 ) { // 2000ms
                ACCELEVENTbits.flag1 = 1;
                name = 14;
            }
            if ( accel_duration_2 > ACELbits.dur2 ) { // 600ms
                ACCELEVENTbits.flag1 = 0;
                ACCELEVENTbits.flag2 = 1;
                name = 15;
            }
            if ( accel_duration_3 > ACELbits.dur3 ) { // 300ms
                ACCELEVENTbits.flag1 = 0;
                ACCELEVENTbits.flag2 = 0;
                ACCELEVENTbits.flag3 = 1;
                name = 16;
            }
            if ( accel_duration_4 > ACELbits.dur4 ) { // 300ms
                ACCELEVENTbits.flag1 = 0;
                ACCELEVENTbits.flag2 = 0;
                ACCELEVENTbits.flag3 = 0;
                ACCELEVENTbits.flag4 = 1;
                name = 17;
            }
                ACCELEVENTbits.duration1 = accel_duration_1;
                ACCELEVENTbits.duration2 = accel_duration_2;
                ACCELEVENTbits.duration3 = accel_duration_3;
                ACCELEVENTbits.duration4 = accel_duration_4;
                ACCELEVENTbits.max_accel = (unsigned char) max_acceleration;
        lowest_accel_trigger = 0;
        accel_duration_1 = 0; accel_duration_2 = 0; accel_duration_3 = 0; accel_duration_4 = 0;
    }
    
}


// ПРАВЫЙ ПОВОРОТ
if (( Gyp_buf[0] <= LALRbits.trh1 ) && ( lowest_lalr_trigger == 0 )) lowest_lalr_trigger = 1;// Превзойден минимальный порог торможения

if ( lowest_lalr_trigger == 1 ) {
    
    if ( GY <= LALRbits.trh1 ) { // 300 mg
        if (lalr_duration_1 < 120) lalr_duration_1 ++;
    }
    else {
        max_lateralr = 0;
        for (i = 0; i < lalr_duration_1; i++ ) {
            if ( Gyp_buf[i] <= LALRbits.trh2 ) lalr_duration_2 ++; // 400 mg
            if ( Gyp_buf[i] <= LALRbits.trh3 ) lalr_duration_3 ++; // 500 mg
            if ( Gyp_buf[i] <= LALRbits.trh4 ) lalr_duration_4 ++; // 600 mg
            if ( Gyp_buf[i] < max_lateralr) max_lateralr = Gyp_buf[i];
        } 
        
            if ( lalr_duration_1 > LALRbits.dur1 ) { // 3000ms
                LALREVENTbits.flag1 = 1;
                name1 = 18;
            }
            if ( lalr_duration_2 > LALRbits.dur2 ) { // 2000ms
                LALREVENTbits.flag1 = 0;
                LALREVENTbits.flag2 = 1;
                name1 = 19;
            }
            if ( lalr_duration_3 > LALRbits.dur3 ) { // 600ms
                LALREVENTbits.flag1 = 0;
                LALREVENTbits.flag2 = 0;
                LALREVENTbits.flag3 = 1;
                name1 = 20;
            }
            if ( lalr_duration_4 > LALRbits.dur4 ) { // 300ms
                LALREVENTbits.flag1 = 0;
                LALREVENTbits.flag2 = 0;
                LALREVENTbits.flag3 = 0;
                LALREVENTbits.flag4 = 1;
                name1 = 21;
            }
                LALREVENTbits.duration1 = lalr_duration_1;
                LALREVENTbits.duration2 = lalr_duration_2;
                LALREVENTbits.duration3 = lalr_duration_3;
                LALREVENTbits.duration4 = lalr_duration_4;                
                LALREVENTbits.max_decel = (unsigned char) -1 * max_lateralr;
        lowest_lalr_trigger = 0;
        lalr_duration_1 = 0; lalr_duration_2 = 0; lalr_duration_3 = 0; lalr_duration_4 = 0;
    }
    
}


// ЛЕВЫЙ ПОВОРОТ
if (( Gyp_buf[0] >= LALLbits.trh1) && ( lowest_lall_trigger == 0 )) lowest_lall_trigger = 1;// Превзойден минимальный порог торможения

if ( lowest_lall_trigger == 1 ) {
    
    if ( GY >= LALLbits.trh1 ) { // 300 mg
        if (lall_duration_1 < 120) lall_duration_1 ++;
    }
    else {
        max_laterall = 0;
        for (i = 0; i < lall_duration_1; i++ ) {
            if ( Gyp_buf[i] >= LALLbits.trh2) lall_duration_2 ++; // 400 mg
            if ( Gyp_buf[i] >= LALLbits.trh3) lall_duration_3 ++; // 500 mg
            if ( Gyp_buf[i] >= LALLbits.trh4) lall_duration_4 ++; // 600 mg
            if ( Gyp_buf[i] > max_laterall) max_laterall = Gyp_buf[i];
        } 
        Nop();Nop();Nop();
        
            if ( lall_duration_1 > LALLbits.dur1 ) { // 3000ms
                LALLEVENTbits.flag1 = 1;
                name1 = 22;
            }
            if ( lalr_duration_2 > LALLbits.dur2 ) { // 2000ms
                LALLEVENTbits.flag1 = 0;
                LALLEVENTbits.flag2 = 1;
                name1 = 23;
            }
            if ( lalr_duration_3 > LALLbits.dur3 ) { // 600ms
                LALLEVENTbits.flag1 = 0;
                LALLEVENTbits.flag2 = 0;
                LALLEVENTbits.flag3 = 1;
                name1 = 24;
            }
            if ( lalr_duration_4 > LALLbits.dur4 ) { // 300ms
                LALLEVENTbits.flag1 = 0;
                LALLEVENTbits.flag2 = 0;
                LALLEVENTbits.flag3 = 0;
                LALLEVENTbits.flag4 = 1;
                name1 = 25;
            }
                LALLEVENTbits.duration1 = lall_duration_1;
                LALLEVENTbits.duration2 = lall_duration_2;
                LALLEVENTbits.duration3 = lall_duration_3;
                LALLEVENTbits.duration4 = lall_duration_4;                
                LALLEVENTbits.max_accel = (unsigned char) max_laterall;
        lowest_lall_trigger = 0;
        lall_duration_1 = 0; lall_duration_2 = 0; lall_duration_3 = 0; lall_duration_4 = 0;
    }
    
}


    ptr = Gxp_buf; ptr++;
    memmove (ptr, Gxp_buf, 119);
    ptr = Gyp_buf; ptr++;
    memmove (ptr, Gyp_buf, 119); 

    unsigned int ACK_counter;
    if ((name != 0)||(name1 != 0)) {

unsigned long long temp_to_send; 

// Отправка торможений и ускорений
            if ((name >= 10)&&(name <= 17)) {
                    reload_GPRS_header ( 4, name, 0x0011 ); // N = 3, name = 1, type = 1, ACK = 1
                    memmove ( command_temp_buf, GPRS_header_buf, 12 );
                    ACK_counter = 0xFFFF;
                    command_temp_buf[12] = (unsigned char) (ACK_counter >> 8); command_temp_buf[13] = (unsigned char) ACK_counter; // ACK
                    command_temp_buf[14] = 0xFF; command_temp_buf[15] = 0x0B;  command_temp_buf[16] = 0x20; // Dataflags
                    memmove  ( &command_temp_buf[17], Navi_bin, 22 );
                    command_temp_buf[39] = max_speed_to_send;
                
                if (name <= 13) { temp_to_send = DECELEVENTbits.DECELEVENT; } // Торможения
                else { temp_to_send = ACCELEVENTbits.ACCELEVENT; }            // Ускорения
                    
                    command_temp_buf[40] = (unsigned char)(temp_to_send >> 40);
                    command_temp_buf[41] = (unsigned char)(temp_to_send >> 32);
                    command_temp_buf[42] = (unsigned char)(temp_to_send >> 24);
                    command_temp_buf[43] = (unsigned char)(temp_to_send >> 16);
                    command_temp_buf[44] = (unsigned char)(temp_to_send >> 8);
                    command_temp_buf[45] = (unsigned char)(temp_to_send);
                    
                if (name <= 13) {  // Настройки торможений
                    command_temp_buf[46] = -1 * DCELbits.trh1; command_temp_buf[47] = DCELbits.dur1;
                    command_temp_buf[48] = -1 * DCELbits.trh2; command_temp_buf[49] = DCELbits.dur2;
                    command_temp_buf[50] = -1 * DCELbits.trh3; command_temp_buf[51] = DCELbits.dur3;
                    command_temp_buf[52] = -1 * DCELbits.trh4; command_temp_buf[53] = DCELbits.dur4;
                }
                else {  // Настройки ускорений
                    command_temp_buf[46] = ACELbits.trh1; command_temp_buf[47] = ACELbits.dur1;
                    command_temp_buf[48] = ACELbits.trh2; command_temp_buf[49] = ACELbits.dur2;
                    command_temp_buf[50] = ACELbits.trh3; command_temp_buf[51] = ACELbits.dur3;
                    command_temp_buf[52] = ACELbits.trh4; command_temp_buf[53] = ACELbits.dur4;
                }           

        temp = FM25_read_8( 1260 ); //
//        temp = 0x0000000000200000; // сиквенс намбер всегда включен
                    if (  temp & 0x0000000000200000  ) {
                        sequence_number = get_sequence_number ();
                        command_temp_buf[ 54 ] = (unsigned char)(sequence_number >> 24);
                        command_temp_buf[ 55 ] = (unsigned char)(sequence_number >> 16);
                        command_temp_buf[ 56 ] = (unsigned char)(sequence_number >> 8);
                        command_temp_buf[ 57 ] = (unsigned char)(sequence_number);            
                        len = 58;
                    }
                    else { len = 54; }
                    
                    command_temp_buf[113] = len; //38
                    if ( ACCDATbits.queue == 1 ) write_data_into_save_to_flash_bufs ( command_temp_buf, len );            
//                    send_acc_sms ( name, 0 );

                    reload_GPRS_header ( 1, name, 0x0012 ); // N = 3, name = 1, type = 2, ACK = 1
                    memmove ( command_temp_buf, GPRS_header_buf, 12 );
                    ACK_counter = 0xFFFF;
                    command_temp_buf[12] = (unsigned char) (ACK_counter >> 8); command_temp_buf[13] = (unsigned char) ACK_counter; // ACK
                    memmove  ( &command_temp_buf[14], Navi_bin, 6 ); // Время и дата
                    
                    command_temp_buf[20] = (unsigned char)(temp_to_send >> 8);
                    if ( command_temp_buf[20] >= 90 ) command_temp_buf[20] = 92;
                    else command_temp_buf[20] = command_temp_buf[20] + 2;

                    memmove ( &command_temp_buf[21], Gxp_buf, command_temp_buf[20] );

                    temp = FM25_read_8( 1260 ); //                     
                    if (  temp & 0x0000000000200000 ) {
                        sequence_number = get_sequence_number ();
                        command_temp_buf[ 21 + command_temp_buf[20] ] = (unsigned char)(sequence_number >> 24);
                        command_temp_buf[ 21 + command_temp_buf[20] + 1 ] = (unsigned char)(sequence_number >> 16);
                        command_temp_buf[ 21 + command_temp_buf[20] + 2 ] = (unsigned char)(sequence_number >> 8);
                        command_temp_buf[ 21 + command_temp_buf[20] + 3 ] = (unsigned char)(sequence_number);            
                        len = 21 + command_temp_buf[20] + 4;
                    }
                    else { len = 21 + command_temp_buf[20]; }                    
                    
                    if ( ACCDATbits.queue == 1 ) write_data_into_save_to_flash_bufs ( command_temp_buf, len );
                    
                DECELEVENTbits.DECELEVENT = 0; ACCELEVENTbits.ACCELEVENT = 0;
            }

/* Отправка поворотов */
            if ((name1 >= 18)&&(name1 <= 25)) {
                
                    reload_GPRS_header ( 4, name1, 0x0011 ); // N = 3, name = 1, type = 1, ACK = 1
                    memmove ( command_temp_buf, GPRS_header_buf, 12 );
                    ACK_counter = 0xFFFF;
                    command_temp_buf[12] = (unsigned char) (ACK_counter >> 8); command_temp_buf[13] = (unsigned char) ACK_counter; // ACK
                    command_temp_buf[14] = 0xFF; command_temp_buf[15] = 0x0B; command_temp_buf[16] = 0x20;  // Dataflags
                    memmove  ( &command_temp_buf[17], Navi_bin, 22 );
                    command_temp_buf[39] = max_speed_to_send;
                
                if (name1 <= 21) { temp_to_send = LALREVENTbits.LALREVENT; }
                else { temp_to_send = LALLEVENTbits.LALLEVENT; }
                
                    command_temp_buf[40] = (unsigned char)(temp_to_send >> 40);
                    command_temp_buf[41] = (unsigned char)(temp_to_send >> 32);
                    command_temp_buf[42] = (unsigned char)(temp_to_send >> 24);
                    command_temp_buf[43] = (unsigned char)(temp_to_send >> 16);
                    command_temp_buf[44] = (unsigned char)(temp_to_send >> 8);
                    command_temp_buf[45] = (unsigned char)(temp_to_send);
                    
                    command_temp_buf[46] = LALLbits.trh1; command_temp_buf[47] = LALLbits.dur1;
                    command_temp_buf[48] = LALLbits.trh2; command_temp_buf[49] = LALLbits.dur2;
                    command_temp_buf[50] = LALLbits.trh3; command_temp_buf[51] = LALLbits.dur3;
                    command_temp_buf[52] = LALLbits.trh4; command_temp_buf[53] = LALLbits.dur4;
                    
                    temp = FM25_read_8( 1260 ); // 
//                    temp = 0x0000000000200000; // сиквенс намбер всегда включен
                    if (  temp & 0x0000000000200000 ) {
                        sequence_number = get_sequence_number ();
                        command_temp_buf[ 54 ] = (unsigned char)(sequence_number >> 24);
                        command_temp_buf[ 55 ] = (unsigned char)(sequence_number >> 16);
                        command_temp_buf[ 56 ] = (unsigned char)(sequence_number >> 8);
                        command_temp_buf[ 57 ] = (unsigned char)(sequence_number);            
                        len = 58;
                    }
                    else { len = 54; }
                    
                    command_temp_buf[113] = len;
                    if ( ACCDATbits.queue == 1 ) write_data_into_save_to_flash_bufs ( command_temp_buf, len );            
//                    send_acc_sms ( 0, name1 );
            
                    reload_GPRS_header ( 1, name1, 0x0012 ); // N = 3, name = 1, type = 2, ACK = 1
                    memmove ( command_temp_buf, GPRS_header_buf, 12 );
                    ACK_counter = 0xFFFF;
                    command_temp_buf[12] = (unsigned char) (ACK_counter >> 8); command_temp_buf[13] = (unsigned char) ACK_counter; // ACK
                    memmove  ( &command_temp_buf[14], Navi_bin, 6 ); // Время и дата
                    
                    command_temp_buf[20] = (unsigned char)(temp_to_send >> 8);
                    if ( command_temp_buf[20] >= 90 ) command_temp_buf[20] = 92;
                    else command_temp_buf[20] = command_temp_buf[20] + 2;

                    memmove ( &command_temp_buf[21], Gyp_buf, command_temp_buf[20] );

                    temp = FM25_read_8( 1260 ); //
                    if (  temp & 0x0000000000200000  ) {
                        sequence_number = get_sequence_number ();
                        command_temp_buf[ 21 + command_temp_buf[20] ] = (unsigned char)(sequence_number >> 24);
                        command_temp_buf[ 21 + command_temp_buf[20] + 1 ] = (unsigned char)(sequence_number >> 16);
                        command_temp_buf[ 21 + command_temp_buf[20] + 2 ] = (unsigned char)(sequence_number >> 8);
                        command_temp_buf[ 21 + command_temp_buf[20] + 3 ] = (unsigned char)(sequence_number);            
                        len = 21 + command_temp_buf[20] + 4;
                    }
                    else { len = 21 + command_temp_buf[20]; }                    
                    
                    if ( ACCDATbits.queue == 1 ) write_data_into_save_to_flash_bufs ( command_temp_buf, len );

                    
                    LALREVENTbits.LALREVENT = 0;   LALLEVENTbits.LALLEVENT = 0;
            }

            name = 0;
            name1 = 0;
    }

    
}
/*
void send_acc_sms (unsigned char name, unsigned char name1) {
    
            if ( name == 10 && SMSENbits.dcel == 1) {
                write_text_to_SMS_buf ( "Deceleration 1", "\"+79269524636\"\0" );
//                write_text_to_SMS_buf ( "Deceleration 1", "\"+79032559788\"\0" );                
            }
            if ( name == 11 && SMSENbits.dcel == 1) {
                write_text_to_SMS_buf ( "Deceleration 2", "\"+79269524636\"\0" );
//                write_text_to_SMS_buf ( "Deceleration 2", "\"+79032559788\"\0" );                
            }
            if ( name == 12 && SMSENbits.dcel == 1 ) {
                write_text_to_SMS_buf ( "Deceleration 3", "\"+79269524636\"\0" );
//                write_text_to_SMS_buf ( "Deceleration 3", "\"+79032559788\"\0" );                
            }
            if ( name == 13 && SMSENbits.dcel == 1 ) {
                write_text_to_SMS_buf ( "Deceleration 4", "\"+79269524636\"\0" );
//                write_text_to_SMS_buf ( "Deceleration 4", "\"+79032559788\"\0" );                
            }
            if ( name == 14 && SMSENbits.acel == 1 ) {
                write_text_to_SMS_buf ( "Acceleration 1", "\"+79269524636\"\0" );
//                write_text_to_SMS_buf ( "Acceleration 1", "\"+79032559788\"\0" );                
            }
            if ( name == 15 && SMSENbits.acel == 1  ) {
                write_text_to_SMS_buf ( "Acceleration 2", "\"+79269524636\"\0" );
//                write_text_to_SMS_buf ( "Acceleration 2", "\"+79032559788\"\0" );                
            }
            if ( name == 16 && SMSENbits.acel == 1  ) {
                write_text_to_SMS_buf ( "Acceleration 3", "\"+79269524636\"\0" );
//                write_text_to_SMS_buf ( "Acceleration 3", "\"+79032559788\"\0" );                
            }
            if ( name == 17 && SMSENbits.acel == 1  ) {
                write_text_to_SMS_buf ( "Acceleration 4", "\"+79269524636\"\0" );
//                write_text_to_SMS_buf ( "Acceleration 4", "\"+79032559788\"\0" );                
            }

            if ( name1 == 18 && SMSENbits.lal == 1  ) {
                write_text_to_SMS_buf ( "Right cornering 1", "\"+79269524636\"\0" );
//                write_text_to_SMS_buf ( "Right cornering 1", "\"+79032559788\"\0" );                
            }
            if ( name1 == 19 && SMSENbits.lal == 1   ) {
                write_text_to_SMS_buf ( "Right cornering 2", "\"+79269524636\"\0" );
//                write_text_to_SMS_buf ( "Right cornering 2", "\"+79032559788\"\0" );                
            }
            if ( name1 == 20 && SMSENbits.lal == 1   ) {
                write_text_to_SMS_buf ( "Right cornering 3", "\"+79269524636\"\0" );
//                write_text_to_SMS_buf ( "Right cornering 3", "\"+79032559788\"\0" );                
            }
            if ( name1 == 21 && SMSENbits.lal == 1   ) {
                write_text_to_SMS_buf ( "Right cornering 4", "\"+79269524636\"\0" );
//                write_text_to_SMS_buf ( "Right cornering 4", "\"+79032559788\"\0" );                
            }

            if ( name1 == 22 && SMSENbits.lal == 1   ) {
                write_text_to_SMS_buf ( "Left cornering 1", "\"+79269524636\"\0" );
//                write_text_to_SMS_buf ( "Left cornering 1", "\"+79032559788\"\0" );                
            }
            if ( name1 == 23 && SMSENbits.lal == 1   ) {
                write_text_to_SMS_buf ( "Left cornering 2", "\"+79269524636\"\0" );
//                write_text_to_SMS_buf ( "Left cornering 2", "\"+79032559788\"\0" );                
            }
            if ( name1 == 24 && SMSENbits.lal == 1   ) {
                write_text_to_SMS_buf ( "Left cornering 3", "\"+79269524636\"\0" );
//                write_text_to_SMS_buf ( "Left cornering 3", "\"+79032559788\"\0" );                
            }
            if ( name1 == 25 && SMSENbits.lal == 1   ) {
                write_text_to_SMS_buf ( "Left cornering 4", "\"+79269524636\"\0" );
//                write_text_to_SMS_buf ( "Left cornering 4", "\"+79032559788\"\0" );                
            }
            
            
}
*/
void crash_detection (int x, int y, int z) {

static unsigned char crash_counter = 0, crash_counter1 = 0;;
static unsigned int crash_trh_switch_timer = 0;//, xy_trh, xyz_trh, duration;
int zi;

    if (CRASHTASKbits.crash_record_done == 1) return;

//    x = 125; y = -5678; z = 102;
    x = (x + 2)/4; x = x + 511; //x = (x + 2)/4;
    if (x < 0) x = 0; else { if(x > 1023) x = 1023;}
    y = (y + 2)/4; y = y + 511; 
    if (y < 0) y = 0; else { if(y > 1023) y = 1023;}
    z = (z + 2)/4; z = z + 511; 
    if (z < 0) z = 0; else { if(z > 1023) z = 1023;}
    
    CRASH_ACC_buf [0][CRASH_ACC_W_ptr] = 0;
    CRASH_ACC_buf [0][CRASH_ACC_W_ptr] = CRASH_ACC_buf [0][CRASH_ACC_W_ptr] + x;
    CRASH_ACC_buf [0][CRASH_ACC_W_ptr] = CRASH_ACC_buf [0][CRASH_ACC_W_ptr] << 10;
    CRASH_ACC_buf [0][CRASH_ACC_W_ptr] = CRASH_ACC_buf [0][CRASH_ACC_W_ptr] + y;
    CRASH_ACC_buf [0][CRASH_ACC_W_ptr] = CRASH_ACC_buf [0][CRASH_ACC_W_ptr] << 10;
    CRASH_ACC_buf [0][CRASH_ACC_W_ptr] = CRASH_ACC_buf [0][CRASH_ACC_W_ptr] + z;

    if (ignition == 0) {
        if ( crash_trh_switch_timer < 3000 ) crash_trh_switch_timer ++;
        else {
            xy_trh   = CRASHSETIGNOFFbits.gxy;
            xyz_trh  = CRASHSETIGNOFFbits.gxyz; 
            duration = CRASHSETIGNOFFbits.duration;            
        }
    } 
    else {
        crash_trh_switch_timer = 0;
        xy_trh   = CRASHSETbits.gxy;
        xyz_trh  = CRASHSETbits.gxyz; 
        duration = CRASHSETbits.duration;         
    }

if (SERVFLAGSbits.serv_status == 1) crash_counter = 0;
    
    if (crash_detection_type == 0) {
        if (CRASHSAVETASKbits.CRASHSAVETASK == 0) { // Детектирование краша в период записи предыдущего во флэшь запрещено  
            if (Gxyi > xy_trh && Gxyzi > xyz_trh && crash_trigger == 0) { crash_counter++; } else crash_counter = 0;
            Nop();Nop();Nop(); 
            if ( generate_crash_flag == 1 ) { // Искусственная генерация краша
                crash_counter = duration + 1;
                generate_crash_flag = 0;
            }
        }
    } else {
        if (CRASHSAVETASKbits.CRASHSAVETASK == 0) { // Детектирование краша в период записи предыдущего во флэшь запрещено  
            if (Gxyi > xy_trh && crash_trigger == 0) { crash_counter++; } else crash_counter = 0;
            Nop();Nop();Nop();
//            zi = Gzi - 256;
//            if ( zi < 0 ) zi = -1 * zi;
//            if (zi > xyz_trh && crash_trigger == 0) { crash_counter1++; } else crash_counter1 = 0;
            if ( generate_crash_flag == 1 ) { // Искусственная генерация краша
                crash_counter = duration + 1;
                generate_crash_flag = 0;
            }
        }  
    }

    
    if (crash_counter > duration || crash_counter1 > duration) {
        if (CRASHTASKbits.crash_trigger == 0) {
//            Gx_test = 0; Gy_test = 0; Gz_test = 255;
            CRASHTASKbits.crash_trigger = 1;
            crash_counter = 0;
            crash_counter1 = 0;
            CRASH_ACC_point_ptr = CRASH_ACC_W_ptr;
            if (CRASH_TREK_W_ptr != 0) CRASH_TREK_point_ptr = CRASH_TREK_W_ptr - 1;
            else CRASH_TREK_point_ptr = 19;
        }
    }
    if (CRASHTASKbits.crash_trigger == 1) {
        if (CRASHTASKbits.post_acc_counter <= 299 ) CRASHTASKbits.post_acc_counter ++;
        else {
            CRASHTASKbits.crash_record_done = 1;
            
        }
    }

    CRASH_ACC_W_ptr ++; CRASH_ACC_W_ptr %= 600;
}
void crash_trek_record (void) {

    if (CRASHTASKbits.trek_record_done == 1) return;

    
   memmove ( &CRASH_TREK_buf [CRASH_TREK_W_ptr][0], &Navi_bin, 22 );
   CRASH_TREK_W_ptr ++; 
   CRASH_TREK_W_ptr  %= 20;

    if (CRASHTASKbits.crash_trigger == 1) {
        if (CRASHTASKbits.post_trek_counter <= 9 ) CRASHTASKbits.post_trek_counter ++;
        else {
            CRASHTASKbits.trek_record_done = 1;
            
        }
    }
    
}
void tilt_detection ( char source ) {

static unsigned int Gtrh, ready_flag = 0, tilt_counter = 0; //tilt_overage_counter = 0,
volatile static int /*temp_Gxyi, temp_h, temp_l,*/ Gxi_trh = 0, Gyi_trh = 0;
static long Gxy_overage = 0, Gxi_overage = 0, Gyi_overage = 0;
    
    if ( ignition == 1 || SERVFLAGSbits.serv_status == 1 || source == 1 ) { 
        tilt_counter = 0; ready_flag = 0; 
        Gxy_overage = 0; tilt_overage_counter = 0; 
        TILTFLAGSbits.TILTFLAGS =  0;
        tilt_delay_counter = 0;
        return;
    }
//    if (sleep_counter < 300) { tilt_counter = 0;ready_flag = 0; Gxy_overage = 0; tilt_overage_counter = 0; return; }
//    Gxyi = 50;
//    if (sleep_counter < 300) return;

    if ( tilt_delay_counter < 3000 ) {
        tilt_delay_counter ++;
        return;
    }

    if (tilt_overage_counter < 100) {
        if (tilt_overage_counter == 0) {
            Gxy_overage = 0;
            Gxi_overage = 0;
            Gyi_overage = 0;            
        }
        tilt_overage_counter ++;
        ready_flag = 0;
            Nop();Nop();Nop();
            Gxy_overage = Gxy_overage + Gxyi;
            Gxi_overage = Gxi_overage + Gxi;
            Gyi_overage = Gyi_overage + Gyi;
        if(tilt_overage_counter == 100) {
            Gxy_overage = (Gxy_overage + 50) / 100;
            Gxi_overage = Gxi_overage / 100;
            Gyi_overage = Gyi_overage / 100;
            Gxi_trh = (int) Gxi_overage;
            Gyi_trh = (int) Gyi_overage;
            Gtrh = (unsigned int) Gxy_overage;
            ready_flag = 1;
        }
        
    }

    if (ready_flag == 1) {
        Gxi_overage = Gxi - Gxi_trh;
        Gyi_overage = Gyi - Gyi_trh;
        Gxy_overage = Gxi_overage * Gxi_overage + Gyi_overage * Gyi_overage;
        Gxy_overage = sqrt (Gxy_overage);
        
//        temp_Gxyi = Gxyi - Gtrh;
        Nop();Nop();Nop();
//        if ( temp_Gxyi < 0 ) temp_Gxyi = -1 * temp_Gxyi;
//        temp_h =  (int)( (int)Gtrh + (int)TILTSETbits.treshold );
//        temp_l =  (int)( (int)Gtrh - (int)TILTSETbits.treshold );
//        Nop();Nop();Nop();
        if ( TILTFLAGSbits.tilt_on_event == 0 )  { // ( temp_Gxyi < temp_h && temp_Gxyi > temp_l ) || 
            Nop();Nop();Nop();
            if ( (unsigned int)Gxy_overage > TILTSETbits.treshold ) { // temp_Gxyi < temp_h && temp_Gxyi > temp_l 
                tilt_counter ++; 
            } else {
                tilt_counter = 0;
            }
        } else { 
            Nop();Nop();Nop();
            tilt_counter = 0;
        }

        if (tilt_counter > TILTSETbits.duration) { //8
            TILTFLAGSbits.tilt_on_event = 1;
            tilt_counter = 0;
            tilt_off_timer = tilt_off_timer_setting * 6000;
        }
    }

    if ( TILTFLAGSbits.tilt_on_event == 1 ) {
        if ( tilt_off_timer > 0 ) tilt_off_timer --;
        else {
            Nop();Nop();Nop();
            TILTFLAGSbits.TILTFLAGS = 0;
        }
    }

/*
    if (ready_flag == 1) {
        if ( Gxyi > (Gtrh + TILTSETbits.treshold) && TILTFLAGSbits.tilt_on_event == 0) { tilt_counter++; } else tilt_counter = 0;//50

        if (tilt_counter > TILTSETbits.duration) { //8
            TILTFLAGSbits.tilt_on_event = 1;
            tilt_counter = 0;
        }
    } 
*/
}
void tilt_message_generator (void) {

    if (TILTFLAGSbits.tilt_on_event == 1 && TILTFLAGSbits.tilt_on_event_sent == 0) {
        
        if (TILTFLAGSbits.tilt_delay_timer < 3000) {TILTFLAGSbits.tilt_delay_timer ++; }
        else {
            TILTFLAGSbits.tilt_delay_timer = 0;
            TILTFLAGSbits.tilt_on_event_sent = 1;
/*            
            reload_GPRS_header ( 3, 40, 0x0011); // N = 3, name = 30, type = 1, ACK = 1
            memmove ( command_temp_buf, GPRS_header_buf, 12 );
            unsigned int ACK_counter = 0xFFFF;
            command_temp_buf[12] = (unsigned char) (ACK_counter >> 8); command_temp_buf[13] = (unsigned char) ACK_counter; // ACK
            command_temp_buf[14] = 0xFF; command_temp_buf[15] = 0x01; // Dataflags
            memmove  ( &command_temp_buf[16], Navi_bin, 22 );
            command_temp_buf[113] = 38; //38
            write_data_into_save_to_flash_bufs ( command_temp_buf, 38 );            
*/
            generate_content_of_message ( 40, 1 );            
            
        }
        
    }
    
}

void beep_task (void) {
//unsigned int puls, unsigned int pause, unsigned char beep_num;
static unsigned int puls = 0, pause = 0;
static unsigned char beep_num = 0;

    if ( BEEPFLAGSbits.start != 1 ) return;
    
    if ( BEEPFLAGSbits.running == 0 ) {
        BEEPFLAGSbits.running = 1;
        puls = BEEPFLAGSbits.pulse;
        pause = BEEPFLAGSbits.pause;
        beep_num = BEEPFLAGSbits.num;
        PMD1bits.T5MD   = 0;
        T5CON = 0x8000;
        PR5 = 3704;
        IEC1bits.T5IE = 1;        
    }

    if ( beep_num > 0 ) {
        if (puls > 0) {
            puls --;
            _TRISD8 = 0;
            
        } else {
            _TRISD8 = 1;
            pause --;
                if ( pause == 0 ) {
                        if ( beep_num > 0 ) {
                            beep_num --;                    
                            puls = BEEPFLAGSbits.pulse;
                            pause = BEEPFLAGSbits.pause;
                        }                    
//                        else {
//                            stop_beep_task ();
//                        }

                }
        }
    } 
    else {
        stop_beep_task ();
    } 
}
void start_beep_task (unsigned int puls, unsigned int pause, unsigned char beep_num) {
    
    stop_beep_task ();
    BEEPFLAGSbits.start = 1;
    BEEPFLAGSbits.pulse = puls;
    BEEPFLAGSbits.pause = pause;
    BEEPFLAGSbits.num = beep_num;
    
}
void stop_beep_task (void) {

    _TRISD8 = 1;    
    BEEPFLAGSbits.BEEPFLAGS = 0;
    PMD1bits.T5MD = 1;
	IEC1bits.T5IE = 0;
    IFS1bits.T5IF = 0;    
    T5CON = 0x0000;
    TMR5 = 0;
    
}

int configure_GSM_modul_uc15 (void) {

int i;

    if (GSMSTATUSbits.power == 1) {modem_on_off (MODEM_EMERG_RST);}
    else {modem_on_off (MODEM_ON);}  

for ( i = 0; i < 4000; i ++ ) {
    asm("clrwdt");
    __delay_ms (10);
}

for ( i = 0; i < 5; i ++ ) {
    start_UART1_transmission ( WAITON, (unsigned int)load_UART1_Tx_buf ("at\r\0") );
    __delay_ms (200);
}
Nop();Nop();Nop();

    start_UART1_transmission ( WAITON, (unsigned int)load_UART1_Tx_buf ("at+ipr=115200\r\0") );
    __delay_ms (250);
    __delay_ms (250);
    Nop();Nop();Nop();
    start_UART1_transmission ( WAITON, (unsigned int)load_UART1_Tx_buf ("at+cmgf=1\r\0") );
    __delay_ms (250);
    __delay_ms (250);
    Nop();Nop();Nop();
    start_UART1_transmission ( WAITON, (unsigned int)load_UART1_Tx_buf ("at+cscs=\"IRA\"\r\0") );
    __delay_ms (250);
    __delay_ms (250);
    Nop();Nop();Nop();
    start_UART1_transmission ( WAITON, (unsigned int)load_UART1_Tx_buf ("at+creg=1\r\0") );
    __delay_ms (250);
    __delay_ms (250);
    Nop();Nop();Nop();
    start_UART1_transmission ( WAITON, (unsigned int)load_UART1_Tx_buf ("at+cgreg=1\r\0") );
    __delay_ms (250);
    __delay_ms (250);
    Nop();Nop();Nop();
    start_UART1_transmission ( WAITON, (unsigned int)load_UART1_Tx_buf ("ate0\r\0") );
    __delay_ms (250);
    __delay_ms (250); 
    Nop();Nop();Nop();
//    start_UART1_transmission ( WAITOFF, (unsigned int)load_UART1_Tx_buf ("at+qsclk=1\r\0") );    
//    __delay_ms (250);
//    __delay_ms (250);
    start_UART1_transmission ( WAITON, (unsigned int)load_UART1_Tx_buf ("at&w\r\0") );
    __delay_ms (250);
    __delay_ms (250);__delay_ms (250);
    Nop();Nop();Nop();
    start_UART1_transmission ( WAITON, (unsigned int)load_UART1_Tx_buf ("at+gsn\r\0") );
    __delay_ms (250);
    __delay_ms (250);__delay_ms (250);
    Nop();Nop();Nop();
    
    Nop();Nop();Nop();    
    i = read_IMEI_from_UART1_buf ();
    
    if ( i == 1) init_TYPE0 ();
    
return i;    
}
int configure_GSM_modul (void) {

int i;

    if (GSMSTATUSbits.power == 1) {modem_on_off (MODEM_EMERG_RST);}
    else {modem_on_off (MODEM_ON);}  

for ( i = 0; i < 4000; i ++ ) {
    asm("clrwdt");
    __delay_ms (10);
}

for ( i = 0; i < 5; i ++ ) {
    start_UART1_transmission ( WAITON, (unsigned int)load_UART1_Tx_buf ("at\r\0") );
    __delay_ms (200);
}
Nop();Nop();Nop();

    start_UART1_transmission ( WAITON, (unsigned int)load_UART1_Tx_buf ("at+ipr=115200\r\0") );
    __delay_ms (250);
    __delay_ms (250);
    start_UART1_transmission ( WAITON, (unsigned int)load_UART1_Tx_buf ("at+cmgf=1\r\0") );
    __delay_ms (250);
    __delay_ms (250);
# if defined (UC15)
    start_UART1_transmission ( WAITON, (unsigned int)load_UART1_Tx_buf ("at+cscs=\"UCS2\"\r\0") );
# else
    start_UART1_transmission ( WAITON, (unsigned int)load_UART1_Tx_buf ("at+cscs=\"pccp437\"\r\0") );
# endif
    __delay_ms (250);
    __delay_ms (250);
    start_UART1_transmission ( WAITON, (unsigned int)load_UART1_Tx_buf ("at+creg=1\r\0") );
    __delay_ms (250);
    __delay_ms (250);
    start_UART1_transmission ( WAITON, (unsigned int)load_UART1_Tx_buf ("at+cgreg=1\r\0") );
    __delay_ms (250);
    __delay_ms (250);
    start_UART1_transmission ( WAITON, (unsigned int)load_UART1_Tx_buf ("ate0\r\0") );
    __delay_ms (250);
    __delay_ms (250);    
//    start_UART1_transmission ( WAITOFF, (unsigned int)load_UART1_Tx_buf ("at+qsclk=1\r\0") );    
//    __delay_ms (250);
//    __delay_ms (250);
# if defined (UC15)    
    start_UART1_transmission ( WAITOFF, (unsigned int)load_UART1_Tx_buf ("AT+QINDCFG=\"all\",1\r\0") );    
    __delay_ms (250);
    __delay_ms (250);
    
    start_UART1_transmission ( WAITOFF, (unsigned int)load_UART1_Tx_buf ("AT+QURCCFG=\"urcport\",\"uart1\"\r\0") );    
    __delay_ms (250);
    __delay_ms (250);            
# endif
    start_UART1_transmission ( WAITON, (unsigned int)load_UART1_Tx_buf ("at&w\r\0") );
    __delay_ms (250);
    __delay_ms (250);__delay_ms (250);
# if defined (UC15)
    start_UART1_transmission ( WAITON, (unsigned int)load_UART1_Tx_buf ("at+cgsn\r\0") );
# else    
    start_UART1_transmission ( WAITON, (unsigned int)load_UART1_Tx_buf ("at+qgsn\r\0") );
# endif
    __delay_ms (250);
    __delay_ms (250);__delay_ms (250);
    Nop();Nop();Nop();
    
    Nop();Nop();Nop();    
    i = read_IMEI_from_UART1_buf ();
    
    if ( i == 1) init_TYPE0 ();
    
return i;    
}
void get_IMEI (void) {
    if (GSMSTATUSbits.rdy == 1 && MODEMTASCKSbits.onoff == 1 && GEIMEIbits.start == 0) {
        GEIMEIbits.start = 1;
# if defined (UC15) 
            start_UART1_transmission ( WAITOFF, (unsigned int)load_UART1_Tx_buf ("at+cgsn\r\0") );
# else
            start_UART1_transmission ( WAITOFF, (unsigned int)load_UART1_Tx_buf ("at+qgsn\r\0") );//;+QSCLK=1
# endif
    }
}
int read_IMEI_from_UART1_buf (void) {
    unsigned int temp, i; char *ptr;
    
    ptr = &UART1_Rx_buf;
Nop();Nop();Nop();
# if defined (UC15)
//    temp = strstr( ptr + 150, "+GSN" );
//    if ( UART1_Rx_buf[U1_num_W_tmp - 29] == "O" && UART1_Rx_buf[U1_num_W_tmp - 28] == "K" &&
//         UART1_Rx_buf[U1_num_W_tmp - 3]  == "O" && UART1_Rx_buf[U1_num_W_tmp - 2]  == "K" ) {
        temp = &UART1_Rx_buf[U1_num_W_tmp - 23];
        temp = temp - 8;
//    } else temp = 0;

# else
    temp = strstr( ptr + 150, "+QGSN" );
# endif    
    if (temp == 0) return 0;
    
    ptr = temp + 8;
    for (i = 0; i < 15; i ++) {
        IMEI_str [i] = *(ptr ++);
    }
    IMEI_str [15] = 0;
    return 1;
    
}
void init_TYPE0 (void) {

    TYPE0 [0] = 0x26;
    TYPE0 [1] = (( IMEI_str [0] - 0x30 ) << 4) + ( IMEI_str [1] - 0x30 );
    TYPE0 [2] = (( IMEI_str [2] - 0x30 ) << 4) + ( IMEI_str [3] - 0x30 );
    TYPE0 [3] = (( IMEI_str [4] - 0x30 ) << 4) + ( IMEI_str [5] - 0x30 );
    TYPE0 [4] = (( IMEI_str [6] - 0x30 ) << 4) + ( IMEI_str [7] - 0x30 );
    TYPE0 [5] = (( IMEI_str [8] - 0x30 ) << 4) + ( IMEI_str [9] - 0x30 );
    TYPE0 [6] = (( IMEI_str [10] - 0x30 ) << 4) + ( IMEI_str [11] - 0x30 );
    TYPE0 [7] = (( IMEI_str [12] - 0x30 ) << 4) + ( IMEI_str [13] - 0x30 );
    TYPE0 [8] = (( IMEI_str [14] - 0x30 ) << 4);
Nop();Nop();Nop();     
}

/* FRAM ПАМЯТЬ */
int FM25_write_enable (void) {
IEC3bits.T8IE = 0;
	CS_FM25 = 0;
		SPI1BUF = 0b00000110;	while (!SPI1STATbits.SPIRBF);
	CS_FM25 = 1;
IEC3bits.T8IE = 1;
return SPI1BUF;
} // Разрешение записи в FM25
int FM25_write_desable (void) {
IEC3bits.T8IE = 0;
	CS_FM25 = 0;
		SPI1BUF = 0b00000100;	while (!SPI1STATbits.SPIRBF);
	CS_FM25 = 1;
IEC3bits.T8IE = 1;
return SPI1BUF;
} // Запрещение записи в FM25
int FM25_read_status (void) {
    int temp;
IEC3bits.T8IE = 0;    
	CS_FM25 = 0;
		SPI1BUF = 0b00000101;	while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = 0b00000000;	while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
	CS_FM25 = 1;
IEC3bits.T8IE = 1;
return temp;
}  // Разрешение записи в FM25
int FM25_write_8 (unsigned int address, unsigned long long data) {
    int temp;
IEC3bits.T8IE = 0;    
	CS_FM25 = 0;
		SPI1BUF = 0b00000110;	while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
	CS_FM25 = 1;
	asm ("nop"); asm ("nop"); asm ("nop");
	CS_FM25 = 0;
        SPI1BUF =  0x02;            while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (address >> 8);	while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF =  address;	        while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (data >> 56);     while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (data >> 48);     while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (data >> 40);     while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (data >> 32);     while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (data >> 24);     while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;        
        SPI1BUF = (data >> 16);     while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;        
        SPI1BUF = (data >> 8);      while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF =  data;            while (!SPI1STATbits.SPIRBF);

	CS_FM25 = 1;
	asm ("nop");
IEC3bits.T8IE = 1;    
return SPI1BUF;
} //
int FM25_write_7 (unsigned int address, unsigned long long data) {
    int temp;
IEC3bits.T8IE = 0;    
	CS_FM25 = 0;
		SPI1BUF = 0b00000110;	while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
	CS_FM25 = 1;
	asm ("nop"); asm ("nop"); asm ("nop");
	CS_FM25 = 0;
        SPI1BUF =  0x02;            while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (address >> 8);	while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF =  address;	        while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (data >> 48);     while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (data >> 40);     while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (data >> 32);     while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (data >> 24);     while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;        
        SPI1BUF = (data >> 16);     while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;        
        SPI1BUF = (data >> 8);      while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF =  data;            while (!SPI1STATbits.SPIRBF);

	CS_FM25 = 1;
	asm ("nop");
IEC3bits.T8IE = 1;    
return SPI1BUF;
} //
int FM25_write_6 (unsigned int address, unsigned long long data) {
    int temp;
IEC3bits.T8IE = 0;    
	CS_FM25 = 0;
		SPI1BUF = 0b00000110;	while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
	CS_FM25 = 1;
	asm ("nop"); asm ("nop"); asm ("nop");
	CS_FM25 = 0;
        SPI1BUF =  0x02;            while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (address >> 8);	while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF =  address;	        while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (data >> 40);     while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (data >> 32);     while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (data >> 24);     while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;        
        SPI1BUF = (data >> 16);     while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;        
        SPI1BUF = (data >> 8);      while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF =  data;            while (!SPI1STATbits.SPIRBF);

	CS_FM25 = 1;
	asm ("nop");
IEC3bits.T8IE = 1;    
return SPI1BUF;
} //
int FM25_write_5 (unsigned int address, unsigned long long data) {
    int temp;
IEC3bits.T8IE = 0;    
	CS_FM25 = 0;
		SPI1BUF = 0b00000110;	while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
	CS_FM25 = 1;
	asm ("nop"); asm ("nop"); asm ("nop");
	CS_FM25 = 0;
        SPI1BUF =  0x02;            while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (address >> 8);	while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF =  address;	        while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (data >> 32);     while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (data >> 24);     while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;        
        SPI1BUF = (data >> 16);     while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;        
        SPI1BUF = (data >> 8);      while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF =  data;            while (!SPI1STATbits.SPIRBF);

	CS_FM25 = 1;
	asm ("nop");
IEC3bits.T8IE = 1;    
return SPI1BUF;
} //
int FM25_write_4 (unsigned int address, unsigned long data) {
    int temp;
IEC3bits.T8IE = 0;    
	CS_FM25 = 0;
		SPI1BUF = 0b00000110;	while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
	CS_FM25 = 1;
	asm ("nop"); asm ("nop"); asm ("nop");
	CS_FM25 = 0;
        SPI1BUF =  0x02;            while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (address >> 8);	while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF =  address;	        while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (data >> 24);     while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;        
        SPI1BUF = (data >> 16);     while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;        
        SPI1BUF = (data >> 8);      while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF =  data;            while (!SPI1STATbits.SPIRBF);

	CS_FM25 = 1;
	asm ("nop");
IEC3bits.T8IE = 1;    
return SPI1BUF;
} //
int FM25_write_2 (unsigned int address, unsigned int data) {
    int temp;
IEC3bits.T8IE = 0;    
	CS_FM25 = 0;
		SPI1BUF = 0b00000110;	while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
	CS_FM25 = 1;
	asm ("nop"); asm ("nop"); asm ("nop");
	CS_FM25 = 0;
        SPI1BUF =  0x02;            while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (address >> 8);	while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF =  address;	        while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (data >> 8);      while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF =  data;            while (!SPI1STATbits.SPIRBF);
//		writeSPI1(0x02); // Команда чтения  
//		writeSPI1(address >> 8);
//		writeSPI1(address);
//		writeSPI1(data >> 8);
//		writeSPI1(data);
	CS_FM25 = 1;
	asm ("nop");
IEC3bits.T8IE = 1;    
return SPI1BUF;
} // 
int FM25_write_1 (unsigned int address, unsigned int data) {
    int temp;
IEC3bits.T8IE = 0;    
	CS_FM25 = 0;
		SPI1BUF = 0b00000110;	while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
	CS_FM25 = 1;
	asm ("nop"); asm ("nop"); asm ("nop");
	CS_FM25 = 0;
        SPI1BUF =  0x02;            while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (address >> 8);	while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF =  address;	        while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF =  data;            while (!SPI1STATbits.SPIRBF);
	CS_FM25 = 1;
	asm ("nop");
IEC3bits.T8IE = 1;    
return SPI1BUF;
} //

int FM25_write_4_signed (unsigned int address, long data) {
    int temp;
IEC3bits.T8IE = 0;    
	CS_FM25 = 0;
		SPI1BUF = 0b00000110;	while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
	CS_FM25 = 1;
	asm ("nop"); asm ("nop"); asm ("nop");
	CS_FM25 = 0;
        SPI1BUF =  0x02;            while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (address >> 8);	while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF =  address;	        while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (data >> 24);     while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;        
        SPI1BUF = (data >> 16);     while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;        
        SPI1BUF = (data >> 8);      while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF =  data;            while (!SPI1STATbits.SPIRBF);

	CS_FM25 = 1;
	asm ("nop");
IEC3bits.T8IE = 1;    
return SPI1BUF;
} //
int FM25_write_2_signed (unsigned int address, int data) {
    int temp;
IEC3bits.T8IE = 0;    
	CS_FM25 = 0;
		SPI1BUF = 0b00000110;	while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
	CS_FM25 = 1;
	asm ("nop"); asm ("nop"); asm ("nop");
	CS_FM25 = 0;
        SPI1BUF =  0x02;            while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (address >> 8);	while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF =  address;	        while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = (data >> 8);      while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF =  data;            while (!SPI1STATbits.SPIRBF);
//		writeSPI1(0x02); // Команда чтения  
//		writeSPI1(address >> 8);
//		writeSPI1(address);
//		writeSPI1(data >> 8);
//		writeSPI1(data);
	CS_FM25 = 1;
	asm ("nop");
IEC3bits.T8IE = 1;    
return SPI1BUF;
} // 


unsigned long long FM25_read_8 (unsigned int address) {
unsigned long long result;
unsigned int temp;
IEC3bits.T8IE = 0;
    result = 0;
	CS_FM25 = 0;
		SPI1BUF = 0x03;           while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;// Команда чтения  
		SPI1BUF = (address >> 8); while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
		SPI1BUF = address;        while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
		SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result =                 (unsigned long long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long long) SPI1BUF;
	CS_FM25 = 1;

IEC3bits.T8IE = 1;    
return result;
} // RFM22_spi_R_W()
unsigned long long FM25_read_7 (unsigned int address) {
unsigned long long result;
unsigned int temp;
IEC3bits.T8IE = 0;
    result = 0;
	CS_FM25 = 0;
		SPI1BUF = 0x03;           while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;// Команда чтения  
		SPI1BUF = (address >> 8); while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
		SPI1BUF = address;        while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
		SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result =                 (unsigned long long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long long) SPI1BUF;
	CS_FM25 = 1;

IEC3bits.T8IE = 1;    
return result;
} // RFM22_spi_R_W()
unsigned long long FM25_read_6 (unsigned int address) {
unsigned long long result;
unsigned int temp;
IEC3bits.T8IE = 0;
    result = 0;
	CS_FM25 = 0;
		SPI1BUF = 0x03;           while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;// Команда чтения  
		SPI1BUF = (address >> 8); while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
		SPI1BUF = address;        while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
		SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result =                 (unsigned long long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long long) SPI1BUF;
	CS_FM25 = 1;

IEC3bits.T8IE = 1;    
return result;
} // RFM22_spi_R_W()
unsigned long long FM25_read_5 (unsigned int address) {
unsigned long long result;
unsigned int temp;
IEC3bits.T8IE = 0;
    result = 0;
	CS_FM25 = 0;
		SPI1BUF = 0x03;           while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;// Команда чтения  
		SPI1BUF = (address >> 8); while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
		SPI1BUF = address;        while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
		SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result =                 (unsigned long long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long long) SPI1BUF;
	CS_FM25 = 1;

IEC3bits.T8IE = 1;    
return result;
} // RFM22_spi_R_W()
unsigned long FM25_read_4 (unsigned int address) {
unsigned long result;
unsigned int temp;
IEC3bits.T8IE = 0;
    result = 0;
	CS_FM25 = 0;
		SPI1BUF = 0x03;           while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;// Команда чтения  
		SPI1BUF = (address >> 8); while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
		SPI1BUF = address;        while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
		SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result =                 (unsigned long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long) SPI1BUF;        
	CS_FM25 = 1;
IEC3bits.T8IE = 1;
    
return result;
} // RFM22_spi_R_W()
int FM25_read_2 (unsigned int address) {
unsigned int result;
IEC3bits.T8IE = 0;
	CS_FM25 = 0;
		writeSPI1(0x03); // Команда чтения  
		writeSPI1(address >> 8);
		writeSPI1(address);
		result = writeSPI1(0x00);
		result = result << 8;
		result = result + writeSPI1(0x00);
	CS_FM25 = 1;
	asm ("nop");
IEC3bits.T8IE = 1;    
return result;
} // RFM22_spi_R_W()
char FM25_read_1 (unsigned int address) {
unsigned int result;
IEC3bits.T8IE = 0;
	CS_FM25 = 0;
		writeSPI1(0x03); // Команда чтения  
		writeSPI1(address >> 8);
		writeSPI1(address);
		result = writeSPI1(0x00);
	CS_FM25 = 1;
	asm ("nop");
IEC3bits.T8IE = 1;    
return (char) result;
} // RFM22_spi_R_W()

long FM25_read_4_signed (unsigned int address) {
unsigned long result;
unsigned int temp;
IEC3bits.T8IE = 0;
    result = 0;
	CS_FM25 = 0;
		SPI1BUF = 0x03;           while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;// Команда чтения  
		SPI1BUF = (address >> 8); while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
		SPI1BUF = address;        while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
		SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result =                 (unsigned long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long) SPI1BUF;
        SPI1BUF = 0x00;           while (!SPI1STATbits.SPIRBF); result = (result << 8) + (unsigned long) SPI1BUF;        
	CS_FM25 = 1;
IEC3bits.T8IE = 1;
    
return (long)result;
} // RFM22_spi_R_W()
int FM25_read_2_signed (unsigned int address) {
unsigned int result;
IEC3bits.T8IE = 0;
	CS_FM25 = 0;
		writeSPI1(0x03); // Команда чтения  
		writeSPI1(address >> 8);
		writeSPI1(address);
		result = writeSPI1(0x00);
		result = result << 8;
		result = result + writeSPI1(0x00);
	CS_FM25 = 1;
	asm ("nop");
IEC3bits.T8IE = 1;    
return result;
} // RFM22_spi_R_W()


/* РАДИОКАНАЛ */
int  writeSPI3(int data){
	SPI3BUF = data;
	while (!SPI3STATbits.SPIRBF);
return SPI3BUF;
}	// writeSPI1()
void Si4461_init (void) {

	Si4461_CMD_stream ( GPIO_PIN_CFG, 8 );
	wait_ready ();
    Si4461_CMD_stream (GPIO_PIN_CFG, 1); // чтение конф. IO GPIO_PIN_CFG[8]= { 0x13, 0x07, 0x08, 0x20, 0x21, 0x27, 0x00, 0x00 };
//    while (Si4461_get_reply_stream ( READ_CMD_BUFF, 7 ) != 0xFF);
//    Nop();Nop();Nop();
	Si4461_CMD_stream ( GLOBAL_XO_TUNE_1, 5 );
	wait_ready ();
	Si4461_CMD_stream ( GLOBAL_CLK_CFG_1, 5 );
	wait_ready ();
	Si4461_CMD_stream ( GLOBAL_CONFIG_1, 5 );
	wait_ready ();
	Si4461_CMD_stream ( INT_CTL_ENABLE_3, 8 );
	wait_ready ();
//	Si4461_CMD_stream ( INT_CTL_ENABLE_3, 7 );
//	wait_ready ();
	Si4461_CMD_stream ( FRR_CTL_A_MODE_4, 8 );
	wait_ready ();
	Si4461_CMD_stream ( PREAMBLE_TX_LENGTH_9, 13 );
	wait_ready ();
	Si4461_CMD_stream ( SYNC_CONFIG, 5 );
	wait_ready ();
//	Si4461_CMD_stream ( SYNC_BITS, 8 );
//	wait_ready ();
	Si4461_CMD_stream ( PKT_CRC_CONFIG_1, 5 );
	wait_ready ();
	Si4461_CMD_stream ( PKT_WHT_SEED_15_8_4, 8 );
	wait_ready ();
	Si4461_CMD_stream ( PKT_LEN_12, 16 );
	wait_ready ();
//	Si4461_CMD_stream ( PH_RX_DIS, 5 );
//	wait_ready ();

	Si4461_CMD_stream ( PKT_FIELD_2_CRC_CONFIG_12, 16 );
	wait_ready ();
	Si4461_CMD_stream ( PKT_FIELD_5_CRC_CONFIG_1, 5 );
	wait_ready ();
	Si4461_CMD_stream ( MODEM_MOD_TYPE_12, 16 );
	wait_ready ();
	Si4461_CMD_stream ( MODEM_FREQ_DEV_0_1, 5 );
	wait_ready ();
	Si4461_CMD_stream ( MODEM_TX_RAMP_DELAY_8, 12 );
	wait_ready ();
	Si4461_CMD_stream ( MODEM_BCR_OSR_1_9, 13 );
	wait_ready ();
	Si4461_CMD_stream ( MODEM_AFC_GEAR_7, 11 );
	wait_ready ();
	Si4461_CMD_stream ( MODEM_AGC_CONTROL_1, 5 );
	wait_ready ();
	Si4461_CMD_stream ( MODEM_AGC_WINDOW_SIZE_9, 13 );
	wait_ready ();
	Si4461_CMD_stream ( MODEM_OOK_CNT1_11, 15 );
	wait_ready ();
	Si4461_CMD_stream ( MODEM_RSSI_COMP_1, 5 );
	wait_ready ();
	Si4461_CMD_stream ( MODEM_CLKGEN_BAND_1, 5 );
	wait_ready ();
	Si4461_CMD_stream ( MODEM_CHFLT_RX1_CHFLT_COE13_7_0_12, 16 );
	wait_ready ();
	Si4461_CMD_stream ( MODEM_CHFLT_RX1_CHFLT_COE1_7_0_12, 16 );
	wait_ready ();
	Si4461_CMD_stream ( MODEM_CHFLT_RX2_CHFLT_COE7_7_0_12, 16 );
	wait_ready ();
	Si4461_CMD_stream ( PA_MODE_4, 8 );
	wait_ready ();
	Si4461_CMD_stream ( SYNTH_PFDCP_CPFF_7, 11 );
	wait_ready ();
	Si4461_CMD_stream ( MATCH_VALUE_1_12, 16 );
	wait_ready ();
	Si4461_CMD_stream ( FREQ_CONTROL_INTE_8, 12 );
	wait_ready ();

}
void wait_ready (void) {
 
	while (Si4461_get_reply_stream ( READ_CMD_BUFF, 0 ) != 0xFF); 

}
void Si4461_CMD_stream (unsigned char *CMD_ptr, unsigned int lenth) {
unsigned char tmp, j;

	CS_SI4461 = 0;
	for (j = 0; j < lenth; j ++) {
		SPI3BUF = * CMD_ptr ++; while (!SPI3STATbits.SPIRBF); tmp = SPI3BUF;
	}
	CS_SI4461 = 1;

} // void Si4461_CMD_stream
int  Si4461_get_reply_stream (unsigned char * CMD_ptr, unsigned int lenth) {
unsigned char CTS, j;

	CS_SI4461 = 0;

		SPI3BUF = * CMD_ptr; while (!SPI3STATbits.SPIRBF); CTS = SPI3BUF;

		SPI3BUF = 0;         while (!SPI3STATbits.SPIRBF); CTS = SPI3BUF;
		if ( CTS != 0xFF ) {
			CS_SI4461 = 1;
			return 0;
		}
        for (j = 0; j < lenth; j ++) {
            SPI3BUF = 0; while (!SPI3STATbits.SPIRBF); Si4461_buf[j] = (unsigned char)SPI3BUF;
        }
	CS_SI4461 = 1;

return CTS;
} // Si4461_get_reply_stream
void Si4461_interrupt_reset (void) {
	Si4461_CMD_stream ( GET_INT_STATUS, 1 );
	wait_ready ();
}
void Si4461_GET_property (unsigned int GROUP, unsigned int NUM_PROPS, unsigned int START_PROP, int lenth) {
unsigned char tmp, j;

	CS_SI4461 = 0;

		SPI3BUF = 0x12;       while (!SPI3STATbits.SPIRBF); tmp = SPI3BUF;
		SPI3BUF = GROUP;      while (!SPI3STATbits.SPIRBF); tmp = SPI3BUF;
		SPI3BUF = NUM_PROPS;  while (!SPI3STATbits.SPIRBF); tmp = SPI3BUF;
		SPI3BUF = START_PROP; while (!SPI3STATbits.SPIRBF); tmp = SPI3BUF;
        
        SPI3BUF = 0;         while (!SPI3STATbits.SPIRBF); tmp = SPI3BUF;
		if ( tmp != 0xFF ) {
			CS_SI4461 = 1;
			return 0;
		}
        
        for (j = 0; j < lenth; j ++) {
            SPI3BUF = 0; while (!SPI3STATbits.SPIRBF); Si4461_buf[j] = SPI3BUF;
        }

	CS_SI4461 = 1;

} 
void Si4461_start_receiving () {
    
//    if (rel == 0) {    
    // Переход из режима RECEIVE в режим READY
        Si4461_interrupt_reset ();
        CHANGE_STATE[1] = READY;
        Si4461_CMD_stream ( CHANGE_STATE, 2 );
        wait_ready ();
        
        SYNC_BITS_SW2 [4] = SW2_receive1_transp | SW2; //SW2_receive1
        if ( rel_transaction_flag == 1 ) { SYNC_BITS_SW2 [4] = SW2_receive1_relay | SW2;  } 
        if ( RLEARNTASKSbits.start == 1) { SYNC_BITS_SW2 [4] = SW2_lrn_rel; }
        if ( TLEARNTASKSbits.start == 1) { SYNC_BITS_SW2 [4] = SW2_lrn_trnsp; }
        if (TFINISHTASKSbits.start == 1) { SYNC_BITS_SW2 [4] = SW2_lrn_trnsp; }
        Si4461_CMD_stream ( SYNC_BITS_SW2, 5 );
        wait_ready ();
    //	Si4461_interrupt_reset ();
    // Длина пакета 0 байт
        PKT_LENTH[4]= 0;
        Si4461_CMD_stream ( PKT_LENTH, 5 );
//    } 
//    else {
////     Переход из режима RECEIVE в режим READY
//        Si4461_interrupt_reset ();
//        CHANGE_STATE[1] = READY;
//        Si4461_CMD_stream ( CHANGE_STATE, 2 );
//        wait_ready ();
//        SYNC_BITS_SW2 [4] = SW2_receive1 | SW2;
//        Si4461_CMD_stream ( SYNC_BITS_SW2, 5 );
//        wait_ready ();
////    	Si4461_interrupt_reset ();
////     Длина пакета 8 байт
//        PKT_LENTH[4]= 8;
//        Si4461_CMD_stream ( PKT_LENTH, 5 );    
//    }
    
	wait_ready ();
// Сброс всех прерываний
//	Si4461_interrupt_reset ();    
// Запуск приема пакета из восьми байт данных
	Si4461_CMD_stream ( START_RX, 3 );
	wait_ready ();
    
}
unsigned long unit_transp_generator (unsigned long temp) {
unsigned char LFSRSW_bit = 0;
//unsigned long temp;

    LFSRSWbits.LFSRSW = temp;
    
	LFSRSW_bit = (LFSRSWbits.b24 ^ LFSRSWbits.b4
	^ LFSRSWbits.b3 ^ LFSRSWbits.b1);
	LFSRSWbits.LFSRSW = LFSRSWbits.LFSRSW >> 1;
	LFSRSWbits.b24 = LFSRSW_bit;

	SWbits.SW = LFSRSWbits.LFSRSW;

	SWbits.nibble0 = sw0[SWbits.nibble0];
	SWbits.nibble1 = sw1[SWbits.nibble1];
	SWbits.nibble2 = sw2[SWbits.nibble2];
	SWbits.nibble3 = sw3[SWbits.nibble3];
	SWbits.nibble4 = sw4[SWbits.nibble4];
	SWbits.nibble5 = sw5[SWbits.nibble5];
    
    temp = 0;
    temp = SWbits.SW;
    
    
    
return temp & 0x00FFFFFF;

//	НЕ ЗАБЫТЬ ПОСТАВИТЬ ПРОВЕРКУ НА СОВПАДЕНИЕ СО СЛОВОМ СИНХР ОБУЧЕНИЯ
/*
	SW0 = SWbits.nibble1; SW0 = (SW0 << 4) + SWbits.nibble0;
	SW1 = SWbits.nibble3; SW1 = (SW1 << 4) + SWbits.nibble2;	
	SW2 = SWbits.nibble5; SW2 = (SW2 << 4) + SWbits.nibble4;
*/
}
void Transp_number_generator (void) {
    unsigned char LFSRT_bit;
// Полином (20, 3, 0)    
	LFSRT_bit = (LFSRTbits.b1 ^ LFSRTbits.b4 ^ LFSRTbits.b6 ^ LFSRTbits.b20);
	LFSRTbits.LFSRT = LFSRTbits.LFSRT >> 1;
	LFSRTbits.b20 = LFSRT_bit;
}
void read_parameters (int z) {
    int p;
    unsigned long long temp;
    volatile unsigned char temp_byte;
    unsigned int i, j;
//	ee_write(0x00, 0x1); // флаг начальной инициализации
//	transp1_num = FM25_read_4( 8 );  // 1-я
//	transp2_num = FM25_read_4( 12 ); // 2-я
//	transp3_num = FM25_read_4( 16 ); // 3-я
//	transp4_num = FM25_read_4( 20 ); // 4-я
//	transp5_num = FM25_read_4( 24 ); // 5-я
//	transp6_num = FM25_read_4( 28 ); // 6-я    


	Transp_flags[0] = 0;
	Transp_flags[1] = FM25_read_1( 32 ); Transp_flags[2] = FM25_read_1( 33 ); // 1-я, 2-я
	Transp_flags[3] = FM25_read_1( 34 ); Transp_flags[4] = FM25_read_1( 35 ); // 3-я, 4-я
	Transp_flags[5] = FM25_read_1( 36 ); Transp_flags[6] = FM25_read_1( 37 ); // 5-я, 6-я 

// Чтение IMEI
    for (p = 0; p < 15; p++) {// IMEI_str c 46 по 60 
        IMEI_str[p] = FM25_read_1( p + 46 );
    }
    IMEI_str[15] = 0;

//    memmove ( IMEI_str, "865733020391181", 15 ); // стенд 1
//    memmove ( IMEI_str, "865733020392281", 15 ); // стенд 2
//    memmove ( IMEI_str, "865733020393381", 15 ); // стенд 3 
//    memmove ( IMEI_str, "865733020394481", 15 ); // стенд 4
//    memmove ( IMEI_str, "865733020395581", 15 ); // стенд 5
//    memmove ( IMEI_str, "865733020396681", 15 ); // стенд 6    
    
    init_TYPE0 ();
if (z == 1) {
    
    unit_transp_sw_generator (); // Генерация кода блока, кодов меток и реле из IMEI

    
//	Unit_num = FM25_read_4 (0x0001);
//	SW2 = FM25_read_1( 0x0005 ); SW1 = FM25_read_1( 0x0006 ); SW0 = FM25_read_1( 0x0007 );    
	LFSRbits.LFSR = FM25_read_4( 38 ); 
  
//	LFSRbits.LFSR = ee_read (0xD0);
//	LFSRbits.LFSR = (LFSRbits.LFSR << 16) + ee_read (0xD2);
//	Unit_num = ee_read (0x16);
//	Unit_num = (Unit_num << 16) + ee_read (0x18);
//	CVR_CON = ee_read (0x46);
//	WaitUp = ee_read (0x4A);
//	Robbery = ee_read (0x0C);
//	wup_timer = ee_read (0x114);
//	SW2 = ee_read (0x20); SW1 = ee_read (0x22); SW0 = ee_read (0x24);
}

// Чтение указателя записи и чтения (отсылки краша)  буфера крашей, номера краша    
   save_crash_to_flash_ptr_W = (unsigned int) FM25_read_2 ( 61 );// 61, 62 запись
   crash_to_send_ptr         = (unsigned int) FM25_read_2 ( 63 );// 63, 64 чтение
   number_of_crash           = (unsigned int) FM25_read_2 ( 65 );// 65, 66 номер  краша
// Чтение указатеей записи и чтения сообщений из поездки во флэши, 0...19999
   flash_ptr_R               = (unsigned int) FM25_read_2 ( 67 );// 67, 68   
   flash_ptr_W               = (unsigned int) FM25_read_2 ( 69 );// 69, 70
// GPS одометр   
   GPS_odometer              = (unsigned long) FM25_read_4 ( 71 );//71, 72, 73, 74
// Чтение указатеей записи и чтения сообщений из очереди 2 во флэши, 0...4800
   flash2_ptr_R               = (unsigned int) FM25_read_2 ( 75 );// 75, 76   
   flash2_ptr_W               = (unsigned int) FM25_read_2 ( 77 );// 77, 78
   
   
   hands_free_enable         = (unsigned int) FM25_read_1 ( 1000 );//1000
   relay_enable              = (unsigned int) FM25_read_1 ( 1001 );//1000
   arm_enable                = (unsigned int) FM25_read_1 ( 1002 );//1000
   lock_close_autorun_enable = (unsigned int) FM25_read_1 ( 1003 ); 
   
    temp = FM25_read_8( 1004 ); // 1  timed
    TIMEDDATbits.TIMEDDAT                   = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1012 ); // 2  distance
    DISTDATbits.DISTDAT                     = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1020 ); // 3  heading
    HEADINGDATbits.HEADINGDAT               = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1028 ); // 4  ignition on
    IGNONDATbits.IGNONDAT                   = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1036 ); // 5  ignition off
    IGNOFFDATbits.IGNOFFDAT                 = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1044 ); // 6  power on
    POWERONDATbits.POWERONDAT               = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1052 ); // 7  power off
    POWEROFFDATbits.POWEROFFDAT             = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1060 ); // 8  idle start
    IDLESTARTDATbits.IDLESTARTDAT           = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1068 ); // 9  idle end
    IDLEENDDATbits.IDLEENDDAT               = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1076 );// 26 dinamic cal
    DINAMICCALDATbits.DINAMICCALDAT         = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1084 );// 27 arm
    ARMDATbits.ARMDAT                       = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1092 );// 28 disarm
    DISARMDATbits.DISARMDAT                 = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1100 );// 29 intrusion
    INTRUSIONDATbits.INTRUSIONDAT           = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1108 );// 30 serv on
    SERVONDATbits.SERVONDAT                 = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1116 );// 31 serv off
    SERVOFFDATbits.SERVOFFDAT               = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1124 );// 32 serv auto off
    SERVAUTOOFFDATbits.SERVAUTOOFFDAT       = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1132 );// 33 start unsuccess
    STARTUNSUCCESSDATbits.STARTUNSUCCESSDAT = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1140 );// 34 start success
    STARTSUCCESSDATbits.STARTSUCCESSDAT     = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1148 );// 35 lock open
    LOCKOPENDATbits.LOCKOPENDAT             = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1156 );// 36 lock close
    LOCKCLOSEDATbits.LOCKCLOSEDAT           = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1164 );// 37 autorun command
    AUTORUNCOMMANDDATbits.AUTORUNCOMMANDDAT = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1172 );// 39 robbery
    ROBBERYDATbits.ROBBERYDAT               = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1180 );// 40 tilt
    TILTDATbits.TILTDAT                     = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1188 );// 41 fwrnw
    FWRNWDATbits.FWRNWDAT                   = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1196 );// 42 fw dounloaded
    FWDLDDATbits.FWDLDDAT                   = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1204 );// 43 lock command
    LOCKCOMMANDDATbits.LOCKCOMMANDDAT       = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1212 );// 44 unlock command
    UNLOCKCOMMANDDATbits.UNLOCKCOMMANDDAT   = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1220 );// 45 transp nums
    TNUMSDATbits.TNUMSDAT                   = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1228 );// 46 panic
    PANICDATbits.PANICDAT                   = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1236 );// 47 static cal 
    STATICCALDATbits.STATICCALDAT           = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1244 );// 47 static cal 
    UNITSTATUSDATbits.UNITSTATUSDAT         = (unsigned char)((temp >> 56) & 0xFF);

    sequence_number = (unsigned long) FM25_read_4( 1252 ); 
    
    temp = FM25_read_8( 1260 );// 10-25 ACC events 
    ACCDATbits.ACCDAT                       = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1268 );// 38, 48 VIN 
    VINDATbits.VINDAT                       = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1276 );// 26, 27 тип 2 DTCs 
    DTCDATbits.DTCDAT                       = (unsigned char)((temp >> 56) & 0xFF);    
    temp = FM25_read_8( 1284 );// 10 - 25 тип2 графики ускорения при маневрах 
    ACCCHARTSDATbits.ACCCHARTSDAT           = (unsigned char)((temp >> 56) & 0xFF);

//    FM25_write_4( 1292, (unsigned long) 0x2BC12C03 );// 50 тип1 CRASHSETbits     
    temp = 0;
    temp = (unsigned long)FM25_read_4( 1292 );// 50 тип1 CRASH event settings
//    temp = 0;
//    temp = temp + 0x578;
//    temp = temp << 13;
//    temp = temp + 0x4B0;
//    temp = temp << 6;
//    temp = temp + 0x03;    
//    CRASHSETbits.CRASHSET = (unsigned long) temp;
    CRASHSETbits.duration = (unsigned char) temp & 0x3F;
    temp = temp >> 6;  CRASHSETbits.gxy  = (unsigned int)(temp & 0x1FFF);
    temp = temp >> 13; CRASHSETbits.gxyz = (unsigned int)(temp & 0x1FFF);
    TILTSETbits.TILTSET   = FM25_read_2( 1296 );// 40 тип1 TILT event settings

    temp = FM25_read_8( 1298 );// 50 тип1 сообщение об аварии
    CRASHDATbits.CRASHDAT                   = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1306 );// 51 тип1 сообщение о включении webasto
    WEBASTOONDATbits.WEBASTOONDAT           = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1314 );// 52 тип1 сообщение о выключении webasto
    WEBASTOOFFDATbits.WEBASTOOFFDAT         = (unsigned char)((temp >> 56) & 0xFF);

    REPORTSETbits.period = FM25_read_4( 1322 );// 50 тип1 CRASH event settings
    temp = FM25_read_8( 1326 );// 53 тип1 отчетное сообщение

    REPORTDATbits.REPORTDAT         = (unsigned char)((temp >> 56) & 0xFF);
//    temp = FM25_read_8( 1475 );// 54 тип1 тестовое сообщение для него способ передачи задается командой
    temp = FM25_read_8( 1483 );// 54 тип1    
    ALARMDATbits.ALARMDAT         = (unsigned char)((temp >> 56) & 0xFF);    
    temp = FM25_read_8( 1491 );// 54 тип1    
    PWOFFMSGDATbits.PWOFFMSGDAT   = (unsigned char)((temp >> 56) & 0xFF);

    temp = 0;
    temp = (unsigned long long)FM25_read_4( 1499 );// 50 тип1 CRASH event settings ignition ON   
    PWOFFMSGSETbits.PWOFFMSGSET = (unsigned long)temp;

    temp = FM25_read_8( 1503 );// 57, 58 тип1 Check Engine   
    MILMSGDATbits.MILMSGDAT   = (unsigned char)((temp >> 56) & 0xFF);

    ROBBERYSETbits.ROBBERYSET = FM25_read_4( 1511 );// 39 тип1 Robbery 
    
 
    
    BATLOWSETbits.BATLOWSET = (unsigned long)FM25_read_4( 1517 );// 60 тип1 аккум разъряжен 
    
    temp = FM25_read_8( 1521 );// 59 тип1 аккум разряжен  
    BATLOWDATbits.BATLOWDAT = (unsigned char)((temp >> 56) & 0xFF);  
    
    dd_intrusion_off_setting = (unsigned int)FM25_read_2( 1529 ); 

    CANREQ1SETbits.CANREQ1SET = FM25_read_8( 1534 );
    CANREQ2SETbits.CANREQ2SET = FM25_read_8( 1542 );
    CANREQ3SETbits.CANREQ3SET = FM25_read_8( 1550 );
    CANREQ1DATbits.CANREQ1DAT = FM25_read_8( 1558 );
    CANREQ2DATbits.CANREQ2DAT = FM25_read_8( 1566 );
    CANREQ3DATbits.CANREQ3DAT = FM25_read_8( 1574 );
    
    temp = 0;
    temp = (unsigned long)FM25_read_4( 1582 );// 50 тип1 CRASH event settings ignition OFF
    CRASHSETIGNOFFbits.duration = (unsigned char) temp & 0x3F;
    temp = temp >> 6;  CRASHSETIGNOFFbits.gxy  = (unsigned int)(temp & 0x1FFF);
    temp = temp >> 13; CRASHSETIGNOFFbits.gxyz = (unsigned int)(temp & 0x1FFF); 
    
    SERVFLAGSbits.SERVFLAGS = (unsigned char) FM25_read_1 ( 1586 );//1000
    
    if (SERVFLAGSbits.serv_status == 1) {
        OUTbits.serv_flag = 1;
    }
    fisical_input_enable = (unsigned int) FM25_read_1 ( 1587 );//1000
    
    IGNPULSVFALLTSETbits.IGNPULSVFALLTSET = (unsigned long)FM25_read_4( 1588 );
    ign_volt_trh = (unsigned int) FM25_read_2( 1592 );
    OC1R = ign_volt_trh; 
    
    temp = FM25_read_8( 1594 );// 35 lock open
    BOOTLOCKOPENDATbits.BOOTLOCKOPENDAT = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 1602 );// 36 lock close
    BOOTLOCKCLOSEDATbits.BOOTLOCKCLOSEDAT = (unsigned char)((temp >> 56) & 0xFF);
    
    ACELbits.ACEL = (unsigned long long)FM25_read_8( 1610 );
    DCELbits.DCEL = (unsigned long long)FM25_read_8( 1618 );
    LALLbits.LALL = (unsigned long long)FM25_read_8( 1626 ); 
    LALRbits.trh1 = -1*LALLbits.trh1; LALRbits.dur1 = LALLbits.dur1;    LALRbits.trh2 = -1*LALLbits.trh2;
    LALRbits.dur2 = LALLbits.dur2;    LALRbits.trh3 = -1*LALLbits.trh3; LALRbits.dur3 = LALLbits.dur3;
    LALRbits.trh4 = -1*LALLbits.trh4; LALRbits.dur4 = LALLbits.dur4; 
    
    temp = FM25_read_8( 1634 );// 72 TRANSPPRESDATbits
    TRANSPPRESSLPDATbits.TRANSPPRESSLPDAT = (unsigned char)((temp >> 56) & 0xFF);
    
    temp = FM25_read_8( 1642 );// 80, 81
    BELTCHANGEDATbits.BELTCHANGEDAT = (unsigned char)((temp >> 56) & 0xFF);   
    

    DOPENSET1bits.DOPENSET1 = (unsigned long long)FM25_read_8( 1650 );
    DOPENDAT1bits.DOPENDAT1 = (unsigned long long)FM25_read_8( 1658 ); 
    DOPENTIME1bits.DOPENTIME1 = (unsigned long)FM25_read_4( 1666 );
    fuel_consumption_quantum = (unsigned int)FM25_read_2( 1670 );
    
    CANBRPPRMSbits.CANBRPPRMS = (unsigned long long) FM25_read_8( 1672 );// 
    RPMPRMSbits.RPMPRMS = (unsigned long long) FM25_read_8( 1680 );// 
    
    
  
    PERIFSLEEPSETbits.PERIFSLEEPSET = (unsigned int) FM25_read_2( 1700 ); // PERIFSLEEPSETbits
    crash_detection_type = (unsigned char) FM25_read_1( 1702 ); // PERIFSLEEPSETbits
    
    temp = FM25_read_8( 1703 ); // 63 speed changed 
    SPEEDDATbits.SPEEDDAT = (unsigned char)((temp >> 56) & 0xFF);
    SPEEDSETbits.SPEEDSET = (unsigned int) FM25_read_2 ( 1711 ); // 63 speed changed 
     
    
    LINLOCKDATAbits.LINLOCKDATA  = (unsigned long long) FM25_read_8 ( 1717 );
    LIN_LOCK_CRC  = FM25_read_1 ( 1725 );
    LIN_LOCK_ADDR = FM25_read_1 ( 1726 );
    temp_byte = FM25_read_1 ( 1727 );
    LIN_LOCK_LENGTH = temp_byte & 0x0F;
    LIN_LOCK_TRANSMITTION_ATTEMPTS = (temp_byte >> 4) & 0x0F;
    
    LINUNLOCKDATAbits.LINUNLOCKDATA = (unsigned long long) FM25_read_8 ( 1728  );
    LIN_UNLOCK_CRC  = FM25_read_1 ( 1736  );
    LIN_UNLOCK_ADDR = FM25_read_1 ( 1737  );
    temp_byte = FM25_read_1 ( 1738 );        
    LIN_UNLOCK_LENGTH = temp_byte & 0x0F;
    LIN_UNLOCK_TRANSMITTION_ATTEMPTS = (temp_byte >> 4) & 0x0F;
    OUTFUNCbits.OUTFUNC = (unsigned long long) FM25_read_8 ( 1739 );
    
    lockbytes_learned = (unsigned int)FM25_read_1 ( 1747 );
    LOCK_BYTES_buf[0] = (unsigned int)FM25_read_1 ( 1748 );
    LOCK_BYTES_buf[1] = (unsigned int)FM25_read_1 ( 1749 );
    LOCK_BYTES_buf[2] = (unsigned int)FM25_read_1 ( 1750 );
    LOCK_BYTES_buf[3] = (unsigned int)FM25_read_1 ( 1751 );
    LOCK_BYTES_buf[4] = (unsigned int)FM25_read_1 ( 1752 );
    LOCK_BYTES_buf[5] = (unsigned int)FM25_read_1 ( 1753 );
    LOCK_BYTES_buf[6] = (unsigned int)FM25_read_1 ( 1754 );
    LOCK_BYTES_buf[7] = (unsigned int)FM25_read_1 ( 1755 );

# if defined (UC15)
    
# else    
    j = 24;
    for (i = 0; i < 25; i ++) { // apn
        AT_CNT_SGP[j] = (unsigned char) FM25_read_1 ( (i + 1756) );
        if (AT_CNT_SGP[j] == 0) break;
        j++;
    }
    AT_CNT_SGP[j++] = '"';
    AT_CNT_SGP[j++] = ',';
    AT_CNT_SGP[j++] = '"';
    for (i = 0; i < 10; i ++) { // login
        AT_CNT_SGP[j] = (unsigned char) FM25_read_1 ( (i + 1781) );
        if (AT_CNT_SGP[j] == 0) break;
        j++;
    }
    AT_CNT_SGP[j++] = '"';
    AT_CNT_SGP[j++] = ',';
    AT_CNT_SGP[j++] = '"'; 
    for (i = 0; i < 10; i ++) { // password
        AT_CNT_SGP[j] = (unsigned char) FM25_read_1 ( (i + 1791) );
        if (AT_CNT_SGP[j] == 0) break;
        j++;
    }
    AT_CNT_SGP[j++] = '"';    
    AT_CNT_SGP[j++] = 0x0D;
    AT_CNT_SGP[j++] = 0;
# endif
# if defined (UC15)
    
# else     
    j = 28;
    for (i = 0; i < 30; i ++) { // server
        AT_QIOPEN[j] = (unsigned char) FM25_read_1 ( (i + 1801) );
        if (AT_QIOPEN[j] == 0) break;
        j++;
    }
    AT_QIOPEN[j++] = '"';
    AT_QIOPEN[j++] = ',';
    for (i = 0; i < 5; i ++) { // password
        AT_QIOPEN[j] = (unsigned char) FM25_read_1 ( (i + 1831) );
        if (AT_QIOPEN[j] == 0) break;
        j++;
    }
    AT_QIOPEN[j++] = 0x0D;
    AT_QIOPEN[j++] = 0;
# endif
    
    temp = 0;
    temp = (unsigned long) FM25_read_4( 1837 );
    LINLOCKPSTATPRMSbits.LINLOCKPSTATPRMS = temp; 
    mil_req_len = (unsigned char) FM25_read_1 ( 1841 );

    temp = FM25_read_8( 1842 );// 59 тип1 АКПП статус  
    GEARBOXDATbits.GEARBOXDAT = (unsigned char)((temp >> 56) & 0xFF); 
    
    LINBOOTUNLOCKDATAbits.LINBOOTUNLOCKDATA = (unsigned long long) FM25_read_8 ( 1850  );
    LIN_BOOT_UNLOCK_CRC  = FM25_read_1 ( 1858  );
    LIN_BOOT_UNLOCK_ADDR = FM25_read_1 ( 1859  );
    temp_byte = FM25_read_1 ( 1860 );        
    LIN_BOOT_UNLOCK_LENGTH = temp_byte & 0x0F;
    LIN_BOOT_UNLOCK_TRANSMITTION_ATTEMPTS = (temp_byte >> 4) & 0x0F;

    LINLOCKDATA2bits.LINLOCKDATA2  = (unsigned long long) FM25_read_8 ( 1872 ); //
    LIN_LOCK_CRC2  = FM25_read_1 ( 1880 ); // 
    LIN_LOCK_ADDR2 = FM25_read_1 ( 1881 ); //
    temp_byte = FM25_read_1 ( 1882 ); //
    LIN_LOCK_LENGTH2 = temp_byte & 0x0F;
    LIN_LOCK_TRANSMITTION_ATTEMPTS2 = (temp_byte >> 4) & 0x0F;

//FM25_write_8 ( 1861, (unsigned long long) LINUNLOCKDATA2bits.LINUNLOCKDATA2 );    
    LINUNLOCKDATA2bits.LINUNLOCKDATA2 = (unsigned long long) FM25_read_8 ( 1861 ); //1872
    LIN_UNLOCK_CRC2  = FM25_read_1 ( 1869  ); //1880
    LIN_UNLOCK_ADDR2 = FM25_read_1 ( 1870  ); //1881
    temp_byte = FM25_read_1 ( 1871 ); // 1882       
    LIN_UNLOCK_LENGTH2 = temp_byte & 0x0F;
    LIN_UNLOCK_TRANSMITTION_ATTEMPTS2 = (temp_byte >> 4) & 0x0F;    
    lin_snif_enable = (unsigned char)FM25_read_1 ( 1883 ); 
    TEMPERATURESETbits.TEMPERATURESET = (unsigned int)FM25_read_2 ( 1884 );
    battery_charge_type = FM25_read_1 ( 1886 );
    temp = FM25_read_8( 1894 );// 54 тип1    
    BLINKRPTRDATbits.BLINKRPTRDAT  = (unsigned char)((temp >> 56) & 0xFF);    
    
    rf_reset_enable = (unsigned char) FM25_read_1 ( 1955 );

    SPEEDTRHSET1bits.SPEEDTRHSET1 = (unsigned int)FM25_read_2( 1903 );// 66  
    SPEEDTRHSET2bits.SPEEDTRHSET2 = (unsigned int)FM25_read_2( 1905 );// 68 
    SPEEDTRHSET3bits.SPEEDTRHSET3 = (unsigned int)FM25_read_2( 1907 );// 70 
    temp = FM25_read_8( 1909 );// 66 - 71 тип1 
    SPEEDTRHDATbits.SPEEDTRHDAT = (unsigned char)((temp >> 56) & 0xFF);
    fuel_sensor_enable = FM25_read_1 ( 1917 );
    
    temp = (unsigned long long) FM25_read_8 ( 1918 ); //
    FEQUbits.FEQU = temp;
    LINCOMMANDSTATPRMSbits.LINCOMMANDSTATPRMS = (unsigned long) FM25_read_4( 1926 );
    start_engine_volt_trh = FM25_read_1 ( 1930 ); 
    INPPOLbits.INPPOL = FM25_read_1 ( 1933 );
    temp = FM25_read_8( 1934 );// 66 - 71 тип1 
    IMSIDATbits.IMSIDAT = (unsigned char)((temp >> 56) & 0xFF);
    PULSAFTERAUOTORUNPRMSbits.PULSAFTERAUOTORUNPRMS = (unsigned int) FM25_read_2( 1942 );
    tilt_off_timer_setting = (unsigned char) FM25_read_1 ( 1944 );
    temperatura_correct_timer_setting = (unsigned char) FM25_read_1 ( 1945 );
    t_lights_off_timeout = (unsigned char) FM25_read_1 ( 1946 );
    temp = FM25_read_8( 1947 );// 82 timed webasto  
    TIMEDWBSTDATbits.TIMEDWBSTDAT = (unsigned char)((temp >> 56) & 0xFF);    
    INFUNCbits.INFUNC = (unsigned long long) FM25_read_8( 1956 );//
    DIAGNSIGNALSbits.DIAGNSIGNALS =  (unsigned long ) FM25_read_4( 1964 );
    OUTPOLbits.OUTPOL = (unsigned char) FM25_read_1( 1968);
    OBDREQENbits.OBDREQEN = (unsigned char) FM25_read_1( 1969 );
    temp_byte = FM25_read_1( 1970 );
    crash_filt_cutoff_frq = temp_byte & 0x0F;
    acc_sampling_frequency = (temp_byte >> 4) & 0x0F;
    srvr_flag = FM25_read_1( 1971 );//
    sleep_timer = (unsigned int) FM25_read_1( 1972 ); // sleep_timer
    sleep_timer = sleep_timer * 600;
    RBLKDATbits.RBLKDAT = (unsigned char) FM25_read_1( 1973 );
    disarm_by_doors_unlock_enable = (unsigned char) FM25_read_1( 1974 );//
    timed_period = (unsigned char) FM25_read_1( 1975 );//
    HF2DATbits.HF2DAT = (unsigned char) FM25_read_1( 1976 );
    SECONDAUTHORbits.SECONDAUTHOR = (unsigned char) FM25_read_1( 1977 );
    SECONDAUTHORDATbits.SECONDAUTHORDAT = (unsigned char) FM25_read_1( 1978 );
    SECONDAUTHORDATFAILbits.SECONDAUTHORDATFAIL = (unsigned char) FM25_read_1( 1979 );
    DTCWBUSDATbits.DTCWBUSDAT = (unsigned char) FM25_read_1( 1980 );
    fake_doors_open_type = (unsigned char) FM25_read_1( 1981 );
    
    temp = FM25_read_8( 879 ); // 74
    LIGTSDATbits.LIGTSDAT = (unsigned char)((temp >> 56) & 0xFF);
    temp = FM25_read_8( 887 ); // 76 
    TRTLLIGTSDATbits.TRLIGTSDAT = (unsigned char)((temp >> 56) & 0xFF);    
    
    Nop();Nop();Nop();
// Настройки CAN 
    wbst_startenginecan_switch = (unsigned char) FM25_read_1( 1692 );
    if ( wbst_startenginecan_switch == 0 ) {
        WBSTSTARTDAT1bits.WBSTSTARTDAT1   = (unsigned long long) FM25_read_8( 422 );
        WBSTSTARTTIME1bits.WBSTSTARTTIME1 = (unsigned long long) FM25_read_8( 414 );
        WBSTSTARTSET2bits.WBSTSTARTSET2   = (unsigned long long) FM25_read_8( 406 );
        WBSTSTARTDAT2bits.WBSTSTARTDAT2   = (unsigned long long) FM25_read_8( 398 );
        WBSTSTARTTIME2bits.WBSTSTARTTIME2 = (unsigned long long) FM25_read_8( 390 );       
        WBSTSTARTSET3bits.WBSTSTARTSET3   = (unsigned long long) FM25_read_8( 382 );
        WBSTSTARTDAT3bits.WBSTSTARTDAT3   = (unsigned long long) FM25_read_8( 374 );
        WBSTSTARTTIME3bits.WBSTSTARTTIME3 = (unsigned long long) FM25_read_8( 366 );        
        WBSTSTARTSET4bits.WBSTSTARTSET4   = (unsigned long long) FM25_read_8( 358 );
        WBSTSTARTDAT4bits.WBSTSTARTDAT4   = (unsigned long long) FM25_read_8( 350 );
        WBSTSTARTTIME4bits.WBSTSTARTTIME4 = (unsigned long long) FM25_read_8( 342 );
        WBSTSTARTSET5bits.WBSTSTARTSET5   = (unsigned long long) FM25_read_8( 334 );
        WBSTSTARTDAT5bits.WBSTSTARTDAT5   = (unsigned long long) FM25_read_8( 326 );
        WBSTSTARTTIME5bits.WBSTSTARTTIME5 = (unsigned long long) FM25_read_8( 318 );        

        WBSTSTOPSET1bits.WBSTSTOPSET1 = (unsigned long long) FM25_read_8( 310 );
        WBSTSTOPDAT1bits.WBSTSTOPDAT1   = (unsigned long long) FM25_read_8( 302 );
        WBSTSTOPTIME1bits.WBSTSTOPTIME1 = (unsigned long long) FM25_read_8( 294 );        
        WBSTSTOPSET2bits.WBSTSTOPSET2 = (unsigned long long) FM25_read_8( 286 );
        WBSTSTOPDAT2bits.WBSTSTOPDAT2   = (unsigned long long) FM25_read_8( 278 );
        WBSTSTOPTIME2bits.WBSTSTOPTIME2 = (unsigned long long) FM25_read_8( 270 );        
        WBSTSTOPSET3bits.WBSTSTOPSET3 = (unsigned long long) FM25_read_8( 262 );
        WBSTSTOPDAT3bits.WBSTSTOPDAT3   = (unsigned long long) FM25_read_8( 254 );
        WBSTSTOPTIME3bits.WBSTSTOPTIME3 = (unsigned long long) FM25_read_8( 246 );        
        WBSTSTOPSET4bits.WBSTSTOPSET4 = (unsigned long long) FM25_read_8( 238 );
        WBSTSTOPDAT4bits.WBSTSTOPDAT4   = (unsigned long long) FM25_read_8( 230 );
        WBSTSTOPTIME4bits.WBSTSTOPTIME4 = (unsigned long long) FM25_read_8( 222 );       
        WBSTSTOPSET5bits.WBSTSTOPSET5 = (unsigned long long) FM25_read_8( 214 );
        WBSTSTOPDAT5bits.WBSTSTOPDAT5   = (unsigned long long) FM25_read_8( 206 );
        WBSTSTOPTIME5bits.WBSTSTOPTIME5 = (unsigned long long) FM25_read_8( 198 );        

        WBSTRSET1bits.WBSTRSET1         = (unsigned long long) FM25_read_8( 190 );
        WBSTRDAT1bits.WBSTRDAT1         = (unsigned long long) FM25_read_8( 182 );
        WBSTCANWAKETIMEbits.WBSTCANWAKETIME = (unsigned long long) FM25_read_8( 174 ); //WBSTRTIME1bits.WBSTRTIME1
        WBSTSTARTSET1bits.WBSTSTARTSET1 = (unsigned long long) FM25_read_8( 166 );

        WBSTSTARTSET6bits.WBSTSTARTSET6   = (unsigned long long) FM25_read_8( 158 );
        WBSTSTARTDAT6bits.WBSTSTARTDAT6   = (unsigned long long) FM25_read_8( 150 );
        WBSTSTARTTIME6bits.WBSTSTARTTIME6 = (unsigned long long) FM25_read_8( 142 );
        WBSTSTOPSET6bits.WBSTSTOPSET6     = (unsigned long long) FM25_read_8( 134 );
        WBSTSTOPDAT6bits.WBSTSTOPDAT6     = (unsigned long long) FM25_read_8( 126 );
        WBSTSTOPTIME6bits.WBSTSTOPTIME6   = (unsigned long long) FM25_read_8( 118 );
    } else {
       STRTENGCSTARTSET1bits.STRTENGCSTARTSET1   = (unsigned long long) FM25_read_8( 166 );
       STRTENGCSTARTDAT1bits.STRTENGCSTARTDAT1   = (unsigned long long) FM25_read_8( 422 );
       STRTENGCSTARTTIME1bits.STRTENGCSTARTTIME1 = (unsigned long long) FM25_read_8( 414 );

       STRTENGCSTARTSET2bits.STRTENGCSTARTSET2   = (unsigned long long) FM25_read_8( 406 );
       STRTENGCSTARTDAT2bits.STRTENGCSTARTDAT2   = (unsigned long long) FM25_read_8( 398 );
       STRTENGCSTARTTIME2bits.STRTENGCSTARTTIME2 = (unsigned long long) FM25_read_8( 390 );       

       STRTENGCSTARTSET3bits.STRTENGCSTARTSET3   = (unsigned long long) FM25_read_8( 382 );
       STRTENGCSTARTDAT3bits.STRTENGCSTARTDAT3   = (unsigned long long) FM25_read_8( 374 );
       STRTENGCSTARTTIME3bits.STRTENGCSTARTTIME3 = (unsigned long long) FM25_read_8( 366 );        

       STRTENGCSTARTSET4bits.STRTENGCSTARTSET4   = (unsigned long long) FM25_read_8( 358 );
       STRTENGCSTARTDAT4bits.STRTENGCSTARTDAT4   = (unsigned long long) FM25_read_8( 350 );
       STRTENGCSTARTTIME4bits.STRTENGCSTARTTIME4 = (unsigned long long) FM25_read_8( 342 );
        
       STRTENGCSTARTSET5bits.STRTENGCSTARTSET5   = (unsigned long long) FM25_read_8( 334 );
       STRTENGCSTARTDAT5bits.STRTENGCSTARTDAT5   = (unsigned long long) FM25_read_8( 326 );
       STRTENGCSTARTTIME5bits.STRTENGCSTARTTIME5 = (unsigned long long) FM25_read_8( 318 );        

       STRTENGCSTOPSET1bits.STRTENGCSTOPSET1   = (unsigned long long) FM25_read_8( 310 );
       STRTENGCSTOPDAT1bits.STRTENGCSTOPDAT1   = (unsigned long long) FM25_read_8( 302 );
       STRTENGCSTOPTIME1bits.STRTENGCSTOPTIME1 = (unsigned long long) FM25_read_8( 294 );        
        
       STRTENGCSTOPSET2bits.STRTENGCSTOPSET2   = (unsigned long long) FM25_read_8( 286 );
       STRTENGCSTOPDAT2bits.STRTENGCSTOPDAT2   = (unsigned long long) FM25_read_8( 278 );
       STRTENGCSTOPTIME2bits.STRTENGCSTOPTIME2 = (unsigned long long) FM25_read_8( 270 );        
        
       STRTENGCSTOPSET3bits.STRTENGCSTOPSET3   = (unsigned long long) FM25_read_8( 262 );
       STRTENGCSTOPDAT3bits.STRTENGCSTOPDAT3   = (unsigned long long) FM25_read_8( 254 );
       STRTENGCSTOPTIME3bits.STRTENGCSTOPTIME3 = (unsigned long long) FM25_read_8( 246 );        
        
       STRTENGCSTOPSET4bits.STRTENGCSTOPSET4   = (unsigned long long) FM25_read_8( 238 );
       STRTENGCSTOPDAT4bits.STRTENGCSTOPDAT4   = (unsigned long long) FM25_read_8( 230 );
       STRTENGCSTOPTIME4bits.STRTENGCSTOPTIME4 = (unsigned long long) FM25_read_8( 222 );       
        
       STRTENGCSTOPSET5bits.STRTENGCSTOPSET5   = (unsigned long long) FM25_read_8( 214 );
       STRTENGCSTOPDAT5bits.STRTENGCSTOPDAT5   = (unsigned long long) FM25_read_8( 206 );
       STRTENGCSTOPTIME5bits.STRTENGCSTOPTIME5 = (unsigned long long) FM25_read_8( 198 );        
    }
    
    CAN1SETTINGSbits.CAN1SETTINGS   = (unsigned int) FM25_read_2 ( 512 );  // CAN1
    CAN2SETTINGSbits.CAN2SETTINGS   = (unsigned int) FM25_read_2 ( 514 );  // CAN2
    CANIGNPRMSbits.CANIGNPRMS       = (unsigned long long) FM25_read_8 ( 516 );// Ignition
    CANDDPRMSbits.CANDDPRMS         = (unsigned long long) FM25_read_8 ( 524 );// вод дверь
    CANFPDPRMSbits.CANFPDPRMS       = (unsigned long long) FM25_read_8 ( 532 );// прав передн дверь
    CANRLDPRMSbits.CANRLDPRMS       = (unsigned long long) FM25_read_8 ( 540 );// лев задн дверь
    CANRRDPRMSbits.CANRRDPRMS       = (unsigned long long) FM25_read_8 ( 548 );// прав задн дверь
    CANBNPRMSbits.CANBNPRMS         = (unsigned long long) FM25_read_8 ( 556 );// багажник
    CANBTPRMSbits.CANBTPRMS         = (unsigned long long) FM25_read_8 ( 564 );// капот
    CANODOPRMSbits.CANODOPRMS       = (unsigned long long) FM25_read_8 ( 572 );// пробег
    CANFLPRMSbits.CANFLPRMS         = (unsigned long long) FM25_read_8 ( 580 );// топливо     
    CANBELTPRMSbits.CANBELTPRMS     = (unsigned long long) FM25_read_8 ( 588 );// ремень
    LOCKSTATPRMSbits.LOCKSTATPRMS   = (unsigned long long) FM25_read_8 ( 596 );// ремень
    LOCKSTATPRMS2bits.LOCKSTATPRMS2 = (unsigned long long) FM25_read_8 ( 604 );// ремень тип 2 
    temp = (unsigned long long) FM25_read_8 ( 612 );
    Nop();Nop();Nop();
    CANIGNPRMS2bits.CANIGNPRMS2     = (unsigned long long) FM25_read_8 ( 612 );// Ignition тип 2
    Nop();Nop();Nop();
    ENJSTATUSPRMS2bits.ENJSTATUSPRMS2 = (unsigned long long) FM25_read_8 ( 620 );// Статус двигателя тип 2
    WEBASTOSTATPRMSbits.WEBASTOSTATPRMS   = (unsigned long long) FM25_read_8 ( 628 );// Статус двигателя тип 2
    ALARMSTATPRMS2bits.ALARMSTATPRMS2   = (unsigned long long) FM25_read_8 ( 636 );// Статус акпп тип 2
    GEARBOXSTATPRMS2bits.GEARBOXSTATPRMS2   = (unsigned long long) FM25_read_8 ( 644 );// Статус акпп тип 2 
    LOCKSTATPRMS3bits.LOCKSTATPRMS3 = (unsigned long long) FM25_read_8 ( 652 );// Замки тип 3    
    BOOTLOCKSTATPRMSbits.BOOTLOCKSTATPRMS = (unsigned long long) FM25_read_8 ( 660 );// Замок багажника тип 1 
    CAN1CFGbits.CAN1CFG = (unsigned long) FM25_read_4 ( 668 ); // bit timing can1
    CAN2CFGbits.CAN2CFG = (unsigned long) FM25_read_4 ( 672 ); // bit timing can1
    
    CLOCKSET1bits.CLOCKSET1   = (unsigned long long) FM25_read_8 ( 676 );//
    CLOCKDAT1bits.CLOCKDAT1   = (unsigned long long) FM25_read_8 ( 684 );//
    CLOCKTIME1bits.CLOCKTIME1 = (unsigned long long) FM25_read_8 ( 692 );//
    
    CLOCKSET2bits.CLOCKSET2   = (unsigned long long) FM25_read_8 ( 700 );//
    CLOCKDAT2bits.CLOCKDAT2   = (unsigned long long) FM25_read_8 ( 708 );//
    CLOCKTIME2bits.CLOCKTIME2 = (unsigned long long) FM25_read_8 ( 716 );//    
    
    CLOCKSET3bits.CLOCKSET3   = (unsigned long long) FM25_read_8 ( 724 );//
    CLOCKDAT3bits.CLOCKDAT3   = (unsigned long long) FM25_read_8 ( 732 );//
    CLOCKTIME3bits.CLOCKTIME3 = (unsigned long long) FM25_read_8 ( 740 );//
    
    CUNLOCKSET1bits.CUNLOCKSET1 = (unsigned long long) FM25_read_8 ( 748 );//
    CUNLOCKDAT1bits.CUNLOCKDAT1 = (unsigned long long) FM25_read_8 ( 756 );//
    CUNLOCKSET2bits.CUNLOCKSET2 = (unsigned long long) FM25_read_8 ( 764 );//
    CUNLOCKDAT2bits.CUNLOCKDAT2 = (unsigned long long) FM25_read_8 ( 772 );//
    CUNLOCKSET3bits.CUNLOCKSET3 = (unsigned long long) FM25_read_8 ( 780 );//
    CUNLOCKDAT3bits.CUNLOCKDAT3 = (unsigned long long) FM25_read_8 ( 788 );//
    CBTUNLOCKSET1bits.CBTUNLOCKSET1   = (unsigned long long) FM25_read_8 ( 796 );//
    CBTUNLOCKDAT1bits.CBTUNLOCKDAT1   = (unsigned long long) FM25_read_8 ( 804 );//
    CBTUNLOCKTIME1bits.CBTUNLOCKTIME1 = (unsigned long long) FM25_read_8 ( 812 );//
    CBTUNLOCKSET2bits.CBTUNLOCKSET2   = (unsigned long long) FM25_read_8 ( 820 );//
    CBTUNLOCKDAT2bits.CBTUNLOCKDAT2   = (unsigned long long) FM25_read_8 ( 828 );//
    CBTUNLOCKTIME2bits.CBTUNLOCKTIME2 = (unsigned long long) FM25_read_8 ( 836 );//
    CBTUNLOCKSET3bits.CBTUNLOCKSET3   = (unsigned long long) FM25_read_8 ( 844 );//
    CBTUNLOCKDAT3bits.CBTUNLOCKDAT3   = (unsigned long long) FM25_read_8 ( 852 );//
    CBTUNLOCKTIME3bits.CBTUNLOCKTIME3 = (unsigned long long) FM25_read_8 ( 860 );//
    CANLOCKBYTESPRMSbits.CANLOCKBYTESPRMS = (unsigned long long) FM25_read_8 ( 868 );// 
    lockbytes_enable = (unsigned int) FM25_read_1 ( 876 );
    CANLOCKBYTESPRMS2bits.CANLOCKBYTESPRMS2 = (unsigned int) FM25_read_2 ( 877 );
    CANLIGHTSPRMSbits.CANLIGHTSPRMS = (unsigned long long) FM25_read_8 ( 895 );
    CANTLLIGHTSPRMSbits.CANTLLIGHTSPRMS = (unsigned long long) FM25_read_8 ( 903 );
    CANTRLIGHTSPRMSbits.CANTRLIGHTSPRMS = (unsigned long long) FM25_read_8 ( 911 );
    CANFLCNPNPRMSbits.CANFLCNPNPRMS = (unsigned long long) FM25_read_8 ( 919 );
    CANFL2PRMSbits.CANFL2PRMS = (unsigned long long) FM25_read_8 ( 927 );
    CANFL3PRMSbits.CANFL3PRMS = (unsigned long long) FM25_read_8 ( 935 );
    CANODOCHECKBYTESbits.CANODOCHECKBYTES = (unsigned long long) FM25_read_5 ( 943 );
    TOYOTAKEYDATbits.TOYOTAKEYDAT = (unsigned long long) FM25_read_8 ( 948 );
    CANBUTTONPRMSbits.CANBUTTONPRMS  = (unsigned long long) FM25_read_8( 956 );
    
    p = FM25_read_1 ( 1384 );// Статус калибровки акселерометра
    if ( p == 1 ) {
       read_autocal_results ();
       AUTOCALSTATUSbits.staticcal = 1;
       AUTOCALSTATUSbits.finished  = 1;
    }
    if ( p == 2 ) {
        read_autocal_results ();
        AUTOCALbits.staticcal = 0;
        AUTOCALbits.orientation = 1;
        AUTOCALSTATUSbits.staticcal = 1;
    }
    
    read_valid_phone_numbers ();
    
    FW_version = (unsigned long)FM25_read_4 (2026);
    
}//read_parameters ()

void read_valid_phone_numbers (void) {
int i;

//    for ( i =0; i < 15; i ++) {
//        PHONES_buf[0][i] = (unsigned char) FM25_read_1 ( (1385 + i) );
//    }
    PHONES_buf[0][0] = 'E';PHONES_buf[0][1] = 'l';PHONES_buf[0][2] = 'e';
    PHONES_buf[0][3] = 'm';PHONES_buf[0][4] = 'e';PHONES_buf[0][5] = 'n';
    PHONES_buf[0][6] = 't';PHONES_buf[0][7] = 0;
    for ( i =0; i < 15; i ++) {
        PHONES_buf[1][i] = (unsigned char) FM25_read_1 ( (1400 + i) );
    }
    for ( i =0; i < 15; i ++) {
        PHONES_buf[2][i] = (unsigned char) FM25_read_1 ( (1415 + i) );
    }
    for ( i =0; i < 15; i ++) {
        PHONES_buf[3][i] = (unsigned char) FM25_read_1 ( (1430 + i) );
    }
    for ( i =0; i < 15; i ++) {
        PHONES_buf[4][i] = (unsigned char) FM25_read_1 ( (1445 + i) );
    }
    for ( i =0; i < 15; i ++) {
        PHONES_buf[5][i] = (unsigned char) FM25_read_1 ( (1460 + i) );
    }    
Nop();Nop();Nop();
}

void unit_transp_sw_generator (void) {
unsigned long temp;

    temp = 0;
    
    temp =         IMEI_str[7]  - 0x30;  temp = temp * 10;
    temp = temp + (IMEI_str[8]  - 0x30); temp = temp * 10;
    temp = temp + (IMEI_str[9]  - 0x30); temp = temp * 10;
    temp = temp + (IMEI_str[10] - 0x30); temp = temp * 10;
    temp = temp + (IMEI_str[11] - 0x30); temp = temp * 10;
    temp = temp + (IMEI_str[12] - 0x30); temp = temp * 10;
    temp = temp + (IMEI_str[13] - 0x30); temp = temp * 10; 
    temp = temp + (IMEI_str[14] - 0x30);
//    temp = 22101687;

Nop();Nop();Nop();    
    temp = temp & 0x00FFFFFF;
    first_IMEI_digits = temp;
    
    SW0 = (unsigned char)  temp;
    SW1 = (unsigned char) (temp >> 8);
    SW2 = (unsigned char) (temp >> 16);
    SW2 = SW2 & 0x0F;
    
    Unit_num    = unit_transp_generator ((unsigned long) temp);
    transp1_num = unit_transp_generator ((unsigned long) Unit_num); 
    transp2_num = unit_transp_generator ((unsigned long) transp1_num); 
    transp3_num = unit_transp_generator ((unsigned long) transp2_num);
    transp4_num = unit_transp_generator ((unsigned long) transp3_num);
    transp5_num = unit_transp_generator ((unsigned long) transp4_num);
    transp6_num = unit_transp_generator ((unsigned long) transp5_num);
    
    Nop();Nop();Nop();
}

void next_portion_255 (void) {
unsigned int i;

//for (i = 0; i < 128; i ++) {
Gamma_H ();
Gamma_H ();	
//}
}
void Gamma_H (void) {
    unsigned char LFSR_bit;
    
    LFSR_bit = 0;
	LFSR_bit = (LFSRbits.b1 ^ LFSRbits.b2
	^ LFSRbits.b3 ^ LFSRbits.b5
	^ LFSRbits.b7 ^ LFSRbits.b32);
	LFSRbits.LFSR = LFSRbits.LFSR >> 1;
	LFSRbits.b32 = LFSR_bit;

} //Подпрограмма выработки старших 32 бит гаммы
void Gamma_L (void) {
unsigned long long cripto_temp;

	omega_0 = N2; 
	cripto_temp = omega_0 + C1;
	if (cripto_temp < 0x100000000) omega0 = cripto_temp;
	else omega0 = cripto_temp - 0x100000000;
}
int  receive1 (void)	{
unsigned char /*k,*/ kr;

// Сброс всех прерываний
	Si4461_interrupt_reset ();
// Длина пакета 8 байт
	PKT_LENTH[4]= 0;
	Si4461_CMD_stream ( PKT_LENTH, 5 );
	wait_ready ();
// Запуск приема пакета из восьми байт данных
	Si4461_CMD_stream ( START_RX, 3 );
	wait_ready ();

	kr = 0;
//	TMR1 = 0;
	nIRQ = 0;
//	Ign_irq = 0;

	IFS1bits.INT1IF = 0;
	IEC1bits.INT1IE = 1;

	while (1){
//		asm ("clrwdt");  
//		if (Sleep_flag == 1) To_sleep_mode ();
		if (nIRQ == 1){	kr = 1; break; }
//		if (Ign_irq == 1) break;
//		if (robbery_blocked_flag == 2) break;
//		if (PERIF_FLGSbits.loc_cntrl_flag == 1) break;
//		if (pin_timer_flag == 1) start_pin_entering ();
	}

//	IEC1bits.INT1IE = 0;
	nIRQ = 0;
//	Sleep_flag = 0;

// Переход из режима RECEIVE в режим READY
/*    
	CHANGE_STATE[1] = READY;
	Si4461_CMD_stream ( CHANGE_STATE, 2 );
	wait_ready ();
*/
// Сброс всех прерываний
//	Si4461_interrupt_reset ();

return kr;
} // receive1 ()
void Encription (void){
	Encription_1 (K0);	Encription_1 (K1);	Encription_1 (K2);
	Encription_1 (K3);	Encription_1 (K4);	Encription_1 (K5);
	Encription_1 (K6);	Encription_1 (K7);
	Encription_1 (K0);	Encription_1 (K1);	Encription_1 (K2);
	Encription_1 (K3);	Encription_1 (K4);	Encription_1 (K5);
	Encription_1 (K6);	Encription_1 (K7);
	Encription_1 (K0);	Encription_1 (K1);	Encription_1 (K2);
	Encription_1 (K3);	Encription_1 (K4);	Encription_1 (K5);
	Encription_1 (K6);	Encription_1 (K7);
	Encription_1 (K7);	Encription_1 (K6);	Encription_1 (K5);
	Encription_1 (K4);	Encription_1 (K3);	Encription_1 (K2);
	Encription_1 (K1);	Encription_1 (K0);

	N3 = N1;
	N1 = N2;
	N2 = N3;

} // Encription
void Encription_1 (unsigned long KK1){
/*
ОШИБКА!!!
KK должно быть long long
*/
/*
_LATB0 = 1;
	KK = KK + N1;
	if (KK < 0x100000000) value.temp = KK;
	else value.temp = KK - 0x100000000;
_LATB0 = 0;
*/
unsigned long long KK;

	KK = (unsigned long long)KK1;
	KK = KK + (unsigned long long)N1;
	if (KK < 0x100000000) {
		value.temp = (unsigned long)KK;
	}
	else { 
		value.temp = (unsigned long)(KK - 0x100000000);
	}

/*
unsigned long tmp_dwrd, tmp1_dwrd;

_LATB0 = 1;
	    tmp_dwrd = 0xFFFFFFFF - KK;
	    tmp1_dwrd = 0xFFFFFFFF - N1;

	    if (tmp_dwrd >= N1) {
		    value.temp = KK + N1;
		}
	    else {
		    value.temp = tmp_dwrd + tmp1_dwrd;
			value.temp = 0xFFFFFFFF - value.temp - 1;
		}
_LATB0 = 0;
*/
	value.nibble0 = H0[value.nibble0];
	value.nibble1 = H1[value.nibble1];
	value.nibble2 = H2[value.nibble2];
	value.nibble3 = H3[value.nibble3];
	value.nibble4 = H4[value.nibble4];
	value.nibble5 = H5[value.nibble5];
	value.nibble6 = H6[value.nibble6];
	value.nibble7 = H7[value.nibble7];

	SS = value.temp >> 21;
	value.temp = value.temp << 11;
	value.temp = value.temp + SS;

	value.temp = value.temp ^ N2;
	N2 = N1;
	N1 = value.temp;

} // encription_1()
void Decription (void){
	Encription_1 (K0);	Encription_1 (K1);	Encription_1 (K2);
	Encription_1 (K3);	Encription_1 (K4);	Encription_1 (K5);
	Encription_1 (K6);	Encription_1 (K7);
	Encription_1 (K7);	Encription_1 (K6);	Encription_1 (K5);
	Encription_1 (K4);	Encription_1 (K3);	Encription_1 (K2);
	Encription_1 (K1);	Encription_1 (K0);
	Encription_1 (K7);	Encription_1 (K6);	Encription_1 (K5);
	Encription_1 (K4);	Encription_1 (K3);	Encription_1 (K2);
	Encription_1 (K1);	Encription_1 (K0);
	Encription_1 (K7);	Encription_1 (K6);	Encription_1 (K5);
	Encription_1 (K4);	Encription_1 (K3);	Encription_1 (K2);
	Encription_1 (K1);	Encription_1 (K0);

	N3 = N1;
	N1 = N2;
	N2 = N3;

} // Decription
void Transmit (unsigned int length)	{

//	Si4461_interrupt_reset ();

	if (length != 0) {
		CS_SI4461 = 0;
			writeSPI3 (0x66);	// WRITE_TX_FIFO CMD
			writeSPI3 (N1); writeSPI3 (N1 >> 8); writeSPI3 (N1 >> 16); writeSPI3 (N1 >> 24);
			writeSPI3 (N2); writeSPI3 (N2 >> 8); writeSPI3 (N2 >> 16); writeSPI3 (N2 >> 24);
		CS_SI4461 = 1;
	}

	START_TX[2] = TX_to_READY; //TX_to_READY
	START_TX[4] = length;
	Si4461_CMD_stream ( START_TX, 5 );
    
	Si4461_interrupt_reset ();
    
	while (_RD11 == 1);                //wait for Tx complete

//	Ubatt = RFM22_spi_R_W (0x1B, 0x00);

//	Si4461_interrupt_reset ();
Nop();
Nop();
Nop();
}	// Transmit ()
int  receive ()	{
unsigned char k, kr;

// Сброс всех прерываний
	Si4461_interrupt_reset ();

// Длина пакета 8 байт
	PKT_LENTH[4]= 8;
	Si4461_CMD_stream ( PKT_LENTH, 5 );
	wait_ready ();
// Запуск приема пакета из восьми байт данных
	Si4461_CMD_stream ( START_RX, 3 );
	wait_ready ();

	kr = 0;
	TMR1 = 0;
	while (TMR1 < receive_timeout){ // (1){ //
//		asm ("clrwdt");
		if (_RD11 == 0) {
		kr = 1;
		break;
		}
	}

if (kr == 1) {
	Si4461_interrupt_reset ();
	TMR1 = 0;
	while (TMR1 < receive_timeout){
		if (_RD11 == 0) {
		break;
		}
	}
	if ( TMR1 >=  receive_timeout ) kr = 0;
		CS_SI4461 = 0;
			writeSPI3(0x77); // READ Rx buffer command
			for (k=0; k<8; k++)	{
			rx_buf[k] = writeSPI3 (0);
			}
		CS_SI4461 = 1;
} //if (kr == 1)

// Переход из режима RECEIVE в режим READY
	CHANGE_STATE[1] = READY;
	Si4461_CMD_stream ( CHANGE_STATE, 2 );
	wait_ready ();

// Сброс всех прерываний
	Si4461_interrupt_reset ();
Nop();
Nop();
Nop();

return kr;
} // receive ()
//void transaction_delay (void) {
//
//__delay_us(250);__delay_us(250);__delay_us(250); // !!!!!!!!!!!!!!!!!!!!!!!
//__delay_us(250);__delay_us(250);__delay_us(250);
//__delay_us(250);__delay_us(250);
////__delay_us(250);__delay_us(250);__delay_us(250);__delay_us(150);// С оптимизацией
////__delay_ms(1);__delay_us(200);// раскомментировать без оптимизации
//
//}
void read_rx_buffer (void) {
	N2 = rx_buf[7]; // Чтение приемного буфера	
	N2 = N2 << 8;	N2 = N2 + rx_buf[6];	N2 = N2 << 8;	N2 = N2 + rx_buf[5];
	N2 = N2 << 8;	N2 = N2 + rx_buf[4];	N1 = N1 << 8;	N1 = N1 + rx_buf[3]; 
	N1 = N1 << 8;	N1 = N1 + rx_buf[2];	N1 = N1 << 8;	N1 = N1 + rx_buf[1];
	N1 = N1 << 8;	N1 = N1 + rx_buf[0];
}
unsigned int  portion_chek (void) {

int tr_num_ok, unit_num_ok, NN_check_ok; 
volatile unsigned char temp;
tr_num_ok = 0; 
unit_num_ok = 0;
NN_check_ok = 0;
temp = 0;

union {
    unsigned int RESULT;
    struct
    {
        unsigned char tr_number_ok:1;
		unsigned char tr_num_ok:1;
		unsigned char decoded_ok:1;
        unsigned char validity:5;
        unsigned char not_valid:1;		
        unsigned char tr_flag_corrupted_err:1;
        unsigned char tr_number_corrupted_err:1;

        unsigned char :5;
    };     
} RESULTbits; //

 
RESULTbits.RESULT = 0;

if (tempNN2 == N2) {
	RESULTbits.decoded_ok = 1;
	if ( IN_TMPbits.transp_num == 1 ) { //1
        temp = FM25_read_1( 32 );
        if (temp == Transp_flags[1]) { // не испорчены данные о статусе метки
            if (temp == 1) { // метка валидна
                RESULTbits.tr_num_ok = 1;
            } else { // метка не валидна, но данные в буфере флагов меток не испорчены
                RESULTbits.validity = temp;
                RESULTbits.not_valid = 1;
            }
        } else { // испорчены данные в буфере
            Transp_flags[1] = temp; // восстановление корректного флага
            RESULTbits.tr_flag_corrupted_err = 1;
            RESULTbits.tr_num_ok = 1;
        }
        if (IN_TMPbits.transp_number == transp1_num)  RESULTbits.tr_number_ok = 1;
        else {
            RESULTbits.tr_number_corrupted_err = 1;
            unit_transp_sw_generator (); // генерация кодов меток заново
            if (IN_TMPbits.transp_number == transp1_num)  RESULTbits.tr_number_ok = 1; // если восстановились
        }
	}
    
	if (IN_TMPbits.transp_num == 2) {
//        Transp_flags[2] = FM25_read_1( 33 );
//		if (IN_TMPbits.transp_num == Transp_flags[2]) tr_num_ok = 2;
//        if (IN_TMPbits.transp_number == transp2_num) unit_num_ok = 1;
        
        temp = FM25_read_1( 33 );
        if (temp == Transp_flags[2]) { // не испорчены данные о статусе метки
            if (temp == 2) { // метка валидна
                RESULTbits.tr_num_ok = 1;
            } else { // метка не валидна, но данные в буфере флагов меток не испорчены
                RESULTbits.validity = temp;
                RESULTbits.not_valid = 1;
            }
        } else { // испорчены данные в буфере
            Transp_flags[2] = temp; // восстановление корректного флага
            RESULTbits.tr_flag_corrupted_err = 1;
            RESULTbits.tr_num_ok = 1;
        }
        if (IN_TMPbits.transp_number == transp2_num)  RESULTbits.tr_number_ok = 1;
        else {
            RESULTbits.tr_number_corrupted_err = 1;
            unit_transp_sw_generator (); // генерация кодов меток заново
            if (IN_TMPbits.transp_number == transp2_num)  RESULTbits.tr_number_ok = 1; // если восстановились
        }        
	}
    
	if (IN_TMPbits.transp_num == 3) {
//        Transp_flags[3] = FM25_read_1( 34 );
//		if (IN_TMPbits.transp_num == Transp_flags[3]) tr_num_ok = 2;
//        if (IN_TMPbits.transp_number == transp3_num) unit_num_ok = 1;
        
        temp = FM25_read_1( 34 );
        if (temp == Transp_flags[3]) { // не испорчены данные о статусе метки
            if (temp == 3) { // метка валидна
                RESULTbits.tr_num_ok = 1;
            } else { // метка не валидна, но данные в буфере флагов меток не испорчены
                RESULTbits.validity = temp;
                RESULTbits.not_valid = 1;
            }
        } else { // испорчены данные в буфере
            Transp_flags[3] = temp; // восстановление корректного флага
            RESULTbits.tr_flag_corrupted_err = 1;
            RESULTbits.tr_num_ok = 1;
        }
        if (IN_TMPbits.transp_number == transp3_num)  RESULTbits.tr_number_ok = 1;
        else {
            RESULTbits.tr_number_corrupted_err = 1;
            unit_transp_sw_generator (); // генерация кодов меток заново
            if (IN_TMPbits.transp_number == transp3_num)  RESULTbits.tr_number_ok = 1; // если восстановились
        }        
	}
    
	if (IN_TMPbits.transp_num == 4) {
//        Transp_flags[4] = FM25_read_1( 35 );
//		if (IN_TMPbits.transp_num == Transp_flags[4]) tr_num_ok = 2;
//        if (IN_TMPbits.transp_number == transp4_num) unit_num_ok = 1;
        
        temp = FM25_read_1( 35 );
        if (temp == Transp_flags[4]) { // не испорчены данные о статусе метки
            if (temp == 4) { // метка валидна
                RESULTbits.tr_num_ok = 1;
            } else { // метка не валидна, но данные в буфере флагов меток не испорчены
                RESULTbits.validity = temp;
                RESULTbits.not_valid = 1;
            }
        } else { // испорчены данные в буфере
            Transp_flags[4] = temp; // восстановление корректного флага
            RESULTbits.tr_flag_corrupted_err = 1;
            RESULTbits.tr_num_ok = 1;
        }
        if (IN_TMPbits.transp_number == transp4_num)  RESULTbits.tr_number_ok = 1;
        else {
            RESULTbits.tr_number_corrupted_err = 1;
            unit_transp_sw_generator (); // генерация кодов меток заново
            if (IN_TMPbits.transp_number == transp4_num)  RESULTbits.tr_number_ok = 1; // если восстановились
        }        
	}
    
	if (IN_TMPbits.transp_num == 5) {
//        Transp_flags[5] = FM25_read_1( 36 );
//		if (IN_TMPbits.transp_num == Transp_flags[5]) tr_num_ok = 2;
//        if (IN_TMPbits.transp_number == transp5_num) unit_num_ok = 1;
        
        temp = FM25_read_1( 36 );
        if (temp == Transp_flags[5]) { // не испорчены данные о статусе метки
            if (temp == 5) { // метка валидна
                RESULTbits.tr_num_ok = 1;
            } else { // метка не валидна, но данные в буфере флагов меток не испорчены
                RESULTbits.validity = temp;
                RESULTbits.not_valid = 1;
            }
        } else { // испорчены данные в буфере
            Transp_flags[5] = temp; // восстановление корректного флага
            RESULTbits.tr_flag_corrupted_err = 1;
            RESULTbits.tr_num_ok = 1;
        }
        if (IN_TMPbits.transp_number == transp5_num)  RESULTbits.tr_number_ok = 1;
        else {
            RESULTbits.tr_number_corrupted_err = 1;
            unit_transp_sw_generator (); // генерация кодов меток заново
            if (IN_TMPbits.transp_number == transp5_num)  RESULTbits.tr_number_ok = 1; // если восстановились
        }        
	}
    
	if (IN_TMPbits.transp_num == 6) { //Transp_flags[6]
		RESULTbits.tr_num_ok = 1;
//            if (IN_TMPbits.transp_number == transp6_num) {
//                Nop();Nop();Nop();
//                unit_num_ok = 1;
//            }
        if (IN_TMPbits.transp_number == transp6_num)  RESULTbits.tr_number_ok = 1;
        else {
            RESULTbits.tr_number_corrupted_err = 1;
            unit_transp_sw_generator (); // генерация кодов меток заново
            if (IN_TMPbits.transp_number == transp6_num)  RESULTbits.tr_number_ok = 1; // если восстановились
        }        
	}

} //if (tempNN2 == N2)

//return NN_check_ok | tr_num_ok | unit_num_ok;
return RESULTbits.RESULT;

} // int portion_chek ()
int  RF_data_handler ( void ) {
volatile int result_tmp, portion_corrupted_flag; 
//static unsigned long expected_N2;
volatile union {
    unsigned int RESULT;
    struct
    {
        unsigned char tr_number_ok:1;
		unsigned char tr_num_ok:1;
		unsigned char decoded_ok:1;
        unsigned char validity:5;
        unsigned char not_valid:1;		
        unsigned char tr_flag_corrupted_err:1;
        unsigned char tr_number_corrupted_err:1;

        unsigned char :5;
    };     
} RESULTbits; //

    if ( RFSTATEbits.receiving == 4 ) {
//Генерация ожидаемой посылки
        N1 = tempN1; N2 = tempN2;
        LFSRbits.LFSR = N2;
        Gamma_H (); N2 = LFSRbits.LFSR;
        tempN1 = N1; tempN2 = N2;
        
            read_rx_buffer ();
Nop();Nop();Nop(); 
//H0[0] = 1;
//K0 = 0xA96051EC;
            Decription ();	Gamma_L();	N1 = N1 ^ omega0; // Дешифровка
            portion_corrupted_flag = 0;
            if ( N2 != tempN2 ) {
                portion_corrupted_flag = 1;
                restor_encription_keys ();
                read_rx_buffer ();
                Nop();Nop();Nop();                
                Decription ();	Gamma_L();	N1 = N1 ^ omega0; // Дешифровка
                Nop();Nop();Nop();
            }
            
            N1_freezed = N1; N2_freezed = N2; timer1_freezed = 0; // Контроль всех посылок по радиоканалу
            IN_TMPbits.IN_TMP = N1;
            if (RELTASKSbits.state == 1)    RIN2_TMPbits.RIN2_TMP   = N1;
            if (RELTASKSbits.state == 2)    RIN3_TMPbits.RIN3_TMP   = N1;
            if (RLEARNTASKSbits.start == 1) RLIN_TMPbits.RLIN_TMP   = N1;
            if (TLEARNTASKSbits.start == 1) IN_TLEARNbits.IN_TLEARN = N1;
            if (TFINISHTASKSbits.start == 1) IN_TLEARNbits.IN_TLEARN = N1;
            N1 = N1 & 0x01FFFFFF;
            tempNN2 = N2;
            N1 = tempN1 & 0x03FFFFFF;
            N2 = tempN2;

//static char counter = 0;            
        if (RELTASKSbits.state == 0 && RLEARNTASKSbits.start == 0) { // Сообщение от метки или начальное сообщение от реле
            
//            IN_TMPbits.transp_number = transp2_num; IN_TMPbits.transp_num = 2; 
            
            RESULTbits.RESULT = portion_chek ();
            result_tmp = RESULTbits.RESULT & 0x07;
            Nop();Nop();Nop();
            
            if ( portion_corrupted_flag == 1 ) {
                if ( RESULTbits.decoded_ok == 1 ) {
                    if (DIAGNSIGNALSbits.keys_restored == 1) load_answer ( 2, "encription keys restored", 0, 0 );
                } else {
                    if (DIAGNSIGNALSbits.messsage_corr == 1) load_answer ( 2, "message corrupted", 0, 0 );
                }
            }
            
            if ( RESULTbits.tr_flag_corrupted_err == 1 ) { //    
                Nop();Nop();Nop();
                if (DIAGNSIGNALSbits.tr_flag_restored == 1) load_answer ( 2, "transponder flag restored", 0, 0 );
            }
            
            if ( result_tmp == 5 ) { //   
                Nop();Nop();Nop();
//                tr_not_valid_flag = 1;
                volatile unsigned int temp1; unsigned char temp[5], temp2;
                temp[0] = IN_TMPbits.transp_num + 0x30; temp[1] = ',';
                temp2 = RESULTbits.validity;
                temp1 = convert_hex_to_hexstr ( &temp2 );
                temp[2] = (unsigned char)(temp1 >> 8); temp[3] = (unsigned char)(temp1 & 0x00FF);
                temp[4] = 0;
                send_transponder_not_valid_message ( 1, &temp, 0 );
//                if (DIAGNSIGNALSbits.not_valid_transp == 1) load_answer ( 2, "transponder not valid ", &temp, 0 );
            }
            
            if ( result_tmp == 0 ) { //   
                Nop();Nop();Nop();
                if (DIAGNSIGNALSbits.reset_rf1 == 1) load_answer ( 2, "reset rf due freezed 1", 0, 0 );
            char k;
            CS_SI4461 = 0;
                writeSPI3(0x77); // READ Rx buffer command
                for (k=0; k<8; k++)	{
                    rx_buf[k] = writeSPI3 (0);
                }
            CS_SI4461 = 1;                
/*                rf_reset_flag1 = 1; */
//            if (counter < 5) counter ++;
//            else {
//                Nop();Nop();Nop();
//                counter = 0;
//                char k;
//                CS_SI4461 = 0;
//                    writeSPI3(0x77); // READ Rx buffer command
//                    for (k=0; k<8; k++)	{
//                        rx_buf[k] = writeSPI3 (0);
//                    }
//                CS_SI4461 = 1;
//                load_answer ( 2, "reset rf 1", 0, 0 );
//            }
            }

            if (result_tmp == 7) {
                
//                if ( rf_reset_flag1 == 1 ) load_answer ( 2, "transp ok due rf_reset_flag1", 0, 0 );
                rf_reset_flag1 = 0;
                timer1_freezed = 0; //контроль времени последнего корректного сообщения
                RF_freezed_monitor_flag = 0; // Если принят сигнал от валидного реле или метки, считаем что радиоканал не завис
                F_freezed_monitor_run_counter = 0; // Если принят сигнал от валидного реле или метки, считаем что радиоканал не завис на ходу
                rf_reset_monitor_flag = 0;
                rf_reset_counter = 0;
                if ( IN_TMPbits.transp_num != 6 && (result_tmp & 0b00000100) ) {
                    STATUSFLAGS1bits.transp_num = IN_TMPbits.transp_num;
                }                
                
                if (IN_TMPbits.transp_num != 6) {
                    if ( DIAGNSIGNALSbits.vis_transp == 1 )load_visible_transponders_buf ( (unsigned char) IN_TMPbits.transp_num );
                        if ( DIAGNSIGNALSbits.transp_ok == 1 ) load_answer ( 2, "transponder link done", 0, 0 );
                        
                        transp_presence_counter = 0;
                        STATUSFLAGS1bits.transp_present = 1;
                        STATUSFLAGS1bits.transponder_battery_flag = IN_TMPbits.battery_voltage_flag;
                        RF_WDT = 0;
                        OUTbits.power_status = 1;
                        INbits.IN = IN_TMPbits.IN_TMP >> 24;
//                        if ( OUTbits.serv_flag == 1 && PERIFSLEEPSETbits.rf == 1 ) {} else sleep_counter = 0;
                        if ( PERIFSLEEPSETbits.rf == 1 ) {} else sleep_counter = 0;
                        ROBBFLAGSbits.ROBBFLAGS = 0;
                        HANDSFREETASCK2bits.transp_trigger_flag = 1;
                        HANDSFREETASCK2bits.timer = 0;
                // Паника
                    if (INbits.panic == 1) generate_panic_flag = 1;    
                // Сервисный режим
                    if ((INbits.servON_flag == 1)&&(INbits.servOFF_flag == 0)) {
                        if (OUTbits.serv_flag == 0) start_beep_task ( 7, 7, 3 );
                            fire_rel_transaction_flag = 1;
                            RELTRANSFLGSbits.rel_serv_on = 1;
                            OUTbits.serv_flag = 1;
                            OUTbits.arm_flag = 0; //!!!!!!!!!!!!!!!!!!!
                         
                            SERVFLAGSbits.serv_status = 1;
                            SERVFLAGSbits.serv_on_event = 1;
                            SERVFLAGSbits.serv_off_event = 0;
                            SERVFLAGSbits.serv_off_event_sent = 0;
                            ARMFLAGSbits.arm_timer = 0;
                            ARMFLAGSbits.arm_status = 0;
                            ARMFLAGSbits.arm_on_event = 0;
                            ARMFLAGSbits.arm_on_event_sent = 0;                            
                            ARMFLAGSbits.intrusion_timer = 0;
                            ARMFLAGSbits.intr_event_trigg = 0;
                            ARMFLAGSbits.intr_event = 0;
                            ARMFLAGSbits.intr_event_sent = 0;
                            INTRREASONbits.INTRREASON = 0;                            
                    }
                    if ((INbits.servON_flag == 0)&&(INbits.servOFF_flag == 1)) {
                        if (OUTbits.serv_flag == 1) start_beep_task ( 7, 7, 3 );
                            fire_rel_transaction_flag = 1;
                            RELTRANSFLGSbits.rel_serv_off = 1;
                            OUTbits.serv_flag = 0;
                            SERVFLAGSbits.serv_status = 0;
                            SERVFLAGSbits.serv_off_event = 1;
                            SERVFLAGSbits.serv_on_event = 0;
                            SERVFLAGSbits.serv_on_event_sent = 0;
                    }
                    if (OUTbits.arm_flag == 0) {
                        ARMFLAGSbits.arm_timer = 0;
                        ARMFLAGSbits.arm_status = 0;
                    }
                    if (INbits.disarm_flag == 1) {
//                        if (OUTbits.arm_flag == 1) start_beep_task ( 7, 7, 2 ); // писк снятия с охраны
//                        HANDSFREETASCK2bits.start = 1;
                        if (SECONDAUTHORbits.on == 0) {
                            fire_rel_transaction_flag = 1;
                            RELTRANSFLGSbits.rel_disarm = 1;
                        }
                        OUTbits.arm_flag = 0;
                        ARMFLAGSbits.arm_timer = 0;
                        ARMFLAGSbits.arm_status = 0;
                        ARMFLAGSbits.arm_on_event = 0;
                        ARMFLAGSbits.arm_on_event_sent = 0;
                        ARMFLAGSbits.intrusion_timer = 0;
                        ARMFLAGSbits.intr_event_trigg = 0;
                        ARMFLAGSbits.intr_event = 0;
                        ARMFLAGSbits.intr_event_sent = 0;
                        ARMFLAGSbits.arm_off_event = 1;
                        INTRREASONbits.INTRREASON = 0;

                    }
                    OUTbits.transp_num = INbits.transp_num;	
                    N1 = N1 | OUTbits.OUT;
//                    N1 = OUTbits.OUT;
                } // Метка
                else { // Реле
                    Nop();Nop();Nop();
//                    if (RLEARNTASKSbits.start == 0) { // Посылка от уже прописанного реле
                        periodic_relay_transaction_counter = 0;
                        RF_WDT = 0;
                        RELTASKSbits.state = 1;
                        RIN2_TMPbits.RIN2_TMP = 0;
                        RIN3_TMPbits.RIN3_TMP = 0;
                        IEC0bits.T3IE = 0; rel_timeout_counter = 60; IEC0bits.T3IE = 1; // Таймаут двух последних циклов общения с реле 30мс
                        rel_transaction_flag = 1;
                        
                        if ( fake_serv_flag == 2 || STARTENGINEbits.start == 1 || STARTENGINESbits.start == 1 || STARTENGINEDLbits.start == 1 || STARTENGINEPbits.start == 1 || STARTENGINEObits.start == 1 || STARTENGINEO1bits.start == 1 || STARTENGINECbits.start_tasck == 1 ) {
                            OUTTMPbits.OUTTMP = OUTbits.OUT;
                            OUTTMPbits.arm_flag = 0;
                            if ( fake_serv_flag == 2 ) OUTTMPbits.serv_flag = 1;
                            N1 = OUTTMPbits.OUTTMP;
                        } else {
                            if (SECONDAUTHORbits.on == 1) {
                                OUTTMPbits.OUTTMP = OUTbits.OUT;
                                if (disarmed_by_button_flag == 0) {
                                    OUTTMPbits.arm_flag = 1;    
                                }
                                N1 = OUTTMPbits.OUTTMP; 
                            } else {
                                N1 = OUTbits.OUT;
                            }
                        }
//                    }
//                    else { // Посылка от реле в режиме обучения
//                        Nop();Nop();Nop();
//                    }
                }
            }

        }
        else { // Сообщения 2 и 3 от реле
            Nop();Nop();Nop();
//            result_tmp = portion_chek ();
            RESULTbits.RESULT = 0;
                       
            if (tempNN2 == N2) {
                RESULTbits.decoded_ok = 1;
                if (IN_TMPbits.transp_num == 0) { //Transp_flags[6]
                    RESULTbits.tr_num_ok = 1;
                    if (IN_TMPbits.transp_number == transp6_num)  RESULTbits.tr_number_ok = 1;
                    else {
                        RESULTbits.tr_number_corrupted_err = 1;
                        unit_transp_sw_generator (); // генерация кодов меток заново
                        if (IN_TMPbits.transp_number == transp6_num)  RESULTbits.tr_number_ok = 1; // если восстановились
                    }        
                }
            }
            result_tmp = RESULTbits.RESULT & 0x07; 
            if (result_tmp == 0) {
//            Gamma_H ();    
            Nop();Nop();Nop();
/*            rf_reset_flag1 = 1; */
                if (DIAGNSIGNALSbits.reset_rf1 == 1) load_answer ( 2, "reset rf due freezed 1", 0, 0 );
                char k;
                CS_SI4461 = 0;
                    writeSPI3(0x77); // READ Rx buffer command
                    for (k=0; k<8; k++)	{
                        rx_buf[k] = writeSPI3 (0);
                    }
                CS_SI4461 = 1;             
            
//            if (counter < 5) counter ++;
//            else {
//                Nop();Nop();Nop();
//                counter = 0;
//                char k;
//                CS_SI4461 = 0;
//                    writeSPI3(0x77); // READ Rx buffer command
//                    for (k=0; k<8; k++)	{
//                        rx_buf[k] = writeSPI3 (0);
//                    }
//                CS_SI4461 = 1; 
//                load_answer ( 2, "reset rf 1", 0, 0 );
//            }
//            
            }            
            if (result_tmp == 7) {
                rf_reset_flag1 = 0;
            }
            RF_WDT = 0;
            if (RELTASKSbits.state == 1) {
                RELTASKSbits.state = 2;
                RELOUTbits.counter = RIN2_TMPbits.counter + 1;
                RELOUTbits.serv_flag = OUTbits.serv_flag; RELOUTbits.arm_flag = OUTbits.arm_flag;
                RELOUTbits.autorun_flag = STARTENGINEbits.start;
                    if ( srvr_flag == 1 || fake_serv_flag == 2 || STARTENGINEbits.start == 1 || STARTENGINESbits.start == 1 || STARTENGINEDLbits.start == 1 || STARTENGINEPbits.start == 1 || STARTENGINEObits.start == 1 || STARTENGINEO1bits.start == 1 || STARTENGINECbits.start_tasck == 1  ) {
                        RELOUTTMPbits.RELOUTTMP = RELOUTbits.RELOUT;
                        RELOUTTMPbits.arm_flag = 0;
                        if ( srvr_flag == 1 || fake_serv_flag == 2 ) RELOUTTMPbits.serv_flag = 1;
                        N1 = RELOUTTMPbits.RELOUTTMP;
                    } else {
                        if (SECONDAUTHORbits.on == 1) {
                            RELOUTTMPbits.RELOUTTMP = RELOUTbits.RELOUT;
                            if (disarmed_by_button_flag == 0) {
                                RELOUTTMPbits.arm_flag = 1;    
                            }
                            N1 = RELOUTTMPbits.RELOUTTMP;                            
                        } else {
                            N1 = RELOUTbits.RELOUT;
                        }
                    }
                
            } else {
                if (RELTASKSbits.state == 2) {
                    RELTASKSbits.state = 0;
                        if ( srvr_flag == 1 || fake_serv_flag == 2 || STARTENGINEbits.start == 1 || STARTENGINESbits.start == 1 || STARTENGINEDLbits.start == 1 || STARTENGINEPbits.start == 1 || STARTENGINEObits.start == 1 || STARTENGINEO1bits.start == 1 || STARTENGINECbits.start_tasck == 1  ) {
                            OUTTMPbits.OUTTMP = OUTbits.OUT;
                            OUTTMPbits.arm_flag = 0;
                            if ( srvr_flag == 1 || fake_serv_flag == 2 ) OUTTMPbits.serv_flag = 1;
                            N1 = OUTTMPbits.OUTTMP;
                        } else { 
                            if (SECONDAUTHORbits.on == 1) {
                                OUTTMPbits.OUTTMP = OUTbits.OUT;
                                if (disarmed_by_button_flag == 0) {
                                    OUTTMPbits.arm_flag = 1;    
                                }
                                N1 = OUTTMPbits.OUTTMP; 
                            } else {
                                N1 = OUTbits.OUT;
                            }
                        }
                    RELTASKSbits.state = 0;
                    RELTASKSbits.complete = 1;
                    RELTASKSbits.timeout_counter = 2;
                } 
            }
        }
        
        if (RLEARNTASKSbits.start == 1) {
            Nop();Nop();Nop();
            N1 = first_IMEI_digits;
            if (RLIN_TMPbits.transp_number == transp6_num) {
                Nop();Nop();Nop();
                RLEARNTASKSbits.complete = 1;
            }
            
        }
        if (TLEARNTASKSbits.start == 1 || TFINISHTASKSbits.start == 1) {
            Nop();Nop();Nop();
//            OUT_TLEARNbits.number = first_IMEI_digits;
//            OUT_TLEARNbits.transp_num = TLEARNTASKSbits.temp_tr_num;
            N1 = OUT_TLEARNbits.OUT_TLEARN;
            
        }             
        
    } //if ( RFSTATEbits.receiving == 4 )
static unsigned char counter_5 = 0;
    if ( RFSTATEbits.receiving == 5 ) {
//        if ( counter_5 < 2 ) counter_5 ++;
//        else {
        if ( RELTASKSbits.state != 0 ) {
            Nop();Nop();Nop(); 
        }
            unit_transp_sw_generator ();
            restor_encription_keys ();
            if ( DIAGNSIGNALSbits.lnk_not_compl == 1 ) {
                if ( RELTASKSbits.state == 0 ) { load_answer ( 2, "Transponder link not completed", 0, 0 ); }
                else { load_answer ( 2, "Relay link not completed", 0, 0 ); }
            }
            char k;
            CS_SI4461 = 0;
                writeSPI3(0x77); // READ Rx buffer command
                for (k=0; k<8; k++)	{ rx_buf[k] = writeSPI3 (0); }
            CS_SI4461 = 1;            
//        }
    }

if ( RFSTATEbits.receiving == 4 ) counter_5 = 0;
    
    Si4461_start_receiving ();
    RFSTATEbits.RFSTATE = 0;
    RFSTATEbits.waiting_inquiry = 1;
    
	Gamma_H (); N2 = LFSRbits.LFSR; Gamma_L ();
    if (RELTASKSbits.state == 0 && RLEARNTASKSbits.start == 0 && TLEARNTASKSbits.start == 0 && TFINISHTASKSbits.start == 0) {
        N1 = OUTbits.OUT; N2 = LFSRbits.LFSR;
    }
    else N2 = LFSRbits.LFSR;

	tempN1 = N1; tempN2 = N2;
	N1 = N1 ^ omega0; //Наложение гаммы
	Encription ();

    
    return result_tmp;
}
void disarm_by_doors_unlock (void) {
    
    if ( disarm_by_doors_unlock_enable != 1 ) return;
    
    fire_rel_transaction_flag = 1;
    RELTRANSFLGSbits.rel_disarm = 1;
    OUTbits.arm_flag = 0;
    ARMFLAGSbits.arm_timer = 0;
    ARMFLAGSbits.arm_status = 0;
    ARMFLAGSbits.arm_on_event = 0;
    ARMFLAGSbits.arm_on_event_sent = 0;
    ARMFLAGSbits.intrusion_timer = 0;
    ARMFLAGSbits.intr_event_trigg = 0;
    ARMFLAGSbits.intr_event = 0;
    ARMFLAGSbits.intr_event_sent = 0;
    ARMFLAGSbits.arm_off_event = 1;
    INTRREASONbits.INTRREASON = 0;
                        
}
void load_visible_transponders_buf ( unsigned char num ) {

unsigned int temp = 0;

    transp_in_zone_counter ++;
    
    temp = (int)convert_hex_to_hexstr ( &transp_in_zone_counter );
    Transp_in_zone[10] = (unsigned char) (temp >> 8);
    Transp_in_zone[11] = (unsigned char) (temp & 0x00FF);
    
    switch ( num ) {
        
        case 1:
            Transp_in_zone[0] = '1';
        break;

        case 2:
            Transp_in_zone[2] = '2';
        break;

        case 3:
            Transp_in_zone[4] = '3';
        break;

        case 4:
            Transp_in_zone[6] = '4';
        break;

        case 5:
            Transp_in_zone[8] = '5';
        break;

        default:
        break;
        
    }
    
}
void generate_visible_transponders_list_message ( int connection_status ) {

static unsigned int counter = 0;    

    if ( DIAGNSIGNALSbits.vis_transp == 0 ) {
        Transp_in_zone[0]  = '0'; Transp_in_zone[1]  = ',';
        Transp_in_zone[2]  = '0'; Transp_in_zone[3]  = ',';
        Transp_in_zone[4]  = '0'; Transp_in_zone[5]  = ',';
        Transp_in_zone[6]  = '0'; Transp_in_zone[7]  = ',';
        Transp_in_zone[8]  = '0'; Transp_in_zone[9]  = ',';
        Transp_in_zone[10] = '0'; Transp_in_zone[11] = '0';
        Transp_in_zone[12] = 0;
        counter = 0;
        return;
    } 
    
    if ( connection_status != 4 ) return;


    if ( counter < 100 ) counter ++;
    else {
        load_answer ( 2, "Visible transponders ", &Transp_in_zone, 0 );
        counter = 0;
        transp_in_zone_counter = 0;
        Transp_in_zone[0]  = '0'; Transp_in_zone[1]  = ',';
        Transp_in_zone[2]  = '0'; Transp_in_zone[3]  = ',';
        Transp_in_zone[4]  = '0'; Transp_in_zone[5]  = ',';
        Transp_in_zone[6]  = '0'; Transp_in_zone[7]  = ',';
        Transp_in_zone[8]  = '0'; Transp_in_zone[9]  = ',';
        Transp_in_zone[10] = '0'; Transp_in_zone[11] = '0';
        Transp_in_zone[12] = 0;        
    }

    
    
}
void restor_encription_keys (void) {

	K0 = 0xA96051EB;
	K1 = 0x8F37DC24;
	K2 = 0xB39D2871;
	K3 = 0xA540ECF6;
	K4 = 0x250B3A4C;
	K5 = 0x968EF7D1;
	K6 = 0x516B0E8D;
	K7 = 0xC249F73A;
    
    H0[0]  = 3;
    H0[1]  = 0;
    H0[2]  = 15;
    H0[3]  = 14;
    H0[4]  = 6;
    H0[5]  = 11;
    H0[6]  = 4;
    H0[7]  = 13;
    H0[8]  = 5;
    H0[9]  = 12;
    H0[10] = 10;
    H0[11] = 9;
    H0[12] = 8;
    H0[13] = 7;
    H0[14] = 2;
    H0[15] = 1;
    
    H1[0]  = 11;
    H1[1]  = 6;
    H1[2]  = 2;
    H1[3]  = 4;
    H1[4]  = 3;
    H1[5]  = 9;
    H1[6]  = 14;
    H1[7]  = 1;
    H1[8]  = 12;
    H1[9]  = 7;
    H1[10] = 8;
    H1[11] = 13;
    H1[12] = 0;
    H1[13] = 15;
    H1[14] = 10;
    H1[15] = 5;

    H2[0]  = 9;
    H2[1]  = 13;
    H2[2]  = 5;
    H2[3]  = 3;
    H2[4]  = 7;
    H2[5]  = 4;
    H2[6]  = 1;
    H2[7]  = 10;
    H2[8]  = 8;
    H2[9]  = 0;
    H2[10] = 15;
    H2[11] = 2;
    H2[12] = 11;
    H2[13] = 6;
    H2[14] = 12;
    H2[15] = 14;

    H3[0]  = 4;
    H3[1]  = 0;
    H3[2]  = 15;
    H3[3]  = 9;
    H3[4]  = 11;
    H3[5]  = 8;
    H3[6]  = 10;
    H3[7]  = 12;
    H3[8]  = 1;
    H3[9]  = 3;
    H3[10] = 5;
    H3[11] = 6;
    H3[12] = 7;
    H3[13] = 14;
    H3[14] = 13;
    H3[15] = 2;

    H4[0]  = 12;
    H4[1]  = 4;
    H4[2]  = 0;
    H4[3]  = 15;
    H4[4]  = 2;
    H4[5]  = 6;
    H4[6]  = 1;
    H4[7]  = 10;
    H4[8]  = 11;
    H4[9]  = 3;
    H4[10] = 8;
    H4[11] = 5;
    H4[12] = 9;
    H4[13] = 13;
    H4[14] = 14;
    H4[15] = 7;

H5[0] = 10;
H5[1] = 14;
H5[2] = 6;
H5[3] = 3;
H5[4] = 15;
H5[5] = 13;
H5[6] = 5;
H5[7] = 8;
H5[8] = 4;
H5[9] = 9;
H5[10] = 12;
H5[11] = 7;
H5[12] = 11;
H5[13] = 2;
H5[14] = 0;
H5[15] = 1;

H6[0] = 6;
H6[1] = 3;
H6[2] = 2;
H6[3] = 11;
H6[4] = 13;
H6[5] = 5;
H6[6] = 7;
H6[7] = 12;
H6[8] = 14;
H6[9] = 4;
H6[10] = 9;
H6[11] = 8;
H6[12] = 1;
H6[13] = 10;
H6[14] = 0;
H6[15] = 15;

H7[0] = 2;
H7[1] = 8;
H7[2] = 13;
H7[3] = 6;
H7[4] = 7;
H7[5] = 3;
H7[6] = 5;
H7[7] = 12;
H7[8] = 9;
H7[9] = 4;
H7[10] = 14;
H7[11] = 1;
H7[12] = 11;
H7[13] = 0;
H7[14] = 10;
H7[15] = 15;    
    
}
/*
void destroy_keys_flags (unsigned char connection) {
    static unsigned int counter = 0;
    
    if (connection != 4) return;
    
    if (counter < 300) counter ++;
    else {
        counter = 0;
    }
    
    if (counter == 140) H0[0] = 1;
    if (counter == 290) K0 = 0xA96051EC;    
    
}
*/
void relay_transactions_monitor (void) {
    
    if (RELTASKSbits.complete == 1) {
        Nop();Nop();Nop();
        if (RIN3_TMPbits.confirmation == 1) {
            Nop();Nop();Nop();
            fire_rel_transaction_flag = 0;
            RELOUTbits.command = 0;
            RELOUTbits.param_value = 0; 
            if ( fake_serv_flag == 2 ) {
               if ( RELTRANSFLGSbits.rel_serv_fake == 1 && DIAGNSIGNALSbits.rel_serv_fake ) { RELTRANSFLGSbits.rel_serv_fake = 0; load_answer ( 2, "relay fake service link done", 0, 0 ); }
            } 
            if ( RELTRANSFLGSbits.RELTRANSFLGS == 0 && DIAGNSIGNALSbits.rel_itself ) { load_answer ( 2, "relay itself link done", 0, 0 ); }
            if ( RELTRANSFLGSbits.rel_periodic == 1 && DIAGNSIGNALSbits.rel_periodic ) { RELTRANSFLGSbits.rel_periodic = 0; load_answer ( 2, "relay periodic link done", 0, 0 ); }
            if ( RELTRANSFLGSbits.rel_arm && DIAGNSIGNALSbits.rel_arm ) { 
                if ( srvr_flag == 0 ) {RELTRANSFLGSbits.rel_arm = 0; load_answer ( 2, "relay arm link done srvsr=0", 0, 0 );} 
                else {RELTRANSFLGSbits.rel_arm = 0; load_answer ( 2, "relay arm link done srvsr=1", 0, 0 );}
            }
            if ( RELTRANSFLGSbits.rel_disarm && DIAGNSIGNALSbits.rel_disarm ) { RELTRANSFLGSbits.rel_disarm = 0; load_answer ( 2, "relay disarm link done", 0, 0 ); }
            if ( RELTRANSFLGSbits.rel_serv_on && DIAGNSIGNALSbits.rel_serv_on ) { RELTRANSFLGSbits.rel_serv_on = 0; load_answer ( 2, "relay service ON link done", 0, 0 ); }
            if ( RELTRANSFLGSbits.rel_serv_off && DIAGNSIGNALSbits.rel_serv_off ) { 
                if ( srvr_flag == 0 ) {RELTRANSFLGSbits.rel_serv_off = 0; load_answer ( 2, "relay service OFF link done srvr=0", 0, 0 );} 
                else {RELTRANSFLGSbits.rel_serv_off = 0; load_answer ( 2, "relay service OFF link done srvr=1", 0, 0 );}
            }
            if ( RELTRANSFLGSbits.rel_block ) { generate_content_of_message ( 88, 1 ); }
            if ( RELTRANSFLGSbits.rel_unblock ) { generate_content_of_message ( 89, 1 ); }            
            if ( RELTRANSFLGSbits.rel_block && DIAGNSIGNALSbits.rel_block ) { RELTRANSFLGSbits.rel_block = 0; load_answer ( 2, "relay block link done", 0, 0 ); }
            if ( RELTRANSFLGSbits.rel_unblock && DIAGNSIGNALSbits.rel_unblock ) { RELTRANSFLGSbits.rel_unblock = 0; load_answer ( 2, "relay unblock link done", 0, 0 ); }
            if ( RELTRANSFLGSbits.rel_only_serv_on && DIAGNSIGNALSbits.rel_only_serv ) { RELTRANSFLGSbits.rel_only_serv_on = 0; load_answer ( 2, "relay_only serv ON link done", 0, 0 ); }
            if ( RELTRANSFLGSbits.rel_only_serv_off && DIAGNSIGNALSbits.rel_only_serv ) { RELTRANSFLGSbits.rel_only_serv_off = 0; load_answer ( 2, "relay_only serv OFF link done", 0, 0 ); }            
            if ( RELTRANSFLGSbits.rel_disarm_by_button && DIAGNSIGNALSbits.rel_disarm_by_button ) { RELTRANSFLGSbits.rel_disarm_by_button = 0; load_answer ( 2, "relay disarm by button link done", 0, 0 ); }            

            RELTRANSFLGSbits.RELTRANSFLGS = 0;
            

        }
    }
    
    rel_transaction_flag = 0;
    SW2_receive1 = SW2_receive1_transp; //SW2_receive1
    Si4461_start_receiving ();
    RFSTATEbits.RFSTATE = 0;
    RFSTATEbits.waiting_inquiry = 1; 
    
    RELTASKSbits.RELTASKS = 0; 
}
void periodic_relay_transaction (void) {
    
# if defined (DIRECTTX)
return;    
# endif
    
    if ( relay_enable == 0 || OUTbits.arm_flag == 1 || OUTbits.serv_flag == 1 ) { 
        periodic_relay_transaction_counter = 0; return; 
    }
    
    if (fire_rel_transaction_flag == 1) periodic_relay_transaction_counter = 0;
    
    if (periodic_relay_transaction_counter < 110) periodic_relay_transaction_counter++; 
    else {
        periodic_relay_transaction_counter = 0;
        fire_rel_transaction_flag = 1;
        RELTRANSFLGSbits.rel_periodic = 1;
//        start_beep_task ( 5, 5, 1 );
    }
    
}
void fire_relay_transaction (void) {
static char counter = 0;

//if (relay_enable == 0) {
//    fire_rel_transaction_flag = 0;
//}
Nop();Nop();Nop();
if (fire_rel_transaction_flag == 0) {
    counter = 0;
    return;
}

if (counter < 8) counter ++;
else counter = 0;

if (counter == 2) {   
    if (RFSTATEbits.waiting_inquiry == 1 && RFSTATEbits.transmitting == 0 && RFSTATEbits.receiving == 0) {
       
        CHANGE_STATE[1] = READY;
        Si4461_CMD_stream ( CHANGE_STATE, 2 );
        while (Si4461_get_reply_stream ( READ_CMD_BUFF, 0 ) != 0xFF); //wait_ready ();
        SYNC_BITS_SW2 [4] = SW2_receive1_relay | SW2; // для общения с реле
        Si4461_CMD_stream ( SYNC_BITS_SW2, 5 );
        while (Si4461_get_reply_stream ( READ_CMD_BUFF, 0 ) != 0xFF); //wait_ready ();        

        
        T1CONbits.TON = 0;
        TMR1 = 0; PR1 = 40;
        T1CONbits.TON = 1;
//        L_OUT = 1;
        START_TX[2] = TX_to_READY; //TX_to_READY
        START_TX[4] = 0;
        Si4461_CMD_stream ( START_TX, 5 );
        Si4461_CMD_stream ( GET_INT_STATUS, 1 ); //Si4461_interrupt_reset ();
//        while (Si4461_get_reply_stream ( READ_CMD_BUFF, 0 ) != 0xFF); //wait_ready ();        
        
        fire_relay_flag = 1;
        
    }
    
}
    
    
}
void rel_learn_transactions_monitor (void) {
//unsigned char SW0_tmp, SW1_tmp, SW2_tmp;

   
    if (RLEARNTASKSbits.start == 0) return;
    
    if (RLEARNTASKSbits.timeout_counter == 0) {
        
        Nop();Nop();Nop();
        SYNC_BITS [4] = SW2_lrn_rel; SYNC_BITS [5] = SW1_lrn_rel; SYNC_BITS [6] = SW0_lrn_rel; SYNC_BITS [7] = 0x00; 
        Si4461_CMD_stream ( SYNC_BITS, 8 );
        wait_ready (); 
        Si4461_start_receiving ();
        
        start_beep_task ( 500, 1, 1 );
    }
    
    if (RLEARNTASKSbits.complete == 1)  {
        RLEARNTASKSbits.timeout_counter = 600;
        stop_beep_task ();
    }

    if (RLEARNTASKSbits.timeout_counter < 600) RLEARNTASKSbits.timeout_counter ++;
    else {
        RLEARNTASKSbits.RLEARNTASKS = 0; 
        
        SYNC_BITS [4] = SW2; SYNC_BITS [5] = SW1; SYNC_BITS [6] = SW0; SYNC_BITS [7] = 0x00; 
        Si4461_CMD_stream ( SYNC_BITS, 8 );
        wait_ready (); 
        Si4461_start_receiving ();

        if (RLEARNTASKSbits.complete == 1) {
//            write_data_to_GPRS_buf ( "Relay learned", 13 );
            if ( RELTRANSFLGSbits.rel_learn && DIAGNSIGNALSbits.rel_learn ) { 
                RELTRANSFLGSbits.rel_learn = 0; 
                load_answer ( 2, "relay learn link done", 0, 0 ); 
            }
            start_beep_task ( 20, 20, 2 );
        }
        else  {
            RELTRANSFLGSbits.rel_learn = 0;
            start_beep_task ( 20, 20, 3 );
        }
    }
    
}

int RF_freezed_monitor (void) {

# if defined (DIRECTTX)
return;    
# endif

    if ( rf_reset_enable != 1 ) return;
    
    if ( ARMFLAGSbits.intrusion_timer >= 150 ) {
        Nop();Nop();Nop();
        if (RF_freezed_monitor_flag == 1) {
            Nop();Nop();Nop();
            FM25_write_1( 8, 1 ); // признак перезагрузки для развешивания
            FM25_write_4( 9, (unsigned long)  ARMFLAGSbits.ARMFLAGS );     // состояние и таймеры вторжения и охраны
            FM25_write_2( 13, (unsigned int)  INTRREASONbits.INTRREASON ); // причина вторжения
            FM25_write_1( 15, (unsigned int)  CANDOORSbits.CANDOORS );     // состояние дверей
            FM25_write_1( 16, (unsigned int)  STATUSFLAGS1bits.STATUSFLAGS1 ); // состояние разбоя
            Nop();Nop();Nop();
            asm volatile ( "reset" );
        }
    }    

    if (ignition == 0) {
        RF_freezed_monitor_run_flag = 0;
//        F_freezed_monitor_run_counter = 0;
    }
    
    if ( RF_freezed_monitor_run_flag == 0 && ignition == 1 && ARMFLAGSbits.arm_status == 0 ) {
        
        if (arm_enable == 0) { F_freezed_monitor_run_counter = 0; }
        
         
            if (F_freezed_monitor_run_counter < 600) {
                F_freezed_monitor_run_counter ++; 
                if (F_freezed_monitor_run_counter == 300)  {
                    RFRESETbits.start = 1;
                    convert_N1_N2_to_hexstr ();
                    load_answer ( 2, "reset rf due freezed", 0, 0 );
                }
                if (F_freezed_monitor_run_counter == 200 || F_freezed_monitor_run_counter == 205 || F_freezed_monitor_run_counter == 210 ||
                    F_freezed_monitor_run_counter == 400 || F_freezed_monitor_run_counter == 405 || F_freezed_monitor_run_counter == 410 ) {
                    
                    if ( relay_enable == 1 ) fire_rel_transaction_flag = 1;
                    
                }
            }
            else {
                Nop();Nop();Nop();
                FM25_write_1( 8, 2 ); // признак перезагрузки для развешивания
                FM25_write_4( 9, (unsigned long)  ARMFLAGSbits.ARMFLAGS );     // состояние и таймеры вторжения и охраны
                FM25_write_2( 13, (unsigned int)  INTRREASONbits.INTRREASON ); // причина вторжения
                FM25_write_1( 15, (unsigned int)  CANDOORSbits.CANDOORS );     // состояние дверей
                FM25_write_1( 16, (unsigned int)  STATUSFLAGS1bits.STATUSFLAGS1 ); // состояние двигателя
                FM25_write_2( 17, (unsigned int)  ROBBFLAGSbits.ROBBFLAGS ); // состояние разбоя
                Nop();Nop();Nop();
                asm volatile ( "reset" );
            }
        
    }
    
    
}
void convert_N1_N2_to_hexstr (void) {
    int i, j;
    unsigned char temp_buf [40];
    j = 7;
    for(i = 0; i < 8; i ++) {
        if ((N1_freezed & 0x0000000F) >= 0 && (N1_freezed & 0x0000000F) <= 9) temp_buf[j] = (unsigned char) (N1_freezed & 0x0000000F) + 0x30;
        else { if ((N1_freezed & 0x0000000F) >= 10 && (N1_freezed & 0x0000000F) <= 15) temp_buf[j] = (unsigned char) (N1_freezed & 0x0000000F) + 55; }
        N1_freezed = N1_freezed >> 4;
        j--;
    }
    temp_buf[8] = ',';
    j = 16;
    for(i = 0; i < 8; i ++) {
        if ((N2_freezed & 0x0000000F) >= 0 && (N2_freezed & 0x0000000F) <= 9) temp_buf[j] = (unsigned char) (N2_freezed & 0x0000000F) + 0x30;
        else { if ((N2_freezed & 0x0000000F) >= 10 && (N2_freezed & 0x0000000F) <= 15) temp_buf[j] = (unsigned char) (N2_freezed & 0x0000000F) + 55; }
        N2_freezed = N2_freezed >> 4;
        j--;
    }
    temp_buf[17] = ',';

    j = 21;
    for(i = 0; i < 4; i ++) {
        if ((timer1_freezed & 0x000F) >= 0 && (timer1_freezed & 0x000F) <= 9) temp_buf[j] = (unsigned char) (timer1_freezed & 0x000F) + 0x30;
        else { if ((timer1_freezed & 0x000F) >= 10 && (timer1_freezed & 0x000F) <= 15) temp_buf[j] = (unsigned char) (timer1_freezed & 0x000F) + 55; }
        timer1_freezed = timer1_freezed >> 4;
        j--;
    }    
    temp_buf[22] = ',';    

    j = 26;
    for(i = 0; i < 4; i ++) {
        if ((timer2_freezed & 0x000F) >= 0 && (timer2_freezed & 0x000F) <= 9) temp_buf[j] = (unsigned char) (timer2_freezed & 0x000F) + 0x30;
        else { if ((timer2_freezed & 0x000F) >= 10 && (timer2_freezed & 0x000F) <= 15) temp_buf[j] = (unsigned char) (timer2_freezed & 0x000F) + 55; }
        timer2_freezed = timer2_freezed >> 4;
        j--;
    }    
    temp_buf[27] = ','; 
    
    j = 31;
    for(i = 0; i < 4; i ++) {
        if ((timer3_freezed & 0x000F) >= 0 && (timer3_freezed & 0x000F) <= 9) temp_buf[j] = (unsigned char) (timer3_freezed & 0x000F) + 0x30;
        else { if ((timer3_freezed & 0x000F) >= 10 && (timer3_freezed & 0x000F) <= 15) temp_buf[j] = (unsigned char) (timer3_freezed & 0x000F) + 55; }
        timer3_freezed = timer3_freezed >> 4;
        j--;
    }    
    temp_buf[32] = 0;    
    
    load_answer ( 2, &temp_buf, 0, 0 ); 
    
}
void get_freez_timers (void) {

    if (timer1_freezed < 65535) timer1_freezed ++;
    if (timer2_freezed < 65535) timer2_freezed ++;
    
    if (timer3_freezed < 65535) timer1_freezed ++;
    if (_RD11 == 1) timer3_freezed = 0;
    
}
void transp_learn_transactions_monitor (void) {
//unsigned char SW0_tmp, SW1_tmp, SW2_tmp;

   
    if (TLEARNTASKSbits.start == 0) return;
    
    if (TLEARNTASKSbits.timeout_counter == 0 && TLEARNTASKSbits.running == 0) {
        Nop();Nop();Nop();
        Transp_flags_lrn[0]=0; Transp_flags_lrn[1]=-1;Transp_flags_lrn[2]=-1;Transp_flags_lrn[3]=-1;
        Transp_flags_lrn[4]=-1;Transp_flags_lrn[5]=-1;Transp_flags_lrn[6]=-1;
        OUT_TLEARNbits.number = first_IMEI_digits;
        OUT_TLEARNbits.comand = 1;
        TLEARNTASKSbits.running = 1;
        TLEARNTASKSbits.temp_tr_num = 1;
        OUT_TLEARNbits.transp_num = TLEARNTASKSbits.temp_tr_num;
        SYNC_BITS [4] = SW2_lrn_trnsp; SYNC_BITS [5] = SW1_lrn_trnsp; SYNC_BITS [6] = SW0_lrn_trnsp; SYNC_BITS [7] = 0x00; 
        Si4461_CMD_stream ( SYNC_BITS, 8 );
        wait_ready (); 
        Si4461_start_receiving ();
        start_beep_task ( 700, 1, 1 );
    }
    

    if (TLEARNTASKSbits.timeout_counter < 800) TLEARNTASKSbits.timeout_counter ++;
    else {
        
        Nop();Nop();Nop();
//        TLEARNTASKSbits.TLEARNTASKS = 0; 
        if (IN_TLEARNbits.comand == 4) {
            Nop();Nop();Nop();
//            if (TLEARNTASKSbits.running1 == 0) {
//                TLEARNTASKSbits.running1 = 1;
                Transp_flags_lrn[TLEARNTASKSbits.temp_tr_num] = IN_TLEARNbits.transp_num;
                Transp_flags_lrn[0] = Transp_flags_lrn[0] + 1;
                IN_TLEARNbits.comand = 0;
                TLEARNTASKSbits.timeout_counter = 0;
                TLEARNTASKSbits.temp_tr_num ++;
                OUT_TLEARNbits.transp_num = TLEARNTASKSbits.temp_tr_num;
                if (IN_TLEARNbits.number == first_IMEI_digits) {
                    Nop();Nop();Nop();
                    if ( check_transponder_validity () == 0 ) { 
                        stop_tlearn_tasck (); 
                        start_beep_task ( 20, 20, 4 );
                    }

                        Nop();Nop();Nop();    

                } else {
                    stop_tlearn_tasck ();
                    start_beep_task ( 20, 20, 4 );                    
                }
               
//            }
            if (TLEARNTASKSbits.temp_tr_num == 6) { // 5 метка прописана
                TLEARNTASKSbits.TLEARNTASKS = 0;
                TFINISHTASKSbits.start = 1;// Здесь сделать старт раздачи номеров меткам!!!!!!!!!!!!!
            } else {
                if (TLEARNTASKSbits.TLEARNTASKS != 0)start_beep_task ( 700, 1, 1 );
            }
        }
        else {
            Nop();Nop();Nop();
            if (TLEARNTASKSbits.temp_tr_num <= 1) { // Первая же обучаемая метка не ответила до конца
                stop_tlearn_tasck ();
                start_beep_task ( 20, 20, 3 );
            } else { // Завершился первый этап прописывания хотя бы одной метки
                Nop();Nop();Nop();

                TLEARNTASKSbits.TLEARNTASKS = 0;
                TFINISHTASKSbits.TFINISHTASKS = 0;
                TFINISHTASKSbits.start = 1;
            }
        }


    }
    
}
void transp_learn_finish_monitor (void) {
static unsigned char num = 0;

    if (TFINISHTASKSbits.start == 0) return;
    
    if (TFINISHTASKSbits.running == 0) {
        Nop();Nop();Nop();
        OUT_TLEARNbits.comand = 3;
        TFINISHTASKSbits.running = 1;
        TFINISHTASKSbits.temp_tr_num = 1;
        if ( generate_new_transp_nums () == 0 ) { stop_tlearn_tasck (); start_beep_task ( 20, 20, 4 );}
        else {
            Nop();Nop();Nop();
        }
        
    }
    
    if (TFINISHTASKSbits.timeout_counter == 0) {
        num = 1;
        OUT_TLEARNbits.transp_num = Transp_flags_to_learn[num];//TFINISHTASKSbits.temp_tr_num
        
        OUT_TLEARNbits.number = Transp_flags_to_learn[0]; // Общее количество прописываемых в данный момент меток
//        OUT_TLEARNbits.number = OUT_TLEARNbits.number << 20;;
        set_sw0 (TFINISHTASKSbits.temp_tr_num);        
        
    }

//        if (IN_TLEARNbits.comand == 6) { 
//            Nop();Nop();Nop();
//            TFINISHTASKSbits.timeout_counter = 1;
//            if ( num < Transp_flags_to_learn[0]) {
//                num ++; TFINISHTASKSbits.temp_tr_num ++;
//                OUT_TLEARNbits.transp_num = Transp_flags_to_learn[num];
//                set_sw0 (TFINISHTASKSbits.temp_tr_num);
//            } else { 
//                if ( num == Transp_flags_to_learn[0]) {
//                    Nop();Nop();Nop();
//                    TFINISHTASKSbits.TFINISHTASKS = 0;
//                    save_flags_of_transponders ();
//                    start_beep_task ( 20, 20, 2 );
//                    stop_tlearn_tasck ();
//                }
//            }
//        }
    
    if (TFINISHTASKSbits.timeout_counter < 300) TFINISHTASKSbits.timeout_counter ++;
    else {
        Nop();Nop();Nop();
        if (IN_TLEARNbits.comand == 6) { 
            Nop();Nop();Nop();
            IN_TLEARNbits.comand = 0;
            TFINISHTASKSbits.timeout_counter = 1;
            if ( num < Transp_flags_to_learn[0]) {
                num ++; TFINISHTASKSbits.temp_tr_num ++;
                OUT_TLEARNbits.transp_num = Transp_flags_to_learn[num];
                set_sw0 (TFINISHTASKSbits.temp_tr_num);
            } else { 
                if ( num == Transp_flags_to_learn[0]) {
                    Nop();Nop();Nop();
                    TFINISHTASKSbits.TFINISHTASKS = 0;
                    save_flags_of_transponders ();
                    start_beep_task ( 20, 20, 2 );
                    stop_tlearn_tasck ();
                }
            }
        }
        else {
            Nop();Nop();Nop();
            TFINISHTASKSbits.TFINISHTASKS = 0;
            start_beep_task ( 20, 20, 3 );
            stop_tlearn_tasck ();
        }
    }    
    
}
int check_transponder_validity (void) {
    unsigned char tmp;
    
    if (IN_TLEARNbits.transp_num == 0) return 1;
    tmp = Transp_flags [IN_TLEARNbits.transp_num];
    
    if (tmp == 0) return 1;
    if (tmp == IN_TLEARNbits.transp_num) return 1;
    
return 0;    
}
void save_flags_of_transponders (void) {
unsigned char i;    
transp_flags_to_save = 0;

transp_flags_to_save = 1;

transp_flags_to_save = transp_flags_to_save << 20;

    for (i = 1; i <= Transp_flags_to_learn[0]; i ++) {

       Transp_flags[Transp_flags_to_learn[i]] =  Transp_flags_to_learn[i];

    }
    
    FM25_write_1 ( 32,  Transp_flags[1]);
    FM25_write_1 ( 33,  Transp_flags[2]);
    FM25_write_1 ( 34,  Transp_flags[3]);
    FM25_write_1 ( 35,  Transp_flags[4]);
    FM25_write_1 ( 36,  Transp_flags[5]);

    generate_transp_nums_message ();

Nop();Nop();Nop();    
}
int generate_new_transp_nums (void) {

    unsigned char available_nums [6];
    unsigned char num, i, j, tmp;
    for (i = 0; i < 6; i++) { available_nums [i] = 0; }
    Nop();Nop();Nop();
    num = Transp_flags_lrn[0];
    

    Nop();Nop();Nop();

// Сверка прописываемых и прописанных ранее меток
    for (i = 1; i <= 5; i++) {
        if (Transp_flags[i] == i ) { // метка прописана и не помечена как не валидная
            tmp = 0;
            for(j = 1; j <= num; j ++) {
                if ( Transp_flags[i] == Transp_flags_lrn[j] ) { tmp = 1; break; } 
            }
            if (tmp == 0) Transp_flags[i] = 7; // метки с таким номером нет среди прописываемых
        }
    }
    
// определение всех меток, доступных для прописывания
    j = 1;
    for (i = 1; i <= 5; i++) {
        if (Transp_flags[i] == 0 || Transp_flags[i] == i) {
            available_nums[j] = i;
            available_nums[0] ++;
            j++;
        } else available_nums[j] = 0;// j++; }
    }    
    if ( num > available_nums[0] ) return 0; // количество доступных для прописывания номеров меньше к-ва прописываемых меток
    
// генерация номеров для обучения из числа уже обученных Transp_flags_to_learn

    for (i = 1; i <= num; i ++) {
        
        Transp_flags_to_learn[i] = available_nums[i];
        
    }
    Transp_flags_to_learn[0] = num;
    Nop();Nop();Nop();
    
return 1;    
}
void stop_tlearn_tasck (void) {

    
    TLEARNTASKSbits.TLEARNTASKS = 0;
     SYNC_BITS [4] = SW2; SYNC_BITS [5] = SW1; SYNC_BITS [6] = SW0;
    Si4461_CMD_stream ( SYNC_BITS, 8 );
    wait_ready (); 
    Si4461_start_receiving ();
     
}
void set_sw0 (int num) {
    
    SYNC_BITS [4] = SW2_lrn_trnsp; SYNC_BITS [5] = SW1_lrn_trnsp; SYNC_BITS [7] = 0x00; 
	if (num == 1) SYNC_BITS [6] = 0x03;
	if (num == 2) SYNC_BITS [6] = 0x05;
	if (num == 3) SYNC_BITS [6] = 0x06;
	if (num == 4) SYNC_BITS [6] = 0x09;
    if (num == 5) SYNC_BITS [6] = 0x0A;
    Si4461_CMD_stream ( SYNC_BITS, 8 );
    wait_ready (); 
    Si4461_start_receiving ();    
}
void generate_transp_nums_message (void) {
// Сообщение с номерами меток
    
        reload_GPRS_header ( 4, 45, 0x0011); // N = 3, name = 38, type = 1, ACK = 1
        memmove ( command_temp_buf, GPRS_header_buf, 12 );
        unsigned int ACK_counter = 0xFFFF;
        command_temp_buf[12] = (unsigned char) (ACK_counter >> 8); command_temp_buf[13] = (unsigned char) ACK_counter; // ACK
        command_temp_buf[14] = 0xFF; command_temp_buf[15] = 0x01; command_temp_buf[16] = 0x30; // Dataflags
        memmove  ( &command_temp_buf[17], Navi_bin, 22 );

        command_temp_buf[39] = Transp_flags[1] + 0x30;
        command_temp_buf[40] = Transp_flags[2] + 0x30;
        command_temp_buf[41] = Transp_flags[3] + 0x30;
        command_temp_buf[42] = Transp_flags[4] + 0x30;
        command_temp_buf[43] = Transp_flags[5] + 0x30;
        
        sequence_number = get_sequence_number ();
        command_temp_buf[ 44 ] = (unsigned char)(sequence_number >> 24);
        command_temp_buf[ 45 ] = (unsigned char)(sequence_number >> 16);
        command_temp_buf[ 46 ] = (unsigned char)(sequence_number >> 8);
        command_temp_buf[ 47 ] = (unsigned char)(sequence_number);
        
        command_temp_buf[113] = 48; //38
        write_data_into_save_to_flash_bufs ( command_temp_buf, 48 ); 
        Nop();Nop();Nop();    
}

void service_ON (void) {
    
    OUTbits.serv_flag = 1;
    SERVFLAGSbits.serv_status = 1;
    SERVFLAGSbits.serv_on_event = 1;
    SERVFLAGSbits.serv_off_event = 0;
    SERVFLAGSbits.serv_off_event_sent = 0;
    ARMFLAGSbits.arm_timer = 0;
    ARMFLAGSbits.arm_status = 0;
    ARMFLAGSbits.arm_on_event = 0;
    ARMFLAGSbits.arm_on_event_sent = 0;                            
    ARMFLAGSbits.intrusion_timer = 0;
    ARMFLAGSbits.intr_event_trigg = 0;
    ARMFLAGSbits.intr_event = 0;
    ARMFLAGSbits.intr_event_sent = 0; 
    
}
void service_OFF (void) {
    
    OUTbits.serv_flag = 0;
    SERVFLAGSbits.serv_status = 0;
    SERVFLAGSbits.serv_off_event = 1;
    SERVFLAGSbits.serv_on_event = 0;
    SERVFLAGSbits.serv_on_event_sent = 0;  
    
}
void RF_tasck_monitor (void) {
/**/
# if defined (DIRECTTX)
return;    
# endif    
    
    static unsigned char counter, counter1;
    
    if ( counter1 < 9 ) {
        counter1 ++;
        return;
    }
    counter1 = 0;
    
    if ( RFSTATEbits.waiting_inquiry == 1 ) {
        counter = 0;
        return;
    }
    
    if ( counter < 3 ) counter ++;
    else {
        counter = 0;
        if ( RFRESETbits.start == 0 ) RFRESETbits.start = 1;
        load_answer ( 2, "reset rf 2", 0, 0 );
    }
    
}
void rf_reset_monitor (void) {
/**/ 
    
# if defined (DIRECTTX)
return;    
# endif

static unsigned int counter1 = 0, counter2 = 0;    
char k;

    if (rf_reset_flag1 == 1) {
        
        if ( counter1 < 250) counter1 ++;
        else {
                Nop();Nop();Nop();
            /**/    
                counter1 = 0;
                rf_reset_flag1 = 0;
                if ( ARMFLAGSbits.arm_status == 1 ) {
                    if ( rf_reset_enable == 2 ) {
                        FM25_write_1( 8, 2 ); // признак перезагрузки для развешивания
                        FM25_write_4( 9, (unsigned long)  ARMFLAGSbits.ARMFLAGS );     // состояние и таймеры вторжения и охраны
                        FM25_write_2( 13, (unsigned int)  INTRREASONbits.INTRREASON ); // причина вторжения
                        FM25_write_1( 15, (unsigned int)  CANDOORSbits.CANDOORS );     // состояние дверей
                        FM25_write_1( 16, (unsigned int)  STATUSFLAGS1bits.STATUSFLAGS1 ); // состояние двигателя
                        FM25_write_2( 17, (unsigned int)  ROBBFLAGSbits.ROBBFLAGS ); // состояние разбоя
                        Nop();Nop();Nop();
                        asm volatile ( "reset" ); 
                    }
                }
        }
        
    } else counter1 = 0;

    if ( counter1 == 65 ) {
//            counter1 = 0;
//            rf_reset_flag1 = 0;        
        /**/
            unit_transp_sw_generator (); // Генерация кода блока, кодов меток и реле из IMEI
            CS_SI4461 = 0;
                writeSPI3(0x77); // READ Rx buffer command
                for (k=0; k<8; k++)	{
                    rx_buf[k] = writeSPI3 (0);
                }
            CS_SI4461 = 1;
            load_answer ( 2, "reset rf 1", 0, 0 );  
            
    }
    if ( counter1 == 150 ) {
        
        RFRESETbits.start = 1;
        
        convert_N1_N2_to_hexstr ();
        load_answer ( 2, "reset rf due freezed 1", 0, 0 );        
    }
    
    if ( _RD11 == 0 ) {
        if ( counter2 < 20) counter2 ++;
        else {
            counter2 = 0;
            if ( RFRESETbits.start == 0 ) RFRESETbits.start = 1;
            load_answer ( 2, "reset rf 3", 0, 0 );            
        }        
    }   else {
        counter2 = 0;
    }   
   
}
void RF_wdt (void) {

# if defined (DIRECTTX)
return;    
# endif
    
    RF_WDT ++;
    if (RF_WDT < 1000) return;
//    if (RFSTATEbits.RFSTATE == 0 || RFSTATEbits.RFSTATE == 1) return;
    RF_WDT = 0;
    IEC1bits.INT1IE = 0;
    IEC0bits.T1IE = 0;
    while (Si4461_get_reply_stream ( READ_CMD_BUFF, 1 ) != 0xFF);
//    Si4461_GET_property (0x12, 5, 0);
    Si4461_CMD_stream (GPIO_PIN_CFG, 1); // чтение конф. IO GPIO_PIN_CFG[8]= { 0x13, 0x07, 0x08, 0x20, 0x21, 0x27, 0x00, 0x00 };
    while (Si4461_get_reply_stream ( READ_CMD_BUFF, 4 ) != 0xFF);
    IEC1bits.INT1IE = 1;
    IEC0bits.T1IE = 1;
    
Nop();Nop();Nop();    
if (Si4461_buf[0] != 0x07) {
    RFRESETbits.start = 1;
}
   
//start_beep_task (1, 1, 1);

}

void Si4461_reset (void) {

    static unsigned char reset_counter = 0;
    
    if (RFRESETbits.start != 1) return;

    IEC1bits.INT1IE = 0;
    IEC0bits.T1IE = 0;
    T1CONbits.TON = 0;
    RFSTATEbits.RFSTATE = 0;
    
//    if ((reset_counter >= 0)&&(reset_counter < 5)) { SDN_SI4461 = 1; }
//    else SDN_SI4461 = 0;
    
    if (reset_counter == 0) {
        Nop();Nop();Nop();
        SDN_SI4461 = 1;
//        _LATD0 = 1;
    }
    
    if (reset_counter == 6) {
        Nop();Nop();Nop();        
        SDN_SI4461 = 0;        
    }

    
    if ((reset_counter == 8)) {
        Si4461_CMD_stream ( POWER_UP, 7 );
    }
    if ((reset_counter == 11)) {
        Si4461_init (); 
    }

    if (reset_counter >= 17) {
# if defined (DIRECTTX) 
        CHANGE_STATE[1] = READY;// READY
        Si4461_CMD_stream ( CHANGE_STATE, 2 );
        RFRESETbits.start = 0; 
        RFSTATEbits.RFSTATE = 0;
# else
        reset_counter = 0;
        RFRESETbits.start = 0;
        RFSTATEbits.RFSTATE = 0;
        RFSTATEbits.waiting_inquiry = 1;
        unit_transp_sw_generator (); // Генерация кода блока, кодов меток и реле из IMEI
        SW2 = SW2 & 0x0F;
        SYNC_BITS [4] = SW2;SYNC_BITS [5] = SW1;SYNC_BITS [6] = SW0; SYNC_BITS [7] = 0x00; 
        Si4461_CMD_stream ( SYNC_BITS, 8 );
        wait_ready ();        

        SYNC_BITS_SW2 [4] = SW2_receive1 | SW2;
        Si4461_CMD_stream ( SYNC_BITS_SW2, 5 );
        wait_ready ();
        Si4461_interrupt_reset ();
    // Длина пакета 0 байт
        PKT_LENTH[4]= 0;
        Si4461_CMD_stream ( PKT_LENTH, 5 );
        wait_ready ();
        
    // Запуск приема пакета из восьми байт данных
        Si4461_CMD_stream ( START_RX, 3 );
        wait_ready ();


//    Si4461_GET_property ( 0x11, 0x04, 0x01, 4);  
        init_timer1 ();
        init_timer2 ();
        Nop();Nop();Nop();
        IFS1bits.INT1IF = 0;
        IEC1bits.INT1IE = 1;
        IEC0bits.T1IE = 1; 
        Nop();Nop();Nop();
# endif        
        
    } 
    
    reset_counter ++;
    
//	SDN_SI4461 = 1;
//	__delay_us(50);
//	SDN_SI4461 = 0;
//	__delay_ms(10);
//	Si4461_CMD_stream ( POWER_UP, 7 );
//	__delay_ms(15);
//	wait_ready ();
//	Si4461_init (); 
//    __delay_ms (50);

    
}
void Si4461_turn_ON (void) {

    static unsigned char reset_counter = 0;
    
    if (RF_turn_on_start != 1) { reset_counter = 0; return; }

//    IEC1bits.INT1IE = 0;
//    IEC0bits.T1IE = 0;
//    T1CONbits.TON = 0;
//    RFSTATEbits.RFSTATE = 0;
    
    if (reset_counter == 0) {
        Nop();Nop();Nop();
        SDN_SI4461 = 1;
//        _LATD0 = 1;
    }
    
    if (reset_counter == 6) {
        Nop();Nop();Nop();        
        SDN_SI4461 = 0;        
    }

    
    if ((reset_counter == 8)) {
        Si4461_CMD_stream ( POWER_UP, 7 );
    }
//    if ((reset_counter == 11)) {
//        Si4461_init (); 
//    }

    if ( reset_counter < 10 ) reset_counter ++;
    else {
        reset_counter = 0;
        RF_turn_on_start = 0;
    }
    
}
void check_can_data (void) {
//unsigned char i;    

    
    if (C1RXOVF1 != 0 || C1RXOVF2 != 0 ) {
        Nop(); Nop();Nop();
            can1start();
            init_CAN_filters ();
            Nop();Nop();Nop();
            start_beep_task (1, 1, 1);        
    }
    if (C2RXOVF1 != 0 || C2RXOVF2 != 0 ) {
        Nop(); Nop();Nop();
            can2start();
            init_CAN_filters ();
            Nop();Nop();Nop();
            start_beep_task (1, 1, 1);        
    }    
Nop(); Nop();Nop();

    while ( CAN1AUX_R_ptr != CAN1AUX_W_ptr ) {
        Nop(); Nop();Nop();
//        generate_canbus_sleep_message ( 1 );
        C1INTEbits.RBIE = 0;
            ID_tmp = CAN1AUX_ID_buf[CAN1AUX_R_ptr][0];
//            CAN1AUX_R_ptr_tmp = CAN1AUX_R_ptr; CAN1AUX_W_ptr_tmp = CAN1AUX_W_ptr;
//            ID_tmp = ID;
            CAN1_DATA_buf[0] = CAN1AUX_DATA_buf[CAN1AUX_R_ptr][0]; CAN1_DATA_buf[1] = CAN1AUX_DATA_buf[CAN1AUX_R_ptr][1];
            CAN1_DATA_buf[2] = CAN1AUX_DATA_buf[CAN1AUX_R_ptr][2]; CAN1_DATA_buf[3] = CAN1AUX_DATA_buf[CAN1AUX_R_ptr][3];
            CAN1_DATA_buf[4] = CAN1AUX_DATA_buf[CAN1AUX_R_ptr][4]; CAN1_DATA_buf[5] = CAN1AUX_DATA_buf[CAN1AUX_R_ptr][5];
            CAN1_DATA_buf[6] = CAN1AUX_DATA_buf[CAN1AUX_R_ptr][6]; CAN1_DATA_buf[7] = CAN1AUX_DATA_buf[CAN1AUX_R_ptr][7];
            
//            for ( i = 0; i < 25; i++ ) {
//                CAN1AUX_ID_buf_tmp[i][0] = CAN1AUX_ID_buf[i][0];
//            }
//            CAN1_DATA_buf_tmp[0] = CAN1AUX_DATA_buf[CAN1AUX_R_ptr][0]; CAN1_DATA_buf_tmp[1] = CAN1AUX_DATA_buf[CAN1AUX_R_ptr][1];
//            CAN1_DATA_buf_tmp[2] = CAN1AUX_DATA_buf[CAN1AUX_R_ptr][2]; CAN1_DATA_buf_tmp[3] = CAN1AUX_DATA_buf[CAN1AUX_R_ptr][3];
//            CAN1_DATA_buf_tmp[4] = CAN1AUX_DATA_buf[CAN1AUX_R_ptr][4]; CAN1_DATA_buf_tmp[5] = CAN1AUX_DATA_buf[CAN1AUX_R_ptr][5];
//            CAN1_DATA_buf_tmp[6] = CAN1AUX_DATA_buf[CAN1AUX_R_ptr][6]; CAN1_DATA_buf_tmp[7] = CAN1AUX_DATA_buf[CAN1AUX_R_ptr][7];

            C1INTEbits.RBIE = 1;
        
        if ( ID_tmp == 0x7E8 || ID_tmp == 0x7E9 || ID_tmp == 0x7EA ||
             ID_tmp == 0x18DAF110 || ID_tmp == 0x18DAF118 || ID_tmp == 0x18DAF128) {
            check_OBD_can_data ();
        } 
        else {
//                if (CAN1AUX_ID_buf[CAN1AUX_W_ptr][0] == 0x340 && CAN1AUX_DATA_buf[CAN1AUX_W_ptr][3] != 0x08)  {
//                    Nop();Nop();Nop();
//                }
//                if (CAN1AUX_ID_buf[CAN1AUX_W_ptr][0] == 0x43E && CAN1AUX_DATA_buf[CAN1AUX_W_ptr][4] != 0x01)  {
//                    Nop();Nop();Nop();
//                }            
            apply_can_data (); 
        }
        
        C1INTEbits.RBIE = 0;        
            CAN1AUX_R_ptr++; CAN1AUX_R_ptr %= 25;
//            CAN1AUX_R_ptr_tmp = CAN1AUX_R_ptr; CAN1AUX_W_ptr_tmp = CAN1AUX_W_ptr;
        C1INTEbits.RBIE = 1;
    }

    while ( CAN2AUX_R_ptr != CAN2AUX_W_ptr ) {
        Nop(); Nop();Nop();
//        generate_canbus_sleep_message ( 2 );
        C2INTEbits.RBIE = 0;
            ID2_tmp = CAN2AUX_ID_buf[CAN2AUX_R_ptr][0];
//            CAN2AUX_R_ptr_tmp = CAN2AUX_R_ptr; CAN2AUX_W_ptr_tmp = CAN2AUX_W_ptr;
            
            CAN2_DATA_buf[0] = CAN2AUX_DATA_buf[CAN2AUX_R_ptr][0]; CAN2_DATA_buf[1] = CAN2AUX_DATA_buf[CAN2AUX_R_ptr][1];
            CAN2_DATA_buf[2] = CAN2AUX_DATA_buf[CAN2AUX_R_ptr][2]; CAN2_DATA_buf[3] = CAN2AUX_DATA_buf[CAN2AUX_R_ptr][3];
            CAN2_DATA_buf[4] = CAN2AUX_DATA_buf[CAN2AUX_R_ptr][4]; CAN2_DATA_buf[5] = CAN2AUX_DATA_buf[CAN2AUX_R_ptr][5];
            CAN2_DATA_buf[6] = CAN2AUX_DATA_buf[CAN2AUX_R_ptr][6]; CAN2_DATA_buf[7] = CAN2AUX_DATA_buf[CAN2AUX_R_ptr][7];
            
//            for ( i = 0; i < 25; i++ ) {
//                CAN2AUX_ID_buf_tmp[i][0] = CAN2AUX_ID_buf[i][0];
//            }            
//            CAN2_DATA_buf_tmp[0] = CAN2AUX_DATA_buf[CAN2AUX_R_ptr][0]; CAN2_DATA_buf_tmp[1] = CAN2AUX_DATA_buf[CAN2AUX_R_ptr][1];
//            CAN2_DATA_buf_tmp[2] = CAN2AUX_DATA_buf[CAN2AUX_R_ptr][2]; CAN2_DATA_buf_tmp[3] = CAN2AUX_DATA_buf[CAN2AUX_R_ptr][3];
//            CAN2_DATA_buf_tmp[4] = CAN2AUX_DATA_buf[CAN2AUX_R_ptr][4]; CAN2_DATA_buf_tmp[5] = CAN2AUX_DATA_buf[CAN2AUX_R_ptr][5];
//            CAN2_DATA_buf_tmp[6] = CAN2AUX_DATA_buf[CAN2AUX_R_ptr][6]; CAN2_DATA_buf_tmp[7] = CAN2AUX_DATA_buf[CAN2AUX_R_ptr][7];

            C2INTEbits.RBIE = 1;

        apply_can_data (); 

        C2INTEbits.RBIE = 0;        
            CAN2AUX_R_ptr++; CAN2AUX_R_ptr %= 25;
//            CAN2AUX_R_ptr_tmp = CAN2AUX_R_ptr; CAN2AUX_W_ptr_tmp = CAN2AUX_W_ptr;
        C2INTEbits.RBIE = 1;

    }
    
}

void check_OBD_can_data (void) {
//int  *can1buf_ptr;

    if (ID_tmp == 0x7E8 || ID_tmp == 0x18DAF110) {
//        C1RXFUL1bits.RXFUL5 = 0;
//        rxECAN1( 5 );
        CANOBD_DATA_buf1[0] = CAN1_DATA_buf[0]; CANOBD_DATA_buf1[1] = CAN1_DATA_buf[1];
        CANOBD_DATA_buf1[2] = CAN1_DATA_buf[2]; CANOBD_DATA_buf1[3] = CAN1_DATA_buf[3];
        CANOBD_DATA_buf1[4] = CAN1_DATA_buf[4]; CANOBD_DATA_buf1[5] = CAN1_DATA_buf[5];
        CANOBD_DATA_buf1[6] = CAN1_DATA_buf[6]; CANOBD_DATA_buf1[7] = CAN1_DATA_buf[7]; 
//        CANODOEXISTbits.exist_mes1 = 1;
    }
    if (ID_tmp == 0x7E9 || ID_tmp == 0x18DAF118) {
//        C1RXFUL1bits.RXFUL6 = 0;
//        rxECAN1( 6 );
        CANOBD_DATA_buf1[0] = CAN1_DATA_buf[0]; CANOBD_DATA_buf1[1] = CAN1_DATA_buf[1];
        CANOBD_DATA_buf1[2] = CAN1_DATA_buf[2]; CANOBD_DATA_buf1[3] = CAN1_DATA_buf[3];
        CANOBD_DATA_buf1[4] = CAN1_DATA_buf[4]; CANOBD_DATA_buf1[5] = CAN1_DATA_buf[5];
        CANOBD_DATA_buf1[6] = CAN1_DATA_buf[6]; CANOBD_DATA_buf1[7] = CAN1_DATA_buf[7];         
//        CANODOEXISTbits.exist_mes2 = 1;
    }
    if (ID_tmp == 0x7EA || ID_tmp == 0x18DAF128) {
//        C1RXFUL1bits.RXFUL7 = 0;
//        rxECAN1( 7 );
        CANOBD_DATA_buf1[0] = CAN1_DATA_buf[0]; CANOBD_DATA_buf1[1] = CAN1_DATA_buf[1];
        CANOBD_DATA_buf1[2] = CAN1_DATA_buf[2]; CANOBD_DATA_buf1[3] = CAN1_DATA_buf[3];
        CANOBD_DATA_buf1[4] = CAN1_DATA_buf[4]; CANOBD_DATA_buf1[5] = CAN1_DATA_buf[5];
        CANOBD_DATA_buf1[6] = CAN1_DATA_buf[6]; CANOBD_DATA_buf1[7] = CAN1_DATA_buf[7];         
//        CANODOEXISTbits.exist_mes3 = 1;
    }   

    ECM_mode1 ();
    ECM_mode2 ();
    ECM_mode3 ();
    ECM_mode4 ();
    ECM_mode2 ();
    ECM_mode9 ();
    ECM_modeA ();    
}
void ECM_mode1 (void) {
    unsigned char tmp;
// Чтение ошибок, вина и тп
    if ( CANOBD_DATA_buf1[1] == 0x41 && CANOBD_DATA_buf1[2] == 0x01 && GETMILbits.start == 1) {
        
        if ( ID_tmp == 0x7E8 || ID_tmp == 0x18DAF110) GETMILbits.message_counter = 1;
        if ( ID_tmp == 0x7E9 || ID_tmp == 0x18DAF118) GETMILbits.message_counter = 2;
        if ( ID_tmp == 0x7EA || ID_tmp == 0x18DAF128) GETMILbits.message_counter = 3;
        
        if (GETMILbits.message_counter == 3) {
            Nop();Nop();Nop();
            
//            reset_OBD_tascks ();
        }
        if ( ID_tmp == 0x7E8  || ID_tmp == 0x18DAF110 ) {
            
            mil_status = CANOBD_DATA_buf1[3] & 0x80;
            
            if (mil_status != mil_status_tmp) { 
                
                if ( mil_status ) generate_content_of_message ( 57, 1 ); 
                else generate_content_of_message ( 58, 1 );
            
            }
            mil_status_tmp = mil_status;            
        }
        
    }
// Чтение топлива    
    if ( CANOBD_DATA_buf1[1] == 0x41 && CANOBD_DATA_buf1[2] == 0x2F && FUELTASCKSbits.running == 1) {
        FUELTASCKSbits.data_ready = 1;
        tmp = CANOBD_DATA_buf1[3];
        obd_fuel_level = ((tmp * 100 + 127)/255);

    }

// Чтение топлива тип 3 
    if ( CANFL3PRMSbits.can_number == 1 && CANREQ1SETbits.can_number == 1 ) {
        if ( CANOBD_DATA_buf1[2] == CANREQ1DATbits.B2 && CANOBD_DATA_buf1[3] == CANREQ1DATbits.B3 ) {

            if ( CANFL3PRMSbits.id == ID_tmp ) {

                fuel_level = 0;
                fuel_level = (unsigned int)CANOBD_DATA_buf1[CANFL3PRMSbits.byte1];
                fuel_level = fuel_level << 8;
                fuel_level = fuel_level + (unsigned int)CANOBD_DATA_buf1[CANFL3PRMSbits.byte0];

            }

        }    
    }

// Чтение оборотов во время автозапуска runo    
    if ( CANOBD_DATA_buf1[1] == 0x41 && CANOBD_DATA_buf1[2] == 0x0C && OBDREQENbits.rpm_req == 1) {
        if ( ID_tmp == 0x7E8 || ID_tmp == 0x18DAF110 ) {
            engine_rpm = 0;
            engine_rpm = (unsigned int)CANOBD_DATA_buf1[3];
            engine_rpm = engine_rpm << 8;
            engine_rpm = engine_rpm + (unsigned int)CANOBD_DATA_buf1[4];
        }
    }    

}
void ECM_mode2 (void) {
    
}
void ECM_mode3 (void) {
static unsigned char /*number_of_message1 = 0, number_of_message2 = 0, number_of_message3 = 0,*/ req_type = 0;
static unsigned int DTC_num_bytes = 0, start_ptr, j, i;//, request_timeout = 0;
//static unsigned char DTC_buf [113];



    if (OBDTASCKSbits.mode3 == 1 || OBDTASCKSbits.mode7 == 1 || OBDTASCKSbits.modeA == 1) {}
    else return;
    if (OBDTASCKSbits.mode3 == 1) req_type = 0x43;
    if (OBDTASCKSbits.mode7 == 1) req_type = 0x47;
    if (OBDTASCKSbits.modeA == 1) req_type = 0x4A;

    if (ID_tmp == 0x7E8 || ID_tmp == 0x18DAF110) {
        if (MODE3bits.message_counter1 == 0) {
            if (CANOBD_DATA_buf1[2] == req_type) { start_ptr = 4; MODE3bits.message_num = CANOBD_DATA_buf1[3]; }// Общее количество количество ошибок
            else { 
                start_ptr = 3; MODE3bits.message_num = CANOBD_DATA_buf1[2]; 
            }
            DTC_num_bytes = (unsigned int) ( 2 * MODE3bits.message_num ); // Общее количество количество байт в ошибках
//            MODE3bits.dtc_num_bytes1 = MODE3bits.dtc_num_bytes1 + DTC_num_bytes;
            if ( DTC_num_bytes > 4 ) { 
                if (CAN1SETTINGSbits.ide == 0) { ecan1WriteTxMsgBufId  ( 1, (long) 0x7E0, 0, 0 ); ecan1WriteTxMsgBufData( 1, 8, 0x0030, 0, 0, 0 ); settxtransmit( 1 ); } 
                else {ecan1WriteTxMsgBufId  ( 1, (long) 0x18DA10F1, 1, 0 ); ecan1WriteTxMsgBufData( 1, 8, 0x0030, 0, 0, 0 ); settxtransmit( 1 ); }
            }

            j = 0;
            for (i = start_ptr; i < 8; i ++) {
                DTC_buf[MODE3bits.dtc_num_bytes1] = CANOBD_DATA_buf1[i];
                if (MODE3bits.dtc_num_bytes1 < 92) MODE3bits.dtc_num_bytes1++; 
                if ( DTC_num_bytes > 0 ) DTC_num_bytes --; 
                if (DTC_num_bytes == 0) break;
            }
        } 
        else {
            start_ptr = 1;
            for (i = start_ptr; i < 8; i ++) {
                DTC_buf[MODE3bits.dtc_num_bytes1] = CANOBD_DATA_buf1[i];
                if (MODE3bits.dtc_num_bytes1 < 92) MODE3bits.dtc_num_bytes1++; 
                if ( DTC_num_bytes > 0 ) DTC_num_bytes --; 
                if (DTC_num_bytes == 0) break;
            }
            Nop();Nop();Nop();
        }
        MODE3bits.message_counter1 ++;
    }

    if (ID_tmp == 0x7E9 || ID_tmp == 0x18DAF118) {
        if (MODE3bits.message_counter2 == 0) {
            if (CANOBD_DATA_buf1[2] == req_type) { start_ptr = 4; MODE3bits.message_num = CANOBD_DATA_buf1[3]; }// Общее количество количество ошибок
            else { start_ptr = 3; MODE3bits.message_num = CANOBD_DATA_buf1[2]; }
            DTC_num_bytes = (unsigned int) ( 2 * MODE3bits.message_num ); // Общее количество количество байт в ошибках
//            MODE3bits.dtc_num_bytes2 = MODE3bits.dtc_num_bytes2 + DTC_num_bytes;
            if ( DTC_num_bytes > 4 ) { 
                if (CAN1SETTINGSbits.ide == 0) { ecan1WriteTxMsgBufId  ( 1, (long) 0x7E1, 0, 0 ); ecan1WriteTxMsgBufData( 1, 8, 0x0030, 0, 0, 0 ); settxtransmit( 1 ); }
                else  { ecan1WriteTxMsgBufId  ( 1, (long) 0x18DA18F1, 1, 0 ); ecan1WriteTxMsgBufData( 1, 8, 0x0030, 0, 0, 0 ); settxtransmit( 1 ); }
            }

            for (i = start_ptr; i < 8; i ++) {
                DTC_buf[MODE3bits.dtc_num_bytes1] = CANOBD_DATA_buf1[i];
                if (MODE3bits.dtc_num_bytes1 < 92) MODE3bits.dtc_num_bytes1++; 
                if ( DTC_num_bytes > 0 ) DTC_num_bytes --; 
                if (DTC_num_bytes == 0) break;
            }
            
        }
        else {
            start_ptr = 2;
            for (i = start_ptr; i < 8; i ++) {
                DTC_buf[MODE3bits.dtc_num_bytes1] = CANOBD_DATA_buf1[i];
                if (MODE3bits.dtc_num_bytes1 < 92) MODE3bits.dtc_num_bytes1++; 
                if ( DTC_num_bytes > 0 ) DTC_num_bytes --; 
                if (DTC_num_bytes == 0) break;
            }
            Nop();Nop();Nop();
            
        }
        
        MODE3bits.message_counter2 ++;
    }

    if (ID_tmp == 0x7EA || ID_tmp == 0x18DAF128) {
        
        if (MODE3bits.message_counter3 == 0) {
            if (CANOBD_DATA_buf1[2] == req_type) { start_ptr = 4; MODE3bits.message_num = CANOBD_DATA_buf1[3]; }// Общее количество количество ошибок
            else { start_ptr = 3; MODE3bits.message_num = CANOBD_DATA_buf1[2]; }
            DTC_num_bytes = (unsigned int) ( 2 * MODE3bits.message_num ); // Общее количество количество байт в ошибках
//            MODE3bits.dtc_num_bytes3 = MODE3bits.dtc_num_bytes3 + DTC_num_bytes;
            if ( DTC_num_bytes > 4 ) { 
                if (CAN1SETTINGSbits.ide == 0) { ecan1WriteTxMsgBufId  ( 1, (long) 0x7E2, 0, 0 ); ecan1WriteTxMsgBufData( 1, 8, 0x0030, 0, 0, 0 ); settxtransmit( 1 ); } 
                else  { ecan1WriteTxMsgBufId  ( 1, (long) 0x18DA28F1, 1, 0 ); ecan1WriteTxMsgBufData( 1, 8, 0x0030, 0, 0, 0 ); settxtransmit( 1 ); }
            }

            for (i = start_ptr; i < 8; i ++) {
                DTC_buf[MODE3bits.dtc_num_bytes1] = CANOBD_DATA_buf1[i];
                if (MODE3bits.dtc_num_bytes1 < 92) MODE3bits.dtc_num_bytes1++; 
                if ( DTC_num_bytes > 0 ) DTC_num_bytes --; 
                if (DTC_num_bytes == 0) break;
            }
            
        }
        else {
            start_ptr = 2;
            for (i = start_ptr; i < 8; i ++) {
                DTC_buf[MODE3bits.dtc_num_bytes1] = CANOBD_DATA_buf1[i];
                if (MODE3bits.dtc_num_bytes1 < 92) MODE3bits.dtc_num_bytes1++; 
                if ( DTC_num_bytes > 0 ) DTC_num_bytes --; 
                if (DTC_num_bytes == 0) break;
            }
            Nop();Nop();Nop();
            
        }
        
        MODE3bits.message_counter3 ++;
    }



}
void ECM_mode4 (void) {
    
}
void ECM_mode7 (void) {
    
}
void ECM_mode9 (void) {

    if (OBDTASCKSbits.ECM_mode9_02 == 0) return;
    
    if ( ID_tmp == 0x7E8 || ID_tmp == 0x18DAF110 ) {
        Nop();Nop();Nop();
        if (OBDTASCKSbits.ECM_mode9_02 == 1) {
            if ( GETVINbits.message_counter < 3 ) GETVINbits.message_counter ++;
            if ( GETVINbits.message_counter == 1 ) { 
                VIN_TMP[0] = CANOBD_DATA_buf1[5]; VIN_TMP[1] = CANOBD_DATA_buf1[6]; VIN_TMP[2] = CANOBD_DATA_buf1[7];
                if (CAN1SETTINGSbits.ide == 0) { ecan1WriteTxMsgBufId  ( 1, (long) 0x7E0, 0, 0 ); ecan1WriteTxMsgBufData( 1, 8, 0x0030, 0x0000, 0, 0 ); settxtransmit( 1 ); }
                else  { ecan1WriteTxMsgBufId  ( 1, (long) 0x18DA10F1, 1, 0 ); ecan1WriteTxMsgBufData( 1, 8, 0x0030, 0x0000, 0, 0 ); settxtransmit( 1 ); }
                Nop();Nop();Nop();
            }
            if ( GETVINbits.message_counter == 2 ) {
                VIN_TMP[3] = CANOBD_DATA_buf1[1]; VIN_TMP[4]  = CANOBD_DATA_buf1[2]; VIN_TMP[5]  = CANOBD_DATA_buf1[3];
                VIN_TMP[6] = CANOBD_DATA_buf1[4]; VIN_TMP[7] = CANOBD_DATA_buf1[5]; VIN_TMP[8] = CANOBD_DATA_buf1[6];
                VIN_TMP[9] = CANOBD_DATA_buf1[7];
            }   
            if ( GETVINbits.message_counter == 3 ) {
//                OBDTASCKSbits.ECM_mode9_02 = 0;
//                GETVINbits.GETVIN = 0;
//                OBDTIMERbits.OBDTIMER = 0;
                VIN_TMP[10] = CANOBD_DATA_buf1[1]; VIN_TMP[11]  = CANOBD_DATA_buf1[2]; VIN_TMP[12]  = CANOBD_DATA_buf1[3];
                VIN_TMP[13] = CANOBD_DATA_buf1[4]; VIN_TMP[14] = CANOBD_DATA_buf1[5]; VIN_TMP[15] = CANOBD_DATA_buf1[6];
                VIN_TMP[16] = CANOBD_DATA_buf1[7];
                check_VIN ();
            } 
            
        }
        
    }    
}
void ECM_modeA (void) {
    
}
void monitor_OBD (void) {

//    return;    
    
    static unsigned int OBD_data_request_counter = 0, DTC_reading_flag = 0, retry_timer = 0;
    static unsigned int fuel_request_counter = 0, fuel_pid_not_avalable_counter = 0;
    unsigned long OBD_ID;
    unsigned char len;
    
    if ( CAN1SETTINGSbits.ide == 0 ) OBD_ID = 0x7DF;
    else OBD_ID = 0x18DB33F1;
    
    if (ignition == 0 || OUTbits.serv_flag == 1 || OBDRPMREQbits.start == 1) {
        retry_timer = 0;
        OBD_data_request_counter = 0; 
        fuel_request_counter = 0;
        fuel_pid_not_avalable_counter = 0;
        FUELTASCKSbits.FUELTASCKS = 0;
        
        reset_OBD_tascks ();
        return; 
    }

    

        
        if ( OBD_data_request_counter < 1500 ) OBD_data_request_counter ++;
        else {
            OBD_data_request_counter = 0; 
            if (retry_timer < 5) retry_timer ++;
        }
    if (retry_timer < 5) {
    // Запрос поддерживаемых PID 0, Mode 1    
        if ( OBD_data_request_counter == 100 && OBDTASCKSbits.OBDTASCKS == 0 && OBDREQENbits.mil_req == 1 ) { 
            OBDTASCKSbits.ECM_mode1_00 = 1;
            GETMILbits.start = 1;
            OBDTIMERbits.start = 1;
            if (mil_req_len == 0) len = 3;
            else len = 8;
            ecan1WriteTxMsgBufId  ( 1, (long) OBD_ID, CAN1SETTINGSbits.ide, 0 ); ecan1WriteTxMsgBufData( 1, len, 0x0102, 0x0001, 0, 0 ); settxtransmit( 1 ); 
        }

    // Запрос PID 01, Mode 1    
    //    if ( OBD_data_request_counter == 10 ) { ecan1WriteTxMsgBufId  ( 1, (long) 0x7DF, 0, 0 ); ecan1WriteTxMsgBufData( 1, 3, 0x0102, 0x0001, 0, 0 ); settxtransmit( 1 ); }

        /* Запрос VIN, Mode 9 */
        if ( OBD_data_request_counter == 250 && OBDTASCKSbits.OBDTASCKS == 0 && OBDREQENbits.vin_req == 1  ) {
            OBDTASCKSbits.ECM_mode9_02 = 1;
            GETVINbits.start = 1;
            OBDTIMERbits.start = 1;        
            ecan1WriteTxMsgBufId  ( 1, (long) OBD_ID, CAN1SETTINGSbits.ide, 0 ); ecan1WriteTxMsgBufData( 1, 8, 0x0902, 0x0002, 0, 0 ); settxtransmit( 1 ); 
        }
        /* Запрос DTCs, Mode 3*/ 
        if ( OBD_data_request_counter == 400 && OBDTASCKSbits.OBDTASCKS == 0 && OBDREQENbits.dtc3_req == 1  ) {
            DTC_reading_flag = 1;
            OBDTASCKSbits.mode3 = 1;
            OBDTIMERbits.start = 1;
            ecan1WriteTxMsgBufId  ( 1, (long) OBD_ID, CAN1SETTINGSbits.ide, 0 ); ecan1WriteTxMsgBufData( 1, 8, 0x0301, 0, 0, 0 ); settxtransmit( 1 ); 
        }
        /* Запрос DTCs, Mode 7*/ 
        if ( OBD_data_request_counter == 550 && OBDTASCKSbits.OBDTASCKS == 0 && OBDREQENbits.dtc7_req == 1  ) {
            OBDTASCKSbits.mode7 = 1;
            OBDTIMERbits.start = 1;
            ecan1WriteTxMsgBufId  ( 1, (long) OBD_ID, CAN1SETTINGSbits.ide, 0 ); ecan1WriteTxMsgBufData( 1, 8, 0x0701, 0, 0, 0 ); settxtransmit( 1 ); 
        }    
        /* Запрос DTCs, Mode A*/ 
        if ( OBD_data_request_counter == 700 && OBDTASCKSbits.OBDTASCKS == 0 && OBDREQENbits.dtca_req == 1  ) {
            OBDTASCKSbits.modeA = 1;
            OBDTIMERbits.start = 1;
            ecan1WriteTxMsgBufId  ( 1, (long) OBD_ID, CAN1SETTINGSbits.ide, 0 ); ecan1WriteTxMsgBufData( 1, 8, 0x0A01, 0, 0, 0 ); settxtransmit( 1 ); 
        } 
    } else OBD_data_request_counter = 0;    
    

if (OBDTIMERbits.start == 1) {
    if (OBDTIMERbits.request_timeout < 100) {
        OBDTIMERbits.request_timeout ++;
        Nop();Nop();Nop();
    }
    else {
        OBDTIMERbits.request_timeout = 0;
        OBDTIMERbits.OBDTIMER = 0;
        if ( OBDTASCKSbits.ECM_mode1_00 == 1 ) {
            Nop();Nop();Nop();
            OBDTASCKSbits.ECM_mode1_00 = 0;
            GETMILbits.message_counter = 0;
            reset_OBD_tascks ();
        }        
        if ( OBDTASCKSbits.mode3 == 1 ) {
            Nop();Nop();Nop();
            OBDTASCKSbits.mode3 = 0;
            MODE3bits.message_counter1 = 0;
            MODE3bits.message_counter2 = 0;
            MODE3bits.message_counter3 = 0;
        }
        if ( OBDTASCKSbits.mode7 == 1 ) {
            Nop();Nop();Nop();
            OBDTASCKSbits.mode7 = 0;
            MODE3bits.message_counter1 = 0;
            MODE3bits.message_counter2 = 0;
            MODE3bits.message_counter3 = 0;            
        }
        if ( OBDTASCKSbits.modeA == 1 ) {
            Nop();Nop();Nop();
            if (MODE3bits.dtc_num_bytes1 == 0) reset_DTC_buf ();
            DTC_reading_flag = 0;
            check_DTCs ();
            OBDTASCKSbits.modeA = 0;
            reset_OBD_tascks ();    
        }
        if ( OBDTASCKSbits.ECM_mode9_02 == 1 ) {
            Nop();Nop();Nop();
            OBDTASCKSbits.ECM_mode9_02 = 0;
            reset_OBD_tascks ();
        }        
        

    }
} else {OBDTIMERbits.request_timeout = 0;}    

    
/* Мониторинг таймаута чтения данных ОБД*/    
//    if (OBDTIMERbits.start == 1) {
//        if (OBDTIMERbits.timer < 500) OBDTIMERbits.timer ++;
//        else {
//            OBDTIMERbits.OBDTIMER = 0;
//            reset_OBD_tascks ();
//        }
//    } else {OBDTIMERbits.OBDTIMER = 0;}

/* Мониторинг задачи сброса ошибок */
    if (dtc_reset_start == 1 && DTC_reading_flag == 0 && OBDTASCKSbits.OBDTASCKS == 0) {
        dtc_reset_start = 0;
        retry_timer = 0;
        ecan1WriteTxMsgBufId  ( 1, (long) OBD_ID, CAN1SETTINGSbits.ide, 0 ); ecan1WriteTxMsgBufData( 1, 8, 0x0401, 0, 0, 0 ); settxtransmit( 1 );
    }
/* Мониторинг задачи перезапуска чтения VIN и ошибок */
    if ( dvrq_start == 1 && DTC_reading_flag == 0 && OBDTASCKSbits.OBDTASCKS == 0 ) {
        dvrq_start = 0;
        retry_timer = 0;
        reset_DTC_buf ();
        DTC_buf_tmp[0] = DTC_buf_tmp[0] +1;
        VIN[0] = VIN[0] + 1;
    }    

/* Запрос уровня топлива */    
    if ( retry_timer == 5 && CANFLPRMSbits.can_number == 0 && FUELTASCKSbits.data_not_exist == 0 && OBDREQENbits.fuel_req == 1 ) { // Когда запрос вина и ошибок уже закончился и нет настройки топлива в кан
        if (fuel_request_counter < 3000) fuel_request_counter ++;
        else {
            fuel_request_counter = 0;
//            FUELTASCKSbits.data_ready = 0;
            FUELTASCKSbits.running = 0;
            
            if (FUELTASCKSbits.data_ready == 0) { // Машина не ответила топливом 
                if (fuel_pid_not_avalable_counter < 3) fuel_pid_not_avalable_counter ++; 
            }
            else {
                fuel_level = (unsigned int)obd_fuel_level;
                fuel_pid_not_avalable_counter = 0;
                FUELTASCKSbits.data_ready = 0;
            }
            if (fuel_pid_not_avalable_counter >= 3) FUELTASCKSbits.data_not_exist = 1; 
        }
    } else {
        fuel_request_counter = 0;
    }
    
        if (fuel_request_counter == 2998) {
            FUELTASCKSbits.running = 1;
            ecan1WriteTxMsgBufId  ( 1, (long) OBD_ID, CAN1SETTINGSbits.ide, 0 ); ecan1WriteTxMsgBufData( 1, 8, 0x0102, 0x002f, 0, 0 ); settxtransmit( 1 );
        }
    
}// !!!!!!!!!!!!!!!!!!!!!!ВКЛЮЧИТЬ ФУНКЦИЮ!!!!!!!!!!!!!!!!!!!!!
void reset_OBD_tascks (void) {
    
    OBDTASCKSbits.OBDTASCKS = 0;
    OBDTIMERbits.OBDTIMER = 0;
    GETMILbits.GETMIL = 0;
    GETVINbits.GETVIN = 0;
    MODE3bits.MODE3 = 0;
    MODE7bits.MODE7 = 0;
    MODEAbits.MODEA = 0;
    
    MODE3bits.MODE3 = 0;

    
}
void check_VIN (void) {
int res;
unsigned char len;
res = 0;

    if (VIN[0]  != VIN_TMP [0])  res = 1;
    if (VIN[1]  != VIN_TMP [1])  res = 1;
    if (VIN[2]  != VIN_TMP [2])  res = 1;
    if (VIN[3]  != VIN_TMP [3])  res = 1;
    if (VIN[4]  != VIN_TMP [4])  res = 1;
    if (VIN[5]  != VIN_TMP [5])  res = 1;
    if (VIN[6]  != VIN_TMP [6])  res = 1;
    if (VIN[7]  != VIN_TMP [7])  res = 1;
    if (VIN[8]  != VIN_TMP [8])  res = 1;
    if (VIN[9]  != VIN_TMP [9])  res = 1;
    if (VIN[10] != VIN_TMP [10]) res = 1;
    if (VIN[11] != VIN_TMP [11]) res = 1;
    if (VIN[12] != VIN_TMP [12]) res = 1;
    if (VIN[13] != VIN_TMP [13]) res = 1;
    if (VIN[14] != VIN_TMP [14]) res = 1;
    if (VIN[15] != VIN_TMP [15]) res = 1;
    if (VIN[16] != VIN_TMP [16]) res = 1;


    if (res == 1) {
        reload_GPRS_header ( 4, 38, 0x0011); // N = 3, name = 38, type = 1, ACK = 1
        memmove ( command_temp_buf, GPRS_header_buf, 12 );
        unsigned int ACK_counter = 0xFFFF;
        command_temp_buf[12] = (unsigned char) (ACK_counter >> 8); command_temp_buf[13] = (unsigned char) ACK_counter; // ACK
unsigned long long temp;
        temp = FM25_read_8( 1268 ); //
        command_temp_buf[14] = 0xFF; command_temp_buf[15] = 0x01; 
        if ( temp & 0x0000000000200000 ) {command_temp_buf[16] = 0x21;} else command_temp_buf[16] = 0x01; // Dataflags
        memmove  ( &command_temp_buf[17], Navi_bin, 22 );
        
        for (res = 0; res < 17; res ++) {
            VIN[res] = VIN_TMP [res];
            command_temp_buf[res + 39] = VIN_TMP [res];
        }

        if ( temp & 0x0000000000200000 ) { // Проверка флага VIN
            sequence_number = get_sequence_number ();
            command_temp_buf[ 56 ] = (unsigned char)(sequence_number >> 24);
            command_temp_buf[ 57 ] = (unsigned char)(sequence_number >> 16);
            command_temp_buf[ 58 ] = (unsigned char)(sequence_number >> 8);
            command_temp_buf[ 59 ] = (unsigned char)(sequence_number);            
            len = 60;
        }
        else { len = 56; }
        
            command_temp_buf[113] = len; //38
          
            if ( VINDATbits.queue == 1 ) write_data_into_save_to_flash_bufs ( command_temp_buf, len ); 
        
    }

}
void check_DTCs (void) {
    
    unsigned int i, res;
    unsigned char len;
//    static unsigned char DTC_buf_tmp[93];
    
    res = 0;
    for (i = 0; i < 93; i ++) {
        if (DTC_buf[i] != DTC_buf_tmp[i]) res = 1;
        DTC_buf_tmp[i] = DTC_buf[i];
    }
    
    if (res == 0) return;
    
        reload_GPRS_header ( 1, 26, 0x0012 ); // N = 1, name = 26, type = 2, ACK = 1
        memmove ( command_temp_buf, GPRS_header_buf, 12 );
        command_temp_buf[12] = 0xff; command_temp_buf[13] = 0xff; // ACK
        memmove  ( &command_temp_buf[14], Navi_bin, 6 ); // Время и дата

        command_temp_buf[20] = MODE3bits.dtc_num_bytes1;

        memmove ( &command_temp_buf[21], DTC_buf, command_temp_buf[20] );

unsigned long long temp;
        temp = FM25_read_8( 1276 ); // 
        temp = 0x0000000000200000; // сиквенс намбер всегда включен
        if ( temp & 0x0000000000200000 ) {
            sequence_number = get_sequence_number ();
            command_temp_buf[ 21 + command_temp_buf[20] ] = (unsigned char)(sequence_number >> 24);
            command_temp_buf[ 21 + command_temp_buf[20] + 1 ] = (unsigned char)(sequence_number >> 16);
            command_temp_buf[ 21 + command_temp_buf[20] + 2 ] = (unsigned char)(sequence_number >> 8);
            command_temp_buf[ 21 + command_temp_buf[20] + 3 ] = (unsigned char)(sequence_number);            
            len = 21 + command_temp_buf[20] + 4;
        }
        else { len = 21 + command_temp_buf[20]; }        
        
        Nop();Nop();Nop();
        if ( DTCDATbits.queue == 1 ) write_data_into_save_to_flash_bufs ( command_temp_buf, len );    
    
    
}
void reset_DTC_buf (void) {
unsigned int i;

for (i = 0; i < 93; i++) {
    DTC_buf[i] = 0;
}


}



void apply_can_data ( void ) {

    unsigned char temp_byte = 0x0;
//    volatile unsigned long ID_tmp, ID2_tmp;
    
//    ID_tmp = ID; ID2_tmp = ID2;
    
// ЗАЖИГАНИЕ
    if (  CANIGNPRMSbits.can_number != 0 ) { // && (CANIGNPRMSbits.id == ID_tmp || CANIGNPRMSbits.id == ID2_tmp)
        if (CANIGNPRMSbits.can_number == 1 && CANIGNPRMSbits.id == ID_tmp) {
            generate_canbus_sleep_message ( 1 );
            if (( CAN1_DATA_buf[CANIGNPRMSbits.byte] & CANIGNPRMSbits.bit_mask )) {
                if (CANIGNPRMSbits.inv == 1) ignition = 0; else ignition = 1;
# if defined ( PRODUCTION_MODE )                
                can1_test_ok = 1;
# endif
            } else {
                if (CANIGNPRMSbits.inv == 1) ignition = 1; else ignition = 0;
            }
            if (start_engine_success_flag == 1) { // 
                if (ignition == 0) {
                    start_engine_success_flag = 0;
                    dd_intrusion_off_timer = dd_intrusion_off_setting; // 5 секундный таймер игнорирования вторжения по дверям
                }

            }            
            check_perimeter_state_change ();
        }
        if (CANIGNPRMSbits.can_number == 2 && CANIGNPRMSbits.id == ID2_tmp) {
            generate_canbus_sleep_message ( 2 );
            if (( CAN2_DATA_buf[CANIGNPRMSbits.byte] & CANIGNPRMSbits.bit_mask )) {
                if (CANIGNPRMSbits.inv == 1) ignition = 0; else ignition = 1;
# if defined ( PRODUCTION_MODE )                
                can1_test_ok = 1;
# endif                
            } else {
                if (CANIGNPRMSbits.inv == 1) ignition = 1; else ignition = 0;
            }
                if (start_engine_success_flag == 1) { // 
                    if (ignition == 0) {
                        start_engine_success_flag = 0;
                        dd_intrusion_off_timer = dd_intrusion_off_setting; // 5 секундный таймер игнорирования вторжения по дверям
                    }

                }            
            check_perimeter_state_change ();
        }        
    }

// Водительская дверь
    if (CANDDPRMSbits.can_number != 0) { // && (CANDDPRMSbits.id == ID_tmp || CANDDPRMSbits.id == ID2_tmp)
        if (CANDDPRMSbits.can_number == 1 && CANDDPRMSbits.id == ID_tmp) {
            generate_canbus_sleep_message ( 1 );
            if (CAN1_DATA_buf[CANDDPRMSbits.byte] & CANDDPRMSbits.bit_mask) { 
                if (CANDDPRMSbits.inv == 0) CANDOORSbits.dd = 1; else CANDOORSbits.dd = 0;
# if defined ( PRODUCTION_MODE )                
                can2_test_ok = 1;
#endif
            } 
            else {
                if (CANDDPRMSbits.inv == 0) CANDOORSbits.dd = 0; else CANDOORSbits.dd = 1;
            }
            check_perimeter_state_change ();
        }
        if (CANDDPRMSbits.can_number == 2 && CANDDPRMSbits.id == ID2_tmp) {
            generate_canbus_sleep_message ( 2 );
            if (CAN2_DATA_buf[CANDDPRMSbits.byte] & CANDDPRMSbits.bit_mask) { 
                if (CANDDPRMSbits.inv == 0) CANDOORSbits.dd = 1; else CANDOORSbits.dd = 0;
# if defined ( PRODUCTION_MODE )                
                can2_test_ok = 1;
# endif
            } 
            else {
                if (CANDDPRMSbits.inv == 0) CANDOORSbits.dd = 0; else CANDOORSbits.dd = 1;
            }
            check_perimeter_state_change ();
        }        
    }
// Правая передняя дверь
    if (CANFPDPRMSbits.can_number != 0) { // && (CANFPDPRMSbits.id == ID_tmp || CANFPDPRMSbits.id == ID2_tmp)
        if (CANFPDPRMSbits.can_number == 1 && CANFPDPRMSbits.id == ID_tmp) {
            generate_canbus_sleep_message ( 1 );
            if (CAN1_DATA_buf[CANFPDPRMSbits.byte] & CANFPDPRMSbits.bit_mask) { 
                if (CANFPDPRMSbits.inv == 0) CANDOORSbits.fpd = 1; else CANDOORSbits.fpd = 0;  
            } else {
                if (CANFPDPRMSbits.inv == 0) CANDOORSbits.fpd = 0; else CANDOORSbits.fpd = 1; 
            }
            check_perimeter_state_change ();        
        }
        if (CANFPDPRMSbits.can_number == 2 && CANFPDPRMSbits.id == ID2_tmp) {
            generate_canbus_sleep_message ( 2 );
            if (CAN2_DATA_buf[CANFPDPRMSbits.byte] & CANFPDPRMSbits.bit_mask) { 
                if (CANFPDPRMSbits.inv == 0) CANDOORSbits.fpd = 1; else CANDOORSbits.fpd = 0; 
            } else {
                if (CANFPDPRMSbits.inv == 0) CANDOORSbits.fpd = 0; else CANDOORSbits.fpd = 1;
            }
            check_perimeter_state_change ();
        }
    }
// Левая задняя
    if (CANRLDPRMSbits.can_number != 0) { // && (CANRLDPRMSbits.id == ID_tmp || CANRLDPRMSbits.id == ID2_tmp)
        if (CANRLDPRMSbits.can_number == 1 && CANRLDPRMSbits.id == ID_tmp) {
            generate_canbus_sleep_message ( 1 );
            if (CAN1_DATA_buf[CANRLDPRMSbits.byte] & CANRLDPRMSbits.bit_mask) { 
                if (CANRLDPRMSbits.inv == 0) CANDOORSbits.lrd = 1; else CANDOORSbits.lrd = 0;
            } else {
                if (CANRLDPRMSbits.inv == 0) CANDOORSbits.lrd = 0; else CANDOORSbits.lrd = 1;
            }
            check_perimeter_state_change ();
        }
        if (CANRLDPRMSbits.can_number == 2 && CANRLDPRMSbits.id == ID2_tmp) {
            generate_canbus_sleep_message ( 2 );
            if (CAN2_DATA_buf[CANRLDPRMSbits.byte] & CANRLDPRMSbits.bit_mask) {
                if (CANRLDPRMSbits.inv == 0) CANDOORSbits.lrd = 1; else CANDOORSbits.lrd = 0; 
            } else {
                if (CANRLDPRMSbits.inv == 0) CANDOORSbits.lrd = 0; else CANDOORSbits.lrd = 1;
            }
            check_perimeter_state_change ();
        }        
    }    
// Правая задняя дверь
    if (CANRRDPRMSbits.can_number != 0) { // && (CANRRDPRMSbits.id == ID_tmp || CANRRDPRMSbits.id == ID2_tmp)
        if (CANRRDPRMSbits.can_number == 1 && CANRRDPRMSbits.id == ID_tmp) {
            generate_canbus_sleep_message ( 1 );
            if (CAN1_DATA_buf[CANRRDPRMSbits.byte] & CANRRDPRMSbits.bit_mask) { 
                if(CANRRDPRMSbits.inv == 0) CANDOORSbits.rrd = 1; else CANDOORSbits.rrd = 0; 
            } else {
                if(CANRRDPRMSbits.inv == 0) CANDOORSbits.rrd = 0; else CANDOORSbits.rrd = 1; 
            }
            check_perimeter_state_change ();
        }
        if (CANRRDPRMSbits.can_number == 2 && CANRRDPRMSbits.id == ID2_tmp) {
            generate_canbus_sleep_message ( 2 );
            if (CAN2_DATA_buf[CANRRDPRMSbits.byte] & CANRRDPRMSbits.bit_mask) { 
                if(CANRRDPRMSbits.inv == 0) CANDOORSbits.rrd = 1; else CANDOORSbits.rrd = 0; 
            } else {
                if(CANRRDPRMSbits.inv == 0) CANDOORSbits.rrd = 0; else CANDOORSbits.rrd = 1;
            }
            check_perimeter_state_change ();
        }
    }
// Капот
    if (CANBTPRMSbits.can_number != 0) { // && (CANBTPRMSbits.id == ID_tmp || CANBTPRMSbits.id == ID2_tmp)
        if (CANBTPRMSbits.can_number == 1 && CANBTPRMSbits.id == ID_tmp) {
            generate_canbus_sleep_message ( 1 );
            if (CAN1_DATA_buf[CANBTPRMSbits.byte] & CANBTPRMSbits.bit_mask) { 
                if(CANBTPRMSbits.inv == 0) CANDOORSbits.bt = 1; else CANDOORSbits.bt = 0; 
            } else {
                if(CANBTPRMSbits.inv == 0) CANDOORSbits.bt = 0; else CANDOORSbits.bt = 1;
            }
            check_perimeter_state_change ();
        }
        if (CANBTPRMSbits.can_number == 2 && CANBTPRMSbits.id == ID2_tmp) {
            generate_canbus_sleep_message ( 2 );
            if (CAN2_DATA_buf[CANBTPRMSbits.byte] & CANBTPRMSbits.bit_mask) { 
                if(CANBTPRMSbits.inv == 0) CANDOORSbits.bt = 1; else CANDOORSbits.bt = 0; 
            } else {
                if(CANBTPRMSbits.inv == 0) CANDOORSbits.bt = 0; else CANDOORSbits.bt = 1;
            }
            check_perimeter_state_change ();
        }        
    }
// Багажник
    if (CANBNPRMSbits.can_number != 0) { // && (CANBNPRMSbits.id == ID_tmp || CANBNPRMSbits.id == ID2_tmp)
        if (CANBNPRMSbits.can_number == 1 && CANBNPRMSbits.id == ID_tmp) {
            generate_canbus_sleep_message ( 1 );
            if (CAN1_DATA_buf[CANBNPRMSbits.byte] & CANBNPRMSbits.bit_mask) { 
                if (CANBNPRMSbits.inv == 0) CANDOORSbits.bn = 1; else CANDOORSbits.bn = 0;
            } else {
                if (CANBNPRMSbits.inv == 0) CANDOORSbits.bn = 0; else CANDOORSbits.bn = 1; 
            }
            check_perimeter_state_change ();
        }
        if (CANBNPRMSbits.can_number == 2 && CANBNPRMSbits.id == ID2_tmp) {
            generate_canbus_sleep_message ( 2 );
            if (CAN2_DATA_buf[CANBNPRMSbits.byte] & CANBNPRMSbits.bit_mask) { 
                if (CANBNPRMSbits.inv == 0) CANDOORSbits.bn = 1; else CANDOORSbits.bn = 0; 
            } else {
                if (CANBNPRMSbits.inv == 0) CANDOORSbits.bn = 0; else CANDOORSbits.bn = 1;
            }
            check_perimeter_state_change ();
        }        
    }

// Ремень безопасности  
    
static unsigned char belt_tmp = 0;    
if (CANBELTPRMSbits.can_number != 0 ) { //&& (  CANBELTPRMSbits.id == ID_tmp || CANBELTPRMSbits.id == ID2_tmp )
    if (CANBELTPRMSbits.can_number == 1 && CANBELTPRMSbits.id == ID_tmp ) {
        generate_canbus_sleep_message ( 1 );
        if (( CAN1_DATA_buf[CANBELTPRMSbits.byte] & CANBELTPRMSbits.bit_mask )) { 
            if (CANBELTPRMSbits.inv == 0) CANDOORSbits.belt = 1; else CANDOORSbits.belt = 0; //STATUSFLAGS1bits.belt
        } else { 
            if (CANBELTPRMSbits.inv == 0) CANDOORSbits.belt = 0; else CANDOORSbits.belt = 1;
        }
    }
    if (CANBELTPRMSbits.can_number == 2 && CANBELTPRMSbits.id == ID2_tmp) {
        generate_canbus_sleep_message ( 2 );
        if (( CAN2_DATA_buf[CANBELTPRMSbits.byte] & CANBELTPRMSbits.bit_mask )) { 
            if (CANBELTPRMSbits.inv == 0) CANDOORSbits.belt = 1; else CANDOORSbits.belt = 0; 
        } else { 
            if (CANBELTPRMSbits.inv == 0) CANDOORSbits.belt = 0; else CANDOORSbits.belt = 1; 
        }
    }
    
    if ( belt_tmp != CANDOORSbits.belt ) {
        Nop();Nop();Nop();
        if ( CANDOORSbits.belt == 1 ) generate_content_of_message ( 80, 1 );
        else  generate_content_of_message ( 81, 1 ); 
        
    } 
    belt_tmp = CANDOORSbits.belt;
    
}    


//ПРОБЕГ        
        if (CANODOPRMSbits.can_number != 0) { // && (CANODOPRMSbits.id == ID_tmp || CANODOPRMSbits.id == ID2_tmp)
//#if defined (MAZDA_CX5)
//            if (CANODOPRMSbits.can_number == 1) {
//                if (CAN1_DATA_buf[0] == 0xC0 && CAN1_DATA_buf[1] == 0x01)  {
//                    CANODObits.B0 = CAN1_DATA_buf[CANODOPRMSbits.byte0];
//                    CANODObits.B1 = CAN1_DATA_buf[CANODOPRMSbits.byte1];
//                    CANODObits.B2 = CAN1_DATA_buf[CANODOPRMSbits.byte2];
//                }
//            }
//            if (CANODOPRMSbits.can_number == 2) {
//                if (CAN2_DATA_buf[0] == 0xC0 && CAN2_DATA_buf[1] == 0x01) {
//                    CANODObits.B0 = CAN2_DATA_buf[CANODOPRMSbits.byte0];
//                    CANODObits.B1 = CAN2_DATA_buf[CANODOPRMSbits.byte1];
//                    CANODObits.B2 = CAN2_DATA_buf[CANODOPRMSbits.byte2];
//                }
//            }            
//#else
            if ( CANODOCHECKBYTESbits.num1 > 7 && CANODOCHECKBYTESbits.num2 > 7 && CANODOCHECKBYTESbits.num3 > 7 ) {
                if (CANODOPRMSbits.can_number == 1 && CANODOPRMSbits.id == ID_tmp) {
                    generate_canbus_sleep_message ( 1 );
                    CANODObits.B0 = CAN1_DATA_buf[CANODOPRMSbits.byte0];
                    CANODObits.B1 = CAN1_DATA_buf[CANODOPRMSbits.byte1];
                    CANODObits.B2 = CAN1_DATA_buf[CANODOPRMSbits.byte2];
                }
                if (CANODOPRMSbits.can_number == 2 && CANODOPRMSbits.id == ID2_tmp) {
                    generate_canbus_sleep_message ( 2 );
                    CANODObits.B0 = CAN2_DATA_buf[CANODOPRMSbits.byte0];
                    CANODObits.B1 = CAN2_DATA_buf[CANODOPRMSbits.byte1];
                    CANODObits.B2 = CAN2_DATA_buf[CANODOPRMSbits.byte2];
                }            
            } else {
                if ( CANODOCHECKBYTESbits.num1 > 7 ) CAN1_DATA_buf[CANODOCHECKBYTESbits.num1] = CANODOCHECKBYTESbits.byte1;
                if ( CANODOCHECKBYTESbits.num2 > 7 ) CAN1_DATA_buf[CANODOCHECKBYTESbits.num2] = CANODOCHECKBYTESbits.byte2;
                if ( CANODOCHECKBYTESbits.num3 > 7 ) CAN1_DATA_buf[CANODOCHECKBYTESbits.num3] = CANODOCHECKBYTESbits.byte3;
                if (CANODOPRMSbits.can_number == 1 && CANODOPRMSbits.id == ID_tmp) {
                    generate_canbus_sleep_message ( 1 );
                    if (CAN1_DATA_buf[CANODOCHECKBYTESbits.num1] == CANODOCHECKBYTESbits.byte1 && CAN1_DATA_buf[CANODOCHECKBYTESbits.num2] == CANODOCHECKBYTESbits.byte2 &&
                        CAN1_DATA_buf[CANODOCHECKBYTESbits.num3] == CANODOCHECKBYTESbits.byte3 ) {
                        CANODObits.B0 = CAN1_DATA_buf[CANODOPRMSbits.byte0];
                        CANODObits.B1 = CAN1_DATA_buf[CANODOPRMSbits.byte1];
                        CANODObits.B2 = CAN1_DATA_buf[CANODOPRMSbits.byte2];                        
                    }
                }
                if (CANODOPRMSbits.can_number == 2 && CANODOPRMSbits.id == ID2_tmp) {
                    generate_canbus_sleep_message ( 2 );
                    if (CAN2_DATA_buf[CANODOCHECKBYTESbits.num1] == CANODOCHECKBYTESbits.byte1 && CAN2_DATA_buf[CANODOCHECKBYTESbits.num2] == CANODOCHECKBYTESbits.byte2 &&
                        CAN2_DATA_buf[CANODOCHECKBYTESbits.num3] == CANODOCHECKBYTESbits.byte3 ) {
                        CANODObits.B0 = CAN2_DATA_buf[CANODOPRMSbits.byte0];
                        CANODObits.B1 = CAN2_DATA_buf[CANODOPRMSbits.byte1];
                        CANODObits.B2 = CAN2_DATA_buf[CANODOPRMSbits.byte2];                        
                    }
                }                
            }
//#endif            
            
            FM25_write_1 (431, (unsigned int)CANODObits.B2);
            FM25_write_1 (432, (unsigned int)CANODObits.B1);
            FM25_write_1 (433, (unsigned int)CANODObits.B0);                


        }

// ТОПЛИВО
        if (CANFLPRMSbits.can_number != 0) { // && (CANFLPRMSbits.id == ID_tmp || CANFLPRMSbits.id == ID2_tmp)
//            if (ignition == 1) {    
                if (CANFLPRMSbits.can_number == 1 && CANFLPRMSbits.id == ID_tmp && CAN1_DATA_buf[CANFLPRMSbits.cntrl_byte_number] == CANFLPRMSbits.cntrl_byte)  fuel_level = (unsigned int)CAN1_DATA_buf[CANFLPRMSbits.byte0];
                if (CANFLPRMSbits.can_number == 2 && CANFLPRMSbits.id == ID2_tmp && CAN2_DATA_buf[CANFLPRMSbits.cntrl_byte_number] == CANFLPRMSbits.cntrl_byte) fuel_level = (unsigned int)CAN2_DATA_buf[CANFLPRMSbits.byte0];
//            }    
        }
// ТОПЛИВО 2 байта
        if (CANFL2PRMSbits.can_number != 0) { // && (CANFL2PRMSbits.id == ID_tmp || CANFL2PRMSbits.id == ID2_tmp)
//            if (ignition == 1) {    
                if (CANFL2PRMSbits.can_number == 1 && CANFL2PRMSbits.id == ID_tmp) {
                    generate_canbus_sleep_message ( 1 );
                    fuel_level = 0;
                    fuel_level = (unsigned int)CAN1_DATA_buf[CANFL2PRMSbits.byte1];
                    fuel_level = fuel_level << 8;
                    fuel_level = fuel_level + (unsigned int)CAN1_DATA_buf[CANFL2PRMSbits.byte0];
                }
                if (CANFL2PRMSbits.can_number == 2 && CANFL2PRMSbits.id == ID2_tmp) {
                    generate_canbus_sleep_message ( 2 );
                    fuel_level = 0;
                    fuel_level = (unsigned int)CAN2_DATA_buf[CANFL2PRMSbits.byte1];
                    fuel_level = fuel_level << 8;
                    fuel_level = fuel_level + (unsigned int)CAN2_DATA_buf[CANFL2PRMSbits.byte0];
                }
//            }    
        }
// РАСХОД ТОПЛИВА
/*static unsigned char fuel_consumption_counter_tmp = 0;*/
        if (CANFLCNPNPRMSbits.can_number != 0) { // && (CANFLCNPNPRMSbits.id == ID_tmp || CANFLCNPNPRMSbits.id == ID2_tmp)
//volatile unsigned char can_tmp;    
            if (CANFLCNPNPRMSbits.can_number == 1 && CANFLCNPNPRMSbits.id == ID_tmp) {
                generate_canbus_sleep_message ( 1 );
//                can_tmp = CAN1_DATA_buf[CANFLCNPNPRMSbits.byte0];
                if ( CAN1_DATA_buf[CANFLCNPNPRMSbits.byte0] < fuel_consumption_counter_tmp ) {
                    Nop();Nop();Nop();
                    fuel_consumption_counter_tmp = 0xFF - fuel_consumption_counter_tmp;
                    fuel_consumption = fuel_consumption + (unsigned long)fuel_consumption_quantum * (unsigned long)( CAN1_DATA_buf[CANFLCNPNPRMSbits.byte0] + fuel_consumption_counter_tmp + 1 );
                } else {
                     fuel_consumption = fuel_consumption + (unsigned long)fuel_consumption_quantum * (unsigned long)( CAN1_DATA_buf[CANFLCNPNPRMSbits.byte0] - fuel_consumption_counter_tmp);
                }
                fuel_consumption_counter_tmp = CAN1_DATA_buf[CANFLCNPNPRMSbits.byte0];
            }
            if (CANFLCNPNPRMSbits.can_number == 2 && CANFLCNPNPRMSbits.id == ID2_tmp) {
                generate_canbus_sleep_message ( 2 );
                if ( CAN2_DATA_buf[CANFLCNPNPRMSbits.byte0] < fuel_consumption_counter_tmp ) {
                    Nop();Nop();Nop();
                    fuel_consumption_counter_tmp = 0xFF - fuel_consumption_counter_tmp;
                    fuel_consumption = fuel_consumption + (unsigned long)fuel_consumption_quantum * (unsigned long)( CAN2_DATA_buf[CANFLCNPNPRMSbits.byte0] + fuel_consumption_counter_tmp + 1 );
                } else {
                     fuel_consumption = fuel_consumption + (unsigned long)fuel_consumption_quantum * (unsigned long)( CAN2_DATA_buf[CANFLCNPNPRMSbits.byte0] - fuel_consumption_counter_tmp);
                }
                fuel_consumption_counter_tmp = CAN2_DATA_buf[CANFLCNPNPRMSbits.byte0];

            }
    
        } 

// ЗАМКИ ДВЕРЕЙ    
if ( LOCKSTATPRMSbits.can_number != 0 ) { // && (LOCKSTATPRMSbits.id == ID_tmp || LOCKSTATPRMSbits.id == ID2_tmp)
    if (LOCKSTATPRMSbits.can_number == 1 && LOCKSTATPRMSbits.id == ID_tmp) {
        generate_canbus_sleep_message ( 1 );
        if (( CAN1_DATA_buf[LOCKSTATPRMSbits.byte] & LOCKSTATPRMSbits.bit_mask )) {
            if (LOCKSTATPRMSbits.inv == 0) lock_status = 1; else lock_status = 0;
        }
        else {
            if (LOCKSTATPRMSbits.inv == 0) lock_status = 0; else lock_status = 1;
        }
    }
    if (LOCKSTATPRMSbits.can_number == 2 && LOCKSTATPRMSbits.id == ID2_tmp) {
        generate_canbus_sleep_message ( 2 );
        if (( CAN2_DATA_buf[LOCKSTATPRMSbits.byte] & LOCKSTATPRMSbits.bit_mask )) {
            if (LOCKSTATPRMSbits.inv == 0) lock_status = 1; else lock_status = 0;
        }
        else {
            if (LOCKSTATPRMSbits.inv == 0) lock_status = 0; else lock_status = 1;
        }
    }
    if (lock_status != lock_status_tmp) { send_lock_status (); }
    lock_status_tmp = lock_status;
}
// ЗАМКИ ДВЕРЕЙ ТИП 2    
    if ( LOCKSTATPRMS2bits.can_number != 0) { // && (LOCKSTATPRMS2bits.id == ID_tmp || LOCKSTATPRMS2bits.id == ID2_tmp) 

        if (LOCKSTATPRMS2bits.can_number == 1 && LOCKSTATPRMS2bits.id == ID_tmp) {generate_canbus_sleep_message ( 1 ); temp_byte =  CAN1_DATA_buf[LOCKSTATPRMS2bits.byte] & LOCKSTATPRMS2bits.bit_mask;}
        if (LOCKSTATPRMS2bits.can_number == 2 && LOCKSTATPRMS2bits.id == ID2_tmp) {generate_canbus_sleep_message ( 2 ); temp_byte =  CAN2_DATA_buf[LOCKSTATPRMS2bits.byte] & LOCKSTATPRMS2bits.bit_mask;} 

        if (temp_byte == LOCKSTATPRMS2bits.value1 ) lock_status = 1;
        if (temp_byte == LOCKSTATPRMS2bits.value2 ) lock_status = 0;

    //    if (LOCKSTATPRMS2bits.can_number == 1) {
    //        if (( CAN1_DATA_buf[LOCKSTATPRMS2bits.byte] & LOCKSTATPRMS2bits.bit_mask ) == LOCKSTATPRMS2bits.value1 ) {
    //            lock_status = 1;
    //        }
    //        if (( CAN1_DATA_buf[LOCKSTATPRMS2bits.byte] & LOCKSTATPRMS2bits.bit_mask ) == LOCKSTATPRMS2bits.value2 ) {
    //            lock_status = 0;
    //        }
    //    }
    //    if (LOCKSTATPRMS2bits.can_number == 2) {
    //        if (( CAN2_DATA_buf[LOCKSTATPRMS2bits.byte] & LOCKSTATPRMS2bits.bit_mask ) == LOCKSTATPRMS2bits.value1 ) {
    //            lock_status = 1;
    //        }
    //        if (( CAN2_DATA_buf[LOCKSTATPRMS2bits.byte] & LOCKSTATPRMS2bits.bit_mask ) == LOCKSTATPRMS2bits.value2 ) {
    //            lock_status = 0;
    //        }
    //    }
        if (lock_status != lock_status_tmp) { send_lock_status (); }
        lock_status_tmp = lock_status;
    }

// ЗАЖИГАНИЕ ТИП 2
    if ( CANIGNPRMS2bits.can_number != 0 ) { // && (CANIGNPRMS2bits.id == ID_tmp || CANIGNPRMS2bits.id == ID2_tmp) 
        if (CANIGNPRMS2bits.can_number == 1 && CANIGNPRMS2bits.id == ID_tmp) {
            generate_canbus_sleep_message ( 1 );
            if (( CAN1_DATA_buf[CANIGNPRMS2bits.byte] & CANIGNPRMS2bits.bit_mask ) == CANIGNPRMS2bits.value1) { ignition = 1; }
            if (( CAN1_DATA_buf[CANIGNPRMS2bits.byte] & CANIGNPRMS2bits.bit_mask ) == CANIGNPRMS2bits.value2) { ignition = 0; }

            if (start_engine_success_flag == 1) { // 
                if (ignition == 0) {
                    start_engine_success_flag = 0;
                    dd_intrusion_off_timer = dd_intrusion_off_setting; // 5 секундный таймер игнорирования вторжения по дверям
                }

            }            

            check_perimeter_state_change ();
        }
        if (CANIGNPRMS2bits.can_number == 2 && CANIGNPRMS2bits.id == ID2_tmp) {
            generate_canbus_sleep_message ( 2 );
            if (( CAN2_DATA_buf[CANIGNPRMS2bits.byte] & CANIGNPRMS2bits.bit_mask ) == CANIGNPRMS2bits.value1) { ignition = 1; }
            if (( CAN2_DATA_buf[CANIGNPRMS2bits.byte] & CANIGNPRMS2bits.bit_mask ) == CANIGNPRMS2bits.value2) { ignition = 0; }

            if (start_engine_success_flag == 1) { // 
                if (ignition == 0) {
                    start_engine_success_flag = 0;
                    dd_intrusion_off_timer = dd_intrusion_off_setting; // 5 секундный таймер игнорирования вторжения по дверям
                }

            }

            check_perimeter_state_change ();
        }        
    }
// СТАТУС ДВИГАТЕЛЯ ТИП 2 ENJSTATUSPRMS2bits
//# if defined (ENJINE_STATUS_OUT)    
    if ( ENJSTATUSPRMS2bits.can_number != 0 && (ENJSTATUSPRMS2bits.id == ID_tmp || ENJSTATUSPRMS2bits.id == ID2_tmp) ) { 
        if (ENJSTATUSPRMS2bits.can_number == 1) {
            generate_canbus_sleep_message ( 1 );
            if (( CAN1_DATA_buf[ENJSTATUSPRMS2bits.byte] & ENJSTATUSPRMS2bits.bit_mask ) == ENJSTATUSPRMS2bits.value1) { 
                engine_status = 1;
    # if defined (MCP23S08)

    # else                
                if (OUTFUNCbits.pin15 == 4) {    
                    L_OUT = 1;
                }
    # endif
            }
            if (( CAN1_DATA_buf[ENJSTATUSPRMS2bits.byte] & ENJSTATUSPRMS2bits.bit_mask ) != ENJSTATUSPRMS2bits.value1) { 
                engine_status = 0;
    # if defined (MCP23S08)

    # else                
                if (OUTFUNCbits.pin15 == 4) {    
                    L_OUT = 0; 
                }
    # endif            
            }
        }
        if (ENJSTATUSPRMS2bits.can_number == 2) {
            generate_canbus_sleep_message ( 2 );
            if (( CAN2_DATA_buf[ENJSTATUSPRMS2bits.byte] & ENJSTATUSPRMS2bits.bit_mask ) == ENJSTATUSPRMS2bits.value1) {
                engine_status = 1;
    # if defined (MCP23S08)

    # else                
                if (OUTFUNCbits.pin15 == 4) {    
                    L_OUT =  1; 
                }
    # endif            
            }
            if (( CAN2_DATA_buf[ENJSTATUSPRMS2bits.byte] & ENJSTATUSPRMS2bits.bit_mask ) != ENJSTATUSPRMS2bits.value1) {
                engine_status = 0;
    # if defined (MCP23S08)

    # else                
                if (OUTFUNCbits.pin15 == 4) {    
                    L_OUT =  0; 
                }
    # endif            
            }
        } 
    }
//# endif 
    
// СТАТУС WEBASTO    
if ( WEBASTOSTATPRMSbits.can_number != 0 ) { // && (WEBASTOSTATPRMSbits.id == ID_tmp || WEBASTOSTATPRMSbits.id == ID2_tmp)
    if (WEBASTOSTATPRMSbits.can_number == 1 && WEBASTOSTATPRMSbits.id == ID_tmp) {
        generate_canbus_sleep_message ( 1 );
        if (( CAN1_DATA_buf[WEBASTOSTATPRMSbits.byte] & WEBASTOSTATPRMSbits.bit_mask )) {
            if (WEBASTOSTATPRMSbits.inv == 0) webasto_status = 1; else webasto_status = 0;
        }
        else {
            if (WEBASTOSTATPRMSbits.inv == 0) webasto_status = 0; else webasto_status = 1;
        }
    }
    if (WEBASTOSTATPRMSbits.can_number == 2 && WEBASTOSTATPRMSbits.id == ID2_tmp) {
        generate_canbus_sleep_message ( 2 );
        if (( CAN2_DATA_buf[WEBASTOSTATPRMSbits.byte] & WEBASTOSTATPRMSbits.bit_mask )) {
            if (WEBASTOSTATPRMSbits.inv == 0) webasto_status = 1; else webasto_status = 0;
        }
        else {
            if (WEBASTOSTATPRMSbits.inv == 0) webasto_status = 0; else webasto_status = 1;
        }
    }
    if (webasto_status != webasto_status_tmp) { send_webasto_status (); }
    webasto_status_tmp = webasto_status;
}

// ШТАТКА ТИП 2    
    if ( ALARMSTATPRMS2bits.can_number != 0 ) { // && (ALARMSTATPRMS2bits.id == ID_tmp || ALARMSTATPRMS2bits.id == ID2_tmp)

        if (ALARMSTATPRMS2bits.can_number == 1 && ALARMSTATPRMS2bits.id == ID_tmp)  {generate_canbus_sleep_message ( 1 ); temp_byte =  CAN1_DATA_buf[ALARMSTATPRMS2bits.byte] & ALARMSTATPRMS2bits.bit_mask;}
        if (ALARMSTATPRMS2bits.can_number == 2 && ALARMSTATPRMS2bits.id == ID2_tmp) {generate_canbus_sleep_message ( 2 ); temp_byte =  CAN2_DATA_buf[ALARMSTATPRMS2bits.byte] & ALARMSTATPRMS2bits.bit_mask;} 

        if (temp_byte == ALARMSTATPRMS2bits.value1 ) alarm2_status = 1;
        else alarm2_status = 0;

        if (alarm2_status != alarm2_status_tmp ) { 
            if (alarm2_status == 1) send_alarm2_status (); 
        }
        alarm2_status_tmp = alarm2_status;
    }

// АКПП ТИП 2    
    if ( GEARBOXSTATPRMS2bits.can_number != 0 ) { // && (GEARBOXSTATPRMS2bits.id == ID_tmp || GEARBOXSTATPRMS2bits.id == ID2_tmp)

        if (GEARBOXSTATPRMS2bits.can_number == 1 && GEARBOXSTATPRMS2bits.id == ID_tmp) {generate_canbus_sleep_message ( 1 ); temp_byte =  CAN1_DATA_buf[GEARBOXSTATPRMS2bits.byte] & GEARBOXSTATPRMS2bits.bit_mask;}
        if (GEARBOXSTATPRMS2bits.can_number == 2 && GEARBOXSTATPRMS2bits.id == ID2_tmp) {generate_canbus_sleep_message ( 2 ); temp_byte =  CAN2_DATA_buf[GEARBOXSTATPRMS2bits.byte] & GEARBOXSTATPRMS2bits.bit_mask;} 

        if (temp_byte == GEARBOXSTATPRMS2bits.value1 ) gearbox2_status = 1;
        else gearbox2_status = 0;


    }
    
// ЗАМКИ ДВЕРЕЙ ТИП 3 
    if ( LOCKSTATPRMS3bits.can_number != 0 ) { // && (LOCKSTATPRMS3bits.id == ID_tmp || LOCKSTATPRMS3bits.id == ID2_tmp) 
        if (LOCKSTATPRMS3bits.can_number == 1 && LOCKSTATPRMS3bits.id == ID_tmp) {
            generate_canbus_sleep_message ( 1 );
            if (( CAN1_DATA_buf[LOCKSTATPRMS3bits.byte] & LOCKSTATPRMS3bits.bit_mask ) == LOCKSTATPRMS3bits.value1) { lock_status = 1; }
            if (( CAN1_DATA_buf[LOCKSTATPRMS3bits.byte] & LOCKSTATPRMS3bits.bit_mask ) == LOCKSTATPRMS3bits.value2) { lock_status = 0; }


        }
        if (LOCKSTATPRMS3bits.can_number == 2 && LOCKSTATPRMS3bits.id == ID2_tmp) {
            generate_canbus_sleep_message ( 2 );
            if (( CAN2_DATA_buf[LOCKSTATPRMS3bits.byte] & LOCKSTATPRMS3bits.bit_mask ) == LOCKSTATPRMS3bits.value1) { lock_status = 1; }
            if (( CAN2_DATA_buf[LOCKSTATPRMS3bits.byte] & LOCKSTATPRMS3bits.bit_mask ) == LOCKSTATPRMS3bits.value2) { lock_status = 0; }

            
        } 
        
        if (lock_status != lock_status_tmp) { send_lock_status (); }
        lock_status_tmp = lock_status;      
        
    }

// ЗАМОК БАГАЖНИКА ТИП 1    
if ( BOOTLOCKSTATPRMSbits.can_number != 0 ) { // && (BOOTLOCKSTATPRMSbits.id == ID_tmp || BOOTLOCKSTATPRMSbits.id == ID2_tmp)
    if (BOOTLOCKSTATPRMSbits.can_number == 1 && BOOTLOCKSTATPRMSbits.id == ID_tmp) {
        generate_canbus_sleep_message ( 1 );
        if (( CAN1_DATA_buf[BOOTLOCKSTATPRMSbits.byte] & BOOTLOCKSTATPRMSbits.bit_mask )) {
            if (BOOTLOCKSTATPRMSbits.inv == 0) boot_lock_status = 1; else boot_lock_status = 0;
        }
        else {
            if (BOOTLOCKSTATPRMSbits.inv == 0) boot_lock_status = 0; else boot_lock_status = 1;
        }
    }
    if (BOOTLOCKSTATPRMSbits.can_number == 2 && BOOTLOCKSTATPRMSbits.id == ID2_tmp) {
        generate_canbus_sleep_message ( 2 );
        if (( CAN2_DATA_buf[BOOTLOCKSTATPRMSbits.byte] & BOOTLOCKSTATPRMSbits.bit_mask )) {
            if (BOOTLOCKSTATPRMSbits.inv == 0) boot_lock_status = 1; else boot_lock_status = 0;
        }
        else {
            if (BOOTLOCKSTATPRMSbits.inv == 0) boot_lock_status = 0; else boot_lock_status = 1;
        }
    }
    if (boot_lock_status != boot_lock_status_tmp) { 
        Nop();Nop();Nop();
        send_boot_lock_status ();
    }
    boot_lock_status_tmp = boot_lock_status;
}    

// ЧТЕНИЕ КОМАНД КЛЮЧА ДЛЯ УПРАВЛЕНИЯ ЗАМКАМИ  
    if ( lockbytes_enable == 1 && LOCKBYTESTASCKbits.start == 1) {
        if ( CANLOCKBYTESPRMSbits.can_number != 0 ) { // && (CANLOCKBYTESPRMSbits.id == ID_tmp || CANLOCKBYTESPRMSbits.id == ID2_tmp)
            if ( lockbytes_learn_param == 1 ||  lockbytes_learn_param == 2  ) {
                if (CANLOCKBYTESPRMSbits.can_number == 1 && CANLOCKBYTESPRMSbits.id == ID_tmp) {
                    generate_canbus_sleep_message ( 1 );
                    if (CANLOCKBYTESPRMSbits.byte0 < 8) LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte0] = CAN1_DATA_buf[CANLOCKBYTESPRMSbits.byte0];
                    if (CANLOCKBYTESPRMSbits.byte1 < 8) LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte1] = CAN1_DATA_buf[CANLOCKBYTESPRMSbits.byte1];
                    if (CANLOCKBYTESPRMSbits.byte2 < 8) LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte2] = CAN1_DATA_buf[CANLOCKBYTESPRMSbits.byte2];
                    if (CANLOCKBYTESPRMS2bits.byte3 < 8) LOCK_BYTES_buf[CANLOCKBYTESPRMS2bits.byte3] = CAN1_DATA_buf[CANLOCKBYTESPRMS2bits.byte3];
                    lock_bytes_learn_tasck ( 1 );
                }
                if (CANLOCKBYTESPRMSbits.can_number == 2 && CANLOCKBYTESPRMSbits.id == ID2_tmp) {
                    generate_canbus_sleep_message ( 2 );
                    if (CANLOCKBYTESPRMSbits.byte0 < 8) LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte0] = CAN2_DATA_buf[CANLOCKBYTESPRMSbits.byte0];
                    if (CANLOCKBYTESPRMSbits.byte1 < 8) LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte1] = CAN2_DATA_buf[CANLOCKBYTESPRMSbits.byte1];
                    if (CANLOCKBYTESPRMSbits.byte2 < 8) LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte2] = CAN2_DATA_buf[CANLOCKBYTESPRMSbits.byte2];
                    if (CANLOCKBYTESPRMS2bits.byte3 < 8) LOCK_BYTES_buf[CANLOCKBYTESPRMS2bits.byte3] = CAN2_DATA_buf[CANLOCKBYTESPRMS2bits.byte3];
                    lock_bytes_learn_tasck ( 1 );
                }
            }
            if ( lockbytes_learn_param == 3 ) {
                if (CANLOCKBYTESPRMSbits.can_number == 1 && CANLOCKBYTESPRMSbits.id == ID_tmp) {
                    generate_canbus_sleep_message ( 1 );
                    if (CANLOCKBYTESPRMSbits.byte0 < 8) LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte0] = CAN1_DATA_buf[CANLOCKBYTESPRMSbits.byte0];
                    if (CANLOCKBYTESPRMSbits.byte1 < 8) LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte1] = CAN1_DATA_buf[CANLOCKBYTESPRMSbits.byte1];
                    if (CANLOCKBYTESPRMSbits.byte2 < 8) LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte2] = CAN1_DATA_buf[CANLOCKBYTESPRMSbits.byte2];
                    if (CANLOCKBYTESPRMS2bits.byte3 < 8) LOCK_BYTES_buf[CANLOCKBYTESPRMS2bits.byte3] = CAN1_DATA_buf[CANLOCKBYTESPRMS2bits.byte3];
                    
                    if (CANLOCKCHECKBYTESbits.num0 < 8) LOCK_BYTES_buf[CANLOCKCHECKBYTESbits.num0] = CAN1_DATA_buf[CANLOCKCHECKBYTESbits.num0];
                    if (CANLOCKCHECKBYTESbits.num1 < 8) LOCK_BYTES_buf[CANLOCKCHECKBYTESbits.num1] = CAN1_DATA_buf[CANLOCKCHECKBYTESbits.num1];
                    if (CANLOCKCHECKBYTESbits.num2 < 8) LOCK_BYTES_buf[CANLOCKCHECKBYTESbits.num2] = CAN1_DATA_buf[CANLOCKCHECKBYTESbits.num2];
                    lock_bytes_learn_tasck ( 1 );
                }
                if (CANLOCKBYTESPRMSbits.can_number == 2 && CANLOCKBYTESPRMSbits.id == ID2_tmp) {
                    generate_canbus_sleep_message ( 2 );
                    if (CANLOCKBYTESPRMSbits.byte0 < 8) LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte0] = CAN2_DATA_buf[CANLOCKBYTESPRMSbits.byte0];
                    if (CANLOCKBYTESPRMSbits.byte1 < 8) LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte1] = CAN2_DATA_buf[CANLOCKBYTESPRMSbits.byte1];
                    if (CANLOCKBYTESPRMSbits.byte2 < 8) LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte2] = CAN2_DATA_buf[CANLOCKBYTESPRMSbits.byte2];
                    if (CANLOCKBYTESPRMS2bits.byte3 < 8) LOCK_BYTES_buf[CANLOCKBYTESPRMS2bits.byte3] = CAN2_DATA_buf[CANLOCKBYTESPRMS2bits.byte3];

                    if (CANLOCKCHECKBYTESbits.num0 < 8) LOCK_BYTES_buf[CANLOCKCHECKBYTESbits.num0] = CAN2_DATA_buf[CANLOCKCHECKBYTESbits.num0];
                    if (CANLOCKCHECKBYTESbits.num1 < 8) LOCK_BYTES_buf[CANLOCKCHECKBYTESbits.num1] = CAN2_DATA_buf[CANLOCKCHECKBYTESbits.num1];
                    if (CANLOCKCHECKBYTESbits.num2 < 8) LOCK_BYTES_buf[CANLOCKCHECKBYTESbits.num2] = CAN2_DATA_buf[CANLOCKCHECKBYTESbits.num2];
                    lock_bytes_learn_tasck ( 1 );
                }                
            }
        }
    }

// Ближний свет
static unsigned char lights_status = 0, lights_status_tmp = 0;

    if (CANLIGHTSPRMSbits.can_number != 0) { // && (CANLIGHTSPRMSbits.id == ID_tmp || CANLIGHTSPRMSbits.id == ID2_tmp)
        if (CANLIGHTSPRMSbits.can_number == 1 && CANLIGHTSPRMSbits.id == ID_tmp) {
            generate_canbus_sleep_message ( 1 );
            if (CAN1_DATA_buf[CANLIGHTSPRMSbits.byte] & CANLIGHTSPRMSbits.bit_mask) { 
                if (CANLIGHTSPRMSbits.inv == 0) lights_status_tmp = 1; else lights_status_tmp = 0; 
            } 
            else {
                if (CANLIGHTSPRMSbits.inv == 0) lights_status_tmp = 0; else lights_status_tmp = 1;
            }
            
        }
        if (CANLIGHTSPRMSbits.can_number == 2 && CANLIGHTSPRMSbits.id == ID2_tmp) {
            generate_canbus_sleep_message ( 2 );
            if (CAN2_DATA_buf[CANLIGHTSPRMSbits.byte] & CANLIGHTSPRMSbits.bit_mask) { 
                if (CANLIGHTSPRMSbits.inv == 0) lights_status_tmp = 1; else lights_status_tmp = 0;
            } 
            else {
                if (CANLIGHTSPRMSbits.inv == 0) lights_status_tmp = 0; else lights_status_tmp = 1;
            }
            
        }

        if ( lights_status != lights_status_tmp ) {
            if ( lights_status == 1 ) generate_content_of_message ( 74, 1 );
            else generate_content_of_message ( 75, 1 );;
        }
        lights_status = lights_status_tmp;
    }
// Повороты левые

    if (CANTLLIGHTSPRMSbits.can_number != 0) { // && (CANTLLIGHTSPRMSbits.id == ID_tmp || CANTLLIGHTSPRMSbits.id == ID2_tmp)
        if (CANTLLIGHTSPRMSbits.can_number == 1 && CANTLLIGHTSPRMSbits.id == ID_tmp) {
            generate_canbus_sleep_message ( 1 );
            if (CAN1_DATA_buf[CANTLLIGHTSPRMSbits.byte] & CANTLLIGHTSPRMSbits.bit_mask) { 
                if (CANTLLIGHTSPRMSbits.inv == 0) tllights_status_tmp = 1; else tllights_status_tmp = 0; 
            } 
            else {
                if (CANTLLIGHTSPRMSbits.inv == 0) tllights_status_tmp = 0; else tllights_status_tmp = 1;
            }
            
        }
        if (CANTLLIGHTSPRMSbits.can_number == 2 && CANTLLIGHTSPRMSbits.id == ID2_tmp) {
            generate_canbus_sleep_message ( 2 );
            if (CAN2_DATA_buf[CANTLLIGHTSPRMSbits.byte] & CANTLLIGHTSPRMSbits.bit_mask) { 
                if (CANTLLIGHTSPRMSbits.inv == 0) tllights_status_tmp = 1; else tllights_status_tmp = 0;
            } 
            else {
                if (CANTLLIGHTSPRMSbits.inv == 0) tllights_status_tmp = 0; else tllights_status_tmp = 1;
            }
            
        }
    }
// Повороты правые
    if (CANTRLIGHTSPRMSbits.can_number != 0) { // && (CANTRLIGHTSPRMSbits.id == ID_tmp || CANTRLIGHTSPRMSbits.id == ID2_tmp)
        if (CANTRLIGHTSPRMSbits.can_number == 1 && CANTRLIGHTSPRMSbits.id == ID_tmp) {
            generate_canbus_sleep_message ( 1 );
            if (CAN1_DATA_buf[CANTRLIGHTSPRMSbits.byte] & CANTRLIGHTSPRMSbits.bit_mask) { 
                if (CANTRLIGHTSPRMSbits.inv == 0) trlights_status_tmp = 1; else trlights_status_tmp = 0; 
            } 
            else {
                if (CANTRLIGHTSPRMSbits.inv == 0) trlights_status_tmp = 0; else trlights_status_tmp = 1;
            }
            generate_turn_lights_message (1);
        }
        if (CANTRLIGHTSPRMSbits.can_number == 2 && CANTRLIGHTSPRMSbits.id == ID2_tmp) {
            generate_canbus_sleep_message ( 2 );
            if (CAN2_DATA_buf[CANTRLIGHTSPRMSbits.byte] & CANTRLIGHTSPRMSbits.bit_mask) { 
                if (CANTRLIGHTSPRMSbits.inv == 0) trlights_status_tmp = 1; else trlights_status_tmp = 0;
            } 
            else {
                if (CANTRLIGHTSPRMSbits.inv == 0) trlights_status_tmp = 0; else trlights_status_tmp = 1;
            }
            generate_turn_lights_message (1);
        }
    }

// Педаль тормоза
    if (CANBRPPRMSbits.can_number != 0) { //
        if (CANBRPPRMSbits.can_number == 1 && CANBRPPRMSbits.id == ID_tmp) {
            generate_canbus_sleep_message ( 1 );
            if (CAN1_DATA_buf[CANBRPPRMSbits.byte] & CANBRPPRMSbits.bit_mask) { 
                if (CANBRPPRMSbits.inv == 0) brake_status = 1; else brake_status = 0;  
            } else {
                if (CANBRPPRMSbits.inv == 0) brake_status = 0; else brake_status = 1; 
            }       
        }
        if (CANBRPPRMSbits.can_number == 2 && CANBRPPRMSbits.id == ID2_tmp) {
            generate_canbus_sleep_message ( 2 );
            if (CAN2_DATA_buf[CANBRPPRMSbits.byte] & CANBRPPRMSbits.bit_mask) { 
                if (CANBRPPRMSbits.inv == 0) brake_status = 1; else brake_status = 0; 
            } else {
                if (CANBRPPRMSbits.inv == 0) brake_status = 0; else brake_status = 1;
            }
        }
    }

// ОБОРОТЫ
        if (RPMPRMSbits.can_number != 0) { // && (CANFL2PRMSbits.id == ID_tmp || CANFL2PRMSbits.id == ID2_tmp)
                if (RPMPRMSbits.can_number == 1 && RPMPRMSbits.id == ID_tmp) {
                    generate_canbus_sleep_message ( 1 );
                    engine_rpm = 0;
                    engine_rpm = (unsigned int)CAN1_DATA_buf[RPMPRMSbits.byte1];
                    engine_rpm = engine_rpm << 8;
                    engine_rpm = engine_rpm + (unsigned int)CAN1_DATA_buf[RPMPRMSbits.byte0];
                }
                if (RPMPRMSbits.can_number == 2 && RPMPRMSbits.id == ID2_tmp) {
                    generate_canbus_sleep_message ( 2 );
                    engine_rpm = 0;
                    engine_rpm = (unsigned int)CAN2_DATA_buf[RPMPRMSbits.byte1];
                    engine_rpm = engine_rpm << 8;
                    engine_rpm = engine_rpm + (unsigned int)CAN2_DATA_buf[RPMPRMSbits.byte0];
                }
        }
// Ключ Тойоты
        if (TOYOTAKEYDATbits.can_number != 0) { // && (CANFL2PRMSbits.id == ID_tmp || CANFL2PRMSbits.id == ID2_tmp)
            if (TOYOTAKEYDATbits.can_number == 1 && TOYOTAKEYDATbits.id == ID_tmp && lock_status == 1) {
                TOYOTAKEYbuf[TOYOTA_W_ptr][0] = CAN1_DATA_buf[0]; TOYOTAKEYbuf[TOYOTA_W_ptr][1] = CAN1_DATA_buf[1]; TOYOTAKEYbuf[TOYOTA_W_ptr][2] = CAN1_DATA_buf[2]; TOYOTAKEYbuf[TOYOTA_W_ptr][3] = CAN1_DATA_buf[3];
                TOYOTAKEYbuf[TOYOTA_W_ptr][4] = CAN1_DATA_buf[4]; TOYOTAKEYbuf[TOYOTA_W_ptr][5] = CAN1_DATA_buf[5]; TOYOTAKEYbuf[TOYOTA_W_ptr][6] = CAN1_DATA_buf[6]; TOYOTAKEYbuf[TOYOTA_W_ptr][7] = CAN1_DATA_buf[7];
                TOYOTA_W_ptr ++; TOYOTA_W_ptr = TOYOTA_W_ptr % 3;
                TOYOTA_R_ptr = TOYOTA_W_ptr + 1; TOYOTA_R_ptr = TOYOTA_R_ptr % 3;
            }
            if (TOYOTAKEYDATbits.can_number == 2 && TOYOTAKEYDATbits.id == ID2_tmp && lock_status == 1) {
                TOYOTAKEYbuf[TOYOTA_W_ptr][0] = CAN2_DATA_buf[0]; TOYOTAKEYbuf[TOYOTA_W_ptr][1] = CAN2_DATA_buf[1]; TOYOTAKEYbuf[TOYOTA_W_ptr][2] = CAN2_DATA_buf[2]; TOYOTAKEYbuf[TOYOTA_W_ptr][3] = CAN2_DATA_buf[3];
                TOYOTAKEYbuf[TOYOTA_W_ptr][4] = CAN2_DATA_buf[4]; TOYOTAKEYbuf[TOYOTA_W_ptr][5] = CAN2_DATA_buf[5]; TOYOTAKEYbuf[TOYOTA_W_ptr][6] = CAN2_DATA_buf[6]; TOYOTAKEYbuf[TOYOTA_W_ptr][7] = CAN2_DATA_buf[7];
                TOYOTA_W_ptr ++; TOYOTA_W_ptr = TOYOTA_W_ptr % 3;
                TOYOTA_R_ptr = TOYOTA_W_ptr + 1; TOYOTA_R_ptr = TOYOTA_R_ptr % 3;
            }
            
        }
// Кнопка разблокировки
    if (  CANBUTTONPRMSbits.can_number != 0 ) { // && (CANIGNPRMSbits.id == ID_tmp || CANIGNPRMSbits.id == ID2_tmp)
        if (CANBUTTONPRMSbits.can_number == 1 && CANBUTTONPRMSbits.id == ID_tmp) {
            generate_canbus_sleep_message ( 1 );
            if (( CAN1_DATA_buf[CANBUTTONPRMSbits.byte] & CANBUTTONPRMSbits.bit_mask ) == CANBUTTONPRMSbits.value1) { can_button = 1; }
            else { can_button = 0; }
//            if (( CAN1_DATA_buf[CANBUTTONPRMSbits.byte] & CANBUTTONPRMSbits.bit_mask )) {
//                if (CANBUTTONPRMSbits.inv == 1) can_button = 0; else can_button = 1;
//            } else { if (CANBUTTONPRMSbits.inv == 1) can_button = 1; else can_button = 0; }
        }
        if (CANBUTTONPRMSbits.can_number == 2 && CANBUTTONPRMSbits.id == ID2_tmp) {
            generate_canbus_sleep_message ( 2 );
            if (( CAN2_DATA_buf[CANBUTTONPRMSbits.byte] & CANBUTTONPRMSbits.bit_mask ) == CANBUTTONPRMSbits.value1) { can_button = 1; }
            else { can_button = 0; }
        }
        check_second_autorisation_button ( 1 );
    }
/*
// Сниффер
    if (ID_to_sniff != 0) {
        if (ID_to_sniff == ID_tmp) {
            redirect_can_to_uart ( (unsigned long)ID_tmp );
        }
    }
*/
#if defined(FOR_TRUCK)
////////////////////////////////////////////////////////////////////////////////
// Fuel Level - Уровень топлива
    if (FUELLEVELbits.can_number != 0) { 
        if (FUELLEVELbits.can_number == 1 && (FUELLEVELbits.id == (ID_tmp & maskIDExtendedFMS))) {
            generate_canbus_sleep_message ( 1 );
            //if ((CAN1_DATA_buf[0] == 0xFF) && (CAN1_DATA_buf[2] == 0xFF) && (CAN1_DATA_buf[3] == 0xFF) && (CAN1_DATA_buf[4] == 0xFF) && 
            //        (CAN1_DATA_buf[5] == 0xFF) && (CAN1_DATA_buf[6] == 0xFF) && (CAN1_DATA_buf[7] == 0xFF)) {
                FUELLEVELbits.value1     = CAN1_DATA_buf[1]; 
                FUELLEVELbits.value2     = CAN1_DATA_buf[6]; 
                fmsData.fuelLevelValue1  = FUELLEVELbits.value1;
                fmsData.fuelLevelValue2  = FUELLEVELbits.value2;
            //}  
            
        }
        if (FUELLEVELbits.can_number == 2 && (FUELLEVELbits.id == (ID2_tmp & maskIDExtendedFMS))) {
            generate_canbus_sleep_message ( 2 );            
            FUELLEVELbits.value1     = CAN2_DATA_buf[1]; 
            FUELLEVELbits.value2     = CAN2_DATA_buf[6]; 
            fmsData.fuelLevelValue1  = FUELLEVELbits.value1; 
            fmsData.fuelLevelValue2  = FUELLEVELbits.value2;
        }              
    }

// Total Fuel Used - Общее израсходованное топливо
    if (TOTALFUELUSEDCONFbits.can_number != 0) { 
        if (TOTALFUELUSEDCONFbits.can_number == 1 && (TOTALFUELUSEDCONFbits.id == (ID_tmp & maskIDExtendedFMS))) {
            generate_canbus_sleep_message ( 1 );
            //if ((CAN1_DATA_buf[0] == 0x00) && (CAN1_DATA_buf[1] == 0x00) && (CAN1_DATA_buf[2] == 0x00) && // ???
            //        (CAN1_DATA_buf[3] == 0x00)) {
                TOTALFUELUSEDbits.value1    = CAN1_DATA_buf[4];
                TOTALFUELUSEDbits.value2    = CAN1_DATA_buf[5];
                TOTALFUELUSEDbits.value3    = CAN1_DATA_buf[6];
                TOTALFUELUSEDbits.value4    = CAN1_DATA_buf[7];
                fmsData.totalFuelUsedValue1 = TOTALFUELUSEDbits.value1;
                fmsData.totalFuelUsedValue2 = TOTALFUELUSEDbits.value2;
                fmsData.totalFuelUsedValue3 = TOTALFUELUSEDbits.value3;
                fmsData.totalFuelUsedValue4 = TOTALFUELUSEDbits.value4;
            //}            
        }
        if (TOTALFUELUSEDCONFbits.can_number == 2 && (TOTALFUELUSEDCONFbits.id == (ID2_tmp & maskIDExtendedFMS))) {
            generate_canbus_sleep_message ( 2 );            
            TOTALFUELUSEDbits.value1    = CAN2_DATA_buf[4];
            TOTALFUELUSEDbits.value2    = CAN2_DATA_buf[5];
            TOTALFUELUSEDbits.value3    = CAN2_DATA_buf[6];
            TOTALFUELUSEDbits.value4    = CAN2_DATA_buf[7];
            fmsData.totalFuelUsedValue1 = TOTALFUELUSEDbits.value1;
            fmsData.totalFuelUsedValue2 = TOTALFUELUSEDbits.value2;
            fmsData.totalFuelUsedValue3 = TOTALFUELUSEDbits.value3;
            fmsData.totalFuelUsedValue4 = TOTALFUELUSEDbits.value4;                      
        }              
    }

// High Resolution Total Vehicle Distance - Общий пробег
    if (TOTALVEHICLEDISTANCECONFbits.can_number != 0) { 
        if (TOTALVEHICLEDISTANCECONFbits.can_number == 1 && 
                (TOTALVEHICLEDISTANCECONFbits.id == (ID_tmp & maskIDExtendedFMS))) {
            generate_canbus_sleep_message ( 1 );
            //if ((CAN1_DATA_buf[4] == 0x80) && (CAN1_DATA_buf[5] == 0x31) && (CAN1_DATA_buf[6] == 0x03) && // ????
            //        (CAN1_DATA_buf[7] == 0x00)) {
                TOTALVEHICLEDISTANCEbits.value1     = CAN1_DATA_buf[0];
                TOTALVEHICLEDISTANCEbits.value2     = CAN1_DATA_buf[1];
                TOTALVEHICLEDISTANCEbits.value3     = CAN1_DATA_buf[2];
                TOTALVEHICLEDISTANCEbits.value4     = CAN1_DATA_buf[3];
                fmsData.totalVehicleDistanceValue1  = TOTALVEHICLEDISTANCEbits.value1; 
                fmsData.totalVehicleDistanceValue2  = TOTALVEHICLEDISTANCEbits.value2;
                fmsData.totalVehicleDistanceValue3  = TOTALVEHICLEDISTANCEbits.value3;
                fmsData.totalVehicleDistanceValue4  = TOTALVEHICLEDISTANCEbits.value4;
            //}           
        }
        if (TOTALVEHICLEDISTANCECONFbits.can_number == 2 && 
                (TOTALVEHICLEDISTANCECONFbits.id == (ID2_tmp & maskIDExtendedFMS))) {
            generate_canbus_sleep_message ( 2 );            
            TOTALVEHICLEDISTANCEbits.value1     = CAN2_DATA_buf[0];
            TOTALVEHICLEDISTANCEbits.value2     = CAN2_DATA_buf[1];
            TOTALVEHICLEDISTANCEbits.value3     = CAN2_DATA_buf[2];
            TOTALVEHICLEDISTANCEbits.value4     = CAN2_DATA_buf[3];
            fmsData.totalVehicleDistanceValue1  = TOTALVEHICLEDISTANCEbits.value1; 
            fmsData.totalVehicleDistanceValue2  = TOTALVEHICLEDISTANCEbits.value2;
            fmsData.totalVehicleDistanceValue3  = TOTALVEHICLEDISTANCEbits.value3;
            fmsData.totalVehicleDistanceValue4  = TOTALVEHICLEDISTANCEbits.value4;                      
        }               
    }

// Total Engine Hours - Общее количество моточасов
    if (ENGINETOTALHOURSCONFbits.can_number != 0) { 
        if (ENGINETOTALHOURSCONFbits.can_number == 1 && 
                (ENGINETOTALHOURSCONFbits.id == (ID_tmp & maskIDExtendedFMS))) {
            generate_canbus_sleep_message ( 1 );
            //if ((CAN1_DATA_buf[4] == 0x02) && (CAN1_DATA_buf[5] == 0x0C) && (CAN1_DATA_buf[6] == 0x00) && // ????
            //        (CAN1_DATA_buf[7] == 0x00)) {
                ENGINETOTALHOURSbits.value1     = CAN1_DATA_buf[0];
                ENGINETOTALHOURSbits.value2     = CAN1_DATA_buf[1];
                ENGINETOTALHOURSbits.value3     = CAN1_DATA_buf[2];
                ENGINETOTALHOURSbits.value4     = CAN1_DATA_buf[3];
                fmsData.engineTotalHoursValue1  = ENGINETOTALHOURSbits.value1;
                fmsData.engineTotalHoursValue2  = ENGINETOTALHOURSbits.value2;
                fmsData.engineTotalHoursValue3  = ENGINETOTALHOURSbits.value3;
                fmsData.engineTotalHoursValue4  = ENGINETOTALHOURSbits.value4;
            //}  
            
        }
        
        if (ENGINETOTALHOURSCONFbits.can_number == 2 && 
                (ENGINETOTALHOURSCONFbits.id == (ID2_tmp & maskIDExtendedFMS))) {
            generate_canbus_sleep_message ( 2 );            
            ENGINETOTALHOURSbits.value1     = CAN2_DATA_buf[0];
            ENGINETOTALHOURSbits.value2     = CAN2_DATA_buf[1];
            ENGINETOTALHOURSbits.value3     = CAN2_DATA_buf[2];
            ENGINETOTALHOURSbits.value4     = CAN2_DATA_buf[3];
            fmsData.engineTotalHoursValue1  = ENGINETOTALHOURSbits.value1;
            fmsData.engineTotalHoursValue2  = ENGINETOTALHOURSbits.value2;
            fmsData.engineTotalHoursValue3  = ENGINETOTALHOURSbits.value3;
            fmsData.engineTotalHoursValue4  = ENGINETOTALHOURSbits.value4;                        
        }               
    }

// Engine Coolant Temperature - Температура охлаждающей жидкости
    if ( EGINECOOLANTTEMPERATUREbits.can_number != 0) { 
        if (EGINECOOLANTTEMPERATUREbits.can_number == 1 && 
                (EGINECOOLANTTEMPERATUREbits.id == (ID_tmp & maskIDExtendedFMS))) {
            generate_canbus_sleep_message ( 1 );
            //if ((CAN1_DATA_buf[1] == 0xFF) && (CAN1_DATA_buf[2] == 0xFF) && (CAN1_DATA_buf[3] == 0xFF) && (CAN1_DATA_buf[4] == 0xFF) && 
            //        (CAN1_DATA_buf[5] == 0xFF) && (CAN1_DATA_buf[6] == 0xFF) && (CAN1_DATA_buf[7] == 0xFF)) {   // ?????
                EGINECOOLANTTEMPERATUREbits.value       = CAN1_DATA_buf[0];  
                fmsData.engineCoolantTemperatureValue   = EGINECOOLANTTEMPERATUREbits.value;
            //}  
            
        }
        if (EGINECOOLANTTEMPERATUREbits.can_number == 2 && 
                (EGINECOOLANTTEMPERATUREbits.id == (ID2_tmp & maskIDExtendedFMS))) {
            generate_canbus_sleep_message ( 2 );            
            EGINECOOLANTTEMPERATUREbits.value       = CAN2_DATA_buf[0];  
            fmsData.engineCoolantTemperatureValue   = EGINECOOLANTTEMPERATUREbits.value;                         
        }               
    }

// Service Distance - Пробег до ТО
    if (SERVICEDISTANCEbits.can_number != 0) { 
        if (SERVICEDISTANCEbits.can_number == 1 && 
                (SERVICEDISTANCEbits.id == (ID_tmp & maskIDExtendedFMS))) {
            generate_canbus_sleep_message ( 1 );
            //if ((CAN1_DATA_buf[0] == 0xFF) && (CAN1_DATA_buf[3] == 0xFF) && (CAN1_DATA_buf[4] == 0xFF) && 
            //        (CAN1_DATA_buf[5] == 0xFF) && (CAN1_DATA_buf[6] == 0xFF) && (CAN1_DATA_buf[7] == 0xFF)) {  
                SERVICEDISTANCEbits.value1      = CAN1_DATA_buf[1];
                SERVICEDISTANCEbits.value2      = CAN1_DATA_buf[2];
                fmsData.serviceDistanceValue1   = SERVICEDISTANCEbits.value1;
                fmsData.serviceDistanceValue2   = SERVICEDISTANCEbits.value2;
            //}             
        }
        if (SERVICEDISTANCEbits.can_number == 2 && 
                (SERVICEDISTANCEbits.id == (ID2_tmp & maskIDExtendedFMS))) {
            generate_canbus_sleep_message ( 2 );            
            SERVICEDISTANCEbits.value1      = CAN2_DATA_buf[1];
            SERVICEDISTANCEbits.value2      = CAN2_DATA_buf[2];
            fmsData.serviceDistanceValue1   = SERVICEDISTANCEbits.value1;
            fmsData.serviceDistanceValue2   = SERVICEDISTANCEbits.value2;                        
        }               
    }

// Engine Speed - Обороты двигателя
    if (ENGINESPEEDbits.can_number != 0) { 
        if (ENGINESPEEDbits.can_number == 1 && 
                (ENGINESPEEDbits.id == (ID_tmp & maskIDExtendedFMS))) {
            generate_canbus_sleep_message ( 1 );
            //if ((CAN1_DATA_buf[0] == 0xFF) && (CAN1_DATA_buf[1] == 0xFF) && (CAN1_DATA_buf[2] == 0xFF) &&
            //        (CAN1_DATA_buf[5] == 0xFF) && (CAN1_DATA_buf[6] == 0xFF) && (CAN1_DATA_buf[7] == 0xFF)) {  
                ENGINESPEEDbits.value1      = CAN1_DATA_buf[3];
                ENGINESPEEDbits.value2      = CAN1_DATA_buf[4];
                fmsData.engineSpeedValue1   = ENGINESPEEDbits.value1;
                fmsData.engineSpeedValue2   = ENGINESPEEDbits.value2;
            //}            
        }
        if (ENGINESPEEDbits.can_number == 2 && 
                (ENGINESPEEDbits.id == (ID2_tmp & maskIDExtendedFMS))) {
            generate_canbus_sleep_message ( 2 );             
            ENGINESPEEDbits.value1      = CAN2_DATA_buf[3];
            ENGINESPEEDbits.value2      = CAN2_DATA_buf[4];
            fmsData.engineSpeedValue1   = ENGINESPEEDbits.value1;
            fmsData.engineSpeedValue2   = ENGINESPEEDbits.value2;                        
        }                
    }

// Axle Weight - Нагрузка на оси 
    if (AXLEWEIGHTbits.can_number != 0) { 
        if (AXLEWEIGHTbits.can_number == 1 && 
                (AXLEWEIGHTbits.id == (ID_tmp & maskIDExtendedFMS))) {
            generate_canbus_sleep_message ( 1 );
            //if ((CAN1_DATA_buf[0] == 0xFF) && (CAN1_DATA_buf[3] == 0xFF) && (CAN1_DATA_buf[4] == 0xFF) && 
            //        (CAN1_DATA_buf[5] == 0xFF) && (CAN1_DATA_buf[6] == 0xFF) && (CAN1_DATA_buf[7] == 0xFF)) {  
                AXLEWEIGHTbits.value1       = CAN1_DATA_buf[1];
                AXLEWEIGHTbits.value2       = CAN1_DATA_buf[2];
                fmsData.axleWeightValue1    = AXLEWEIGHTbits.value1;
                fmsData.axleWeightValue2    = AXLEWEIGHTbits.value2;
            //}            
        }
        if (AXLEWEIGHTbits.can_number == 2 && 
                (AXLEWEIGHTbits.id == (ID2_tmp & maskIDExtendedFMS))) {
            generate_canbus_sleep_message ( 2 );              
            AXLEWEIGHTbits.value1       = CAN2_DATA_buf[1];
            AXLEWEIGHTbits.value2       = CAN2_DATA_buf[2];
            fmsData.axleWeightValue1    = AXLEWEIGHTbits.value1;
            fmsData.axleWeightValue2    = AXLEWEIGHTbits.value2;                        
        }                
    }

// Vehicle Speed - Скорость автомобиля
    if (VEHICLESPEEDbits.can_number != 0) { 
        if (VEHICLESPEEDbits.can_number == 1 && 
                (VEHICLESPEEDbits.id == (ID_tmp & maskIDExtendedFMS))) {
            generate_canbus_sleep_message ( 1 );
            //if ((CAN1_DATA_buf[0] == 0xFF) && (CAN1_DATA_buf[3] == 0xFF) && (CAN1_DATA_buf[4] == 0xFF) && 
            //        (CAN1_DATA_buf[5] == 0xFF) && (CAN1_DATA_buf[6] == 0xFF) && (CAN1_DATA_buf[7] == 0xFF)) {  
                VEHICLESPEEDbits.value1       = CAN1_DATA_buf[1];
                VEHICLESPEEDbits.value2       = CAN1_DATA_buf[2];
                fmsData.vehicleSpeedValue1    = VEHICLESPEEDbits.value1;
                fmsData.vehicleSpeedValue2    = VEHICLESPEEDbits.value2;
            //}            
        }
        if (VEHICLESPEEDbits.can_number == 2 && 
                (VEHICLESPEEDbits.id == (ID2_tmp & maskIDExtendedFMS))) {
            generate_canbus_sleep_message ( 2 );              
            VEHICLESPEEDbits.value1       = CAN2_DATA_buf[1];
            VEHICLESPEEDbits.value2       = CAN2_DATA_buf[2];
            fmsData.vehicleSpeedValue1    = VEHICLESPEEDbits.value1;
            fmsData.vehicleSpeedValue2    = VEHICLESPEEDbits.value2;                        
        }                
    }
// Vehicle Speed - Скорость автомобиля
    if (VEHICLEWEIGHTbits.can_number != 0) { 
        if (VEHICLEWEIGHTbits.can_number == 1 && 
                (VEHICLEWEIGHTbits.id == (ID_tmp & maskIDExtendedFMS))) {
            generate_canbus_sleep_message ( 1 );
            //if ((CAN1_DATA_buf[0] == 0xFF) && (CAN1_DATA_buf[1] == 0xFF) && (CAN1_DATA_buf[4] == 0xFF) && 
            //        (CAN1_DATA_buf[5] == 0xFF) && (CAN1_DATA_buf[6] == 0xFF) && (CAN1_DATA_buf[7] == 0xFF)) {  
                VEHICLEWEIGHTbits.value1    = CAN1_DATA_buf[2];
                VEHICLEWEIGHTbits.value2    = CAN1_DATA_buf[3];
                fmsData.vehicleWeightValue1 = VEHICLEWEIGHTbits.value1;
                fmsData.vehicleWeightValue2 = VEHICLEWEIGHTbits.value2;
            //}            
        }
        if (VEHICLEWEIGHTbits.can_number == 2 && 
                (VEHICLEWEIGHTbits.id == (ID2_tmp & maskIDExtendedFMS))) {
            generate_canbus_sleep_message ( 2 );              
            VEHICLEWEIGHTbits.value1    = CAN2_DATA_buf[2];
            VEHICLEWEIGHTbits.value2    = CAN2_DATA_buf[3];
            fmsData.vehicleWeightValue1 = VEHICLEWEIGHTbits.value1;
            fmsData.vehicleWeightValue2 = VEHICLEWEIGHTbits.value2;                        
        }                
    }
// Vehicle Identification
    if (vin.can_number != 0) { 
        if (vin.can_number == 1 && (vin.id == (ID_tmp & maskIDExtendedFMS))) {
            generate_canbus_sleep_message ( 1 );
            //if ((CAN1_DATA_buf[0] == 0xFF) && (CAN1_DATA_buf[1] == 0xFF) && (CAN1_DATA_buf[4] == 0xFF) && 
            //        (CAN1_DATA_buf[5] == 0xFF) && (CAN1_DATA_buf[6] == 0xFF) && (CAN1_DATA_buf[7] == 0xFF)) {  
                vin.Value[0] = CAN1_DATA_buf[1];
                vin.Value[1] = CAN1_DATA_buf[2];
                //fmsData.VIN[0] = vin.Value[0];
                //fmsData.vehicleWeightValue2 = vin.value2;
            //}            
        }
        if (vin.can_number == 2 && (vin.id == (ID2_tmp & maskIDExtendedFMS))) {
            generate_canbus_sleep_message ( 2 );  
            if ((CAN2_DATA_buf[0] == 0x01) && (CAN2_DATA_buf[1] >= 0x30) && (CAN2_DATA_buf[2] >= 0x30) && 
                    (CAN2_DATA_buf[3] >= 0x30) && (CAN2_DATA_buf[4] >= 0x30) && (CAN2_DATA_buf[5] >= 0x30) &&
                    (CAN2_DATA_buf[6] >= 0x30) && (CAN2_DATA_buf[7] >= 0x30)){
                vin.Value[0]    = CAN2_DATA_buf[1];
                vin.Value[1]    = CAN2_DATA_buf[2];
                vin.Value[2]    = CAN2_DATA_buf[3];
                vin.Value[3]    = CAN2_DATA_buf[4];
                vin.Value[4]    = CAN2_DATA_buf[5];
                vin.Value[5]    = CAN2_DATA_buf[6];
                vin.Value[6]    = CAN2_DATA_buf[7];
                fmsData.VIN[0]  = vin.Value[0];
                fmsData.VIN[1]  = vin.Value[1];
                fmsData.VIN[2]  = vin.Value[2];
                fmsData.VIN[3]  = vin.Value[3];
                fmsData.VIN[4]  = vin.Value[4];
                fmsData.VIN[5]  = vin.Value[5];
                fmsData.VIN[6]  = vin.Value[6];
            }
            else if ((CAN2_DATA_buf[0] == 0x02) && (CAN2_DATA_buf[1] >= 0x30) && (CAN2_DATA_buf[2] >= 0x30) && 
                    (CAN2_DATA_buf[3] >= 0x30) && (CAN2_DATA_buf[4] >= 0x30) && (CAN2_DATA_buf[5] >= 0x30) &&
                    (CAN2_DATA_buf[6] >= 0x30) && (CAN2_DATA_buf[7] >= 0x30)){
                vin.Value[7]    = CAN2_DATA_buf[1];
                vin.Value[8]    = CAN2_DATA_buf[2];
                vin.Value[9]    = CAN2_DATA_buf[3];
                vin.Value[10]   = CAN2_DATA_buf[4];
                vin.Value[11]   = CAN2_DATA_buf[5];
                vin.Value[12]   = CAN2_DATA_buf[6];
                vin.Value[13]   = CAN2_DATA_buf[7];
                fmsData.VIN[7]  = vin.Value[7];
                fmsData.VIN[8]  = vin.Value[8];
                fmsData.VIN[9]  = vin.Value[9];
                fmsData.VIN[10] = vin.Value[10];
                fmsData.VIN[11] = vin.Value[11];
                fmsData.VIN[12] = vin.Value[12];
                fmsData.VIN[13] = vin.Value[13]; 
            }  
            else if ((CAN2_DATA_buf[0] == 0x03) && (CAN2_DATA_buf[1] >= 0x30) && (CAN2_DATA_buf[2] >= 0x30) && 
                    (CAN2_DATA_buf[3] >= 0x30) && (CAN2_DATA_buf[4] == '*') && (CAN2_DATA_buf[5] == 0xFF) &&
                    (CAN2_DATA_buf[6] == 0xFF) && (CAN2_DATA_buf[7] == 0xFF)){
                vin.Value[14]   = CAN2_DATA_buf[1];
                vin.Value[15]   = CAN2_DATA_buf[2];
                vin.Value[16]   = CAN2_DATA_buf[3];            
                fmsData.VIN[14] = vin.Value[14];
                fmsData.VIN[15] = vin.Value[15];
                fmsData.VIN[16] = vin.Value[16];                 
            }
        }                
    }
#endif
}
void send_boot_lock_status (void) {

    if (boot_lock_status == 0) {// открыт
        generate_content_of_message ( 61, 1 );
    }
    else { // закрыт
        generate_content_of_message ( 62, 1 );
    }
    
}
void send_alarm2_status (void) {
        
    generate_content_of_message ( 55, 1 );
    
}
void send_lock_status (void) {

    lock_status_changed = 1;
    
    if (lock_status == 0) {// открыт
        generate_content_of_message ( 35, 1 );
        TOYOTAKEYTMPbuf[0] = TOYOTAKEYbuf[TOYOTA_R_ptr][0];TOYOTAKEYTMPbuf[1] = TOYOTAKEYbuf[TOYOTA_R_ptr][1];
        TOYOTAKEYTMPbuf[2] = TOYOTAKEYbuf[TOYOTA_R_ptr][2];TOYOTAKEYTMPbuf[3] = TOYOTAKEYbuf[TOYOTA_R_ptr][3];
        TOYOTAKEYTMPbuf[4] = TOYOTAKEYbuf[TOYOTA_R_ptr][4];TOYOTAKEYTMPbuf[5] = TOYOTAKEYbuf[TOYOTA_R_ptr][5];
        TOYOTAKEYTMPbuf[6] = TOYOTAKEYbuf[TOYOTA_R_ptr][6];TOYOTAKEYTMPbuf[7] = TOYOTAKEYbuf[TOYOTA_R_ptr][7];
//        TOYOTA_R_ptr = TOYOTA_W_ptr + 1; TOYOTA_R_ptr = TOYOTA_R_ptr % 3;
    }
    else { // закрыт
        generate_content_of_message ( 36, 1 );
    }
    
}
void send_webasto_status (void) {

    if (webasto_status == 0) {// запущено
        generate_content_of_message ( 51, 1 );
    }
    else { // остановлено
        generate_content_of_message ( 52, 1 );
    }
    
}
void send_lock_comand_status (unsigned char command) {

    if (command == 1) {
/*        
        reload_GPRS_header ( 3, 43, 0x0011); // N = 3, name = 36, type = 1, ACK = 1
        memmove ( command_temp_buf, GPRS_header_buf, 12 );
        unsigned int ACK_counter = 0xFFFF;
        command_temp_buf[12] = (unsigned char) (ACK_counter >> 8); command_temp_buf[13] = (unsigned char) ACK_counter; // ACK
        command_temp_buf[14] = 0xFF; command_temp_buf[15] = 0x01; // Dataflags
        memmove  ( &command_temp_buf[16], Navi_bin, 22 );
        command_temp_buf[113] = 38; //38
        write_data_into_save_to_flash_bufs ( command_temp_buf, 38 ); 
*/        
        generate_content_of_message ( 43, 1 );
    }
    else {
/*        
        reload_GPRS_header ( 3, 44, 0x0011); // N = 3, name = 36, type = 1, ACK = 1
        memmove ( command_temp_buf, GPRS_header_buf, 12 );
        unsigned int ACK_counter = 0xFFFF;
        command_temp_buf[12] = (unsigned char) (ACK_counter >> 8); command_temp_buf[13] = (unsigned char) ACK_counter; // ACK
        command_temp_buf[14] = 0xFF; command_temp_buf[15] = 0x01; // Dataflags
        memmove  ( &command_temp_buf[16], Navi_bin, 22 );
        command_temp_buf[113] = 38; //38
        write_data_into_save_to_flash_bufs ( command_temp_buf, 38 );
*/
        generate_content_of_message ( 44, 1 );
    }
    
}

void check_perimeter_state_change (void) {
    
    if (CANDOORSbits.CANDOORS == CANDOORSTMPbits.CANDOORSTMP) return;

    doors_status_changed = 1;
    
    if (ARMFLAGSbits.arm_status == 1) {
        if (INTRREASONbits.INTRREASON == 0) {
            if ((CANDOORSbits.dd  != CANDOORSTMPbits.dd)  &&(CANDOORSbits.dd  == 0)) {ARMFLAGSbits.intr_event_trigg = 1; INTRREASONbits.dd  = 1;}
            if ((CANDOORSbits.fpd != CANDOORSTMPbits.fpd) &&(CANDOORSbits.fpd == 0)) {ARMFLAGSbits.intr_event_trigg = 1; INTRREASONbits.fpd = 1;}
            if ((CANDOORSbits.lrd != CANDOORSTMPbits.lrd) &&(CANDOORSbits.lrd == 0)) {ARMFLAGSbits.intr_event_trigg = 1; INTRREASONbits.lrd = 1;}
            if ((CANDOORSbits.rrd != CANDOORSTMPbits.rrd) &&(CANDOORSbits.rrd == 0)) {ARMFLAGSbits.intr_event_trigg = 1; INTRREASONbits.rrd = 1;}
            if ((CANDOORSbits.bt  != CANDOORSTMPbits.bt)  &&(CANDOORSbits.bt  == 0)) {ARMFLAGSbits.intr_event_trigg = 1; INTRREASONbits.bt  = 1;}
            if ((CANDOORSbits.bn  != CANDOORSTMPbits.bn)  &&(CANDOORSbits.bn  == 0)) {ARMFLAGSbits.intr_event_trigg = 1; INTRREASONbits.bn  = 1;}
        }
 // Запрет вторжения по водительской двери после окончания автозапуска        
        if ( dd_intrusion_off_timer > 0 || intrusion_off_by_input_flag == 1 || door_open_autorun_flag == 1 ) {
            ARMFLAGSbits.intr_event_trigg = 0;
            INTRREASONbits.dd  = 0;
            INTRREASONbits.fpd = 0;
            INTRREASONbits.lrd = 0;
            INTRREASONbits.rrd = 0;
            INTRREASONbits.bt  = 0;
            INTRREASONbits.bn  = 0;            
        }
        
        if (ARMFLAGSbits.intr_event_trigg != 0) {
            if ( STARTENGINEbits.start == 1 || STARTENGINESbits.start == 1 || STARTENGINEDLbits.start == 1 || STARTENGINEPbits.start == 1 ) {
                doors_intr_autorun_flag = 1;
            }
        }
    }
    
    CANDOORSTMPbits.CANDOORSTMP = CANDOORSbits.CANDOORS;
    
}
char get_nibble_from_str ( char *nibble_ptr ) {

    if ((*nibble_ptr >= 0x30)&&(*nibble_ptr <= 0x39)) {   return (*nibble_ptr - 0x30); } 
    else {
        if ((*nibble_ptr == 'A') || (*nibble_ptr == 'a')) return 10;
        if ((*nibble_ptr == 'B') || (*nibble_ptr == 'b')) return 11;
        if ((*nibble_ptr == 'C') || (*nibble_ptr == 'c')) return 12;
        if ((*nibble_ptr == 'D') || (*nibble_ptr == 'd')) return 13;
        if ((*nibble_ptr == 'E') || (*nibble_ptr == 'e')) return 14;
        if ((*nibble_ptr == 'F') || (*nibble_ptr == 'f')) return 15;
    }
    
return -1;
    
}
int  apply_can_settings( char *ptr ) {
    
char param, temp, number_of_can, number_of_filter;//, number_of_byte, bit_mask;
unsigned long id; unsigned int exide;
long temp2;
int temp1;
    param = 0;
    
    if (*(ptr + 4) != '=') return 0;

// Номер параметра    
    temp = get_nibble_from_str ( ptr + 5 );
    if (temp == -1) return 0;
    param = temp;
    temp = get_nibble_from_str ( ptr + 6 );
    if (temp == -1) return 0;
    param = (param << 4) + temp;
    
//    if (param > 15) return 0;

// Номер кана
    number_of_can = 0; temp = 0;
    temp = get_nibble_from_str ( ptr + 8 );
    if (temp == -1) return 0;
    number_of_can = temp;
    if (number_of_can > 2) return 0;
    
// Номер фильтра
    number_of_filter = 0; temp = 0;
    temp = get_nibble_from_str ( ptr + 10 );
    if (temp == -1) return 0;
    number_of_filter = temp;
    if (number_of_filter > 15) return 0;

// ID    
    id = 0; temp = 0;
    temp = get_nibble_from_str ( ptr + 12 );
    if (temp == -1) return 0;
    id = temp;
    temp = get_nibble_from_str ( ptr + 13 );
    if (temp == -1) return 0;
    id = (id << 4) + temp;
    temp = get_nibble_from_str ( ptr + 14 );
    if (temp == -1) return 0;
    id = (id << 4) + temp;
    temp = get_nibble_from_str ( ptr + 15 );
    if (temp == -1) return 0;
    id = (id << 4) + temp;
    temp = get_nibble_from_str ( ptr + 16 );
    if (temp == -1) return 0;
    id = (id << 4) + temp;
    temp = get_nibble_from_str ( ptr + 17 );
    if (temp == -1) return 0;
    id = (id << 4) + temp;
    temp = get_nibble_from_str ( ptr + 18 );
    if (temp == -1) return 0;
    id = (id << 4) + temp;
    temp = get_nibble_from_str ( ptr + 19 );
    if (temp == -1) return 0;
    id = (id << 4) + temp;
/*    
//Ignition
// вод дверь 
// прав передн дверь
// лев задн дверь
// прав задн дверь
// багажник
// капот
// пробег
// топливо
*/    
// Зажигание 
    if (param == 0) {
        Nop();Nop();Nop();
        CANIGNPRMSbits.can_number = number_of_can;
        CANIGNPRMSbits.filt_number = number_of_filter;
        CANIGNPRMSbits.id = id;
        CANIGNPRMSbits.byte = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        CANIGNPRMSbits.byte = temp;
        CANIGNPRMSbits.bit_mask = 0;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        CANIGNPRMSbits.bit_mask = temp;
        temp = get_nibble_from_str ( ptr + 24 ); if (temp == -1) return 0;
        CANIGNPRMSbits.bit_mask = (CANIGNPRMSbits.bit_mask << 4) + temp;
        CANIGNPRMSbits.inv = 0;
        temp = get_nibble_from_str ( ptr + 26 ); if (temp == -1) return 0; 
        CANIGNPRMSbits.inv = temp;
        
        if (CANIGNPRMSbits.can_number !=0) CANIGNPRMS2bits.can_number = 0; // Отключение второго типа, если настроен первый
        
        if (number_of_can == 1) {exide = CAN1SETTINGSbits.ide;} else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)CANIGNPRMSbits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)CANIGNPRMSbits.id, (unsigned int)exide, 15, 0);
        FM25_write_8( 516, (unsigned long long) CANIGNPRMSbits.CANIGNPRMS );
        FM25_write_8( 612, (unsigned long long) CANIGNPRMS2bits.CANIGNPRMS2 );
    }
        Nop();Nop();Nop();
// Дверь водителя
    if (param == 1) {
        Nop();Nop();Nop();
        CANDDPRMSbits.can_number = number_of_can;
        CANDDPRMSbits.filt_number = number_of_filter;
        CANDDPRMSbits.id = id;
        CANDDPRMSbits.byte = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        CANDDPRMSbits.byte = temp;
        CANDDPRMSbits.bit_mask = 0;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        CANDDPRMSbits.bit_mask = temp;
        temp = get_nibble_from_str ( ptr + 24 ); if (temp == -1) return 0;
        CANDDPRMSbits.bit_mask = (CANDDPRMSbits.bit_mask << 4) + temp;
        CANDDPRMSbits.inv = 0;
        temp = get_nibble_from_str ( ptr + 26 ); if (temp == -1) return 0; 
        CANDDPRMSbits.inv = temp;
        if (number_of_can == 1) exide = CAN1SETTINGSbits.ide; else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)CANDDPRMSbits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)CANDDPRMSbits.id, (unsigned int)exide, 15, 0);
        FM25_write_8( 524, (unsigned long long) CANDDPRMSbits.CANDDPRMS );
    }
// Правая пассажирская дверь
    if (param == 2) {
        Nop();Nop();Nop();
        CANFPDPRMSbits.can_number = number_of_can;
        CANFPDPRMSbits.filt_number = number_of_filter;
        CANFPDPRMSbits.id = id;
        CANFPDPRMSbits.byte = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        CANFPDPRMSbits.byte = temp;
        CANFPDPRMSbits.bit_mask = 0;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        CANFPDPRMSbits.bit_mask = temp;
        temp = get_nibble_from_str ( ptr + 24 ); if (temp == -1) return 0;
        CANFPDPRMSbits.bit_mask = (CANFPDPRMSbits.bit_mask << 4) + temp;
        CANFPDPRMSbits.inv = 0;
        temp = get_nibble_from_str ( ptr + 26 ); if (temp == -1) return 0; 
        CANFPDPRMSbits.inv = temp;
        if (number_of_can == 1) exide = CAN1SETTINGSbits.ide; else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1)ecan1WriteRxAcptFilter( (int)number_of_filter,(long)CANFPDPRMSbits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2)ecan2WriteRxAcptFilter( (int)number_of_filter,(long)CANFPDPRMSbits.id, (unsigned int)exide, 15, 0);
        FM25_write_8( 532, (unsigned long long) CANFPDPRMSbits.CANFPDPRMS );
    }
// Левая задняя дверь
    if (param == 3) {
        Nop();Nop();Nop();
        CANRLDPRMSbits.can_number = number_of_can;
        CANRLDPRMSbits.filt_number = number_of_filter;
        CANRLDPRMSbits.id = id;
        CANRLDPRMSbits.byte = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        CANRLDPRMSbits.byte = temp;
        CANRLDPRMSbits.bit_mask = 0;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        CANRLDPRMSbits.bit_mask = temp;
        temp = get_nibble_from_str ( ptr + 24 ); if (temp == -1) return 0;
        CANRLDPRMSbits.bit_mask = (CANRLDPRMSbits.bit_mask << 4) + temp;
        CANRLDPRMSbits.inv = 0;
        temp = get_nibble_from_str ( ptr + 26 ); if (temp == -1) return 0; 
        CANRLDPRMSbits.inv = temp;
        if (number_of_can == 1) exide = CAN1SETTINGSbits.ide; else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)CANRLDPRMSbits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)CANRLDPRMSbits.id, (unsigned int)exide, 15, 0);
        FM25_write_8( 540, (unsigned long long) CANRLDPRMSbits.CANRLDPRMS );
    }
// Правая задняя дверь
    if (param == 4) {
        Nop();Nop();Nop();
        CANRRDPRMSbits.can_number = number_of_can;
        CANRRDPRMSbits.filt_number = number_of_filter;
        CANRRDPRMSbits.id = id;
        CANRRDPRMSbits.byte = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        CANRRDPRMSbits.byte = temp;
        CANRRDPRMSbits.bit_mask = 0;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        CANRRDPRMSbits.bit_mask = temp;
        temp = get_nibble_from_str ( ptr + 24 ); if (temp == -1) return 0;
        CANRRDPRMSbits.bit_mask = (CANRRDPRMSbits.bit_mask << 4) + temp;
        CANRRDPRMSbits.inv = 0;
        temp = get_nibble_from_str ( ptr + 26 ); if (temp == -1) return 0; 
        CANRRDPRMSbits.inv = temp;
        if (number_of_can == 1) exide = CAN1SETTINGSbits.ide; else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)CANRRDPRMSbits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)CANRRDPRMSbits.id, (unsigned int)exide, 15, 0);
        FM25_write_8( 548, (unsigned long long) CANRRDPRMSbits.CANRRDPRMS );
    }
// Багажник
    if (param == 5) {
        Nop();Nop();Nop();
        CANBNPRMSbits.can_number = number_of_can;
        CANBNPRMSbits.filt_number = number_of_filter;
        CANBNPRMSbits.id = id;
        CANBNPRMSbits.byte = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        CANBNPRMSbits.byte = temp;
        CANBNPRMSbits.bit_mask = 0;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        CANBNPRMSbits.bit_mask = temp;
        temp = get_nibble_from_str ( ptr + 24 ); if (temp == -1) return 0;
        CANBNPRMSbits.bit_mask = (CANBNPRMSbits.bit_mask << 4) + temp;
        CANBNPRMSbits.inv = 0;
        temp = get_nibble_from_str ( ptr + 26 ); if (temp == -1) return 0; 
        CANBNPRMSbits.inv = temp;
        if (number_of_can == 1) exide = CAN1SETTINGSbits.ide; else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)CANBNPRMSbits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)CANBNPRMSbits.id, (unsigned int)exide, 15, 0);
        FM25_write_8( 556, (unsigned long long) CANBNPRMSbits.CANBNPRMS );// багажник
    }
// Капот        
    if (param == 6) {
        Nop();Nop();Nop();
        CANBTPRMSbits.can_number = number_of_can;
        CANBTPRMSbits.filt_number = number_of_filter;
        CANBTPRMSbits.id = id;
        CANBTPRMSbits.byte = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        CANBTPRMSbits.byte = temp;
        CANBTPRMSbits.bit_mask = 0;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        CANBTPRMSbits.bit_mask = temp;
        temp = get_nibble_from_str ( ptr + 24 ); if (temp == -1) return 0;
        CANBTPRMSbits.bit_mask = (CANBTPRMSbits.bit_mask << 4) + temp;
        CANBTPRMSbits.inv = 0;
        temp = get_nibble_from_str ( ptr + 26 ); if (temp == -1) return 0; 
        CANBTPRMSbits.inv = temp;
        if (number_of_can == 1) exide = CAN1SETTINGSbits.ide; else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)CANBTPRMSbits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)CANBTPRMSbits.id, (unsigned int)exide, 15, 0);
        FM25_write_8( 564, (unsigned long long) CANBTPRMSbits.CANBTPRMS );
    }
// Ремень безопасности        
    if (param == 7) {
        Nop();Nop();Nop();
        CANBELTPRMSbits.can_number = number_of_can;
        CANBELTPRMSbits.filt_number = number_of_filter;
        CANBELTPRMSbits.id = id;
        CANBELTPRMSbits.byte = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        CANBELTPRMSbits.byte = temp;
        CANBELTPRMSbits.bit_mask = 0;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        CANBELTPRMSbits.bit_mask = temp;
        temp = get_nibble_from_str ( ptr + 24 ); if (temp == -1) return 0;
        CANBELTPRMSbits.bit_mask = (CANBELTPRMSbits.bit_mask << 4) + temp;
        CANBELTPRMSbits.inv = 0;
        temp = get_nibble_from_str ( ptr + 26 ); if (temp == -1) return 0; 
        CANBELTPRMSbits.inv = temp;
        if (number_of_can == 1) exide = CAN1SETTINGSbits.ide; else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)CANBELTPRMSbits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)CANBELTPRMSbits.id, (unsigned int)exide, 15, 0);        
        FM25_write_8( 588, (unsigned long long) CANBELTPRMSbits.CANBELTPRMS );
    }
// Пробег        
    if (param == 8) {
        Nop();Nop();Nop();
        if (*(ptr + 41) != ';') return 0;
        CANODOPRMSbits.can_number = number_of_can;
        CANODOPRMSbits.filt_number = number_of_filter;
        CANODOPRMSbits.id = id;
        CANODOPRMSbits.byte0 = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        CANODOPRMSbits.byte0 = temp;
        CANODOPRMSbits.byte1 = 0;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        CANODOPRMSbits.byte1 = temp;
        CANODOPRMSbits.byte2 = 0;
        temp = get_nibble_from_str ( ptr + 25 ); if (temp == -1) return 0;
        CANODOPRMSbits.byte2 = temp;
        
        temp = get_nibble_from_str ( ptr + 27 ); if (temp == -1) return 0;
        CANODOCHECKBYTESbits.num1 = temp;
        temp = get_nibble_from_str ( ptr + 29 ); if (temp == -1) return 0;
        CANODOCHECKBYTESbits.num2 = temp;
        temp = get_nibble_from_str ( ptr + 31 ); if (temp == -1) return 0;
        CANODOCHECKBYTESbits.num3 = temp;
        temp1 = convert_str_to_hex ( ptr + 33, 2 ); if (temp1 == -1) return 0;
        CANODOCHECKBYTESbits.byte1 = temp1;
        temp1 = convert_str_to_hex ( ptr + 36, 2 ); if (temp1 == -1) return 0;
        CANODOCHECKBYTESbits.byte2 = temp1;        
        temp1 = convert_str_to_hex ( ptr + 39, 2 ); if (temp1 == -1) return 0;
        CANODOCHECKBYTESbits.byte3 = temp1;
        
        FM25_write_5 ( 943, (unsigned long long) CANODOCHECKBYTESbits.CANODOCHECKBYTES );
        
        if (number_of_can == 1) exide = CAN1SETTINGSbits.ide; else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)CANODOPRMSbits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)CANODOPRMSbits.id, (unsigned int)exide, 15, 0);
        FM25_write_8( 572, (unsigned long long) CANODOPRMSbits.CANODOPRMS );
    }
// Топливо        
    if (param == 9) {
        Nop();Nop();Nop();
        CANFLPRMSbits.can_number = number_of_can;
        CANFLPRMSbits.filt_number = number_of_filter;
        CANFLPRMSbits.id = id;
        CANFLPRMSbits.byte0 = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        CANFLPRMSbits.byte0 = temp;
        
        CANFLPRMSbits.cntrl_byte_number = 0;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        CANFLPRMSbits.cntrl_byte_number = (unsigned char)temp;
        
        CANFLPRMSbits.cntrl_byte = 0;
        temp = get_nibble_from_str ( ptr + 25 ); if (temp == -1) return 0;
        CANFLPRMSbits.cntrl_byte = (unsigned char)(temp << 4);        

        temp = get_nibble_from_str ( ptr + 26 ); if (temp == -1) return 0;
        CANFLPRMSbits.cntrl_byte = CANFLPRMSbits.cntrl_byte + (unsigned char)temp;
        
        if (number_of_can == 1) exide = CAN1SETTINGSbits.ide; else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)CANFLPRMSbits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)CANFLPRMSbits.id, (unsigned int)exide, 15, 0);
        FM25_write_8( 580, (unsigned long long) CANFLPRMSbits.CANFLPRMS );
    }
// Замки дверей        
    if (param == 10) {
        Nop();Nop();Nop();
        LOCKSTATPRMSbits.can_number = number_of_can;
        LOCKSTATPRMSbits.filt_number = number_of_filter;
        LOCKSTATPRMSbits.id = id;
        LOCKSTATPRMSbits.byte = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        LOCKSTATPRMSbits.byte = temp;
        LOCKSTATPRMSbits.bit_mask = 0;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        LOCKSTATPRMSbits.bit_mask = temp;
        temp = get_nibble_from_str ( ptr + 24 ); if (temp == -1) return 0;
        LOCKSTATPRMSbits.bit_mask = (LOCKSTATPRMSbits.bit_mask << 4) + temp;
        LOCKSTATPRMSbits.inv = 0;
        temp = get_nibble_from_str ( ptr + 26 ); if (temp == -1) return 0; 
        LOCKSTATPRMSbits.inv = temp;
        
        if (LOCKSTATPRMSbits.can_number != 0) {LOCKSTATPRMS3bits.can_number = 0; LOCKSTATPRMS2bits.can_number = 0;}
        
        if (number_of_can == 1) exide = CAN1SETTINGSbits.ide; else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)LOCKSTATPRMSbits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)LOCKSTATPRMSbits.id, (unsigned int)exide, 15, 0);        

        FM25_write_8( 652, (unsigned long long) LOCKSTATPRMS3bits.LOCKSTATPRMS3 );// Замки тип3
        FM25_write_8( 604, (unsigned long long) LOCKSTATPRMS2bits.LOCKSTATPRMS2 ); // Замки тип 2
        FM25_write_8( 596, (unsigned long long) LOCKSTATPRMSbits.LOCKSTATPRMS ); // Замки тип 1
        
    }
// Замки дверей тип 2        
    if (param == 11) { // 
        Nop();Nop();Nop();
        LOCKSTATPRMS2bits.can_number  = number_of_can;
        LOCKSTATPRMS2bits.filt_number = number_of_filter;
        LOCKSTATPRMS2bits.id = id;
        LOCKSTATPRMS2bits.byte = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        LOCKSTATPRMS2bits.byte = temp;
        LOCKSTATPRMS2bits.bit_mask = 0;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        LOCKSTATPRMS2bits.bit_mask = temp;
        temp = get_nibble_from_str ( ptr + 24 ); if (temp == -1) return 0;
        LOCKSTATPRMS2bits.bit_mask = (LOCKSTATPRMS2bits.bit_mask << 4) + temp;
        LOCKSTATPRMS2bits.value1 = 0;
        temp = get_nibble_from_str ( ptr + 26 ); if (temp == -1) return 0; 
        LOCKSTATPRMS2bits.value1 = temp;
        temp = get_nibble_from_str ( ptr + 27 ); if (temp == -1) return 0;
        LOCKSTATPRMS2bits.value1 = (LOCKSTATPRMS2bits.value1 << 4) + temp;
        LOCKSTATPRMS2bits.value2 = 0;
        temp = get_nibble_from_str ( ptr + 29 ); if (temp == -1) return 0; 
        LOCKSTATPRMS2bits.value2 = temp;
        temp = get_nibble_from_str ( ptr + 30 ); if (temp == -1) return 0;
        LOCKSTATPRMS2bits.value2 = (LOCKSTATPRMS2bits.value2 << 4) + temp; 
        
        if (LOCKSTATPRMS2bits.can_number != 0) {LOCKSTATPRMS3bits.can_number = 0; LOCKSTATPRMSbits.can_number = 0;} // Отключение первого типа, если настроен второй
        
        if (number_of_can == 1) exide = CAN1SETTINGSbits.ide; else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)LOCKSTATPRMS2bits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)LOCKSTATPRMS2bits.id, (unsigned int)exide, 15, 0);

        FM25_write_8( 652, (unsigned long long) LOCKSTATPRMS3bits.LOCKSTATPRMS3 );// Замки тип3
        FM25_write_8( 604, (unsigned long long) LOCKSTATPRMS2bits.LOCKSTATPRMS2 ); // Замки тип 2
        FM25_write_8( 596, (unsigned long long) LOCKSTATPRMSbits.LOCKSTATPRMS ); // Замки тип 1
   

    }        
/*
//unsigned char can_number:2;
//unsigned char filt_number:4;
//unsigned char byte:3;        
//unsigned char bit_mask:8;        
//unsigned char value1:8;
//unsigned char value2:8;
//unsigned long id:29;
 */        
// Зажигание тип 2 
    if (param == 0x0C) {
        Nop();Nop();Nop();
        CANIGNPRMS2bits.can_number = number_of_can;
        CANIGNPRMS2bits.filt_number = number_of_filter;
        CANIGNPRMS2bits.id = id;
        CANIGNPRMS2bits.byte = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        CANIGNPRMS2bits.byte = temp;
        CANIGNPRMS2bits.bit_mask = 0;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        CANIGNPRMS2bits.bit_mask = temp;
        temp = get_nibble_from_str ( ptr + 24 ); if (temp == -1) return 0;
        CANIGNPRMS2bits.bit_mask = (CANIGNPRMS2bits.bit_mask << 4) + temp;

        CANIGNPRMS2bits.value1 = 0;
        temp = get_nibble_from_str ( ptr + 26 ); if (temp == -1) return 0; 
        CANIGNPRMS2bits.value1 = temp;
        temp = get_nibble_from_str ( ptr + 27 ); if (temp == -1) return 0;
        CANIGNPRMS2bits.value1 = (CANIGNPRMS2bits.value1 << 4) + temp; 
        CANIGNPRMS2bits.value2 = 0;
        temp = get_nibble_from_str ( ptr + 29 ); if (temp == -1) return 0; 
        CANIGNPRMS2bits.value2 = temp;
        temp = get_nibble_from_str ( ptr + 30 ); if (temp == -1) return 0;
        CANIGNPRMS2bits.value2 = (CANIGNPRMS2bits.value2 << 4) + temp;        
        if (CANIGNPRMS2bits.can_number !=0) CANIGNPRMSbits.can_number = 0; // Отключение первого типа, если настроен второй
        if (number_of_can == 1) {exide = CAN1SETTINGSbits.ide;} else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)CANIGNPRMS2bits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)CANIGNPRMS2bits.id, (unsigned int)exide, 15, 0);

        FM25_write_8( 612, (unsigned long long) CANIGNPRMS2bits.CANIGNPRMS2 );// Зажигание тип2
        FM25_write_8( 516, (unsigned long long) CANIGNPRMSbits.CANIGNPRMS );
    }
// Статус двигателя тип 2 
    if (param == 0x0D) {
        Nop();Nop();Nop();
        ENJSTATUSPRMS2bits.can_number = number_of_can;
        ENJSTATUSPRMS2bits.filt_number = number_of_filter;
        ENJSTATUSPRMS2bits.id = id;
        ENJSTATUSPRMS2bits.byte = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        ENJSTATUSPRMS2bits.byte = temp;
        ENJSTATUSPRMS2bits.bit_mask = 0;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        ENJSTATUSPRMS2bits.bit_mask = temp;
        temp = get_nibble_from_str ( ptr + 24 ); if (temp == -1) return 0;
        ENJSTATUSPRMS2bits.bit_mask = (ENJSTATUSPRMS2bits.bit_mask << 4) + temp;

        ENJSTATUSPRMS2bits.value1 = 0;
        temp = get_nibble_from_str ( ptr + 26 ); if (temp == -1) return 0; 
        ENJSTATUSPRMS2bits.value1 = temp;
        temp = get_nibble_from_str ( ptr + 27 ); if (temp == -1) return 0;
        ENJSTATUSPRMS2bits.value1 = (ENJSTATUSPRMS2bits.value1 << 4) + temp; 
        ENJSTATUSPRMS2bits.value2 = 0;
        temp = get_nibble_from_str ( ptr + 29 ); if (temp == -1) return 0; 
        ENJSTATUSPRMS2bits.value2 = temp;
        temp = get_nibble_from_str ( ptr + 30 ); if (temp == -1) return 0;
        ENJSTATUSPRMS2bits.value2 = (ENJSTATUSPRMS2bits.value2 << 4) + temp;        
        if (number_of_can == 1) {exide = CAN1SETTINGSbits.ide;} else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)ENJSTATUSPRMS2bits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)ENJSTATUSPRMS2bits.id, (unsigned int)exide, 15, 0);

        FM25_write_8( 620, (unsigned long long) ENJSTATUSPRMS2bits.ENJSTATUSPRMS2 );// Статус двигателя тип2

    } 
        
// Статус WEBASTO       
    if (param == 0x0E) {
        Nop();Nop();Nop();
        WEBASTOSTATPRMSbits.can_number = number_of_can;
        WEBASTOSTATPRMSbits.filt_number = number_of_filter;
        WEBASTOSTATPRMSbits.id = id;
        WEBASTOSTATPRMSbits.byte = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        WEBASTOSTATPRMSbits.byte = temp;
        WEBASTOSTATPRMSbits.bit_mask = 0;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        WEBASTOSTATPRMSbits.bit_mask = temp;
        temp = get_nibble_from_str ( ptr + 24 ); if (temp == -1) return 0;
        WEBASTOSTATPRMSbits.bit_mask = (WEBASTOSTATPRMSbits.bit_mask << 4) + temp;
        WEBASTOSTATPRMSbits.inv = 0;
        temp = get_nibble_from_str ( ptr + 26 ); if (temp == -1) return 0; 
        WEBASTOSTATPRMSbits.inv = temp;
        
        if (number_of_can == 1) exide = CAN1SETTINGSbits.ide; else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)WEBASTOSTATPRMSbits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)WEBASTOSTATPRMSbits.id, (unsigned int)exide, 15, 0);        

        FM25_write_8( 628, (unsigned long long) WEBASTOSTATPRMSbits.WEBASTOSTATPRMS );

    }        

// Статус сигнализации тип 2 
    if (param == 0x0F) {
        Nop();Nop();Nop();
        ALARMSTATPRMS2bits.can_number = number_of_can;
        ALARMSTATPRMS2bits.filt_number = number_of_filter;
        ALARMSTATPRMS2bits.id = id;
        ALARMSTATPRMS2bits.byte = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        ALARMSTATPRMS2bits.byte = temp;
        ALARMSTATPRMS2bits.bit_mask = 0;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        ALARMSTATPRMS2bits.bit_mask = temp;
        temp = get_nibble_from_str ( ptr + 24 ); if (temp == -1) return 0;
        ALARMSTATPRMS2bits.bit_mask = (ALARMSTATPRMS2bits.bit_mask << 4) + temp;

        ALARMSTATPRMS2bits.value1 = 0;
        temp = get_nibble_from_str ( ptr + 26 ); if (temp == -1) return 0; 
        ALARMSTATPRMS2bits.value1 = temp;
        temp = get_nibble_from_str ( ptr + 27 ); if (temp == -1) return 0;
        ALARMSTATPRMS2bits.value1 = (ALARMSTATPRMS2bits.value1 << 4) + temp; 
        ALARMSTATPRMS2bits.value2 = 0;
        temp = get_nibble_from_str ( ptr + 29 ); if (temp == -1) return 0; 
        ALARMSTATPRMS2bits.value2 = temp;
        temp = get_nibble_from_str ( ptr + 30 ); if (temp == -1) return 0;
        ALARMSTATPRMS2bits.value2 = (ALARMSTATPRMS2bits.value2 << 4) + temp;        
        if (number_of_can == 1) {exide = CAN1SETTINGSbits.ide;} else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)ALARMSTATPRMS2bits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)ALARMSTATPRMS2bits.id, (unsigned int)exide, 15, 0);

        FM25_write_8( 636, (unsigned long long) ALARMSTATPRMS2bits.ALARMSTATPRMS2 );// Статус двигателя тип2

    } 
        
// Статус АКПП тип 2 
    if (param == 0x11) {
        Nop();Nop();Nop();
        GEARBOXSTATPRMS2bits.can_number = number_of_can;
        GEARBOXSTATPRMS2bits.filt_number = number_of_filter;
        GEARBOXSTATPRMS2bits.id = id;
        GEARBOXSTATPRMS2bits.byte = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        GEARBOXSTATPRMS2bits.byte = temp;
        GEARBOXSTATPRMS2bits.bit_mask = 0;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        GEARBOXSTATPRMS2bits.bit_mask = temp;
        temp = get_nibble_from_str ( ptr + 24 ); if (temp == -1) return 0;
        GEARBOXSTATPRMS2bits.bit_mask = (GEARBOXSTATPRMS2bits.bit_mask << 4) + temp;

        GEARBOXSTATPRMS2bits.value1 = 0;
        temp = get_nibble_from_str ( ptr + 26 ); if (temp == -1) return 0; 
        GEARBOXSTATPRMS2bits.value1 = temp;
        temp = get_nibble_from_str ( ptr + 27 ); if (temp == -1) return 0;
        GEARBOXSTATPRMS2bits.value1 = (GEARBOXSTATPRMS2bits.value1 << 4) + temp; 
        GEARBOXSTATPRMS2bits.value2 = 0;
        temp = get_nibble_from_str ( ptr + 29 ); if (temp == -1) return 0; 
        GEARBOXSTATPRMS2bits.value2 = temp;
        temp = get_nibble_from_str ( ptr + 30 ); if (temp == -1) return 0;
        GEARBOXSTATPRMS2bits.value2 = (GEARBOXSTATPRMS2bits.value2 << 4) + temp;        
        if (number_of_can == 1) {exide = CAN1SETTINGSbits.ide;} else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)GEARBOXSTATPRMS2bits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)GEARBOXSTATPRMS2bits.id, (unsigned int)exide, 15, 0);

        FM25_write_8( 644, (unsigned long long) GEARBOXSTATPRMS2bits.GEARBOXSTATPRMS2 );// Статус двигателя тип2

    }        

// Замки дверей тип 3 
    if (param == 0x12) {
        Nop();Nop();Nop();
        LOCKSTATPRMS3bits.can_number = number_of_can;
        LOCKSTATPRMS3bits.filt_number = number_of_filter;
        LOCKSTATPRMS3bits.id = id;
        LOCKSTATPRMS3bits.byte = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        LOCKSTATPRMS3bits.byte = temp;
        LOCKSTATPRMS3bits.bit_mask = 0;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        LOCKSTATPRMS3bits.bit_mask = temp;
        temp = get_nibble_from_str ( ptr + 24 ); if (temp == -1) return 0;
        LOCKSTATPRMS3bits.bit_mask = (LOCKSTATPRMS3bits.bit_mask << 4) + temp;

        LOCKSTATPRMS3bits.value1 = 0;
        temp = get_nibble_from_str ( ptr + 26 ); if (temp == -1) return 0; 
        LOCKSTATPRMS3bits.value1 = temp;
        temp = get_nibble_from_str ( ptr + 27 ); if (temp == -1) return 0;
        LOCKSTATPRMS3bits.value1 = (LOCKSTATPRMS3bits.value1 << 4) + temp; 
        LOCKSTATPRMS3bits.value2 = 0;
        temp = get_nibble_from_str ( ptr + 29 ); if (temp == -1) return 0; 
        LOCKSTATPRMS3bits.value2 = temp;
        temp = get_nibble_from_str ( ptr + 30 ); if (temp == -1) return 0;
        LOCKSTATPRMS3bits.value2 = (LOCKSTATPRMS3bits.value2 << 4) + temp;        
        if (LOCKSTATPRMS3bits.can_number != 0 ) {LOCKSTATPRMSbits.can_number = 0; LOCKSTATPRMS2bits.can_number = 0;} // Отключение первого и второго типа, если настроен третий
        if (number_of_can == 1) {exide = CAN1SETTINGSbits.ide;} else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)LOCKSTATPRMS3bits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)LOCKSTATPRMS3bits.id, (unsigned int)exide, 15, 0);

        FM25_write_8( 652, (unsigned long long) LOCKSTATPRMS3bits.LOCKSTATPRMS3 );// Замки тип3
        FM25_write_8( 604, (unsigned long long) LOCKSTATPRMS2bits.LOCKSTATPRMS2 ); // Замки тип 2
        FM25_write_8( 596, (unsigned long long) LOCKSTATPRMSbits.LOCKSTATPRMS ); // Замки тип 1        
    }
// Замок багажника тип 1        
    if (param == 0x13) {
        Nop();Nop();Nop();
        BOOTLOCKSTATPRMSbits.can_number = number_of_can;
        BOOTLOCKSTATPRMSbits.filt_number = number_of_filter;
        BOOTLOCKSTATPRMSbits.id = id;
        BOOTLOCKSTATPRMSbits.byte = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        BOOTLOCKSTATPRMSbits.byte = temp;
        BOOTLOCKSTATPRMSbits.bit_mask = 0;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        BOOTLOCKSTATPRMSbits.bit_mask = temp;
        temp = get_nibble_from_str ( ptr + 24 ); if (temp == -1) return 0;
        BOOTLOCKSTATPRMSbits.bit_mask = (BOOTLOCKSTATPRMSbits.bit_mask << 4) + temp;
        BOOTLOCKSTATPRMSbits.inv = 0;
        temp = get_nibble_from_str ( ptr + 26 ); if (temp == -1) return 0; 
        BOOTLOCKSTATPRMSbits.inv = temp;
        
        if (number_of_can == 1) exide = CAN1SETTINGSbits.ide; else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)BOOTLOCKSTATPRMSbits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)BOOTLOCKSTATPRMSbits.id, (unsigned int)exide, 15, 0);        

        FM25_write_8( 660, (unsigned long long) BOOTLOCKSTATPRMSbits.BOOTLOCKSTATPRMS );// Замок багажника тип 1
    } 
// Байты для чтения команд ключа управления замками дверей        
    if (param == 0x14) { // по алгоритмам 1 и 2
        Nop();Nop();Nop();
        CANLOCKBYTESPRMSbits.can_number = number_of_can;
        CANLOCKBYTESPRMSbits.filt_number = number_of_filter;
        CANLOCKBYTESPRMSbits.id = id;
        CANLOCKBYTESPRMSbits.byte0 = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        CANLOCKBYTESPRMSbits.byte0 = temp;
        CANLOCKBYTESPRMSbits.byte1 = 0;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        CANLOCKBYTESPRMSbits.byte1 = temp;
        CANLOCKBYTESPRMSbits.byte2 = 0;
        temp = get_nibble_from_str ( ptr + 25 ); if (temp == -1) return 0;
        CANLOCKBYTESPRMSbits.byte2 = temp;
        CANLOCKBYTESPRMS2bits.byte3 = 0;
        temp = get_nibble_from_str ( ptr + 27 ); if (temp == -1) return 0;
        CANLOCKBYTESPRMS2bits.byte3 = temp;        
        if (number_of_can == 1) exide = CAN1SETTINGSbits.ide; else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)CANLOCKBYTESPRMSbits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)CANLOCKBYTESPRMSbits.id, (unsigned int)exide, 15, 0);
        FM25_write_8( 868, (unsigned long long) CANLOCKBYTESPRMSbits.CANLOCKBYTESPRMS );
        FM25_write_2( 877, (unsigned int) CANLOCKBYTESPRMS2bits.CANLOCKBYTESPRMS2 );
    }
    if (param == 0x15) { // по алгоритму 3
        Nop();Nop();Nop();
        CANLOCKBYTESPRMSbits.can_number = number_of_can;
        CANLOCKBYTESPRMSbits.filt_number = number_of_filter;
        CANLOCKBYTESPRMSbits.id = id;
        CANLOCKBYTESPRMSbits.byte0 = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        CANLOCKBYTESPRMSbits.byte0 = temp;
        CANLOCKBYTESPRMSbits.byte1 = 0;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        CANLOCKBYTESPRMSbits.byte1 = temp;
        CANLOCKBYTESPRMSbits.byte2 = 0;
        temp = get_nibble_from_str ( ptr + 25 ); if (temp == -1) return 0;
        CANLOCKBYTESPRMSbits.byte2 = temp;
        CANLOCKBYTESPRMS2bits.byte3 = 0;
        temp = get_nibble_from_str ( ptr + 27 ); if (temp == -1) return 0;
        CANLOCKBYTESPRMS2bits.byte3 = temp; 
        
        temp = get_nibble_from_str ( ptr + 29 ); if (temp == -1) return 0;
        CANLOCKCHECKBYTESbits.num0 = temp;
        temp = get_nibble_from_str ( ptr + 31 ); if (temp == -1) return 0;
        CANLOCKCHECKBYTESbits.num1 = temp;
        temp = get_nibble_from_str ( ptr + 33 ); if (temp == -1) return 0;
        CANLOCKCHECKBYTESbits.num2 = temp; 
        
        temp1 = (char)convert_str_to_hex ( ptr + 35, 2 );  if (temp1 == -1) return 0;
        CANLOCKCHECKBYTESbits.byte0 = (unsigned char)temp1;
        temp1 = (char)convert_str_to_hex ( ptr + 38, 2 );  if (temp1 == -1) return 0;
        CANLOCKCHECKBYTESbits.byte1 = (unsigned char)temp1;
        temp1 = (char)convert_str_to_hex ( ptr + 41, 2 );  if (temp1 == -1) return 0;
        CANLOCKCHECKBYTESbits.byte2 = (unsigned char)temp1;
        
        if (number_of_can == 1) exide = CAN1SETTINGSbits.ide; else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)CANLOCKBYTESPRMSbits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)CANLOCKBYTESPRMSbits.id, (unsigned int)exide, 15, 0);
        FM25_write_8( 868, (unsigned long long) CANLOCKBYTESPRMSbits.CANLOCKBYTESPRMS );
        FM25_write_2( 877, (unsigned int) CANLOCKBYTESPRMS2bits.CANLOCKBYTESPRMS2 );
    }

// Ближний свет
    if (param == 0x16) {
        Nop();Nop();Nop();
        CANLIGHTSPRMSbits.can_number = number_of_can;
        CANLIGHTSPRMSbits.filt_number = number_of_filter;
        CANLIGHTSPRMSbits.id = id;
        CANLIGHTSPRMSbits.byte = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        CANLIGHTSPRMSbits.byte = temp;
        CANLIGHTSPRMSbits.bit_mask = 0;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        CANLIGHTSPRMSbits.bit_mask = temp;
        temp = get_nibble_from_str ( ptr + 24 ); if (temp == -1) return 0;
        CANLIGHTSPRMSbits.bit_mask = (CANLIGHTSPRMSbits.bit_mask << 4) + temp;
        CANLIGHTSPRMSbits.inv = 0;
        temp = get_nibble_from_str ( ptr + 26 ); if (temp == -1) return 0; 
        CANLIGHTSPRMSbits.inv = temp;
        
        if (number_of_can == 1) {exide = CAN1SETTINGSbits.ide;} else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)CANLIGHTSPRMSbits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)CANLIGHTSPRMSbits.id, (unsigned int)exide, 15, 0);
        FM25_write_8( 895, (unsigned long long) CANLIGHTSPRMSbits.CANLIGHTSPRMS );

    }
// Поворотники левые       
    if (param == 0x17) {
        Nop();Nop();Nop();
        CANTLLIGHTSPRMSbits.can_number = number_of_can;
        CANTLLIGHTSPRMSbits.filt_number = number_of_filter;
        CANTLLIGHTSPRMSbits.id = id;
        CANTLLIGHTSPRMSbits.byte = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        CANTLLIGHTSPRMSbits.byte = temp;
        CANTLLIGHTSPRMSbits.bit_mask = 0;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        CANTLLIGHTSPRMSbits.bit_mask = temp;
        temp = get_nibble_from_str ( ptr + 24 ); if (temp == -1) return 0;
        CANTLLIGHTSPRMSbits.bit_mask = (CANTLLIGHTSPRMSbits.bit_mask << 4) + temp;
        CANTLLIGHTSPRMSbits.inv = 0;
        temp = get_nibble_from_str ( ptr + 26 ); if (temp == -1) return 0; 
        CANTLLIGHTSPRMSbits.inv = temp;
        
        if (number_of_can == 1) {exide = CAN1SETTINGSbits.ide;} else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)CANTLLIGHTSPRMSbits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)CANTLLIGHTSPRMSbits.id, (unsigned int)exide, 15, 0);
        FM25_write_8( 903, (unsigned long long) CANTLLIGHTSPRMSbits.CANTLLIGHTSPRMS );

    }
// Поворотники правые        
    if (param == 0x18) {
        Nop();Nop();Nop();
        CANTRLIGHTSPRMSbits.can_number = number_of_can;
        CANTRLIGHTSPRMSbits.filt_number = number_of_filter;
        CANTRLIGHTSPRMSbits.id = id;
        CANTRLIGHTSPRMSbits.byte = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        CANTRLIGHTSPRMSbits.byte = temp;
        CANTRLIGHTSPRMSbits.bit_mask = 0;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        CANTRLIGHTSPRMSbits.bit_mask = temp;
        temp = get_nibble_from_str ( ptr + 24 ); if (temp == -1) return 0;
        CANTRLIGHTSPRMSbits.bit_mask = (CANTRLIGHTSPRMSbits.bit_mask << 4) + temp;
        CANTRLIGHTSPRMSbits.inv = 0;
        temp = get_nibble_from_str ( ptr + 26 ); if (temp == -1) return 0; 
        CANTRLIGHTSPRMSbits.inv = temp;
       
        if (number_of_can == 1) {exide = CAN1SETTINGSbits.ide;} else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)CANTRLIGHTSPRMSbits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)CANTRLIGHTSPRMSbits.id, (unsigned int)exide, 15, 0);
        FM25_write_8( 911, (unsigned long long) CANTRLIGHTSPRMSbits.CANTRLIGHTSPRMS );

    }

// Расход топлива        
    if (param == 0x19) {
        Nop();Nop();Nop();
        CANFLCNPNPRMSbits.can_number = number_of_can;
        CANFLCNPNPRMSbits.filt_number = number_of_filter;
        CANFLCNPNPRMSbits.id = id;
        CANFLCNPNPRMSbits.byte0 = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) {CANFLCNPNPRMSbits.CANFLCNPNPRMS = 0; return 0;}
        CANFLCNPNPRMSbits.byte0 = temp;
        temp2 = (long) convert_str_to_hex ( ptr + 23, 4 );
        if (temp2 == -1) {CANFLCNPNPRMSbits.CANFLCNPNPRMS = 0; return 0;} 
        fuel_consumption_quantum = (unsigned int) temp2;
        if (number_of_can == 1) exide = CAN1SETTINGSbits.ide; else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)CANFLCNPNPRMSbits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)CANFLCNPNPRMSbits.id, (unsigned int)exide, 15, 0);
        FM25_write_8( 919, (unsigned long long) CANFLCNPNPRMSbits.CANFLCNPNPRMS );
        FM25_write_2( 1670, (unsigned int) fuel_consumption_quantum );
    }

// Топливо 2 байта       
    if (param == 0x1A) {
        Nop();Nop();Nop();
        CANFL2PRMSbits.can_number = number_of_can;
        CANFL2PRMSbits.filt_number = number_of_filter;
        CANFL2PRMSbits.id = id;
        CANFL2PRMSbits.byte0 = 0;
        CANFL2PRMSbits.byte1 = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        CANFL2PRMSbits.byte1 = temp;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        CANFL2PRMSbits.byte0 = temp;        
        if (number_of_can == 1) exide = CAN1SETTINGSbits.ide; else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)CANFL2PRMSbits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)CANFL2PRMSbits.id, (unsigned int)exide, 15, 0);
        FM25_write_8( 927, (unsigned long long) CANFL2PRMSbits.CANFL2PRMS );
    }
// Топливо 2 байта тип 3      
    if (param == 0x1B) {
        Nop();Nop();Nop();
        CANFL3PRMSbits.can_number = number_of_can;
        CANFL3PRMSbits.filt_number = number_of_filter;
        CANFL3PRMSbits.id = id;
        CANFL3PRMSbits.byte0 = 0;
        CANFL3PRMSbits.byte1 = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        CANFL3PRMSbits.byte1 = temp;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        CANFL3PRMSbits.byte0 = temp;        
        if (number_of_can == 1) exide = CAN1SETTINGSbits.ide; else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)CANFL3PRMSbits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)CANFL3PRMSbits.id, (unsigned int)exide, 15, 0);
        FM25_write_8( 935, (unsigned long long) CANFL3PRMSbits.CANFL3PRMS );
    }
        
    if (param == 0x1C) {
        Nop();Nop();Nop();
        CANBRPPRMSbits.can_number = number_of_can;
        CANBRPPRMSbits.filt_number = number_of_filter;
        CANBRPPRMSbits.id = id;
        CANBRPPRMSbits.byte = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        CANBRPPRMSbits.byte = temp;
        CANBRPPRMSbits.bit_mask = 0;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        CANBRPPRMSbits.bit_mask = temp;
        temp = get_nibble_from_str ( ptr + 24 ); if (temp == -1) return 0;
        CANBRPPRMSbits.bit_mask = (CANBRPPRMSbits.bit_mask << 4) + temp;
        CANBRPPRMSbits.inv = 0;
        temp = get_nibble_from_str ( ptr + 26 ); if (temp == -1) return 0; 
        CANBRPPRMSbits.inv = temp;
        if (number_of_can == 1) exide = CAN1SETTINGSbits.ide; else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1)ecan1WriteRxAcptFilter( (int)number_of_filter,(long)CANBRPPRMSbits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2)ecan2WriteRxAcptFilter( (int)number_of_filter,(long)CANBRPPRMSbits.id, (unsigned int)exide, 15, 0);
        FM25_write_8( 1672, (unsigned long long) CANBRPPRMSbits.CANBRPPRMS );
    }        
        
// Обороты       
    if (param == 0x1D) {
        Nop();Nop();Nop();
        RPMPRMSbits.can_number = number_of_can;
        RPMPRMSbits.filt_number = number_of_filter;
        RPMPRMSbits.id = id;
        RPMPRMSbits.byte0 = 0;
        RPMPRMSbits.byte1 = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        RPMPRMSbits.byte1 = temp;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        RPMPRMSbits.byte0 = temp;        
        if (number_of_can == 1) exide = CAN1SETTINGSbits.ide; else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)RPMPRMSbits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)RPMPRMSbits.id, (unsigned int)exide, 15, 0);
        FM25_write_8( 1680, (unsigned long long) RPMPRMSbits.RPMPRMS);
    }        
// Ключ Тойоты      
    if (param == 0x1E) {
        Nop();Nop();Nop();
        TOYOTAKEYDATbits.can_number = number_of_can;
        TOYOTAKEYDATbits.filt_number = number_of_filter;
        TOYOTAKEYDATbits.id = id;
       
        if (number_of_can == 1) exide = CAN1SETTINGSbits.ide; else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)TOYOTAKEYDATbits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)TOYOTAKEYDATbits.id, (unsigned int)exide, 15, 0);
        FM25_write_8( 948, (unsigned long long) TOYOTAKEYDATbits.TOYOTAKEYDAT);
    }
//can_button
    if (param == 0x1F) {
        Nop();Nop();Nop();
        CANBUTTONPRMSbits.can_number = number_of_can;
        CANBUTTONPRMSbits.filt_number = number_of_filter;
        CANBUTTONPRMSbits.id = id;
        CANBUTTONPRMSbits.byte = 0;
        temp = get_nibble_from_str ( ptr + 21 ); if (temp == -1) return 0;
        CANBUTTONPRMSbits.byte = temp;
        CANBUTTONPRMSbits.bit_mask = 0;
        temp = get_nibble_from_str ( ptr + 23 ); if (temp == -1) return 0;
        CANBUTTONPRMSbits.bit_mask = temp;
        temp = get_nibble_from_str ( ptr + 24 ); if (temp == -1) return 0;
        CANBUTTONPRMSbits.bit_mask = (CANBUTTONPRMSbits.bit_mask << 4) + temp;

        CANBUTTONPRMSbits.value1 = 0;
        temp = get_nibble_from_str ( ptr + 26 ); if (temp == -1) return 0; 
        CANBUTTONPRMSbits.value1 = temp;
        temp = get_nibble_from_str ( ptr + 27 ); if (temp == -1) return 0;
        CANBUTTONPRMSbits.value1 = (CANBUTTONPRMSbits.value1 << 4) + temp; 
        CANBUTTONPRMSbits.value2 = 0;
        temp = get_nibble_from_str ( ptr + 29 ); if (temp == -1) return 0; 
        CANBUTTONPRMSbits.value2 = temp;
        temp = get_nibble_from_str ( ptr + 30 ); if (temp == -1) return 0;
        CANBUTTONPRMSbits.value2 = (CANBUTTONPRMSbits.value2 << 4) + temp; 
        
        if (number_of_can == 1) {exide = CAN1SETTINGSbits.ide;} else exide = CAN2SETTINGSbits.ide;
        if (number_of_can == 1) ecan1WriteRxAcptFilter( (int)number_of_filter,(long)CANBUTTONPRMSbits.id, (unsigned int)exide, 15, 0);
        if (number_of_can == 2) ecan2WriteRxAcptFilter( (int)number_of_filter,(long)CANBUTTONPRMSbits.id, (unsigned int)exide, 15, 0);
        FM25_write_8( 956, (unsigned long long) CANBUTTONPRMSbits.CANBUTTONPRMS );
    }
        
Nop();Nop();Nop(); 
return 1;
}
int apply_can_speed (char *ptr) {
    
char param, /*temp,*/ number_of_can, /*number_of_filter, number_of_byte, bit_mask,*/ on_off, i;
 unsigned int exide, speed;

    param = 0;
    
    if (*(ptr + 4) != '=') return 0;

    if (*(ptr + 5) == 0x31 || *(ptr + 5) == 0x32) {
        number_of_can = *(ptr + 5) - 0x30;
    } else return 0;
    
    if (*(ptr + 7) == 0x30 || *(ptr + 7) == 0x31) {
        on_off = *(ptr + 7) - 0x30;
    } else return 0;

    for (i = 0; i < 4; i ++) {
        if ((*(ptr + 9 + i) < 0x30) || (*(ptr + 9 + i) > 0x39)) return 0;
    }

    speed = 0;
    speed = *(ptr + 9) - 0x30;
    speed = speed * 10 + *(ptr + 10) - 0x30;
    speed = speed * 10 + *(ptr + 11) - 0x30;
    speed = speed * 10 + *(ptr + 12)  - 0x30;
    
    
    if (*(ptr + 14) == 0x30 || *(ptr + 14) == 0x31) {
        exide = *(ptr + 14) - 0x30;
    } else return 0;

    Nop();Nop();Nop();

    if ( number_of_can == 1 ) {
        CAN1SETTINGSbits.bitrate = speed;
        CAN1SETTINGSbits.ide = exide;
        CAN1SETTINGSbits.on = on_off;
        FM25_write_2( 512, (unsigned int) CAN1SETTINGSbits.CAN1SETTINGS );// CAN1 - on = 0, ide = 0, bitrate = 500
        can1start();
        init_CAN_filters ();
    }

    if ( number_of_can == 2 ) {
        CAN2SETTINGSbits.bitrate = speed;
        CAN2SETTINGSbits.ide = exide;
        CAN2SETTINGSbits.on = on_off;
        FM25_write_2( 514, (unsigned int) CAN2SETTINGSbits.CAN2SETTINGS );// 514, 515 CAN2 - on = 0, ide = 0, bitrate = 500        
        can2start();
        init_CAN_filters ();        
    }

return 1;    
}
int apply_can_config (char *ptr) {
    
char param, /*temp,*/ number_of_can;
char   sjw,  seg1, seg2, prseg, sam, sjw_slp, seg1_slp, seg2_slp, prseg_slp, sam_slp;

    param = 0;
    
    if (*(ptr + 4)  != '=' || *(ptr + 6)  != ',' || *(ptr + 8)  != ',' || *(ptr + 10) != ',' || *(ptr + 12) != ',' || *(ptr + 14) != ',' || *(ptr + 16) != ','
     || *(ptr + 18) != ',' || *(ptr + 20) != ',' || *(ptr + 22) != ',' || *(ptr + 24) != ',' || *(ptr + 26) != ';') return 0;


    if (*(ptr + 5)  < 0x31 || *(ptr + 5)  > 0x32) return 0;
    number_of_can = *(ptr + 5) - 0x30;
    
    if (*(ptr + 7)  < 0x30 || *(ptr + 7)  > 0x33 ) return 0;
    sjw = *(ptr + 7) - 0x30;

    if (*(ptr + 9)  < 0x30 || *(ptr + 9)  > 0x37 ) return 0;
    seg1 = *(ptr + 9) - 0x30;    

    if (*(ptr + 11)  < 0x30 || *(ptr + 11)  > 0x37 ) return 0;
    seg2 = *(ptr + 11) - 0x30;    

    if (*(ptr + 13)  < 0x30 || *(ptr + 13)  > 0x37 ) return 0;
    prseg = *(ptr + 13) - 0x30;

    if (*(ptr + 15)  < 0x30 || *(ptr + 15)  > 0x31 ) return 0;
    sam = *(ptr + 15) - 0x30;


    
    if (*(ptr + 17)  < 0x30 || *(ptr + 17)  > 0x33 ) return 0;
    sjw_slp = *(ptr + 17) - 0x30;

    if (*(ptr + 19)  < 0x30 || *(ptr + 19)  > 0x37 ) return 0;
    seg1_slp = *(ptr + 19) - 0x30;    

    if (*(ptr + 21)  < 0x30 || *(ptr + 21)  > 0x37 ) return 0;
    seg2_slp = *(ptr + 21) - 0x30;    

    if (*(ptr + 23)  < 0x30 || *(ptr + 23)  > 0x37 ) return 0;
    prseg_slp = *(ptr + 23) - 0x30;

    if (*(ptr + 25)  < 0x30 || *(ptr + 25)  > 0x31 ) return 0;
    sam_slp = *(ptr + 25) - 0x30;    

    
    Nop();Nop();Nop();

    if ( number_of_can == 1 ) {
        CAN1CFGbits.sjw   = sjw;
        CAN1CFGbits.seg1  = seg1;
        CAN1CFGbits.seg2  = seg2;
        CAN1CFGbits.prseg = prseg;
        CAN1CFGbits.sam   = sam;
        
        CAN1CFGbits.sjw_slp   = sjw_slp;
        CAN1CFGbits.seg1_slp  = seg1_slp;
        CAN1CFGbits.seg2_slp  = seg2_slp;
        CAN1CFGbits.prseg_slp = prseg_slp;
        CAN1CFGbits.sam_slp   = sam_slp;        
        FM25_write_4( 668, (unsigned long) CAN1CFGbits.CAN1CFG );
        can1start();
        init_CAN_filters ();
    }
    Nop();Nop();Nop();
//    CAN1CFGbits.CAN1CFG = 0x094D0CBF;
    if ( number_of_can == 2 ) {
        CAN2CFGbits.sjw   = sjw;
        CAN2CFGbits.seg1  = seg1;
        CAN2CFGbits.seg2  = seg2;
        CAN2CFGbits.prseg = prseg;
        CAN2CFGbits.sam   = sam;
        
        CAN2CFGbits.sjw_slp   = sjw_slp;
        CAN2CFGbits.seg1_slp  = seg1_slp;
        CAN2CFGbits.seg2_slp  = seg2_slp;
        CAN2CFGbits.prseg_slp = prseg_slp;
        CAN2CFGbits.sam_slp   = sam_slp;
        FM25_write_4( 672, (unsigned long) CAN2CFGbits.CAN2CFG );        
        can2start();
        init_CAN_filters ();        
    }

return 1;    
}
void init_CAN_filters (void) {

/* Request Configuration Mode */
	C1CTRL1bits.REQOP=4;
	while(C1CTRL1bits.OPMODE!=4);
    
    if (CANIGNPRMSbits.can_number == 1)   ecan1WriteRxAcptFilter( (int)CANIGNPRMSbits.filt_number,   (long)CANIGNPRMSbits.id,    (unsigned int)CAN1SETTINGSbits.ide, 15, 0); //8 зажигание,
    if (CANDDPRMSbits.can_number == 1)    ecan1WriteRxAcptFilter( (int)CANDDPRMSbits.filt_number,    (long)CANDDPRMSbits.id,     (unsigned int)CAN1SETTINGSbits.ide, 15, 0); //8 зажигание,
    if (CANFPDPRMSbits.can_number == 1)   ecan1WriteRxAcptFilter( (int)CANFPDPRMSbits.filt_number,   (long)CANFPDPRMSbits.id,    (unsigned int)CAN1SETTINGSbits.ide, 15, 0); //8 зажигание,    
    if (CANRLDPRMSbits.can_number == 1)   ecan1WriteRxAcptFilter( (int)CANRLDPRMSbits.filt_number,   (long)CANRLDPRMSbits.id,    (unsigned int)CAN1SETTINGSbits.ide, 15, 0); //8 зажигание,    
    if (CANRRDPRMSbits.can_number == 1)   ecan1WriteRxAcptFilter( (int)CANRRDPRMSbits.filt_number,   (long)CANRRDPRMSbits.id,    (unsigned int)CAN1SETTINGSbits.ide, 15, 0); //8 зажигание,    
    if (CANBNPRMSbits.can_number == 1)    ecan1WriteRxAcptFilter( (int)CANBNPRMSbits.filt_number,    (long)CANBNPRMSbits.id,     (unsigned int)CAN1SETTINGSbits.ide, 15, 0); //8 зажигание,    
    if (CANBTPRMSbits.can_number == 1)    ecan1WriteRxAcptFilter( (int)CANBTPRMSbits.filt_number,    (long)CANBTPRMSbits.id,     (unsigned int)CAN1SETTINGSbits.ide, 15, 0); //8 зажигание,    
    if (CANODOPRMSbits.can_number == 1)   ecan1WriteRxAcptFilter( (int)CANODOPRMSbits.filt_number,   (long)CANODOPRMSbits.id,    (unsigned int)CAN1SETTINGSbits.ide, 15, 0); //8 зажигание,    
    if (CANFLPRMSbits.can_number == 1)    ecan1WriteRxAcptFilter( (int)CANFLPRMSbits.filt_number,    (long)CANFLPRMSbits.id,     (unsigned int)CAN1SETTINGSbits.ide, 15, 0); //8 зажигание,    
    if (CANBELTPRMSbits.can_number == 1)  ecan1WriteRxAcptFilter( (int)CANBELTPRMSbits.filt_number,  (long)CANBELTPRMSbits.id,   (unsigned int)CAN1SETTINGSbits.ide, 15, 0); //8 зажигание,    
    if (LOCKSTATPRMSbits.can_number == 1) ecan1WriteRxAcptFilter( (int)LOCKSTATPRMSbits.filt_number, (long)LOCKSTATPRMSbits.id,  (unsigned int)CAN1SETTINGSbits.ide, 15, 0); //8 зажигание,    
    if (LOCKSTATPRMS2bits.can_number == 1)ecan1WriteRxAcptFilter( (int)LOCKSTATPRMS2bits.filt_number,(long)LOCKSTATPRMS2bits.id, (unsigned int)CAN1SETTINGSbits.ide, 15, 0); //8 зажигание,    
    if (CANIGNPRMS2bits.can_number == 1)  ecan1WriteRxAcptFilter( (int)CANIGNPRMS2bits.filt_number,  (long)CANIGNPRMS2bits.id,   (unsigned int)CAN1SETTINGSbits.ide, 15, 0); //Чтобы работал exid вместо 3 должно быть 0
    if (WEBASTOSTATPRMSbits.can_number == 1) ecan1WriteRxAcptFilter( (int)WEBASTOSTATPRMSbits.filt_number, (long)WEBASTOSTATPRMSbits.id,  (unsigned int)CAN1SETTINGSbits.ide, 15, 0); //8 зажигание,    
    if (ALARMSTATPRMS2bits.can_number == 1) ecan1WriteRxAcptFilter( (int)ALARMSTATPRMS2bits.filt_number, (long)ALARMSTATPRMS2bits.id,  (unsigned int)CAN1SETTINGSbits.ide, 15, 0); //8 зажигание,
    if (GEARBOXSTATPRMS2bits.can_number == 1) ecan1WriteRxAcptFilter( (int)GEARBOXSTATPRMS2bits.filt_number, (long)GEARBOXSTATPRMS2bits.id,  (unsigned int)CAN1SETTINGSbits.ide, 15, 0); //8 зажигание,
    if (LOCKSTATPRMS3bits.can_number == 1) ecan1WriteRxAcptFilter( (int)LOCKSTATPRMS3bits.filt_number, (long)LOCKSTATPRMS3bits.id,  (unsigned int)CAN1SETTINGSbits.ide, 15, 0); //8 зажигание,
    if (BOOTLOCKSTATPRMSbits.can_number == 1) ecan1WriteRxAcptFilter( (int)BOOTLOCKSTATPRMSbits.filt_number, (long)BOOTLOCKSTATPRMSbits.id,  (unsigned int)CAN1SETTINGSbits.ide, 15, 0); //замок багажника тип 1        
    if (CANLOCKBYTESPRMSbits.can_number == 1) ecan1WriteRxAcptFilter( (int)CANLOCKBYTESPRMSbits.filt_number, (long)CANLOCKBYTESPRMSbits.id,  (unsigned int)CAN1SETTINGSbits.ide, 15, 0); // байты команд ключа для управления замками дверей
    if (CANLIGHTSPRMSbits.can_number == 1) ecan1WriteRxAcptFilter( (int)CANLIGHTSPRMSbits.filt_number, (long)CANLIGHTSPRMSbits.id,  (unsigned int)CAN1SETTINGSbits.ide, 15, 0); // байты команд ключа для управления замками дверей
    if (CANTLLIGHTSPRMSbits.can_number == 1) ecan1WriteRxAcptFilter( (int)CANTLLIGHTSPRMSbits.filt_number, (long)CANTLLIGHTSPRMSbits.id,  (unsigned int)CAN1SETTINGSbits.ide, 15, 0); // байты команд ключа для управления замками дверей
    if (CANTRLIGHTSPRMSbits.can_number == 1) ecan1WriteRxAcptFilter( (int)CANTRLIGHTSPRMSbits.filt_number, (long)CANTRLIGHTSPRMSbits.id,  (unsigned int)CAN1SETTINGSbits.ide, 15, 0); // байты команд ключа для управления замками дверей
    if (CANFLCNPNPRMSbits.can_number == 1) ecan1WriteRxAcptFilter( (int)CANFLCNPNPRMSbits.filt_number, (long)CANFLCNPNPRMSbits.id,  (unsigned int)CAN1SETTINGSbits.ide, 15, 0); // байты команд ключа для управления замками дверей
    if (CANFL2PRMSbits.can_number == 1) ecan1WriteRxAcptFilter( (int)CANFL2PRMSbits.filt_number, (long)CANFL2PRMSbits.id,  (unsigned int)CAN1SETTINGSbits.ide, 15, 0); // байты команд ключа для управления замками дверей
    if (CANBRPPRMSbits.can_number == 1) ecan1WriteRxAcptFilter( (int)CANBRPPRMSbits.filt_number, (long)CANBRPPRMSbits.id,  (unsigned int)CAN1SETTINGSbits.ide, 15, 0); // байты команд ключа для управления замками дверей
    if (RPMPRMSbits.can_number == 1) ecan1WriteRxAcptFilter( (int)RPMPRMSbits.filt_number, (long)RPMPRMSbits.id,  (unsigned int)CAN1SETTINGSbits.ide, 15, 0); // байты команд ключа для управления замками дверей
    if (TOYOTAKEYDATbits.can_number == 1) ecan1WriteRxAcptFilter( (int)TOYOTAKEYDATbits.filt_number, (long)TOYOTAKEYDATbits.id,  (unsigned int)CAN1SETTINGSbits.ide, 15, 0); // байты команд ключа для управления замками дверей
    if (CANBUTTONPRMSbits.can_number == 1) ecan1WriteRxAcptFilter( (int)CANBUTTONPRMSbits.filt_number, (long)CANBUTTONPRMSbits.id,  (unsigned int)CAN1SETTINGSbits.ide, 15, 0); // байты команд ключа для управления замками дверей
  
//    ecan1WriteRxAcptFilter( 13,(long)0x7E8, (unsigned int)CAN1SETTINGSbits.ide, 5, 3); //OBD 
//    ecan1WriteRxAcptFilter( 14,(long)0x7E9, (unsigned int)CAN1SETTINGSbits.ide, 6, 3); //OBD 
//    ecan1WriteRxAcptFilter( 15,(long)0x7EA, (unsigned int)CAN1SETTINGSbits.ide, 7, 3); //OBD 
#ifndef FOR_TRUCK   
    if (CAN1SETTINGSbits.ide == 0) {
        ecan1WriteRxAcptFilter( 15,(long)0x7EA, (unsigned int)CAN1SETTINGSbits.ide, 15, 0); //OBD     
        ecan1WriteRxAcptMask  ( 0, 0x1FFFFFF0, 1, 0 );
    } else {
        ecan1WriteRxAcptFilter( 15,(long)0x18DAF128, (unsigned int)CAN1SETTINGSbits.ide, 15, 0); //OBD     
        ecan1WriteRxAcptMask  ( 0, 0x1FFFFFE0, 1, 0 );        
    }
#endif   
    
//#if defined(FOR_TRUCK)    
//    CAN1SETTINGSbits.ide = 1;   // extented - 29 bit 
//    ecan1WriteRxAcptFilter( 15,(long)maskIDExtendedLow, (unsigned int)CAN1SETTINGSbits.ide, 15, 0); //
//    ecan1WriteRxAcptMask  ( 1, maskIDExtendedHigh, 1, 1);
//#endif      
//    ecan1WriteRxAcptMask  ( 3, 0x1FFFFFF0, 0, 0 ); 
     
/* Enter Normal Mode */
	C1CTRL1bits.REQOP=0;
	while(C1CTRL1bits.OPMODE!=0);    
    
/* Request Configuration Mode */
	C2CTRL1bits.REQOP=4;
	while(C2CTRL1bits.OPMODE!=4);    
    
    if (CANIGNPRMSbits.can_number == 2)    ecan2WriteRxAcptFilter( (int)CANIGNPRMSbits.filt_number,   (long)CANIGNPRMSbits.id,    (unsigned int)CAN2SETTINGSbits.ide, 15, 0); //8 зажигание,
    if (CANDDPRMSbits.can_number == 2)     ecan2WriteRxAcptFilter( (int)CANDDPRMSbits.filt_number,    (long)CANDDPRMSbits.id,     (unsigned int)CAN2SETTINGSbits.ide, 15, 0); //8 зажигание,
    if (CANFPDPRMSbits.can_number == 2)    ecan2WriteRxAcptFilter( (int)CANFPDPRMSbits.filt_number,   (long)CANFPDPRMSbits.id,    (unsigned int)CAN2SETTINGSbits.ide, 15, 0); //8 зажигание,    
    if (CANRLDPRMSbits.can_number == 2)    ecan2WriteRxAcptFilter( (int)CANRLDPRMSbits.filt_number,   (long)CANRLDPRMSbits.id,    (unsigned int)CAN2SETTINGSbits.ide, 15, 0); //8 зажигание,    
    if (CANRRDPRMSbits.can_number == 2)    ecan2WriteRxAcptFilter( (int)CANRRDPRMSbits.filt_number,   (long)CANRRDPRMSbits.id,    (unsigned int)CAN2SETTINGSbits.ide, 15, 0); //8 зажигание,    
    if (CANBNPRMSbits.can_number == 2)     ecan2WriteRxAcptFilter( (int)CANBNPRMSbits.filt_number,    (long)CANBNPRMSbits.id,     (unsigned int)CAN2SETTINGSbits.ide, 15, 0); //8 зажигание,    
    if (CANBTPRMSbits.can_number == 2)     ecan2WriteRxAcptFilter( (int)CANBTPRMSbits.filt_number,    (long)CANBTPRMSbits.id,     (unsigned int)CAN2SETTINGSbits.ide, 15, 0); //8 зажигание,    
    if (CANODOPRMSbits.can_number == 2)    ecan2WriteRxAcptFilter( (int)CANODOPRMSbits.filt_number,   (long)CANODOPRMSbits.id,    (unsigned int)CAN2SETTINGSbits.ide, 15, 0); //8 зажигание,    
    if (CANFLPRMSbits.can_number == 2)     ecan2WriteRxAcptFilter( (int)CANFLPRMSbits.filt_number,    (long)CANFLPRMSbits.id,     (unsigned int)CAN2SETTINGSbits.ide, 15, 0); //8 зажигание,    
    if (CANBELTPRMSbits.can_number == 2)   ecan2WriteRxAcptFilter( (int)CANBELTPRMSbits.filt_number,  (long)CANBELTPRMSbits.id,   (unsigned int)CAN2SETTINGSbits.ide, 15, 0); //8 зажигание,    
    if (LOCKSTATPRMSbits.can_number == 2)  ecan2WriteRxAcptFilter( (int)LOCKSTATPRMSbits.filt_number, (long)LOCKSTATPRMSbits.id,  (unsigned int)CAN2SETTINGSbits.ide, 15, 0); //8 зажигание,    
    if (LOCKSTATPRMS2bits.can_number == 2) ecan2WriteRxAcptFilter( (int)LOCKSTATPRMS2bits.filt_number,(long)LOCKSTATPRMS2bits.id, (unsigned int)CAN2SETTINGSbits.ide, 15, 0); //8 зажигание,    
    if (CANIGNPRMS2bits.can_number == 2)   ecan2WriteRxAcptFilter( (int)CANIGNPRMS2bits.filt_number,  (long)CANIGNPRMS2bits.id,   (unsigned int)CAN2SETTINGSbits.ide, 15, 0); //8 зажигание,
    if (WEBASTOSTATPRMSbits.can_number == 2) ecan2WriteRxAcptFilter( (int)WEBASTOSTATPRMSbits.filt_number, (long)WEBASTOSTATPRMSbits.id,  (unsigned int)CAN2SETTINGSbits.ide, 15, 0); //8 зажигание,    
    if (ALARMSTATPRMS2bits.can_number == 2)  ecan2WriteRxAcptFilter( (int)ALARMSTATPRMS2bits.filt_number, (long)ALARMSTATPRMS2bits.id,  (unsigned int)CAN2SETTINGSbits.ide, 15, 0); //8 зажигание,    
    if (GEARBOXSTATPRMS2bits.can_number == 2)  ecan2WriteRxAcptFilter( (int)GEARBOXSTATPRMS2bits.filt_number, (long)GEARBOXSTATPRMS2bits.id,  (unsigned int)CAN2SETTINGSbits.ide, 15, 0); //8 зажигание,    
    if (LOCKSTATPRMS3bits.can_number == 2)  ecan2WriteRxAcptFilter( (int)LOCKSTATPRMS3bits.filt_number, (long)LOCKSTATPRMS3bits.id,  (unsigned int)CAN2SETTINGSbits.ide, 15, 0); //8 зажигание,    
    if (BOOTLOCKSTATPRMSbits.can_number == 2)  ecan2WriteRxAcptFilter( (int)BOOTLOCKSTATPRMSbits.filt_number, (long)BOOTLOCKSTATPRMSbits.id,  (unsigned int)CAN2SETTINGSbits.ide, 15, 0); //замок багажника тип 1
    if (CANLOCKBYTESPRMSbits.can_number == 2)  ecan2WriteRxAcptFilter( (int)CANLOCKBYTESPRMSbits.filt_number, (long)CANLOCKBYTESPRMSbits.id,  (unsigned int)CAN2SETTINGSbits.ide, 15, 0); // байты команд ключа для управления замками дверей
    if (CANLIGHTSPRMSbits.can_number == 2)  ecan2WriteRxAcptFilter( (int)CANLIGHTSPRMSbits.filt_number, (long)CANLIGHTSPRMSbits.id,  (unsigned int)CAN2SETTINGSbits.ide, 15, 0); // байты команд ключа для управления замками дверей
    if (CANTLLIGHTSPRMSbits.can_number == 2)  ecan2WriteRxAcptFilter( (int)CANTLLIGHTSPRMSbits.filt_number, (long)CANTLLIGHTSPRMSbits.id,  (unsigned int)CAN2SETTINGSbits.ide, 15, 0); // байты команд ключа для управления замками дверей
    if (CANTRLIGHTSPRMSbits.can_number == 2)  ecan2WriteRxAcptFilter( (int)CANTRLIGHTSPRMSbits.filt_number, (long)CANTRLIGHTSPRMSbits.id,  (unsigned int)CAN2SETTINGSbits.ide, 15, 0); // байты команд ключа для управления замками дверей
    if (CANFLCNPNPRMSbits.can_number == 2)  ecan2WriteRxAcptFilter( (int)CANFLCNPNPRMSbits.filt_number, (long)CANFLCNPNPRMSbits.id,  (unsigned int)CAN2SETTINGSbits.ide, 15, 0); // байты команд ключа для управления замками дверей
    if (CANFL2PRMSbits.can_number == 2)  ecan2WriteRxAcptFilter( (int)CANFL2PRMSbits.filt_number, (long)CANFL2PRMSbits.id,  (unsigned int)CAN2SETTINGSbits.ide, 15, 0); // байты команд ключа для управления замками дверей
    if (CANBRPPRMSbits.can_number == 2)  ecan2WriteRxAcptFilter( (int)CANBRPPRMSbits.filt_number, (long)CANBRPPRMSbits.id,  (unsigned int)CAN2SETTINGSbits.ide, 15, 0); // байты команд ключа для управления замками дверей
    if (RPMPRMSbits.can_number == 2)  ecan2WriteRxAcptFilter( (int)RPMPRMSbits.filt_number, (long)RPMPRMSbits.id,  (unsigned int)CAN2SETTINGSbits.ide, 15, 0); // байты команд ключа для управления замками дверей
    if (TOYOTAKEYDATbits.can_number == 2)  ecan2WriteRxAcptFilter( (int)TOYOTAKEYDATbits.filt_number, (long)TOYOTAKEYDATbits.id,  (unsigned int)CAN2SETTINGSbits.ide, 15, 0); // байты команд ключа для управления замками дверей
    if (CANBUTTONPRMSbits.can_number == 2)  ecan2WriteRxAcptFilter( (int)CANBUTTONPRMSbits.filt_number, (long)CANBUTTONPRMSbits.id,  (unsigned int)CAN2SETTINGSbits.ide, 15, 0); // байты команд ключа для управления замками дверей
    
    //    ecan2WriteRxAcptMask  ( 3, 0x1FFFFFF0, 1, 0 );
#if defined(FOR_TRUCK)    
    CAN2SETTINGSbits.ide = 1;   // extented - 29 bit 
    ecan2WriteRxAcptFilter( 15,(long)maskIDExtendedLow, (unsigned int)CAN2SETTINGSbits.ide, 15, 0); //
    ecan2WriteRxAcptMask  ( 1, maskIDExtendedHigh, 1, 1);
#endif    
/* Enter Normal Mode */
	C2CTRL1bits.REQOP=0;
	while(C2CTRL1bits.OPMODE!=0);
    
}
void switch_output_during_unlock (void) {

    static unsigned int /*timer = 0,*/ unlock_flag_tmp = 0;
    
    if ( OUTFUNCbits.pin15 == 0x0B || OUTFUNCbits.pin10 == 0x0B ) {

    } else {
        Nop();Nop();Nop();
        SWITCHOUTUNLTASKbits.SWITCHOUTUNLTASK = 0;
        return;        
    }
    
    
    
    if (SWITCHOUTUNLTASKbits.start == 0) {
        if (LOCKUNLOCKbits.start == 1 && LOCKUNLOCKbits.unlock == 1) {
            if ( ignition == 0 ) {
                unlock_flag_tmp = 1;
                LOCKUNLOCKbits.start = 0; 
                LOCKUNLOCKbits.unlock = 0;
                SWITCHOUTUNLTASKbits.start = 1;
                
                    if (OUTbits.arm_flag == 1) {
                        fire_rel_transaction_flag = 1;
                        ARMFLAGSbits.arm_timer = 0;
                        ARMFLAGSbits.arm_status = 0;
                        OUTbits.arm_flag = 0;
                        ARMFLAGSbits.arm_timer = 0;
                        ARMFLAGSbits.arm_status = 0;
                        ARMFLAGSbits.arm_on_event = 0;
                        ARMFLAGSbits.arm_on_event_sent = 0;
                        ARMFLAGSbits.intrusion_timer = 0;
                        ARMFLAGSbits.intr_event_trigg = 0;
                        ARMFLAGSbits.intr_event = 0;
                        ARMFLAGSbits.intr_event_sent = 0;
                        ARMFLAGSbits.arm_off_event = 1;
                        INTRREASONbits.INTRREASON = 0;                     
                    }
                
            }
        } else {
            Nop();Nop();Nop();
            //return;
        }
    }
    Nop();Nop();Nop();

    if (SWITCHOUTUNLTASKbits.start == 0) {
        SWITCHOUTUNLTASKbits.SWITCHOUTUNLTASK = 0;
        return;
    }
    
    if ( SWITCHOUTUNLTASKbits.timer < 500 ) {
        SWITCHOUTUNLTASKbits.timer ++;
# if defined (MCP23S08)
    
# else        
        if ( OUTFUNCbits.pin15 == 0x0B ) { L_OUT = 1; }
        if ( OUTFUNCbits.pin10 == 0x0B ) { OUT2 = 1; }
# endif        
    }
    else {
        SWITCHOUTUNLTASKbits.SWITCHOUTUNLTASK = 0;
# if defined (MCP23S08)
    
# else        
        if ( OUTFUNCbits.pin15 == 0x0B ) { L_OUT = 0; }
        if ( OUTFUNCbits.pin10 == 0x0B ) { OUT2 = 0; }
# endif        
    }
    
    if ( SWITCHOUTUNLTASKbits.timer == 100 ) {
        LOCKUNLOCKbits.start = 1; 
        LOCKUNLOCKbits.unlock = 1;        
    }
    
}
void lock_unlock_doors_thru_can (void) {
    static unsigned char counter = 0, counter1 = 0, can1_flag = 0, can2_flag = 0;


//    LOCKUNLOCKbits.start = 0;
//    can1_flag = 0; can2_flag = 0;
    if (LOCKUNLOCKbits.start == 0) { LOCKUNLOCKbits.LOCKUNLOCK = 0; counter1 = 0; counter = 0; return; }


///*X-RAY*/
//#if defined(X_RAY)    
//if ( CAN1SETTINGSbits.on == 1 && CAN1SETTINGSbits.ide == 0 ) {   
//    if ( LOCKUNLOCKbits.lock == 1 ) {
//        if ( LOCKUNLOCKbits.counter == 0 ) {
//            can1_flag = 1;
//            LOCKUNLOCKbits.counter = 1;
//            ecan1WriteTxMsgBufId ( 0, (long) 0x350, (unsigned int) 0, (unsigned int) 0 );
//            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x00C3, (unsigned int) 0x74C2, (unsigned int) 0x1414, (unsigned int) 0x8594 );
//            settxtransmit( 0 );
//            return;            
//        }
//        if ( LOCKUNLOCKbits.counter == 1 ) {
//            if (counter1 == 30) {
//                LOCKUNLOCKbits.counter = 2;
//                ecan1WriteTxMsgBufId ( 0, (long) 0x350, (unsigned int) 0, (unsigned int) 0 );
//                ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x00C3, (unsigned int) 0x74C2, (unsigned int) 0x1414, (unsigned int) 0x8594 );
//                settxtransmit( 0 );
//                return;
//            }
//        }        
//        if ( LOCKUNLOCKbits.counter == 2 ) {
//            if (counter1 == 60) {
//                LOCKUNLOCKbits.counter = 3;
//                ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );    
//                ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x1002, (unsigned int) 0x00C0, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                settxtransmit( 0 );
//                return;
//            }
//        }
//        if ( LOCKUNLOCKbits.counter == 3 ) {
//            if (counter1 == 90) {            
//                LOCKUNLOCKbits.counter = 4;
//                ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//                ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x3004, (unsigned int) 0x0001, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                settxtransmit( 0 );
//                return;
//            }
//        }
//    }//if ( LOCKUNLOCKbits.lock == 1 )
//
//    if ( LOCKUNLOCKbits.unlock == 1 ) { 
//        if ( LOCKUNLOCKbits.counter == 0 ) {
//            can1_flag = 1;
//            LOCKUNLOCKbits.counter = 1;
//            ecan1WriteTxMsgBufId ( 0, (long) 0x350, (unsigned int) 0, (unsigned int) 0 );
//            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x00C3, (unsigned int) 0x74C2, (unsigned int) 0x1414, (unsigned int) 0x8594 );
//            settxtransmit( 0 );
//            return;
//        }
//        if ( LOCKUNLOCKbits.counter == 1 ) {
//            if (counter1 == 30) {
//                LOCKUNLOCKbits.counter = 2;
//                ecan1WriteTxMsgBufId ( 0, (long) 0x350, (unsigned int) 0, (unsigned int) 0 );
//                ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x00C3, (unsigned int) 0x74C2, (unsigned int) 0x1414, (unsigned int) 0x8594 );
//                settxtransmit( 0 );
//                return;
//            }
//        }        
//        if ( LOCKUNLOCKbits.counter == 2 ) {
//            if (counter1 == 60) {
//                LOCKUNLOCKbits.counter = 3;
//                ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//                ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x1002, (unsigned int) 0x00C0, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                settxtransmit( 0 );
//            return;
//            }            
//        }
//        if ( LOCKUNLOCKbits.counter == 3 ) {
//            if (counter1 == 90) {
//                LOCKUNLOCKbits.counter = 4;
//                ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//                ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x3004, (unsigned int) 0x0001, (unsigned int) 0x0001, (unsigned int) 0x0000 );
//                settxtransmit( 0 );
//                return;
//            }
//        }
//
//    }//if ( LOCKUNLOCKbits.unlock == 1 )  
//    
//}
//#endif    
//   
///*VESTA*/
//# if defined (VESTA)
//if ( CAN1SETTINGSbits.on == 1 && CAN1SETTINGSbits.ide == 0 ) {     
//    if ( LOCKUNLOCKbits.lock == 1 ) {
//        if ( LOCKUNLOCKbits.counter == 0 ) {
//            can1_flag = 1;
//            LOCKUNLOCKbits.counter = 1;
//            ecan1WriteTxMsgBufId ( 0, (long) 0x5DE, (unsigned int) 0, (unsigned int) 0 );
//            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0200 );
//            settxtransmit( 0 );
//            return;            
//        }
//        if ( LOCKUNLOCKbits.counter == 1 ) {
//            LOCKUNLOCKbits.counter = 2;
//            ecan1WriteTxMsgBufId ( 0, (long) 0x5DE, (unsigned int) 0, (unsigned int) 0 );
//            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0200 );
//            settxtransmit( 0 );
//            return;            
//        }        
//        if ( LOCKUNLOCKbits.counter == 2 ) {
//            if (counter1 == 50) { 
//            LOCKUNLOCKbits.counter = 3;
//            ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );    
//            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x1002, (unsigned int) 0x00C0, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//            settxtransmit( 0 );
//            return;
//            }
//        }
//        if ( LOCKUNLOCKbits.counter == 3 ) {
//            LOCKUNLOCKbits.counter = 4;
////            LOCKUNLOCKbits.LOCKUNLOCK = 0;
//            ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x3004, (unsigned int) 0x0001, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//            settxtransmit( 0 );
//            
////            CANRESETbits.start = 1;
//            return;
//
//        }
//    }//if ( LOCKUNLOCKbits.lock == 1 )
//
//    if ( LOCKUNLOCKbits.unlock == 1 ) { 
//        if (boot_lock_unlock_flag == 0) {
//            if ( LOCKUNLOCKbits.counter == 0 ) {
//                can1_flag = 1;
//                LOCKUNLOCKbits.counter = 1;
//                ecan1WriteTxMsgBufId ( 0, (long) 0x5DE, (unsigned int) 0, (unsigned int) 0 );
//                ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0200 );
//                settxtransmit( 0 );
//                return;
//            }
//            if ( LOCKUNLOCKbits.counter == 1 ) {
//                LOCKUNLOCKbits.counter = 2;
//                ecan1WriteTxMsgBufId ( 0, (long) 0x5DE, (unsigned int) 0, (unsigned int) 0 );
//                ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0200 );
//                settxtransmit( 0 );
//                return;
//            }        
//            if ( LOCKUNLOCKbits.counter == 2 ) {
//                if (counter1 == 50) { 
//                LOCKUNLOCKbits.counter = 3;
//                ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//                ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x1002, (unsigned int) 0x00C0, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                settxtransmit( 0 );
//                return;
//                }            
//            }
//            if ( LOCKUNLOCKbits.counter == 3 ) {
//                LOCKUNLOCKbits.counter = 4;
//                ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//                ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x3004, (unsigned int) 0x0001, (unsigned int) 0x0001, (unsigned int) 0x0000 );
//                settxtransmit( 0 );
//                return;
//
//            }
//        } else {
//            if ( LOCKUNLOCKbits.counter == 0 ) {
//                can1_flag = 1;
//                LOCKUNLOCKbits.counter = 1;
//                ecan1WriteTxMsgBufId ( 0, (long) 0x5DE, (unsigned int) 0, (unsigned int) 0 );
//                ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0200 );
//                settxtransmit( 0 );
//                return;
//            }
//            if ( LOCKUNLOCKbits.counter == 1 ) {
//                LOCKUNLOCKbits.counter = 2;
//                ecan1WriteTxMsgBufId ( 0, (long) 0x5DE, (unsigned int) 0, (unsigned int) 0 );
//                ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0200 );
//                settxtransmit( 0 );
//                return;
//            }        
//            if ( LOCKUNLOCKbits.counter == 2 ) {
//                if (counter1 == 50) { 
//                LOCKUNLOCKbits.counter = 3;
//                ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//                ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x1002, (unsigned int) 0x00C0, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                settxtransmit( 0 );
//                return;
//                }            
//            }
//            if ( LOCKUNLOCKbits.counter == 3 ) {
//                LOCKUNLOCKbits.counter = 4;
//                ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//                ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x3003, (unsigned int) 0x0005, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                settxtransmit( 0 );
//                return;
//
//            }            
//        }
//
//    }//if ( LOCKUNLOCKbits.unlock == 1 )
//}
//#endif
//    
///*LANDROVER*/ 
//# if defined (FREELANDER2) 
//if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.ide == 0 ) {     
//    if ( LOCKUNLOCKbits.lock == 1 ) {
//
//        if ( LOCKUNLOCKbits.counter == 0 ) {
//                can2_flag = 1;
//            LOCKUNLOCKbits.counter = 1;
//            ecan2WriteTxMsgBufId ( 0, (long) 0x6C, (unsigned int) 0, (unsigned int) 0 );
//            ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x3800, (unsigned int) 0x081D, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//            settxtransmit2( 0 );
//            return;
//        }
//        if ( LOCKUNLOCKbits.counter == 1 ) {
//            
//            if (counter1 == 40) {
//                LOCKUNLOCKbits.counter = 2;
////                LOCKUNLOCKbits.LOCKUNLOCK = 0;
//                ecan2WriteTxMsgBufId ( 0, (long) 0x7E, (unsigned int) 0, (unsigned int) 0 );
//                ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x3B00, (unsigned int) 0x0A80, (unsigned int) 0x0100, (unsigned int) 0x64C0 );
//                settxtransmit2( 0 );
////                CANRESETbits.start = 1;
//                return;
//            }
//        }        
//
//    }//if ( LOCKUNLOCKbits.lock == 1 )
//
//    if ( LOCKUNLOCKbits.unlock == 1 ) { 
//
//        if ( LOCKUNLOCKbits.counter == 0 ) {
//                can2_flag = 1;
//            LOCKUNLOCKbits.counter = 1;
//            ecan2WriteTxMsgBufId ( 0, (long) 0x6C, (unsigned int) 0, (unsigned int) 0 );
//            ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x3800, (unsigned int) 0x081D, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//            settxtransmit2( 0 );
//            return;
//        }        
//        if ( LOCKUNLOCKbits.counter == 1 ) {
//            
//            if (counter1 == 50) { 
//                LOCKUNLOCKbits.counter = 2;
////                LOCKUNLOCKbits.LOCKUNLOCK = 0;
//                ecan2WriteTxMsgBufId ( 0, (long) 0x7E, (unsigned int) 0, (unsigned int) 0 );
//                ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x3B00, (unsigned int) 0x0A80, (unsigned int) 0x1F00, (unsigned int) 0x64C0 );
//                settxtransmit2( 0 );
////                CANRESETbits.start = 1;
//                return;
//            }
//        }    
//
//    }//if ( LOCKUNLOCKbits.unlock == 1 )    
//}
//# endif
//
///* INFINITY FX35 */
//# if defined (INFINITY_FX35)
//if ( CAN1SETTINGSbits.on == 1 && CAN1SETTINGSbits.ide == 0 ) {     
//    if ( LOCKUNLOCKbits.lock == 1 ) {
//        if ( LOCKUNLOCKbits.counter == 0 ) {
//            can1_flag = 1;
//            LOCKUNLOCKbits.counter = 1;
//            ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x1002, (unsigned int) 0xFFC0, (unsigned int) 0x0FFFF, (unsigned int) 0xFFFF );
//            settxtransmit( 0 );
//            return;            
//        }
//        if ( LOCKUNLOCKbits.counter == 1 ) {
//            LOCKUNLOCKbits.counter = 2;
//            ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x1002, (unsigned int) 0xFFC0, (unsigned int) 0xFFFF, (unsigned int) 0xFFFF );
//            settxtransmit( 0 );
//            return;            
//        }        
//        if ( LOCKUNLOCKbits.counter == 2 ) {
//            if (counter1 == 30) { 
//            LOCKUNLOCKbits.counter = 3;
//            ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );    
//            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x3004, (unsigned int) 0x0005, (unsigned int) 0xFF01, (unsigned int) 0xFFFF );
//            settxtransmit( 0 );
//            return;
//            }
//        }
////        if ( LOCKUNLOCKbits.counter == 3 ) {
////            LOCKUNLOCKbits.counter = 4;
////            ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
////            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x3004, (unsigned int) 0x0005, (unsigned int) 0xFF01, (unsigned int) 0xFFFF );
////            settxtransmit( 0 );
////            return;
////
////        }
//    }//if ( LOCKUNLOCKbits.lock == 1 )
//
//    if ( LOCKUNLOCKbits.unlock == 1 ) { 
//        if ( LOCKUNLOCKbits.counter == 0 ) {
//            can1_flag = 1;
//            LOCKUNLOCKbits.counter = 1;
//            ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x1002, (unsigned int) 0xFFC0, (unsigned int) 0xFFFF, (unsigned int) 0xFFFF );
//            settxtransmit( 0 );
//            return;
//        }
//        if ( LOCKUNLOCKbits.counter == 1 ) {
//            LOCKUNLOCKbits.counter = 2;
//            ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x1002, (unsigned int) 0xFFC0, (unsigned int) 0xFFFF, (unsigned int) 0xFFFF );
//            settxtransmit( 0 );
//            return;
//        }        
//        if ( LOCKUNLOCKbits.counter == 2 ) {
//            if (counter1 == 30) { 
//            LOCKUNLOCKbits.counter = 3;
//            ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x3004, (unsigned int) 0x0005, (unsigned int) 0xFF02, (unsigned int) 0xFFFF );
//            settxtransmit( 0 );
//            return;
//            }            
//        }
////        if ( LOCKUNLOCKbits.counter == 3 ) {
////            LOCKUNLOCKbits.counter = 4;
////            ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
////            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x1002, (unsigned int) 0x00C0, (unsigned int) 0x0001, (unsigned int) 0x0000 );
////            settxtransmit( 0 );
////            return;
////
////        }
//
//    }//if ( LOCKUNLOCKbits.unlock == 1 )
//}
//# endif
//
///*INFINITY FX 37*/ 
//# if defined (INFINITY_FX37)
//if ( CAN1SETTINGSbits.on == 1 && CAN1SETTINGSbits.ide == 0 ) {     
//    if ( LOCKUNLOCKbits.lock == 1 ) {
//        if ( LOCKUNLOCKbits.counter == 0 ) {
//            can1_flag = 1;
//            LOCKUNLOCKbits.counter = 1;
//            ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x1002, (unsigned int) 0xFFC0, (unsigned int) 0x0FFFF, (unsigned int) 0xFFFF );
//            settxtransmit( 0 );
//            return;            
//        }
//        if ( LOCKUNLOCKbits.counter == 1 ) {
//            LOCKUNLOCKbits.counter = 2;
//            ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x1002, (unsigned int) 0xFFC0, (unsigned int) 0x0FFFF, (unsigned int) 0xFFFF );
//            settxtransmit( 0 );
//            return;            
//        }        
//        if ( LOCKUNLOCKbits.counter == 2 ) {
//            if (counter1 == 30) { 
//            LOCKUNLOCKbits.counter = 3;
//            ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );    
//            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x3004, (unsigned int) 0x0007, (unsigned int) 0xFF01, (unsigned int) 0xFFFF );
//            settxtransmit( 0 );
//            return;
//            }
//        }
//
//    }//if ( LOCKUNLOCKbits.lock == 1 )
//
//    if ( LOCKUNLOCKbits.unlock == 1 ) { 
//        if ( LOCKUNLOCKbits.counter == 0 ) {
//            can1_flag = 1;
//            LOCKUNLOCKbits.counter = 1;
//            ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x1002, (unsigned int) 0xFFC0, (unsigned int) 0xFFFF, (unsigned int) 0xFFFF );
//            settxtransmit( 0 );
//            return;
//        }
//        if ( LOCKUNLOCKbits.counter == 1 ) {
//            LOCKUNLOCKbits.counter = 2;
//            ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x1002, (unsigned int) 0xFFC0, (unsigned int) 0xFFFF, (unsigned int) 0xFFFF );
//            settxtransmit( 0 );
//            return;
//        }        
//        if ( LOCKUNLOCKbits.counter == 2 ) {
//            if (counter1 == 30) { 
//            LOCKUNLOCKbits.counter = 3;
//            ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x3004, (unsigned int) 0x0007, (unsigned int) 0xFF02, (unsigned int) 0xFFFF );
//            settxtransmit( 0 );
//            return;
//            }            
//        }
//
//    }//if ( LOCKUNLOCKbits.unlock == 1 )
//}
//# endif    
//
///*LEXUS_CT200H*/
//#if defined(LEXUS_CT200H)    
//if ( CAN1SETTINGSbits.on == 1 && CAN1SETTINGSbits.ide == 0 ) {     
//    if ( LOCKUNLOCKbits.lock == 1 ) {
//        if ( LOCKUNLOCKbits.counter == 0 ) {
//            can1_flag = 1;
//            LOCKUNLOCKbits.counter = 1;
//            ecan1WriteTxMsgBufId ( 0, (long) 0x631, (unsigned int) 0, (unsigned int) 0 );
//            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x8018, (unsigned int) 0x0253, (unsigned int) 0x0A00, (unsigned int) 0x0000 );
//            settxtransmit( 0 );
//            return;            
//        }
//        if ( LOCKUNLOCKbits.counter == 1 ) {
//            if (counter1 == 20) {
//                LOCKUNLOCKbits.counter = 2;
//                ecan1WriteTxMsgBufId ( 0, (long) 0x631, (unsigned int) 0, (unsigned int) 0 );
//                ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x8018, (unsigned int) 0x0253, (unsigned int) 0x0A00, (unsigned int) 0x0000 );
//                settxtransmit( 0 );
//                return;
//            }
//        }        
////        if ( LOCKUNLOCKbits.counter == 2 ) {
////            if (counter1 == 40) {
////                LOCKUNLOCKbits.counter = 3;
////                ecan1WriteTxMsgBufId ( 0, (long) 0x631, (unsigned int) 0, (unsigned int) 0 );    
////                ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x8018, (unsigned int) 0x0253, (unsigned int) 0x0A00, (unsigned int) 0x0000 );
////                settxtransmit( 0 );
////                return;
////            }
////        }
//
//    }//if ( LOCKUNLOCKbits.lock == 1 )
//
//    if ( LOCKUNLOCKbits.unlock == 1 ) { 
//        if ( LOCKUNLOCKbits.counter == 0 ) {
//            can1_flag = 1;
//            LOCKUNLOCKbits.counter = 1;
//            ecan1WriteTxMsgBufId ( 0, (long) 0x631, (unsigned int) 0, (unsigned int) 0 );
//            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x8018, (unsigned int) 0x0453, (unsigned int) 0x0A00, (unsigned int) 0x0000 );
//            settxtransmit( 0 );
//            return;
//        }
//        if ( LOCKUNLOCKbits.counter == 1 ) {
//            if (counter1 == 20) {
//                LOCKUNLOCKbits.counter = 2;
//                ecan1WriteTxMsgBufId ( 0, (long) 0x631, (unsigned int) 0, (unsigned int) 0 );
//                ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x8018, (unsigned int) 0x0453, (unsigned int) 0x0A00, (unsigned int) 0x0000 );
//                settxtransmit( 0 );
//                return;
//            }
//        }        
////        if ( LOCKUNLOCKbits.counter == 2 ) {
////            if (counter1 == 40) {
////                LOCKUNLOCKbits.counter = 3;
////                ecan1WriteTxMsgBufId ( 0, (long) 0x631, (unsigned int) 0, (unsigned int) 0 );
////                ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x8018, (unsigned int) 0x0453, (unsigned int) 0x0A00, (unsigned int) 0x0000 );
////                settxtransmit( 0 );
////            return;
////            }            
////        }
//
//    }//if ( LOCKUNLOCKbits.unlock == 1 )    
//}
//#endif	
//	
///*AUDI_A6*/
//#if defined (AUDI_A6)
//    if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.ide == 0 && CAN2SETTINGSbits.bitrate == 500 ) {
//        
//        if ( LOCKUNLOCKbits.lock == 1 ) {
//
//                if (counter1 == 1 || counter1 == 11 || counter1 == 21 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x180, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//                }
//                if (counter1 == 31 || counter1 == 41 || counter1 == 51 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x180, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x4555, (unsigned int) 0x8000, (unsigned int) 0x2E20, (unsigned int) 0x0006 );
//                    settxtransmit2( 0 );
//                }       
//
//
//        }//if ( LOCKUNLOCKbits.lock == 1 )
//
//        if ( LOCKUNLOCKbits.unlock == 1 ) { 
//            
////            if ( LOCKUNLOCKbits.counter == 0 ) {
////                can1_flag = 1;
////                LOCKUNLOCKbits.counter = 1;
////                ecan1WriteTxMsgBufId ( 0, (long) 0x631, (unsigned int) 0, (unsigned int) 0 );
////                ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x8018, (unsigned int) 0x0453, (unsigned int) 0x0A00, (unsigned int) 0x0000 );
////                settxtransmit( 0 );
////                return;
////            }
////            if ( LOCKUNLOCKbits.counter == 1 ) {
////                if (counter1 == 20) {
////                    LOCKUNLOCKbits.counter = 2;
////                    ecan1WriteTxMsgBufId ( 0, (long) 0x631, (unsigned int) 0, (unsigned int) 0 );
////                    ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x8018, (unsigned int) 0x0453, (unsigned int) 0x0A00, (unsigned int) 0x0000 );
////                    settxtransmit( 0 );
////                    return;
////                }
////            }        
//
//                if (counter1 == 1 || counter1 == 11 || counter1 == 21 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x180, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//                }            
//                if (counter1 == 31 || counter1 == 41 || counter1 == 51 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x180, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0202, (unsigned int) 0x4000, (unsigned int) 0x2E10, (unsigned int) 0x0006 );
//                    settxtransmit2( 0 );
//                }
//        }//if ( LOCKUNLOCKbits.unlock == 1 )
//    
//    }
//
//#endif    
//
///*NISSAN*/
//# if defined (NISSAN)
//if ( CAN1SETTINGSbits.on == 1 && CAN1SETTINGSbits.ide == 0 ) { 
//    if ( LOCKUNLOCKbits.lock == 1 ) {
//        if ( LOCKUNLOCKbits.counter == 0 ) {
//            can1_flag = 1;
//            LOCKUNLOCKbits.counter = 1;
//            ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x1002, (unsigned int) 0xFFC0, (unsigned int) 0x0FFFF, (unsigned int) 0xFFFF );
//            settxtransmit( 0 );
//            return;            
//        }
//        if ( LOCKUNLOCKbits.counter == 1 ) {
//            LOCKUNLOCKbits.counter = 2;
//            ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x1002, (unsigned int) 0xFFC0, (unsigned int) 0x0FFFF, (unsigned int) 0xFFFF );
//            settxtransmit( 0 );
//            return;            
//        }        
//        if ( LOCKUNLOCKbits.counter == 2 ) {
//            if (counter1 == 30) { 
//            LOCKUNLOCKbits.counter = 3;
//            ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );    
//            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x3004, (unsigned int) 0x0005, (unsigned int) 0xFF01, (unsigned int) 0xFFFF );
//            settxtransmit( 0 );
//            return;
//            }
//        }
//
//    }//if ( LOCKUNLOCKbits.lock == 1 )
//
//    if ( LOCKUNLOCKbits.unlock == 1 ) { 
//        if ( LOCKUNLOCKbits.counter == 0 ) {
//            can1_flag = 1;
//            LOCKUNLOCKbits.counter = 1;
//            ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x1002, (unsigned int) 0xFFC0, (unsigned int) 0xFFFF, (unsigned int) 0xFFFF );
//            settxtransmit( 0 );
//            return;
//        }
//        if ( LOCKUNLOCKbits.counter == 1 ) {
//            LOCKUNLOCKbits.counter = 2;
//            ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x1002, (unsigned int) 0xFFC0, (unsigned int) 0xFFFF, (unsigned int) 0xFFFF );
//            settxtransmit( 0 );
//            return;
//        }        
//        if ( LOCKUNLOCKbits.counter == 2 ) {
//            if (counter1 == 30) { 
//            LOCKUNLOCKbits.counter = 3;
//            ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//            ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x3004, (unsigned int) 0x0005, (unsigned int) 0xFF02, (unsigned int) 0xFFFF );
//            settxtransmit( 0 );
//            return;
//            }            
//        }
//
//    }//if ( LOCKUNLOCKbits.unlock == 1 )
//}    
//#endif
//
///*Hyundai i40*/
//# if defined (HYUDAI_I40)
//if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.ide == 0 ) {     
//    if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.bitrate == 100 ) {    
//        if ( LOCKUNLOCKbits.lock == 1 ) {
//            if ( LOCKUNLOCKbits.counter == 0 ) {
//                can2_flag = 1;
//                LOCKUNLOCKbits.counter = 1;
//                ecan2WriteTxMsgBufId ( 0, (long) 0x705, (unsigned int) 0, (unsigned int) 0 );
//                ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0101, (unsigned int) 0x000F, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                settxtransmit2( 0 );
//                return;            
//            }
//            if ( LOCKUNLOCKbits.counter == 1 ) {
//                LOCKUNLOCKbits.counter = 2;
//                ecan2WriteTxMsgBufId ( 0, (long) 0x705, (unsigned int) 0, (unsigned int) 0 );
//                ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0101, (unsigned int) 0x000F, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                settxtransmit2( 0 );
//                return;            
//            }        
//            if ( LOCKUNLOCKbits.counter == 2 ) {
//                if (counter1 == 30) { 
//                LOCKUNLOCKbits.counter = 3;
//                ecan2WriteTxMsgBufId ( 0, (long) 0x705, (unsigned int) 0, (unsigned int) 0 );    
//                ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0021, (unsigned int) 0x100F, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                settxtransmit2( 0 );
//                return;
//                }
//            }
//
//        }//if ( LOCKUNLOCKbits.lock == 1 )
//
//        if ( LOCKUNLOCKbits.unlock == 1 ) { 
//            if ( LOCKUNLOCKbits.counter == 0 ) {
//                can2_flag = 1;
//                LOCKUNLOCKbits.counter = 1;
//                ecan2WriteTxMsgBufId ( 0, (long) 0x705, (unsigned int) 0, (unsigned int) 0 );
//                ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0101, (unsigned int) 0x000F, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                settxtransmit2( 0 );
//                return;
//            }
//            if ( LOCKUNLOCKbits.counter == 1 ) {
//                LOCKUNLOCKbits.counter = 2;
//                ecan2WriteTxMsgBufId ( 0, (long) 0x705, (unsigned int) 0, (unsigned int) 0 );
//                ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0101, (unsigned int) 0x000F, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                settxtransmit2( 0 );
//                return;
//            }        
//            if ( LOCKUNLOCKbits.counter == 2 ) {
//                if (counter1 == 30) { 
//                LOCKUNLOCKbits.counter = 3;
//                ecan2WriteTxMsgBufId ( 0, (long) 0x705, (unsigned int) 0, (unsigned int) 0 );
//                ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0021, (unsigned int) 0x110F, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                settxtransmit2( 0 );
//                return;
//                }            
//            }
//
//        }//if ( LOCKUNLOCKbits.unlock == 1 )
//    }    
//}
//#endif
//    
//
//# if defined (BMW_X3)
//if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.ide == 0 ) { 
//    if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.bitrate == 500 ) {    
//        if ( LOCKUNLOCKbits.lock == 1 ) {
//            if ( LOCKUNLOCKbits.counter == 0 ) {
//                can2_flag = 1;
//                LOCKUNLOCKbits.counter = 1;
//                ecan2WriteTxMsgBufId ( 0, (long) 0x2A0, (unsigned int) 0, (unsigned int) 0 );
//                ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x3333, (unsigned int) 0x0038, (unsigned int) 0xFFFF, (unsigned int) 0xFFFF );
//                settxtransmit2( 0 );
//                return;            
//            }
////            if ( LOCKUNLOCKbits.counter == 1 ) {
////                LOCKUNLOCKbits.counter = 2;
////                ecan2WriteTxMsgBufId ( 0, (long) 0x705, (unsigned int) 0, (unsigned int) 0 );
////                ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0101, (unsigned int) 0x000F, (unsigned int) 0x0000, (unsigned int) 0x0000 );
////                settxtransmit2( 0 );
////                return;            
////            }        
////            if ( LOCKUNLOCKbits.counter == 2 ) {
////                if (counter1 == 30) { 
////                LOCKUNLOCKbits.counter = 3;
////                ecan2WriteTxMsgBufId ( 0, (long) 0x705, (unsigned int) 0, (unsigned int) 0 );    
////                ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0021, (unsigned int) 0x100F, (unsigned int) 0x0000, (unsigned int) 0x0000 );
////                settxtransmit2( 0 );
////                return;
////                }
////            }
//
//        }//if ( LOCKUNLOCKbits.lock == 1 )
//
//        if ( LOCKUNLOCKbits.unlock == 1 ) { 
//            if ( LOCKUNLOCKbits.counter == 0 ) {
//                can2_flag = 1;
//                LOCKUNLOCKbits.counter = 1;
//                ecan2WriteTxMsgBufId ( 0, (long) 0x2A0, (unsigned int) 0, (unsigned int) 0 );
//                ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x1111, (unsigned int) 0x0018, (unsigned int) 0xFFFF, (unsigned int) 0xFFFF );
//                settxtransmit2( 0 );
//                return;
//            }
////            if ( LOCKUNLOCKbits.counter == 1 ) {
////                LOCKUNLOCKbits.counter = 2;
////                ecan2WriteTxMsgBufId ( 0, (long) 0x705, (unsigned int) 0, (unsigned int) 0 );
////                ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0101, (unsigned int) 0x000F, (unsigned int) 0x0000, (unsigned int) 0x0000 );
////                settxtransmit2( 0 );
////                return;
////            }        
////            if ( LOCKUNLOCKbits.counter == 2 ) {
////                if (counter1 == 30) { 
////                LOCKUNLOCKbits.counter = 3;
////                ecan2WriteTxMsgBufId ( 0, (long) 0x705, (unsigned int) 0, (unsigned int) 0 );
////                ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0021, (unsigned int) 0x110F, (unsigned int) 0x0000, (unsigned int) 0x0000 );
////                settxtransmit2( 0 );
////                return;
////                }            
////            }
//
//        }//if ( LOCKUNLOCKbits.unlock == 1 )
//    }    
//}    
//# endif
//    
///*VOLVO_XC70D*/
//#if defined (VOLVO_XC70D)
//    if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.ide == 0 && CAN2SETTINGSbits.bitrate == 125 ) { //125
//        
//        if ( LOCKUNLOCKbits.lock == 1 ) {
//
//                if (counter1 == 1 || counter1 == 11) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0xF5, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x43A0, (unsigned int) 0x20D8, (unsigned int) 0x01A0, (unsigned int) 0x0090 );
//                    settxtransmit2( 0 );
//                }
//
//        }//if ( LOCKUNLOCKbits.lock == 1 )
//
//        if ( LOCKUNLOCKbits.unlock == 1 ) { 
//            
//                if (counter1 == 1 || counter1 == 11) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0xF5, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x43A0, (unsigned int) 0x20D8, (unsigned int) 0x02A0, (unsigned int) 0x0090 );
//                    settxtransmit2( 0 );
//                }            
//
//        }//if ( LOCKUNLOCKbits.unlock == 1 )
//    
//    }
//
//#endif 
//
///*LIFAN_280*/
//#if defined (LIFAN_280)
//    if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.ide == 0 && CAN2SETTINGSbits.bitrate == 125 ) { //125
//        can2_flag = 1;
//        if ( LOCKUNLOCKbits.lock == 1 ) {
//
//                if (counter1 == 1) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x130, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0010, (unsigned int) 0x0002, (unsigned int) 0x0E04, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//                }
//
//        }//if ( LOCKUNLOCKbits.lock == 1 )
//
//        if ( LOCKUNLOCKbits.unlock == 1 ) { 
//            
//                if (counter1 == 1) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x130, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0004, (unsigned int) 0x0001, (unsigned int) 0x0E04, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//                }            
//
//        }//if ( LOCKUNLOCKbits.unlock == 1 )
//    
//    }
//#endif 
//    
///*BMW_X6*/
//#if defined (BMW_X6)
//    if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.ide == 0 && CAN2SETTINGSbits.bitrate == 100 ) { //100
//        can2_flag = 1;
//        if ( LOCKUNLOCKbits.lock == 1 ) {
//
//                if ( counter1 == 1 || counter1 == 11 || counter1 == 22 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x2A0, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x3333, (unsigned int) 0x0038, (unsigned int) 0x4418, (unsigned int) 0x0405 );
//                    settxtransmit2( 0 );
//                }
//
//        }//if ( LOCKUNLOCKbits.lock == 1 )
//
//        if ( LOCKUNLOCKbits.unlock == 1 ) { 
//            
//                if ( counter1 == 1 || counter1 == 11 || counter1 == 22 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x2A0, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x2221, (unsigned int) 0x0018, (unsigned int) 0x4100, (unsigned int) 0x0106 );
//                    settxtransmit2( 0 );
//                }            
//
//        }//if ( LOCKUNLOCKbits.unlock == 1 )
//    
//    }
//#endif
//    
///*BMW_X6*/
//#if defined (JAGUAR)
//    if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.ide == 0 && CAN2SETTINGSbits.bitrate == 125 ) {
//        can2_flag = 1;
//        if ( LOCKUNLOCKbits.lock == 1 ) {
//
//                if ( counter1 == 1 || counter1 == 11 || counter1 == 22 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x1C8, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x02CC, (unsigned int) 0x4847, (unsigned int) 0x013F, (unsigned int) 0x0120 );
//                    settxtransmit2( 0 );
//                }
//
//        }//if ( LOCKUNLOCKbits.lock == 1 )
//
//        if ( LOCKUNLOCKbits.unlock == 1 ) { 
//            
//                if ( counter1 == 1 || counter1 == 11 || counter1 == 22 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x1C8, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x02CC, (unsigned int) 0x4847, (unsigned int) 0x013F, (unsigned int) 0x0220 );
//                    settxtransmit2( 0 );
//                }            
//
//        }//if ( LOCKUNLOCKbits.unlock == 1 )
//    
//    }
//#endif    
//
///*PORSHE_CAENE*/
//#if defined (PORSHE_CAENE)
//    if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.ide == 0 && CAN2SETTINGSbits.bitrate == 500 ) { //100
//        can2_flag = 1;
//        if ( LOCKUNLOCKbits.lock == 1 ) {
//
//                if ( counter1 == 1 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x180, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//                }
//                if ( counter1 == 11 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x180, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0155, (unsigned int) 0x8000, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//                }
//        }//if ( LOCKUNLOCKbits.lock == 1 )
//
//        if ( LOCKUNLOCKbits.unlock == 1 ) { 
//            
//                if ( counter1 == 1 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x180, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//                }            
//                if ( counter1 == 11 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x180, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x000A, (unsigned int) 0x4000, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//                }
//        }//if ( LOCKUNLOCKbits.unlock == 1 )
//    
//    }
//#endif     
//
//
///*BMW_3_F30*/
//#if defined (BMW_3_F30)
//    if ( CAN1SETTINGSbits.on == 1 && CAN1SETTINGSbits.ide == 0 && CAN1SETTINGSbits.bitrate == 500 ) {
//        can1_flag = 1;
//        if ( LOCKUNLOCKbits.lock == 1 ) {
//
//                if ( counter1 == 1 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan1WriteTxMsgBufId ( 0, (long) 0x6F1, (unsigned int) 0, (unsigned int) 0 );
//                    ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0540, (unsigned int) 0x0131, (unsigned int) 0x57AC, (unsigned int) 0x0002 );
//                    settxtransmit( 0 );
//                }
//
//        }//if ( LOCKUNLOCKbits.lock == 1 )
//
//        if ( LOCKUNLOCKbits.unlock == 1 ) { 
//            
//                if ( counter1 == 1 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan1WriteTxMsgBufId ( 0, (long) 0x6F1, (unsigned int) 0, (unsigned int) 0 );
//                    ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0540, (unsigned int) 0x0131, (unsigned int) 0x57AC, (unsigned int) 0x0001 );
//                    settxtransmit( 0 );
//                }            
//
//        }//if ( LOCKUNLOCKbits.unlock == 1 )
//    
//    }
//#endif
//
///*AUDI_A5*/
//#if defined (AUDI_A5)
//    if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.ide == 0 && CAN2SETTINGSbits.bitrate == 500 ) { //100
//        
//        if ( LOCKUNLOCKbits.lock == 1 ) {
//                can2_flag = 1;
//                if (counter1 == 1 || counter1 == 3 || counter1 == 5 || counter1 == 7 || counter1 == 9) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x180, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0555, (unsigned int) 0x8000, (unsigned int) 0x2E20, (unsigned int) 0x0006 );
//                    settxtransmit2( 0 );
//
//                }
//       
//
//
//        }//if ( LOCKUNLOCKbits.lock == 1 )
//
//        if ( LOCKUNLOCKbits.unlock == 1 ) { 
//                can2_flag = 1;
//                if (counter1 == 1 || counter1 == 3 || counter1 == 5 || counter1 == 7 || counter1 == 9) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x180, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x02AA, (unsigned int) 0x4000, (unsigned int) 0x2E10, (unsigned int) 0x0006 );
//                    settxtransmit2( 0 );
//
//                }            
//
//        }//if ( LOCKUNLOCKbits.unlock == 1 )
//    
//    }
//
//#endif    
//    
///*KIA_RIO*/
//#if defined (KIA_RIO)
//    if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.ide == 0 && CAN2SETTINGSbits.bitrate == 100 ) {
//        
//        if ( LOCKUNLOCKbits.lock == 1 ) {
//                can2_flag = 1;
//                if ( counter1 == 1 || counter1 == 3 || counter1 == 5 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x003, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0000, (unsigned int) 0x0011, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//
//                }
//       
//
//
//        }//if ( LOCKUNLOCKbits.lock == 1 )
//
//        if ( LOCKUNLOCKbits.unlock == 1 ) { 
//                can2_flag = 1;
//                if ( counter1 == 1 || counter1 == 3 || counter1 == 5 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x003, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0000, (unsigned int) 0x0012, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//
//                }            
//
//        }//if ( LOCKUNLOCKbits.unlock == 1 )
//    
//    }
//
//#endif    
//
///*TOYOTA_HIGHLANDER_2014*/
//#if defined (TOYOTA_HIGHLANDER_2014)
//    if ( CAN1SETTINGSbits.on == 1 && CAN1SETTINGSbits.ide == 0 && CAN1SETTINGSbits.bitrate == 500 ) {
//        
//        if ( LOCKUNLOCKbits.lock == 1 ) {
//                can1_flag = 1;
//                if ( counter1 == 11 || counter1 == 21 || counter1 == 31 || counter1 == 41 || counter1 == 51 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan1WriteTxMsgBufId ( 0, (long) 0x631, (unsigned int) 0, (unsigned int) 0 );
//                    ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit( 0 );
//
//                }
//       
//                if ( counter1 == 61 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan1WriteTxMsgBufId ( 0, (long) 0x631, (unsigned int) 0, (unsigned int) 0 );
//                    ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x8018, (unsigned int) 0x5253, (unsigned int) 0xBE52, (unsigned int) 0x09B4 );
//                    settxtransmit( 0 );
//
//                }
//
//        }//if ( LOCKUNLOCKbits.lock == 1 )
//
//        if ( LOCKUNLOCKbits.unlock == 1 ) { 
//                can1_flag = 1;
//                if ( counter1 == 11 || counter1 == 21 || counter1 == 31 || counter1 == 41 || counter1 == 51 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan1WriteTxMsgBufId ( 0, (long) 0x631, (unsigned int) 0, (unsigned int) 0 );
//                    ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit( 0 );
//
//                }
//                
//                if ( counter1 == 61 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan1WriteTxMsgBufId ( 0, (long) 0x631, (unsigned int) 0, (unsigned int) 0 );
//                    ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x8018, (unsigned int) 0x5453, (unsigned int) 0xA652, (unsigned int) 0x17B4 );
//                    settxtransmit( 0 );
//
//                }                
//
//        }//if ( LOCKUNLOCKbits.unlock == 1 )
//    
//    }
//#endif     
//
///*KIA_RIO*/
//#if defined (HYUNDAI_SANTAFE_2014)
//    if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.ide == 0 && CAN2SETTINGSbits.bitrate == 100 ) {
//        
//        if ( LOCKUNLOCKbits.lock == 1 ) {
//                can2_flag = 1;
//                if ( counter1 == 1 || counter1 == 11 || counter1 == 21 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x002, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x8000, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//
//                }
//       
//
//
//        }//if ( LOCKUNLOCKbits.lock == 1 )
//
//        if ( LOCKUNLOCKbits.unlock == 1 ) { 
//                can2_flag = 1;
//                if ( counter1 == 1 || counter1 == 11 || counter1 == 21 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x002, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x4000, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//
//                }            
//
//        }//if ( LOCKUNLOCKbits.unlock == 1 )
//    
//    }
//
//#endif    
////
///*MERS_A_2016*/
//#if defined (MERS_A_2016)
//    if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.ide == 0 && CAN2SETTINGSbits.bitrate == 125 ) { //125
//        
//        if ( LOCKUNLOCKbits.lock == 1 ) {
//                can2_flag = 1;
//                if ( counter1 == 1 || counter1 == 11 || counter1 == 21 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x12D, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x6001, (unsigned int) 0xAAA0, (unsigned int) 0x9AA0, (unsigned int) 0x21B8 );
//                    settxtransmit2( 0 );
//
//                }
//       
//
//
//        }//if ( LOCKUNLOCKbits.lock == 1 )
//
//        if ( LOCKUNLOCKbits.unlock == 1 ) { 
//                can2_flag = 1;
//                if ( counter1 == 1 || counter1 == 11 || counter1 == 21 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x12D, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x9001, (unsigned int) 0x5550, (unsigned int) 0x9AA0, (unsigned int) 0x21B8 );
//                    settxtransmit2( 0 );
//
//                }            
//
//        }//if ( LOCKUNLOCKbits.unlock == 1 )
//    
//    }
//
//#endif    
//
///*FPRD_FOCUS3_TREND_SPORT*/ 
//#if defined (FORD_FOCUS3_TREND_SPORT)
//    if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.ide == 0 && CAN2SETTINGSbits.bitrate == 125 ) { //125
//        
//        if ( LOCKUNLOCKbits.lock == 1 ) {
//                can2_flag = 1;
//                if ( counter1 == 1) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x030, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0500, (unsigned int) 0x0820 );
//                    settxtransmit2( 0 );
//
//                }
//       
//
//
//        }//if ( LOCKUNLOCKbits.lock == 1 )
//
//        if ( LOCKUNLOCKbits.unlock == 1 ) { 
//                can2_flag = 1;
//                if ( counter1 == 1) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x030, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0600, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//
//                }            
//
//        }//if ( LOCKUNLOCKbits.unlock == 1 )
//    
//    }
//
//#endif     
//    
///*VW_JETTA_2017*/
//#if defined (VW_JETTA_2017)
//    if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.ide == 0 && CAN2SETTINGSbits.bitrate == 100 ) { //100
//        
//        if ( LOCKUNLOCKbits.lock == 1 ) {
//                can2_flag = 1;
//                if ( counter1 == 1 || counter1 == 11 || counter1 == 21 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x381, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 6, (unsigned int) 0x0C40, (unsigned int) 0x8400, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//
//                }
//       
//
//
//        }//if ( LOCKUNLOCKbits.lock == 1 )
//
//        if ( LOCKUNLOCKbits.unlock == 1 ) { 
//                can2_flag = 1;
//                if ( counter1 == 1 || counter1 == 11 || counter1 == 21 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x291, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 6, (unsigned int) 0x0A49, (unsigned int) 0x0002, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//
//                }            
//
//        }//if ( LOCKUNLOCKbits.unlock == 1 )
//    
//    }
//
//#endif    
//
///*HYUNDAI_SANTAFE_2012*/
//#if defined (HYUNDAI_SANTAFE_2012)
//    if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.ide == 0 && CAN2SETTINGSbits.bitrate == 100 ) {
//        
//        if ( LOCKUNLOCKbits.lock == 1 ) {
//                can2_flag = 1;
//                if ( counter1 == 1 || counter1 == 11 || counter1 == 21 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x000, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0030, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//
//                }
//       
//
//
//        }//if ( LOCKUNLOCKbits.lock == 1 )
//
//        if ( LOCKUNLOCKbits.unlock == 1 ) { 
//                can2_flag = 1;
//                if ( counter1 == 1 || counter1 == 11 || counter1 == 21 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x000, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0040, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//
//                }            
//
//        }//if ( LOCKUNLOCKbits.unlock == 1 )
//    
//    }
//
//#endif    
//
///*PORSHE_PANAMERA_2010*/
//#if defined (PORSHE_PANAMERA_2010)
//    if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.ide == 0 && CAN2SETTINGSbits.bitrate == 500 ) { //100
//        
//        if ( LOCKUNLOCKbits.lock == 1 ) {
//                can2_flag = 1;
//                if ( counter1 == 1 || counter1 == 11 || counter1 == 21 || counter1 == 31 || counter1 == 41 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x180, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//
//                }
//       
//                if ( counter1 == 51 || counter1 == 61 || counter1 == 71 || counter1 == 81 || counter1 == 91 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x180, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0055, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//
//                }
//
//        }//if ( LOCKUNLOCKbits.lock == 1 )
//
//        if ( LOCKUNLOCKbits.unlock == 1 ) { 
//                can2_flag = 1;
//                
//                if ( counter1 == 1 || counter1 == 11 || counter1 == 21 || counter1 == 31 || counter1 == 41 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x180, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//
//                }                
//                
//                if ( counter1 == 51 || counter1 == 61 || counter1 == 71 || counter1 == 81 || counter1 == 91 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x180, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x008A, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//
//                }            
//
//        }//if ( LOCKUNLOCKbits.unlock == 1 )
//    
//    }
//
//#endif    
//    
///*HYUNDAI_GENESIS_COUPE_2012*/
//#if defined (HYUNDAI_GENESIS_COUPE_2012)
//    if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.ide == 0 && CAN2SETTINGSbits.bitrate == 100 ) {
//        
//        if ( LOCKUNLOCKbits.lock == 1 ) {
//                can2_flag = 1;
//                if ( counter1 == 1 || counter1 == 6 || counter1 == 11 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x003, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0000, (unsigned int) 0x0001, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//
//                }
//       
//
//
//        }//if ( LOCKUNLOCKbits.lock == 1 )
//
//        if ( LOCKUNLOCKbits.unlock == 1 ) { 
//                can2_flag = 1;
//            if (boot_lock_unlock_flag == 0) {    
//                if ( counter1 == 1 || counter1 == 6 || counter1 == 11 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x003, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0000, (unsigned int) 0x0002, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//
//                }            
//            } else {
//                if ( counter1 == 1 || counter1 == 6 || counter1 == 11 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x003, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0080, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//
//                }                
//            }
//                
//        }//if ( LOCKUNLOCKbits.unlock == 1 )
//    
//    }
//
//#endif
//
///*LEXUS_LS600h*/
//#if defined (LEXUS_LS600h)
//    if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.ide == 0 && CAN2SETTINGSbits.bitrate == 250 ) { // 250
//        
//        if ( LOCKUNLOCKbits.lock == 1 ) {
//                can2_flag = 1;
//                if ( counter1 == 1 || counter1 == 11 || counter1 == 21 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x631, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x8018, (unsigned int) 0x0253, (unsigned int) 0x0B00, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//
//                }
//       
//
//
//        }//if ( LOCKUNLOCKbits.lock == 1 )
//
//        if ( LOCKUNLOCKbits.unlock == 1 ) { 
//                can2_flag = 1;
//            if (boot_lock_unlock_flag == 0) {    
//                if ( counter1 == 1 || counter1 == 11 || counter1 == 21 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x631, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x8018, (unsigned int) 0x0453, (unsigned int) 0x1300, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//
//                }            
//            } else {
//                if ( counter1 == 1 || counter1 == 11 || counter1 == 21 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan2WriteTxMsgBufId ( 0, (long) 0x631, (unsigned int) 0, (unsigned int) 0 );
//                    ecan2WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x8018, (unsigned int) 0x0853, (unsigned int) 0x1B05, (unsigned int) 0x0000 );
//                    settxtransmit2( 0 );
//
//                }                
//            }
//                
//        }//if ( LOCKUNLOCKbits.unlock == 1 )
//    
//    }
//
//#endif
//
///*TLC200_2012_2015*/
//#if defined (TLC200_2012_2015)
//    if ( CAN1SETTINGSbits.on == 1 && CAN1SETTINGSbits.ide == 0 && CAN1SETTINGSbits.bitrate == 500 ) {
//        
//        if ( LOCKUNLOCKbits.lock == 1 ) {
//                can1_flag = 1;
//                if ( counter1 == 1 || counter1 == 6 || counter1 == 11 || counter1 == 16 || counter1 == 21 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan1WriteTxMsgBufId ( 0, (long) 0x750, (unsigned int) 0, (unsigned int) 0 );
//                    ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0240, (unsigned int) 0xA321, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit( 0 );
//
//                }
//                if ( counter1 == 26 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan1WriteTxMsgBufId ( 0, (long) 0x750, (unsigned int) 0, (unsigned int) 0 );
//                    ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0540, (unsigned int) 0x1130, (unsigned int) 0x8000, (unsigned int) 0x0000 );
//                    settxtransmit( 0 );
//
//                }       
//
//
//        }//if ( LOCKUNLOCKbits.lock == 1 )
//
//        if ( LOCKUNLOCKbits.unlock == 1 ) { 
//                can1_flag = 1;
//            if (boot_lock_unlock_flag == 0) {    
//                if ( counter1 == 1 || counter1 == 6 || counter1 == 11 || counter1 == 16 || counter1 == 21 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan1WriteTxMsgBufId ( 0, (long) 0x750, (unsigned int) 0, (unsigned int) 0 );
//                    ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0240, (unsigned int) 0xA321, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit( 0 );
//
//                }
//                if ( counter1 == 26 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan1WriteTxMsgBufId ( 0, (long) 0x750, (unsigned int) 0, (unsigned int) 0 );
//                    ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0540, (unsigned int) 0x1130, (unsigned int) 0x4000, (unsigned int) 0x0000 );
//                    settxtransmit( 0 );
//
//                }                
//            } else {
//                if ( counter1 == 1 || counter1 == 6 || counter1 == 11 || counter1 == 16 || counter1 == 21 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan1WriteTxMsgBufId ( 0, (long) 0x750, (unsigned int) 0, (unsigned int) 0 );
//                    ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0240, (unsigned int) 0xA321, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit( 0 );
//
//                }
//                if ( counter1 == 26 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan1WriteTxMsgBufId ( 0, (long) 0x750, (unsigned int) 0, (unsigned int) 0 );
//                    ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x04B8, (unsigned int) 0x0130, (unsigned int) 0x8000, (unsigned int) 0x0000 );
//                    settxtransmit( 0 );
//
//                }                
//            }
//                
//        }//if ( LOCKUNLOCKbits.unlock == 1 )
//    
//    }
//
//#endif    
//    
///*NISSAN_MICRA_2005*/
//#if defined (NISSAN_MICRA_2005)
//    if ( CAN1SETTINGSbits.on == 1 && CAN1SETTINGSbits.ide == 0 && CAN1SETTINGSbits.bitrate == 500 ) {
//        
//        if ( LOCKUNLOCKbits.lock == 1 ) {
//                can1_flag = 1;
//                if ( counter1 == 1 || counter1 == 11 || counter1 == 21 || counter1 == 31 || counter1 == 41 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan1WriteTxMsgBufId ( 0, (long) 0x60D, (unsigned int) 0, (unsigned int) 0 );
//                    ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit( 0 );
//
//                }
//                if ( counter1 == 51 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//                    ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x1002, (unsigned int) 0xFFC0, (unsigned int) 0xFFFF, (unsigned int) 0xFFFF );
//                    settxtransmit( 0 );
//
//                }       
//                if ( counter1 == 61 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//                    ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x3004, (unsigned int) 0x0001, (unsigned int) 0xFF01, (unsigned int) 0xFFFF );
//                    settxtransmit( 0 );
//
//                }
//
//        }//if ( LOCKUNLOCKbits.lock == 1 )
//
//        if ( LOCKUNLOCKbits.unlock == 1 ) { 
//                can1_flag = 1;
//                if ( counter1 == 1 || counter1 == 11 || counter1 == 21 || counter1 == 31 || counter1 == 41 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan1WriteTxMsgBufId ( 0, (long) 0x60D, (unsigned int) 0, (unsigned int) 0 );
//                    ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000 );
//                    settxtransmit( 0 );
//
//                }
//                if ( counter1 == 51 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//                    ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x1002, (unsigned int) 0xFFC0, (unsigned int) 0xFFFF, (unsigned int) 0xFFFF );
//                    settxtransmit( 0 );
//
//                }       
//                if ( counter1 == 61 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//                    ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x3004, (unsigned int) 0x0001, (unsigned int) 0xFF02, (unsigned int) 0xFFFF );
//                    settxtransmit( 0 );
//
//                }              
//               
//                
//        }//if ( LOCKUNLOCKbits.unlock == 1 )
//    
//    }
//
//#endif    
//
///*NISSAN_QASHKAI_XTRAIL_2016*/    
//#if defined (NISSAN_QASHKAI_XTRAIL_2016)
//    if ( CAN1SETTINGSbits.on == 1 && CAN1SETTINGSbits.ide == 0 && CAN1SETTINGSbits.bitrate == 500 ) {
//        
//        if ( LOCKUNLOCKbits.lock == 1 ) {
//                can1_flag = 1;
//                if ( counter1 == 1 || counter1 == 11 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//                    ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x1002, (unsigned int) 0xFF03, (unsigned int) 0xFFFF, (unsigned int) 0xFFFF );
//                    settxtransmit( 0 );
//
//                }
//                if ( counter1 == 31 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//                    ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x2F06, (unsigned int) 0x0201, (unsigned int) 0x0003, (unsigned int) 0xFF01 );
//                    settxtransmit( 0 );
//
//                }       
//
//
//        }//if ( LOCKUNLOCKbits.lock == 1 )
//
//        if ( LOCKUNLOCKbits.unlock == 1 ) { 
//                can1_flag = 1;
//                if ( counter1 == 1 || counter1 == 11 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//                    ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x1002, (unsigned int) 0xFF03, (unsigned int) 0xFFFF, (unsigned int) 0xFFFF );
//                    settxtransmit( 0 );
//
//                }
//                if ( counter1 == 21 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan1WriteTxMsgBufId ( 0, (long) 0x745, (unsigned int) 0, (unsigned int) 0 );
//                    ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x2F06, (unsigned int) 0x0201, (unsigned int) 0x0003, (unsigned int) 0xFF02 );
//                    settxtransmit( 0 );
//
//                }       
//                
//        }//if ( LOCKUNLOCKbits.unlock == 1 )
//    
//    }
//
//#endif    
//
///*TOYOTA_CAMRY_2016*/
//#if defined (TOYOTA_CAMRY_2016)
//    if ( CAN1SETTINGSbits.on == 1 && CAN1SETTINGSbits.ide == 0 && CAN1SETTINGSbits.bitrate == 500 ) {
//        
//        if ( LOCKUNLOCKbits.lock == 1 ) {
//                can1_flag = 1;
//                if ( counter1 == 1 || counter1 == 21 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan1WriteTxMsgBufId ( 0, (long) 0x631, (unsigned int) 0, (unsigned int) 0 );
//                    ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x8018, (unsigned int) 0x0253, (unsigned int) 0x0A00, (unsigned int) 0x0000 );
//                    settxtransmit( 0 );
//
//                }
//        }//if ( LOCKUNLOCKbits.lock == 1 )
//
//        if ( LOCKUNLOCKbits.unlock == 1 ) { 
//                can1_flag = 1;
//            if (boot_lock_unlock_flag == 0) {    
//                if ( counter1 == 1 || counter1 == 21 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan1WriteTxMsgBufId ( 0, (long) 0x631, (unsigned int) 0, (unsigned int) 0 );
//                    ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x8018, (unsigned int) 0x0453, (unsigned int) 0x1A00, (unsigned int) 0x0000 );
//                    settxtransmit( 0 );
//
//                }
//            } else {
//                if ( counter1 == 1 || counter1 == 21 ) {
//                    LOCKUNLOCKbits.counter = 2;
//                    ecan1WriteTxMsgBufId ( 0, (long) 0x631, (unsigned int) 0, (unsigned int) 0 );
//                    ecan1WriteTxMsgBufData( 0, (unsigned int) 8, (unsigned int) 0x8018, (unsigned int) 0x0853, (unsigned int) 0x1A01, (unsigned int) 0x0000 );
//                    settxtransmit( 0 );
//
//                }
//            }
//                
//        }//if ( LOCKUNLOCKbits.unlock == 1 )
//    
//    }
//
//#endif        



        
        if ( LOCKUNLOCKbits.lock == 1 ) {

                if ( counter1 != 0 ) {
                    if (CLOCKSET1bits.can_number != 0) {
                        if ( CLOCKTIME1bits.B0 == counter1 || CLOCKTIME1bits.B1 == counter1 || CLOCKTIME1bits.B2 == counter1 || CLOCKTIME1bits.B3 == counter1 ||
                             CLOCKTIME1bits.B4 == counter1 || CLOCKTIME1bits.B5 == counter1 || CLOCKTIME1bits.B6 == counter1 || CLOCKTIME1bits.B7 == counter1 ) 
                        {
                            if (CLOCKSET1bits.can_number == 1) can1_flag = 1; if (CLOCKSET1bits.can_number == 2) can2_flag = 1;
                            send_lock_unlock_command (1, 0);
                        }
                    }
                    if (CLOCKSET2bits.can_number != 0) {
                        if ( CLOCKTIME2bits.B0 == counter1 || CLOCKTIME2bits.B1 == counter1 || CLOCKTIME2bits.B2 == counter1 || CLOCKTIME2bits.B3 == counter1 ||
                             CLOCKTIME2bits.B4 == counter1 || CLOCKTIME2bits.B5 == counter1 || CLOCKTIME2bits.B6 == counter1 || CLOCKTIME2bits.B7 == counter1 ) 
                        {
                            if (CLOCKSET2bits.can_number == 1) can1_flag = 1; if (CLOCKSET2bits.can_number == 2) can2_flag = 1;
                            send_lock_unlock_command (2, 0);
                        }
                    }
                    if (CLOCKSET3bits.can_number != 0) {
                        if ( CLOCKTIME3bits.B0 == counter1 || CLOCKTIME3bits.B1 == counter1 || CLOCKTIME3bits.B2 == counter1 || CLOCKTIME3bits.B3 == counter1 ||
                             CLOCKTIME3bits.B4 == counter1 || CLOCKTIME3bits.B5 == counter1 || CLOCKTIME3bits.B6 == counter1 || CLOCKTIME3bits.B7 == counter1 ) 
                        {
                            if (CLOCKSET3bits.can_number == 1) can1_flag = 1; if (CLOCKSET3bits.can_number == 2) can2_flag = 1;
                            send_lock_unlock_command (3, 0);
                        }
                    }                    
                }
                
                
        }//if ( LOCKUNLOCKbits.lock == 1 )

        if ( LOCKUNLOCKbits.unlock == 1 ) { 

            if (boot_lock_unlock_flag == 0) {    
                if ( counter1 != 0 ) {
                    if (CUNLOCKSET1bits.can_number != 0) {
                        if ( CLOCKTIME1bits.B0 == counter1 || CLOCKTIME1bits.B1 == counter1 || CLOCKTIME1bits.B2 == counter1 || CLOCKTIME1bits.B3 == counter1 ||
                             CLOCKTIME1bits.B4 == counter1 || CLOCKTIME1bits.B5 == counter1 || CLOCKTIME1bits.B6 == counter1 || CLOCKTIME1bits.B7 == counter1 ) 
                        {
                            if (CUNLOCKSET1bits.can_number == 1) can1_flag = 1; if (CUNLOCKSET1bits.can_number == 2) can2_flag = 1;
                            send_lock_unlock_command (4, 1); 

                        }
                    }
                    if (CUNLOCKSET2bits.can_number != 0) {
                        if ( CLOCKTIME2bits.B0 == counter1 || CLOCKTIME2bits.B1 == counter1 || CLOCKTIME2bits.B2 == counter1 || CLOCKTIME2bits.B3 == counter1 ||
                             CLOCKTIME2bits.B4 == counter1 || CLOCKTIME2bits.B5 == counter1 || CLOCKTIME2bits.B6 == counter1 || CLOCKTIME2bits.B7 == counter1 ) 
                        {
                            if (CUNLOCKSET2bits.can_number == 1) can1_flag = 1; if (CUNLOCKSET2bits.can_number == 2) can2_flag = 1;
                            send_lock_unlock_command (5, 1);
                        }
                    }
                    if (CUNLOCKSET3bits.can_number != 0) {
                        if ( CLOCKTIME3bits.B0 == counter1 || CLOCKTIME3bits.B1 == counter1 || CLOCKTIME3bits.B2 == counter1 || CLOCKTIME3bits.B3 == counter1 ||
                             CLOCKTIME3bits.B4 == counter1 || CLOCKTIME3bits.B5 == counter1 || CLOCKTIME3bits.B6 == counter1 || CLOCKTIME3bits.B7 == counter1 ) 
                        {
                            if (CUNLOCKSET3bits.can_number == 1) can1_flag = 1; if (CUNLOCKSET3bits.can_number == 2) can2_flag = 1;
                            send_lock_unlock_command (6, 1);
                        }
                    }
                }
            } else {
                if ( counter1 != 0 ) {

                    if (CBTUNLOCKSET1bits.can_number != 0) {
                        if ( CBTUNLOCKTIME1bits.B0 == counter1 || CBTUNLOCKTIME1bits.B1 == counter1 || CBTUNLOCKTIME1bits.B2 == counter1 || CBTUNLOCKTIME1bits.B3 == counter1 ||
                             CBTUNLOCKTIME1bits.B4 == counter1 || CBTUNLOCKTIME1bits.B5 == counter1 || CBTUNLOCKTIME1bits.B6 == counter1 || CBTUNLOCKTIME1bits.B7 == counter1 ) 
                        {
                            if (CBTUNLOCKSET1bits.can_number == 1) can1_flag = 1; if (CBTUNLOCKSET1bits.can_number == 2) can2_flag = 1;
                            send_lock_unlock_command (7, 0);
                        }
                    }
                    if (CBTUNLOCKSET2bits.can_number != 0) {
                        if ( CBTUNLOCKTIME2bits.B0 == counter1 || CBTUNLOCKTIME2bits.B1 == counter1 || CBTUNLOCKTIME2bits.B2 == counter1 || CBTUNLOCKTIME2bits.B3 == counter1 ||
                             CBTUNLOCKTIME2bits.B4 == counter1 || CBTUNLOCKTIME2bits.B5 == counter1 || CBTUNLOCKTIME2bits.B6 == counter1 || CBTUNLOCKTIME2bits.B7 == counter1 ) 
                        {
                            if (CBTUNLOCKSET2bits.can_number == 1) can1_flag = 1; if (CBTUNLOCKSET2bits.can_number == 2) can2_flag = 1;
                            send_lock_unlock_command (8, 0);
                        }
                    }
                    if (CBTUNLOCKSET3bits.can_number != 0) {
                        if ( CBTUNLOCKTIME3bits.B0 == counter1 || CBTUNLOCKTIME3bits.B1 == counter1 || CBTUNLOCKTIME3bits.B2 == counter1 || CBTUNLOCKTIME3bits.B3 == counter1 ||
                             CBTUNLOCKTIME3bits.B4 == counter1 || CBTUNLOCKTIME3bits.B5 == counter1 || CBTUNLOCKTIME3bits.B6 == counter1 || CBTUNLOCKTIME3bits.B7 == counter1 ) 
                        {
                            if (CBTUNLOCKSET3bits.can_number == 1) can1_flag = 1; if (CBTUNLOCKSET3bits.can_number == 2) can2_flag = 1;
                            send_lock_unlock_command (9, 0);
                        }
                    }                    

                }
            }
                
        }//if ( LOCKUNLOCKbits.unlock == 1 )
    

    
    
    if (counter1 >= 10 && counter1 <= 80) {
#if defined(FISICAL_LOCK)
    # if defined (MCP23S08)

    # else        
            if ( OUTFUNCbits.pin15 == 1 && OUTFUNCbits.pin10 == 1 ) {
                if ( LOCKUNLOCKbits.lock == 1 ) L_OUT = 1;
                if ( LOCKUNLOCKbits.unlock == 1 ) OUT2 = 1;
            } 
    # endif        
#endif
#if defined(ONE_WIRE_FISICAL_LOCK)
    # if defined (MCP23S08)

    # else        
            if (OUTFUNCbits.pin15 == 2) {
                L_OUT = 1;
            }
    # endif        
#endif            
    }
    else {
#if defined(FISICAL_LOCK)
    # if defined (MCP23S08)

    # else        
            if ( OUTFUNCbits.pin15 == 1 && OUTFUNCbits.pin10 == 1 ) {
               L_OUT = 0;
               OUT2 = 0;
            } 
    # endif        
#endif
#if defined(ONE_WIRE_FISICAL_LOCK) 
    # if defined (MCP23S08)

    # else        
            if (OUTFUNCbits.pin15 == 2) {
                L_OUT = 0;
            } 
    # endif        
#endif            
    }
    
    if (counter1 < 250) {counter1 ++;} // 60
    else {
    Nop();Nop();Nop();
    counter1 = 0; 
        if (can1_flag == 1) {can1_flag = 0; C1TR01CONbits.TXREQ0 = 0; }
        if (can2_flag == 1) {can2_flag = 0; C2TR01CONbits.TXREQ0 = 0; }

        if ( LOCKUNLOCKbits.lock == 1 ) send_lock_comand_status (1);
        if ( LOCKUNLOCKbits.unlock == 1 && boot_lock_unlock_flag == 0 ) send_lock_comand_status (0);
        LOCKUNLOCKbits.LOCKUNLOCK = 0;
        boot_lock_unlock_flag = 0;
    //    CANRESETbits.start = 1;
    }

    
}
void door_open_thru_can (void) {
    static unsigned char counter = 0, counter1 = 0, can1_flag = 0, can2_flag = 0;
    
    if ( fake_doors_open_type != 0 ) return;
    
    if (DOOROPENbits.start == 0) { DOOROPENbits.DOOROPEN = 0; counter1 = 0; counter = 0; return; }
    
    if (LOCKUNLOCKbits.start == 1) return;
    
        if ( counter1 != 0 ) {
            if (DOPENSET1bits.can_number != 0) {
                if ( DOPENTIME1bits.B0 == counter1 || DOPENTIME1bits.B1 == counter1 || DOPENTIME1bits.B2 == counter1 || DOPENTIME1bits.B3 == counter1 ) 
                {
                    door_open_autorun_flag = 1;
                    if (DOPENSET1bits.can_number == 1) can1_flag = 1; if (DOPENSET1bits.can_number == 2) can2_flag = 1;
                    send_door_open_command ();

                }
            }

        }
                
    if (counter1 < 250) {counter1 ++;} // 60
    else {
    Nop();Nop();Nop();
        DOOROPENbits.DOOROPEN = 0;
        counter1 = 0;
        door_open_autorun_flag = 0;
        if (can1_flag == 1) {can1_flag = 0; C1TR01CONbits.TXREQ0 = 0; }
        if (can2_flag == 1) {can2_flag = 0; C2TR01CONbits.TXREQ0 = 0; }

    }

    
}
void door_open_thru_can_type2 (void) {
    static unsigned int counter = 0, counter1 = 0, lock_open_done_flag = 0, can1_flag = 0, can2_flag = 0;
    
    if ( fake_doors_open_type != 1 ) return;
    
    if (DOOROPENbits.start == 0) { DOOROPENbits.DOOROPEN = 0; counter1 = 0; counter = 0; lock_open_done_flag = 0; return; }

    if ( counter < 270 ) counter ++;
    else {
        if ( lock_open_done_flag == 0 ) {
            lock_open_done_flag = 1;
//            counter = 0;
        }
    }
    if ( counter == 1 ) {
        LOCKUNLOCKbits.start = 1;
        LOCKUNLOCKbits.unlock = 1;
    }

    if ( lock_open_done_flag == 1 ) {
            if ( counter1 != 0 ) {
                if (DOPENSET1bits.can_number != 0) {
                    if ( DOPENTIME1bits.B0 == counter1 || DOPENTIME1bits.B1 == counter1 || DOPENTIME1bits.B2 == counter1 || DOPENTIME1bits.B3 == counter1 ) 
                    {
                        door_open_autorun_flag = 1;
                        if (DOPENSET1bits.can_number == 1) can1_flag = 1; if (DOPENSET1bits.can_number == 2) can2_flag = 1;
                        send_door_open_command ();

                    }
                }

            }

            if (counter1 < 250) {counter1 ++;} // 60
            else {
            Nop();Nop();Nop();
                DOOROPENbits.DOOROPEN = 0;
                counter1 = 0;
                counter = 0;
                door_open_autorun_flag = 0;
                lock_open_done_flag = 0;
                LOCKUNLOCKbits.start = 1;
                LOCKUNLOCKbits.lock = 1;
                if (can1_flag == 1) {can1_flag = 0; C1TR01CONbits.TXREQ0 = 0; }
                if (can2_flag == 1) {can2_flag = 0; C2TR01CONbits.TXREQ0 = 0; }
            }
    }
    
}

# if defined (LIN)
void second_ettempt_lin_unlock (void) {
static unsigned int counter = 0;


    if ( second_attempt == 0 ) { second_attempt_done = 0; counter = 0; return; }

    if ( counter < 50 ) counter ++;
    else {
        Nop();Nop();Nop();
        Nop();Nop();Nop();
//        lin_lock_flag_tmp2 = 0;
        if ( lin_lock_flag_tmp2 == 1 ) {
            counter = 0;
            second_attempt_done = 1;
            LINLOCKUNLOCKbits.start = 1; 
            LINLOCKUNLOCKbits.command = 1;
        } else {
            counter = 0;
            second_attempt = 0; 
            second_attempt_done = 0;
        }
    }

}
void lock_unlock_doors_thru_lin (void) {
//lin_sleep, lin_wake_transmitting, lin_sleep_counter;
static unsigned int timeout = 0;//, second_attempt = 0;    
    
    if (lin_sleep_counter < 150) lin_sleep_counter ++;
    else {
        lin_sleep = 1;
    }
    
    if (LINLOCKUNLOCKbits.start == 0) {
        LINLOCKUNLOCKbits.LINLOCKUNLOCK = 0;
        timeout = 0;
//        second_attempt = 0;
        return;
    }


        if ( timeout > 0 ) timeout --;

        if ( timeout == 1 ) {
            Nop();Nop();Nop();
            if (second_attempt_done == 1) {
                second_attempt_done = 0;
                second_attempt = 0;
                LINLOCKUNLOCKbits.LINLOCKUNLOCK = 0;
                return;                
            }
            if ( LINLOCKUNLOCKbits.unlock == 1 && ignition == 0 && second_attempt == 0 ) { //&& second_attempt == 0

                    LINLOCKUNLOCKbits.LINLOCKUNLOCK = 0;
                    second_attempt = 1;
                    LINLOCKUNLOCKbits.LINLOCKUNLOCK = 0;

            } else {
                LINLOCKUNLOCKbits.LINLOCKUNLOCK = 0;
                return;
            }
        }


    
    if (lin_sleep == 1) {
        if (LINLOCKUNLOCKbits.wake_sent == 0) {
            IEC5bits.U3RXIE = 0;
                LINLOCKUNLOCKbits.wake_sent = 1;
                timeout = 250;
                lin_wake_transmitting = 1;
                UART3_Tx_buf[0] = 0x80;
                start_UART3_LIN_transmission ( 1 );
            IEC5bits.U3RXIE = 1;
        }
    } else {
    
        if (LINLOCKUNLOCKbits.running == 0) { // && timeout == 0 
// Запрет прерываний UART3
            IEC5bits.U3RXIE = 0;
                LINLOCKUNLOCKbits.running = 1;
                
                    if (LINLOCKUNLOCKbits.command == 0) { //0 – закрыть при включенном зажигании LINLOCKDATAbits 
                        LINLOCKUNLOCKbits.lock = 1;
                        if ( ignition == 1) {// || key_unlock_ign_on_timer != 00 – (кнопочная)закрыть при включенном зажигании 
                            UART3_Tx_buf[0] = LINLOCKDATAbits.byte0; UART3_Tx_buf[1] = LINLOCKDATAbits.byte1;
                            UART3_Tx_buf[2] = LINLOCKDATAbits.byte2; UART3_Tx_buf[3] = LINLOCKDATAbits.byte3;
                            UART3_Tx_buf[4] = LINLOCKDATAbits.byte4; UART3_Tx_buf[5] = LINLOCKDATAbits.byte5;
                            UART3_Tx_buf[6] = LINLOCKDATAbits.byte6; UART3_Tx_buf[7] = LINLOCKDATAbits.byte7;
                            
//                            UART3_Tx_buf[LIN_LOCK_LENGTH - 2] = lin_status_byte;
//                            LIN_LOCK_CRC = LIN_CRC_calc( UART3_Tx_buf, (LIN_LOCK_LENGTH - 1), 1 );                            
                            
                            UART3_Tx_buf[LIN_LOCK_LENGTH - 1] = LIN_LOCK_CRC; 
                            LIN_TRANSMITTION_LENGTH = LIN_LOCK_LENGTH;
                            num_of_lin_transmittions = LIN_LOCK_TRANSMITTION_ATTEMPTS;
                            lin_counter = 2;
                        } else {//2 – (брелочная) закрыть при выключенном зажигании LINLOCKDATA2bits
                            UART3_Tx_buf[0] = LINLOCKDATA2bits.byte0; UART3_Tx_buf[1] = LINLOCKDATA2bits.byte1;
                            UART3_Tx_buf[2] = LINLOCKDATA2bits.byte2; UART3_Tx_buf[3] = LINLOCKDATA2bits.byte3;
                            UART3_Tx_buf[4] = LINLOCKDATA2bits.byte4; UART3_Tx_buf[5] = LINLOCKDATA2bits.byte5;
                            UART3_Tx_buf[6] = LINLOCKDATA2bits.byte6; UART3_Tx_buf[7] = LINLOCKDATA2bits.byte7;
                            
//                            UART3_Tx_buf[LIN_LOCK_LENGTH2 - 2] = lin_status_byte;
//                            LIN_LOCK_CRC2 = LIN_CRC_calc( UART3_Tx_buf, (LIN_LOCK_LENGTH2 - 1), 1 );                            
                            
                            UART3_Tx_buf[LIN_LOCK_LENGTH2 - 1] = LIN_LOCK_CRC2; 
                            LIN_TRANSMITTION_LENGTH = LIN_LOCK_LENGTH2;
                            num_of_lin_transmittions = LIN_LOCK_TRANSMITTION_ATTEMPTS2;
                            lin_counter = 2;
                        }

                        if (timeout != 1) generate_content_of_message ( 43, 1 );
                    }
                    else { 
                        LINLOCKUNLOCKbits.unlock = 1;
                        if ( ignition == 1) {// || key_unlock_ign_on_timer != 0 1 – (кнопочная) открыть при включенном зажигании LINUNLOCKDATAbits
                            UART3_Tx_buf[0] = LINUNLOCKDATAbits.byte0; UART3_Tx_buf[1] = LINUNLOCKDATAbits.byte1;
                            UART3_Tx_buf[2] = LINUNLOCKDATAbits.byte2; UART3_Tx_buf[3] = LINUNLOCKDATAbits.byte3;
                            UART3_Tx_buf[4] = LINUNLOCKDATAbits.byte4; UART3_Tx_buf[5] = LINUNLOCKDATAbits.byte5;
                            UART3_Tx_buf[6] = LINUNLOCKDATAbits.byte6; UART3_Tx_buf[7] = LINUNLOCKDATAbits.byte7;
                            
//                            UART3_Tx_buf[LIN_UNLOCK_LENGTH - 2] = lin_status_byte;
//                            LIN_UNLOCK_CRC = LIN_CRC_calc( UART3_Tx_buf, (LIN_UNLOCK_LENGTH - 1), 1 );                            
                            
                            UART3_Tx_buf[LIN_UNLOCK_LENGTH - 1] = LIN_UNLOCK_CRC; 
                            LIN_TRANSMITTION_LENGTH = LIN_UNLOCK_LENGTH;
                            num_of_lin_transmittions = LIN_UNLOCK_TRANSMITTION_ATTEMPTS;
                            lin_counter = 2;
                        } else {//3 – (брелочная) открыть при выключенном зажигании LINUNLOCKDATA2bits
                            UART3_Tx_buf[0] = LINUNLOCKDATA2bits.byte0; UART3_Tx_buf[1] = LINUNLOCKDATA2bits.byte1;
                            UART3_Tx_buf[2] = LINUNLOCKDATA2bits.byte2; UART3_Tx_buf[3] = LINUNLOCKDATA2bits.byte3;
                            UART3_Tx_buf[4] = LINUNLOCKDATA2bits.byte4; UART3_Tx_buf[5] = LINUNLOCKDATA2bits.byte5;
                            UART3_Tx_buf[6] = LINUNLOCKDATA2bits.byte6; UART3_Tx_buf[7] = LINUNLOCKDATA2bits.byte7;
                            
//                            UART3_Tx_buf[LIN_UNLOCK_LENGTH2 - 2] = lin_status_byte;
//                            LIN_UNLOCK_CRC2 = LIN_CRC_calc( UART3_Tx_buf, (LIN_UNLOCK_LENGTH2 - 1), 1 );                            
                            
                            UART3_Tx_buf[LIN_UNLOCK_LENGTH2 - 1] = LIN_UNLOCK_CRC2; 
                            LIN_TRANSMITTION_LENGTH = LIN_UNLOCK_LENGTH2;
                            num_of_lin_transmittions = LIN_UNLOCK_TRANSMITTION_ATTEMPTS2;
                            lin_counter = 2;
                        }
                        
                        generate_content_of_message ( 44, 1 );
                    }
                timeout = 250;
                IEC5bits.U3RXIE = 1;
// разрешение прерываний UART3
        }
    }

}
void unlock_boot_thru_lin_tasck (void) {
    static unsigned int counter = 0;

    if ( lin_boot_unlock_start == 0 ) {
        counter = 0; 
        return;
    }
    
    if ( counter < 400 ) counter ++;
    else {
        counter = 0;
        lin_boot_unlock_start = 0;
        LINBOOTUNLOCKbits.LINBOOTUNLOCK = 0;
    }
    
    if ( counter == 1 || counter == 200 ) {
        LINBOOTUNLOCKbits.start = 1;
        
    }
    
}
void unlock_boot_thru_lin (void) {
//lin_sleep, lin_wake_transmitting, lin_sleep_counter;
static unsigned int timeout = 0;    
    
    
    if (LINBOOTUNLOCKbits.start == 0) {
        LINBOOTUNLOCKbits.LINBOOTUNLOCK = 0;
        timeout = 0;
        return;
    }


        if ( timeout > 0 ) timeout --;

        if ( timeout == 1 ) LINBOOTUNLOCKbits.LINBOOTUNLOCK = 0;


    
    if (lin_sleep == 1 && LINBOOTUNLOCKbits.wake_sent == 0) {
        if (LINBOOTUNLOCKbits.wake_sent == 0) {
            IEC5bits.U3RXIE = 0;
                LINBOOTUNLOCKbits.wake_sent = 1;
                timeout = 250;
                lin_wake_transmitting = 1;
                UART3_Tx_buf[0] = 0x80;
                start_UART3_LIN_transmission ( 1 );
            IEC5bits.U3RXIE = 1;
        }
    } else {
    
        if (LINBOOTUNLOCKbits.running == 0) { // && timeout == 0 
// Запрет прерываний UART3
            IEC5bits.U3RXIE = 0;
                LINBOOTUNLOCKbits.running = 1;
                
                    if (LINBOOTUNLOCKbits.command == 0) { 
                        LINBOOTUNLOCKbits.unlock = 1; 
                        UART3_Tx_buf[0] = LINBOOTUNLOCKDATAbits.byte0; UART3_Tx_buf[1] = LINBOOTUNLOCKDATAbits.byte1;
                        UART3_Tx_buf[2] = LINBOOTUNLOCKDATAbits.byte2; UART3_Tx_buf[3] = LINBOOTUNLOCKDATAbits.byte3;
                        UART3_Tx_buf[4] = LINBOOTUNLOCKDATAbits.byte4; UART3_Tx_buf[5] = LINBOOTUNLOCKDATAbits.byte5;
                        UART3_Tx_buf[6] = LINBOOTUNLOCKDATAbits.byte6; UART3_Tx_buf[7] = LINBOOTUNLOCKDATAbits.byte7;
                        
                        UART3_Tx_buf[LIN_BOOT_UNLOCK_LENGTH - 2] = lin_status_byte;
                        
                        LIN_BOOT_UNLOCK_CRC = LIN_CRC_calc( UART3_Tx_buf, (LIN_BOOT_UNLOCK_LENGTH - 1), 1 );
                        
                        UART3_Tx_buf[LIN_BOOT_UNLOCK_LENGTH - 1] = LIN_BOOT_UNLOCK_CRC; 
                        LIN_TRANSMITTION_LENGTH = LIN_BOOT_UNLOCK_LENGTH;
                        num_of_lin_transmittions = LIN_BOOT_UNLOCK_TRANSMITTION_ATTEMPTS;
//                        generate_content_of_message ( 44, 1 );
                    }
                timeout = 250;
                IEC5bits.U3RXIE = 1;
// разрешение прерываний UART3
        }
       
    }

}
void start_UART3_LIN_transmission ( int length ) {
// Data transmit the data using interrupts
    U3_Tx_length = length;
    Tx3_DataAvailable = 0;
//    U3STAbits.UTXBRK = 1;
//    Tx3_num = 1;
//    WriteUART3((unsigned int)0);
    IEC5bits.U3TXIE = 1;
    IFS5bits.U3TXIF = 1;

}

int  apply_LIN_settings( char *ptr ) {
    
char param, ADDR, /*number_of_filter,*/ number_of_byte, bit_mask, inv, enable, len;
int temp;
unsigned char byte1, byte2, byte3, byte4;//, byte5;


    param = 0;
    
    if (*(ptr + 5) != '=' || *(ptr + 8) != ',' || *(ptr + 10) != ',' || *(ptr + 12) != ',' || 
        *(ptr + 15) != ',' ) return 0;


    
// Номер параметра 
    param = 0; temp = 0;
    temp = get_nibble_from_str ( ptr + 6 );
    if (temp == -1) return 0;
    param = temp;
    temp = get_nibble_from_str ( ptr + 7 );
    if (temp == -1) return 0;
    param = (param << 4) + temp;
    if (param > 31) return 0;

// Вкл/выкл
    enable = 0; temp = 0;
    temp = get_nibble_from_str ( ptr + 9 );
    if (temp == -1) return 0;
    enable = temp; 
    if ( enable != 0 && enable != 1 ) return 0;    

// Длина
    len = 0; temp = 0;
    temp = get_nibble_from_str ( ptr + 11 );
    if (temp == -1) return 0;
    len = temp; 
    if ( len == 0 || len > 31 ) return 0;
    
// Адрес
    ADDR = 0; temp = 0;
    temp = get_nibble_from_str ( ptr + 13 );
    if (temp == -1) return 0;
    ADDR = temp;
    temp = get_nibble_from_str ( ptr + 14 );
    if (temp == -1) return 0;
    ADDR = (ADDR << 4) + temp;
    
 

    
    if (param == 0x01) {
        
// Номер байта
        number_of_byte = 0; temp = 0;
        temp = get_nibble_from_str ( ptr + 16 );
        if (temp == -1) return 0;
        number_of_byte = temp;
        if (number_of_byte > 7) return 0;

// Маска
        bit_mask = 0; temp = 0; 
        temp = get_nibble_from_str ( ptr + 18 );
        if (temp == -1) return 0;
        bit_mask = temp;
        temp = get_nibble_from_str ( ptr + 19 );
        if (temp == -1) return 0;
        bit_mask = (bit_mask << 4) + temp;

// Инверсия
        inv = 0; temp = 0;
        temp = get_nibble_from_str ( ptr + 21 );
        if (temp == -1) return 0;
        inv = temp;
        if (inv != 0 && inv != 1) return 0;        
        
        LINLOCKPSTATPRMSbits.addr = ADDR;
        LINLOCKPSTATPRMSbits.bit_mask = bit_mask;
        LINLOCKPSTATPRMSbits.byte = number_of_byte;
        LINLOCKPSTATPRMSbits.enable = enable;
        LINLOCKPSTATPRMSbits.inv = inv;
        LINLOCKPSTATPRMSbits.param = param;
        LINLOCKPSTATPRMSbits.len = len;
        FM25_write_4( 1837, (unsigned long) LINLOCKPSTATPRMSbits.LINLOCKPSTATPRMS );
    }
    
    if (param == 0x02) {
// Номер байта кнопки открывания
        byte1 = 0; temp = 0;
        temp = get_nibble_from_str ( ptr + 16 );
        if (temp == -1) return 0;
        byte1 = temp;
        if (byte1 > 7) return 0;
// Номер бита кнопки открывания
        byte2 = 0; temp = 0;
        temp = get_nibble_from_str ( ptr + 18 );
        if (temp == -1) return 0;
        byte2 = temp;
        if (byte2 > 7) return 0;
// Номер байта кнопки открывания
        byte3 = 0; temp = 0;
        temp = get_nibble_from_str ( ptr + 20 );
        if (temp == -1) return 0;
        byte3 = temp;
        if (byte3 > 7) return 0;
// Номер бита кнопки открывания
        byte4 = 0; temp = 0;
        temp = get_nibble_from_str ( ptr + 22 );
        if (temp == -1) return 0;
        byte4 = temp;
        if (byte4 > 7) return 0;

        LINCOMMANDSTATPRMSbits.enable = enable;
        LINCOMMANDSTATPRMSbits.addr   = ADDR;
        LINCOMMANDSTATPRMSbits.len    = len;
        LINCOMMANDSTATPRMSbits.byte_unlock = byte1;
        LINCOMMANDSTATPRMSbits.bit_unlock  = byte2;
        LINCOMMANDSTATPRMSbits.byte_lock   = byte3;
        LINCOMMANDSTATPRMSbits.bit_lock    = byte4;
        
        FM25_write_4( 1926, (unsigned long) LINCOMMANDSTATPRMSbits.LINCOMMANDSTATPRMS );
        
    } 
    
    
    return 1;
}
void apply_LIN_data ( void ) {
    
//    static unsigned char lin_lock_flag_tmp = 0, lin_lock_flag = 0;
    volatile int i, crc;
    static volatile int fuel_level_lin_tmp = 0, overage_counter = 0, tmp;
    volatile unsigned char bit_mask;

    if (Start_accumulation3 == 1) return;
    
// СТАТУС ЗАМКОВ
    if ( LINLOCKPSTATPRMSbits.enable != 0 && ( LINLOCKPSTATPRMSbits.addr == LIN_Rx_copy_buf[2] && LINLOCKUNLOCKbits.start == 0 )) { 
//        LIN_Rx_copy_buf[3] = 0x00; LIN_Rx_copy_buf[4] = 0x20; LIN_Rx_copy_buf[5] = 0x20; LIN_Rx_copy_buf[6] = 0x40; LIN_Rx_copy_buf[7] = 0x7F;
        crc = 0;
        for (i = 0; i < LINLOCKPSTATPRMSbits.len; i ++) { //  расчет контрольной суммы
            crc = crc + LIN_Rx_copy_buf[i + 3];
        }
        i = crc % 0xFF;
        crc = i + LIN_Rx_copy_buf [ LINLOCKPSTATPRMSbits.len + 3 ];//crc + LIN_Rx_copy_buf [ LINLOCKPSTATPRMSbits.len + 3 ];
        if ( crc == 0xFF ) {
            
            lin_status_byte = LIN_Rx_copy_buf [ LINLOCKPSTATPRMSbits.len + 2 ];
            
            if (( LIN_Rx_copy_buf[ (LINLOCKPSTATPRMSbits.byte + 2) ] & LINLOCKPSTATPRMSbits.bit_mask )) {
                if (LINLOCKPSTATPRMSbits.inv == 1) lin_lock_flag = 0; else lin_lock_flag = 1;
            } else {
                if (LINLOCKPSTATPRMSbits.inv == 1) lin_lock_flag = 1; else lin_lock_flag = 0;
            }

//            if ( lin_lock_flag != lin_lock_flag_tmp ) {
//                if (lin_lock_flag == 1) generate_content_of_message ( 36, 1 ); // Замки закрылись
//                else generate_content_of_message ( 35, 1 );  // Замки открылись
//            }
//            lin_lock_flag_tmp = lin_lock_flag;
        }
    }
    
    
// СТАТУС КНОПКИ КЛЮЧА
/*    
LIN_Rx_copy_buf[0] = 0x00; LIN_Rx_copy_buf[1] = 0x55; LIN_Rx_copy_buf[2] = 0x03;    
LIN_Rx_copy_buf[3] = 0x00; LIN_Rx_copy_buf[4] = 0x80; LIN_Rx_copy_buf[5] = 0x00; LIN_Rx_copy_buf[6] = 0xC0; LIN_Rx_copy_buf[7] = 0xBE;
*/    
    if ( LINCOMMANDSTATPRMSbits.enable == 1 && ignition == 1 && key_unlock_ign_on_timer ==0 && ( LINCOMMANDSTATPRMSbits.addr == LIN_Rx_copy_buf[2] && LINLOCKUNLOCKbits.start == 0 )) { 
        crc = 0;
        for (i = 0; i < LINCOMMANDSTATPRMSbits.len; i ++) { //  расчет контрольной суммы
            crc = crc + LIN_Rx_copy_buf[i + 3];
        }
        i = crc % 0xFF;
        crc = i + LIN_Rx_copy_buf [ LINCOMMANDSTATPRMSbits.len + 3 ];
        if ( crc == 0xFF ) {
            
            bit_mask = get_bitmask_from_number ( LINCOMMANDSTATPRMSbits.bit_unlock );

            if (( LIN_Rx_copy_buf[ (LINCOMMANDSTATPRMSbits.byte_unlock + 3) ] & bit_mask )) {
                Nop();Nop();Nop();
                if ( lin_lock_flag_tmp2 == 1 ){ // если закрыты, открываем

                        key_unlock_ign_on_timer = 200;
                        LINLOCKUNLOCKbits.start = 1; LINLOCKUNLOCKbits.command = 1;

                }
                
            } 
            bit_mask = get_bitmask_from_number ( LINCOMMANDSTATPRMSbits.bit_lock );

            if (( LIN_Rx_copy_buf[ (LINCOMMANDSTATPRMSbits.byte_lock + 3) ] & bit_mask )) {
                Nop();Nop();Nop();
                if ( lin_lock_flag_tmp2 == 0 ){ // если открыты, закрываем

                        key_unlock_ign_on_timer = 200;
                        LINLOCKUNLOCKbits.start = 1; LINLOCKUNLOCKbits.command = 0;

                }
            }

        }
    }    


// Топливо с датчика
    if ( LIN_Rx_copy_buf[2] == 0x03 && fuel_sensor_enable != 0 ) {
        
        crc = 0;
        for (i = 0; i < 6; i ++) { //  расчет контрольной суммы
            crc = crc + LIN_Rx_copy_buf[i + 3];
        }
        i = crc % 0xFF;
        crc = i + LIN_Rx_copy_buf [ 6 + 3 ];
        crc = 0xFF;
        if ( crc == 0xFF ) {
            
        switch ( fuel_sensor_enable ) {
            
            if ( ignition == 0 ) {
                overage_counter = 0;
                fuel_level_lin_tmp = 0;
            }
            
            case 1:
                Nop();Nop();Nop();
                tmp = (unsigned int)LIN_Rx_copy_buf [3];
                tmp = (tmp << 8) + (unsigned int)LIN_Rx_copy_buf [4];
                if (overage_counter <= 29) {
                    overage_counter ++;
                    fuel_level_lin_tmp = fuel_level_lin_tmp + tmp;
                } else {
                    overage_counter = 0;
                    fuel_level_lin = (fuel_level_lin_tmp + 15)/30;
                    fuel_level_lin_tmp = 0;
                }
            break;
            case 2:
                Nop();Nop();Nop();
                tmp = (unsigned int)LIN_Rx_copy_buf [5];
                tmp = (tmp << 8) + (unsigned int)LIN_Rx_copy_buf [6];
                if (overage_counter <= 29) {
                    overage_counter ++;
                    fuel_level_lin_tmp = fuel_level_lin_tmp + tmp;
                } else {
                    overage_counter = 0;
                    fuel_level_lin = (fuel_level_lin_tmp + 15)/30;
                    fuel_level_lin_tmp = 0;
                }                
            break;
            case 3:
                Nop();Nop();Nop();
                tmp = (unsigned int)LIN_Rx_copy_buf [7];
                tmp = (tmp<< 8) + (unsigned int)LIN_Rx_copy_buf [8];
                if (overage_counter <= 29) {
                    overage_counter ++;
                    fuel_level_lin_tmp = fuel_level_lin_tmp + tmp;
                } else {
                    overage_counter = 0;
                    fuel_level_lin = (fuel_level_lin_tmp + 15)/30;
                    fuel_level_lin_tmp = 0;
                }                
            break;            
            default:
                
            break;
        }    
        
        }
    }

# if defined (LIN_SLAVE)
if ( LIN_Rx_copy_buf[2] == 0x08 ) {
    
}    
# endif    
    
}
void key_unlock_during_ign_on_timeout (void) {
    
    if ( key_unlock_ign_on_timer > 0 ) key_unlock_ign_on_timer --;
    
}
unsigned char get_bitmask_from_number ( unsigned char num )  {
    
    if ( num == 0 ) return 0b00000001;
    if ( num == 1 ) return 0b00000010;
    if ( num == 2 ) return 0b00000100;
    if ( num == 3 ) return 0b00001000;
    if ( num == 4 ) return 0b00010000;
    if ( num == 5 ) return 0b00100000;
    if ( num == 6 ) return 0b01000000;
    if ( num == 7 ) return 0b10000000;
    
    return 0xFF;
}
void check_lin_boot_status_debounce (void) {

    static unsigned char lin_boot_counter = 0;
    
    if ( lin_lock_flag == 1 ) {

        if (lin_boot_counter < 100) lin_boot_counter ++;
        else {
            lin_boot_counter = 100;
            lin_lock_flag_tmp = 1;
        }

    }
    else {
        
        if (lin_boot_counter > 0) lin_boot_counter --;
        else {
            lin_lock_flag_tmp = 0;
        } 
        
    }

    
    if ( lin_lock_flag_tmp2 != lin_lock_flag_tmp ) {
        if (lin_lock_flag_tmp == 1) { generate_content_of_message ( 36, 1 ); } // lin_lock_flag = 1; Замки закрылись
        else { generate_content_of_message ( 35, 1 ); }  // lin_lock_flag = 1; Замки открылись
        lin_lock_flag_tmp2 = lin_lock_flag_tmp;         
    }
    
}
int save_lin_lock_settings (unsigned char *ptr) {

    int type, num, len, l_id, l_crc;
    int  byte0, byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8;
    
    if ( *(ptr + 7)  != ',' || *(ptr + 9)  != ',' || *(ptr + 11) != ',' || *(ptr + 14) != ',' || *(ptr + 17) != ',' || 
         *(ptr + 20) != ',' || *(ptr + 23) != ',' || *(ptr + 26) != ',' || *(ptr + 29) != ',' || *(ptr + 32) != ',' || 
         *(ptr + 35) != ',' || *(ptr + 38) != ',' ) return 0;
    
    type = (int)convert_str_to_hex ( ptr + 6, 1 );
    if ( type  < 0 || type > 3 ) return 0;
    
    num = (int)convert_str_to_hex ( ptr + 8, 1 );
    if (num < 0 || num > 15) return 0;
    len = (int)convert_str_to_hex ( ptr + 10, 1 );
    if (len <= 0 || len > 8) return 0;    
    l_id = (int)convert_str_to_hex ( ptr + 12, 2 );
    if (l_id < 0) return 0;

    byte0 = (int)convert_str_to_hex ( ptr + 15, 2 );
    if (byte0 < 0) return 0;
    byte1 = (int)convert_str_to_hex ( ptr + 18, 2 );
    if (byte1 < 0) return 0;
    byte2 = (int)convert_str_to_hex ( ptr + 21, 2 );
    if (byte2 < 0) return 0;
    byte3 = (int)convert_str_to_hex ( ptr + 24, 2 );
    if (byte3 < 0) return 0;
    byte4 = (int)convert_str_to_hex ( ptr + 27, 2 );
    if (byte4 < 0) return 0;
    byte5 = (int)convert_str_to_hex ( ptr + 30, 2 );
    if (byte5 < 0) return 0;
    byte6 = (int)convert_str_to_hex ( ptr + 33, 2 );
    if (byte6 < 0) return 0;
    byte7 = (int)convert_str_to_hex ( ptr + 36, 2 );
    if (byte7 < 0) return 0;
    byte8 = (int)convert_str_to_hex ( ptr + 39, 2 );
    if (byte8 < 0) return 0;    
    
//    ptr = ptr +15;
    l_crc = (int)convert_str_to_hex ( (ptr + 15 + (len - 1)*3), 2 );

//unsigned char LIN_LOCK_CRC, LIN_UNLOCK_CRC, LIN_LOCK_LENGTH, LIN_UNLOCK_LENGTH;
//unsigned char LIN_LOCK_ADDR, LIN_UNLOCK_ADDR, LIN_LOCK_TRANSMITTION_ATTEMPTS, LIN_UNLOCK_TRANSMITTION_ATTEMPTS;
    
    if (type == 1) { //1 – открыть при включенном зажигании LINUNLOCKDATAbits
        LINUNLOCKDATAbits.byte0 = byte0;
        LINUNLOCKDATAbits.byte1 = byte1;
        LINUNLOCKDATAbits.byte2 = byte2;
        LINUNLOCKDATAbits.byte3 = byte3;
        LINUNLOCKDATAbits.byte4 = byte4;
        LINUNLOCKDATAbits.byte5 = byte5;
        LINUNLOCKDATAbits.byte6 = byte6;
        LINUNLOCKDATAbits.byte7 = byte7;
        LIN_UNLOCK_CRC    = (unsigned char)l_crc;
        LIN_UNLOCK_ADDR   = (unsigned char)l_id;
        LIN_UNLOCK_LENGTH = (unsigned char)len;
        LIN_UNLOCK_TRANSMITTION_ATTEMPTS = num;
        FM25_write_8 ( 1728, (unsigned long long) LINUNLOCKDATAbits.LINUNLOCKDATA );
        FM25_write_1 ( 1736, (unsigned int) LIN_UNLOCK_CRC );
        FM25_write_1 ( 1737, (unsigned int) LIN_UNLOCK_ADDR );
        FM25_write_1 ( 1738, (unsigned int) ( ((LIN_UNLOCK_TRANSMITTION_ATTEMPTS << 4) + LIN_UNLOCK_LENGTH) ));        
    }
    if (type == 0) { //0 – закрыть при включенном зажигании LINLOCKDATAbits
        LINLOCKDATAbits.byte0 = byte0;
        LINLOCKDATAbits.byte1 = byte1;
        LINLOCKDATAbits.byte2 = byte2;
        LINLOCKDATAbits.byte3 = byte3;
        LINLOCKDATAbits.byte4 = byte4;
        LINLOCKDATAbits.byte5 = byte5;
        LINLOCKDATAbits.byte6 = byte6;
        LINLOCKDATAbits.byte7 = byte7;
        LIN_LOCK_CRC    = (unsigned char)l_crc;
        LIN_LOCK_ADDR   = (unsigned char)l_id;
        LIN_LOCK_LENGTH = (unsigned char)len;
        LIN_LOCK_TRANSMITTION_ATTEMPTS = num;
        FM25_write_8 ( 1717, (unsigned long long) LINLOCKDATAbits.LINLOCKDATA );
        FM25_write_1 ( 1725, (unsigned int) LIN_LOCK_CRC );
        FM25_write_1 ( 1726, (unsigned int) LIN_LOCK_ADDR );
        FM25_write_1 ( 1727, (unsigned int) ( ((LIN_LOCK_TRANSMITTION_ATTEMPTS << 4) + LIN_LOCK_LENGTH) ));
    }
    if (type == 3) { //3 – открыть при выключенном зажигании LINUNLOCKDATA2bits
        LINUNLOCKDATA2bits.byte0 = byte0;
        LINUNLOCKDATA2bits.byte1 = byte1;
        LINUNLOCKDATA2bits.byte2 = byte2;
        LINUNLOCKDATA2bits.byte3 = byte3;
        LINUNLOCKDATA2bits.byte4 = byte4;
        LINUNLOCKDATA2bits.byte5 = byte5;
        LINUNLOCKDATA2bits.byte6 = byte6;
        LINUNLOCKDATA2bits.byte7 = byte7;
        LIN_UNLOCK_CRC2    = (unsigned char)l_crc;
        LIN_UNLOCK_ADDR2   = (unsigned char)l_id;
        LIN_UNLOCK_LENGTH2 = (unsigned char)len;
        LIN_UNLOCK_TRANSMITTION_ATTEMPTS2 = num;
        FM25_write_8 ( 1861, (unsigned long long) LINUNLOCKDATA2bits.LINUNLOCKDATA2 );
        FM25_write_1 ( 1869, (unsigned int) LIN_UNLOCK_CRC2 );
        FM25_write_1 ( 1870, (unsigned int) LIN_UNLOCK_ADDR2 );
        FM25_write_1 ( 1871, (unsigned int) ( ((LIN_UNLOCK_TRANSMITTION_ATTEMPTS2 << 4) + LIN_UNLOCK_LENGTH2) ));        
    }    
    if (type == 2) { //2 – закрыть при выключенном зажигании LINLOCKDATA2bits
        LINLOCKDATA2bits.byte0 = byte0;
        LINLOCKDATA2bits.byte1 = byte1;
        LINLOCKDATA2bits.byte2 = byte2;
        LINLOCKDATA2bits.byte3 = byte3;
        LINLOCKDATA2bits.byte4 = byte4;
        LINLOCKDATA2bits.byte5 = byte5;
        LINLOCKDATA2bits.byte6 = byte6;
        LINLOCKDATA2bits.byte7 = byte7;
        LIN_LOCK_CRC2    = (unsigned char)l_crc;
        LIN_LOCK_ADDR2   = (unsigned char)l_id;
        LIN_LOCK_LENGTH2 = (unsigned char)len;
        LIN_LOCK_TRANSMITTION_ATTEMPTS2 = num;
        FM25_write_8 ( 1872, (unsigned long long) LINLOCKDATA2bits.LINLOCKDATA2 );
        FM25_write_1 ( 1880, (unsigned int) LIN_LOCK_CRC2 );
        FM25_write_1 ( 1881, (unsigned int) LIN_LOCK_ADDR2 );
        FM25_write_1 ( 1882, (unsigned int) ( ((LIN_LOCK_TRANSMITTION_ATTEMPTS2 << 4) + LIN_LOCK_LENGTH2) ));
    }    
    
return 1;    
}
int save_lin_boot_lock_settings (unsigned char *ptr) {

    int type, num, len, l_id, l_crc;
    int  byte0, byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8;
    
    if ( *(ptr + 7)  != ',' || *(ptr + 9)  != ',' || *(ptr + 11) != ',' || *(ptr + 14) != ',' || *(ptr + 17) != ',' || 
         *(ptr + 20) != ',' || *(ptr + 23) != ',' || *(ptr + 26) != ',' || *(ptr + 29) != ',' || *(ptr + 32) != ',' || 
         *(ptr + 35) != ',' || *(ptr + 38) != ',' ) return 0;
    
    type = (int)convert_str_to_hex ( ptr + 6, 1 );
    if ( type  < 0 || type > 1 ) return 0;
    
    num = (int)convert_str_to_hex ( ptr + 8, 1 );
    if (num < 0 || num > 15) return 0;
    len = (int)convert_str_to_hex ( ptr + 10, 1 );
    if (len <= 0 || len > 8) return 0;    
    l_id = (int)convert_str_to_hex ( ptr + 12, 2 );
    if (l_id < 0) return 0;

    byte0 = (int)convert_str_to_hex ( ptr + 15, 2 );
    if (byte0 < 0) return 0;
    byte1 = (int)convert_str_to_hex ( ptr + 18, 2 );
    if (byte1 < 0) return 0;
    byte2 = (int)convert_str_to_hex ( ptr + 21, 2 );
    if (byte2 < 0) return 0;
    byte3 = (int)convert_str_to_hex ( ptr + 24, 2 );
    if (byte3 < 0) return 0;
    byte4 = (int)convert_str_to_hex ( ptr + 27, 2 );
    if (byte4 < 0) return 0;
    byte5 = (int)convert_str_to_hex ( ptr + 30, 2 );
    if (byte5 < 0) return 0;
    byte6 = (int)convert_str_to_hex ( ptr + 33, 2 );
    if (byte6 < 0) return 0;
    byte7 = (int)convert_str_to_hex ( ptr + 36, 2 );
    if (byte7 < 0) return 0;
    byte8 = (int)convert_str_to_hex ( ptr + 39, 2 );
    if (byte8 < 0) return 0;    
    
//    ptr = ptr +15;
    l_crc = (int)convert_str_to_hex ( (ptr + 15 + (len - 1)*3), 2 );

//unsigned char LIN_LOCK_CRC, LIN_UNLOCK_CRC, LIN_LOCK_LENGTH, LIN_UNLOCK_LENGTH;
//unsigned char LIN_LOCK_ADDR, LIN_UNLOCK_ADDR, LIN_LOCK_TRANSMITTION_ATTEMPTS, LIN_UNLOCK_TRANSMITTION_ATTEMPTS;
    
    if (type == 1) {
        LINBOOTUNLOCKDATAbits.byte0 = byte0;
        LINBOOTUNLOCKDATAbits.byte1 = byte1;
        LINBOOTUNLOCKDATAbits.byte2 = byte2;
        LINBOOTUNLOCKDATAbits.byte3 = byte3;
        LINBOOTUNLOCKDATAbits.byte4 = byte4;
        LINBOOTUNLOCKDATAbits.byte5 = byte5;
        LINBOOTUNLOCKDATAbits.byte6 = byte6;
        LINBOOTUNLOCKDATAbits.byte7 = byte7;
        LIN_BOOT_UNLOCK_CRC    = (unsigned char)l_crc;
        LIN_BOOT_UNLOCK_ADDR   = (unsigned char)l_id;
        LIN_BOOT_UNLOCK_LENGTH = (unsigned char)len;
        LIN_BOOT_UNLOCK_TRANSMITTION_ATTEMPTS = num;
        FM25_write_8 ( 1850, (unsigned long long) LINBOOTUNLOCKDATAbits.LINBOOTUNLOCKDATA );
        FM25_write_1 ( 1858, (unsigned int) LIN_BOOT_UNLOCK_CRC );
        FM25_write_1 ( 1859, (unsigned int) LIN_BOOT_UNLOCK_ADDR );
        FM25_write_1 ( 1860, (unsigned int) (((LIN_BOOT_UNLOCK_TRANSMITTION_ATTEMPTS << 4) + LIN_BOOT_UNLOCK_LENGTH)));        
    }
    
return 1;    
}

void transmit_LIN_to_debug (unsigned char len) {

unsigned char i, temp_buf[53], temp_byte, nibble0, nibble1;
unsigned char j = 0x0;

    for (i = 0; i < len; i++) {
        temp_byte = LIN_Rx_copy_buf[i];
        nibble0 = temp_byte & 0x0F; nibble1 = (temp_byte >> 4) & 0x0F;
        if (nibble0 <= 9) nibble0 = nibble0 + 0x30;
        else nibble0 = nibble0 + 0x37;
        if (nibble1 <= 9) nibble1 = nibble1 + 0x30;
        else nibble1 = nibble1 + 0x37;        
        j = i * 2;
        temp_buf[j] = nibble1;
        temp_buf[j + 1] = nibble0;
    }
    temp_buf[j + 2] = 0;
    
    load_UART4_Tx_buf (temp_buf);
    start_UART4_transmission(WAITOFF);
    // Data Transmit and receiving the data using interrupts

}
# endif


void send_lock_unlock_command ( int command_number, int lock_unlock_sign ) {
    
    unsigned int temp1 = 0, temp2 = 0, temp3 = 0, temp4 = 0; 

    unsigned long ID        = 0x0;
    unsigned int len        = 0x0;
    unsigned int can_number = 0x0;
    
        switch (command_number)
        {
            case 1:
                can_number = CLOCKSET1bits.can_number;
                ID = CLOCKSET1bits.id;
                len = CLOCKSET1bits.len;
                temp1 = CLOCKDAT1bits.B1; temp1 = (temp1 << 8) + CLOCKDAT1bits.B0; temp2 = CLOCKDAT1bits.B3; temp2 = (temp2 << 8) + CLOCKDAT1bits.B2;
                temp3 = CLOCKDAT1bits.B5; temp3 = (temp3 << 8) + CLOCKDAT1bits.B4; temp4 = CLOCKDAT1bits.B7; temp4 = (temp4 << 8) + CLOCKDAT1bits.B6;
                    if (TOYOTAKEYDATbits.can_number != 0 && ID == TOYOTAKEYDATbits.id && lock_unlock_sign == 1) {
                        temp2 = TOYOTAKEYTMPbuf[3]; temp2 = (temp2 << 8) + TOYOTAKEYTMPbuf[2];
                        temp3 = TOYOTAKEYTMPbuf[5]; temp3 = (temp3 << 8) + TOYOTAKEYTMPbuf[4]; 
                        temp4 = TOYOTAKEYTMPbuf[7]; temp4 = (temp4 << 8) + TOYOTAKEYTMPbuf[6];
                    }
                break;
            case 2:
                can_number = CLOCKSET2bits.can_number;
                ID = CLOCKSET2bits.id;
                len = CLOCKSET2bits.len;
                temp1 = CLOCKDAT2bits.B1; temp1 = (temp1 << 8) + CLOCKDAT2bits.B0; temp2 = CLOCKDAT2bits.B3; temp2 = (temp2 << 8) + CLOCKDAT2bits.B2;
                temp3 = CLOCKDAT2bits.B5; temp3 = (temp3 << 8) + CLOCKDAT2bits.B4; temp4 = CLOCKDAT2bits.B7; temp4 = (temp4 << 8) + CLOCKDAT2bits.B6;
                    if (TOYOTAKEYDATbits.can_number != 0 && ID == TOYOTAKEYDATbits.id && lock_unlock_sign == 1) {
                        temp2 = TOYOTAKEYTMPbuf[3]; temp2 = (temp2 << 8) + TOYOTAKEYTMPbuf[2];
                        temp3 = TOYOTAKEYTMPbuf[5]; temp3 = (temp3 << 8) + TOYOTAKEYTMPbuf[4]; 
                        temp4 = TOYOTAKEYTMPbuf[7]; temp4 = (temp4 << 8) + TOYOTAKEYTMPbuf[6];
                    }
                break;
            case 3:
                can_number = CLOCKSET3bits.can_number;
                ID = CLOCKSET3bits.id;
                len = CLOCKSET3bits.len;
                temp1 = CLOCKDAT3bits.B1; temp1 = (temp1 << 8) + CLOCKDAT3bits.B0; temp2 = CLOCKDAT3bits.B3; temp2 = (temp2 << 8) + CLOCKDAT3bits.B2;
                temp3 = CLOCKDAT3bits.B5; temp3 = (temp3 << 8) + CLOCKDAT3bits.B4; temp4 = CLOCKDAT3bits.B7; temp4 = (temp4 << 8) + CLOCKDAT3bits.B6;
                    if (TOYOTAKEYDATbits.can_number != 0 && ID == TOYOTAKEYDATbits.id && lock_unlock_sign == 1) {
                        temp2 = TOYOTAKEYTMPbuf[3]; temp2 = (temp2 << 8) + TOYOTAKEYTMPbuf[2];
                        temp3 = TOYOTAKEYTMPbuf[5]; temp3 = (temp3 << 8) + TOYOTAKEYTMPbuf[4]; 
                        temp4 = TOYOTAKEYTMPbuf[7]; temp4 = (temp4 << 8) + TOYOTAKEYTMPbuf[6];
                    }
                break;
            case 4:
                can_number = CUNLOCKSET1bits.can_number;
                ID = CUNLOCKSET1bits.id;
                len = CUNLOCKSET1bits.len;                
                temp1 = CUNLOCKDAT1bits.B1; temp1 = (temp1 << 8) + CUNLOCKDAT1bits.B0; temp2 = CUNLOCKDAT1bits.B3; temp2 = (temp2 << 8) + CUNLOCKDAT1bits.B2;
                temp3 = CUNLOCKDAT1bits.B5; temp3 = (temp3 << 8) + CUNLOCKDAT1bits.B4; temp4 = CUNLOCKDAT1bits.B7; temp4 = (temp4 << 8) + CUNLOCKDAT1bits.B6;
                    if (TOYOTAKEYDATbits.can_number != 0 && ID == TOYOTAKEYDATbits.id && lock_unlock_sign == 1) {
                        temp2 = TOYOTAKEYTMPbuf[3]; temp2 = (temp2 << 8) + TOYOTAKEYTMPbuf[2];
                        temp3 = TOYOTAKEYTMPbuf[5]; temp3 = (temp3 << 8) + TOYOTAKEYTMPbuf[4]; 
                        temp4 = TOYOTAKEYTMPbuf[7]; temp4 = (temp4 << 8) + TOYOTAKEYTMPbuf[6];
                    }
                break;
            case 5:
                can_number = CUNLOCKSET2bits.can_number;
                ID = CUNLOCKSET2bits.id;
                len = CUNLOCKSET2bits.len;                
                temp1 = CUNLOCKDAT2bits.B1; temp1 = (temp1 << 8) + CUNLOCKDAT2bits.B0; temp2 = CUNLOCKDAT2bits.B3; temp2 = (temp2 << 8) + CUNLOCKDAT2bits.B2;
                temp3 = CUNLOCKDAT2bits.B5; temp3 = (temp3 << 8) + CUNLOCKDAT2bits.B4; temp4 = CUNLOCKDAT2bits.B7; temp4 = (temp4 << 8) + CUNLOCKDAT2bits.B6;
                    if (TOYOTAKEYDATbits.can_number != 0 && ID == TOYOTAKEYDATbits.id && lock_unlock_sign == 1) {
                        temp2 = TOYOTAKEYTMPbuf[3]; temp2 = (temp2 << 8) + TOYOTAKEYTMPbuf[2];
                        temp3 = TOYOTAKEYTMPbuf[5]; temp3 = (temp3 << 8) + TOYOTAKEYTMPbuf[4]; 
                        temp4 = TOYOTAKEYTMPbuf[7]; temp4 = (temp4 << 8) + TOYOTAKEYTMPbuf[6];
                    }
                break;
            case 6:
                can_number = CUNLOCKSET3bits.can_number;
                ID = CUNLOCKSET3bits.id;
                len = CUNLOCKSET3bits.len;                
                temp1 = CUNLOCKDAT3bits.B1; temp1 = (temp1 << 8) + CUNLOCKDAT3bits.B0; temp2 = CUNLOCKDAT3bits.B3; temp2 = (temp2 << 8) + CUNLOCKDAT3bits.B2;
                temp3 = CUNLOCKDAT3bits.B5; temp3 = (temp3 << 8) + CUNLOCKDAT3bits.B4; temp4 = CUNLOCKDAT3bits.B7; temp4 = (temp4 << 8) + CUNLOCKDAT3bits.B6;
                    if (TOYOTAKEYDATbits.can_number != 0 && ID == TOYOTAKEYDATbits.id && lock_unlock_sign == 1) {
                        temp2 = TOYOTAKEYTMPbuf[3]; temp2 = (temp2 << 8) + TOYOTAKEYTMPbuf[2];
                        temp3 = TOYOTAKEYTMPbuf[5]; temp3 = (temp3 << 8) + TOYOTAKEYTMPbuf[4]; 
                        temp4 = TOYOTAKEYTMPbuf[7]; temp4 = (temp4 << 8) + TOYOTAKEYTMPbuf[6];
                    }
                break;
            case 7:
                can_number = CBTUNLOCKSET1bits.can_number;
                ID = CBTUNLOCKSET1bits.id;
                len = CBTUNLOCKSET1bits.len;
                temp1 = CBTUNLOCKDAT1bits.B1; temp1 = (temp1 << 8) + CBTUNLOCKDAT1bits.B0; temp2 = CBTUNLOCKDAT1bits.B3; temp2 = (temp2 << 8) + CBTUNLOCKDAT1bits.B2;
                temp3 = CBTUNLOCKDAT1bits.B5; temp3 = (temp3 << 8) + CBTUNLOCKDAT1bits.B4; temp4 = CBTUNLOCKDAT1bits.B7; temp4 = (temp4 << 8) + CBTUNLOCKDAT1bits.B6;
                    if (TOYOTAKEYDATbits.can_number != 0 && ID == TOYOTAKEYDATbits.id && lock_unlock_sign == 1) {
                        temp2 = TOYOTAKEYTMPbuf[3]; temp2 = (temp2 << 8) + TOYOTAKEYTMPbuf[2];
                        temp3 = TOYOTAKEYTMPbuf[5]; temp3 = (temp3 << 8) + TOYOTAKEYTMPbuf[4]; 
                        temp4 = TOYOTAKEYTMPbuf[7]; temp4 = (temp4 << 8) + TOYOTAKEYTMPbuf[6];
                    }
                break;
            case 8:
                can_number = CBTUNLOCKSET2bits.can_number;
                ID = CBTUNLOCKSET2bits.id;
                len = CBTUNLOCKSET2bits.len;
                temp1 = CBTUNLOCKDAT2bits.B1; temp1 = (temp1 << 8) + CBTUNLOCKDAT2bits.B0; temp2 = CBTUNLOCKDAT2bits.B3; temp2 = (temp2 << 8) + CBTUNLOCKDAT2bits.B2;
                temp3 = CBTUNLOCKDAT2bits.B5; temp3 = (temp3 << 8) + CBTUNLOCKDAT2bits.B4; temp4 = CBTUNLOCKDAT2bits.B7; temp4 = (temp4 << 8) + CBTUNLOCKDAT2bits.B6;
                    if (TOYOTAKEYDATbits.can_number != 0 && ID == TOYOTAKEYDATbits.id && lock_unlock_sign == 1) {
                        temp2 = TOYOTAKEYTMPbuf[3]; temp2 = (temp2 << 8) + TOYOTAKEYTMPbuf[2];
                        temp3 = TOYOTAKEYTMPbuf[5]; temp3 = (temp3 << 8) + TOYOTAKEYTMPbuf[4]; 
                        temp4 = TOYOTAKEYTMPbuf[7]; temp4 = (temp4 << 8) + TOYOTAKEYTMPbuf[6];
                    }
                break;
            case 9:
                can_number = CBTUNLOCKSET3bits.can_number;
                ID = CBTUNLOCKSET3bits.id;
                len = CBTUNLOCKSET3bits.len;
                temp1 = CBTUNLOCKDAT3bits.B1; temp1 = (temp1 << 8) + CBTUNLOCKDAT3bits.B0; temp2 = CBTUNLOCKDAT3bits.B3; temp2 = (temp2 << 8) + CBTUNLOCKDAT3bits.B2;
                temp3 = CBTUNLOCKDAT3bits.B5; temp3 = (temp3 << 8) + CBTUNLOCKDAT3bits.B4; temp4 = CBTUNLOCKDAT3bits.B7; temp4 = (temp4 << 8) + CBTUNLOCKDAT3bits.B6;
                    if (TOYOTAKEYDATbits.can_number != 0 && ID == TOYOTAKEYDATbits.id && lock_unlock_sign == 1) {
                        temp2 = TOYOTAKEYTMPbuf[3]; temp2 = (temp2 << 8) + TOYOTAKEYTMPbuf[2];
                        temp3 = TOYOTAKEYTMPbuf[5]; temp3 = (temp3 << 8) + TOYOTAKEYTMPbuf[4]; 
                        temp4 = TOYOTAKEYTMPbuf[7]; temp4 = (temp4 << 8) + TOYOTAKEYTMPbuf[6];
                    }
                break;
            default:
                break;
        }
    
    if ( lockbytes_enable == 0 ) {    
        if (can_number == 1) {
            ecan1WriteTxMsgBufId ( 0, (long) ID, (unsigned int) CAN1SETTINGSbits.ide, (unsigned int) 0 );
            ecan1WriteTxMsgBufData( 0, (unsigned int) len, temp1, temp2, temp3, temp4 );
            settxtransmit( 0 );                                
        }
        if (can_number == 2) {
            ecan2WriteTxMsgBufId ( 0, (long) ID, (unsigned int) CAN2SETTINGSbits.ide, (unsigned int) 0 );
            ecan2WriteTxMsgBufData( 0, (unsigned int) len, temp1, temp2, temp3, temp4 );
            settxtransmit2( 0 );                                
        }  
        
    } else {
        
        if ( lockbytes_learned == 1 && LOCKBYTESTASCKbits.start == 0 ) { // блок обучен и задача обучения не выполняется прямо сейчас
            Nop();Nop();Nop();
            if ( ID == CANLOCKBYTESPRMSbits.id ) {
                
                LOCK_BYTES_buf_tmp1[1] = (unsigned char)((temp1 >> 8) & 0xFF); LOCK_BYTES_buf_tmp1[0] = (unsigned char)(temp1 & 0xFF);
                LOCK_BYTES_buf_tmp1[3] = (unsigned char)((temp2 >> 8) & 0xFF); LOCK_BYTES_buf_tmp1[2] = (unsigned char)(temp2 & 0xFF);
                LOCK_BYTES_buf_tmp1[5] = (unsigned char)((temp3 >> 8) & 0xFF); LOCK_BYTES_buf_tmp1[4] = (unsigned char)(temp3 & 0xFF);
                LOCK_BYTES_buf_tmp1[7] = (unsigned char)((temp4 >> 8) & 0xFF); LOCK_BYTES_buf_tmp1[6] = (unsigned char)(temp4 & 0xFF);
                
                if (CANLOCKBYTESPRMSbits.byte0 < 8) LOCK_BYTES_buf_tmp1[CANLOCKBYTESPRMSbits.byte0] = LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte0];
                if (CANLOCKBYTESPRMSbits.byte1 < 8) LOCK_BYTES_buf_tmp1[CANLOCKBYTESPRMSbits.byte1] = LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte1];
                if (CANLOCKBYTESPRMSbits.byte2 < 8) LOCK_BYTES_buf_tmp1[CANLOCKBYTESPRMSbits.byte2] = LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte2];
                if (CANLOCKBYTESPRMS2bits.byte3 < 8) LOCK_BYTES_buf_tmp1[CANLOCKBYTESPRMS2bits.byte3] = LOCK_BYTES_buf[CANLOCKBYTESPRMS2bits.byte3];
                
                temp1 = LOCK_BYTES_buf_tmp1[1]; temp1 = (temp1 << 8) + LOCK_BYTES_buf_tmp1[0]; 
                temp2 = LOCK_BYTES_buf_tmp1[3]; temp2 = (temp2 << 8) + LOCK_BYTES_buf_tmp1[2];
                temp3 = LOCK_BYTES_buf_tmp1[5]; temp3 = (temp3 << 8) + LOCK_BYTES_buf_tmp1[4]; 
                temp4 = LOCK_BYTES_buf_tmp1[7]; temp4 = (temp4 << 8) + LOCK_BYTES_buf_tmp1[6];
                
            }
            if (can_number == 1) {
                ecan1WriteTxMsgBufId ( 0, (long) ID, (unsigned int) CAN1SETTINGSbits.ide, (unsigned int) 0 );
                ecan1WriteTxMsgBufData( 0, (unsigned int) len, temp1, temp2, temp3, temp4 );
                settxtransmit( 0 );                                
            }
            if (can_number == 2) {
                ecan2WriteTxMsgBufId ( 0, (long) ID, (unsigned int) CAN2SETTINGSbits.ide, (unsigned int) 0 );
                ecan2WriteTxMsgBufData( 0, (unsigned int) len, temp1, temp2, temp3, temp4 );
                settxtransmit2( 0 );                                
            }            
        }
        
    }
    
}
void send_door_open_command () {
    
    unsigned int temp1 = 0, temp2 = 0, temp3 = 0, temp4 = 0; 

    unsigned long ID;
    unsigned int len, can_number;
    
        can_number = DOPENSET1bits.can_number;
        ID = DOPENSET1bits.id;
        len = DOPENSET1bits.len;
        temp1 = DOPENDAT1bits.B1; temp1 = (temp1 << 8) + DOPENDAT1bits.B0; temp2 = DOPENDAT1bits.B3; temp2 = (temp2 << 8) + DOPENDAT1bits.B2;
        temp3 = DOPENDAT1bits.B5; temp3 = (temp3 << 8) + DOPENDAT1bits.B4; temp4 = DOPENDAT1bits.B7; temp4 = (temp4 << 8) + DOPENDAT1bits.B6;
 
        if (can_number == 1) {
            ecan1WriteTxMsgBufId ( 0, (long) ID, (unsigned int) CAN1SETTINGSbits.ide, (unsigned int) 0 );
            ecan1WriteTxMsgBufData( 0, (unsigned int) len, temp1, temp2, temp3, temp4 );
            settxtransmit( 0 );                                
        }
        if (can_number == 2) {
            ecan2WriteTxMsgBufId ( 0, (long) ID, (unsigned int) CAN2SETTINGSbits.ide, (unsigned int) 0 );
            ecan2WriteTxMsgBufData( 0, (unsigned int) len, temp1, temp2, temp3, temp4 );
            settxtransmit2( 0 );                                
        }  
        

    
}
/*
void send_lock_command1 ( void ) {
    unsigned int temp1 = 0, temp2 = 0, temp3 = 0, temp4 = 0;    
    
    temp1 = CLOCKDAT1bits.B1; temp1 = (temp1 << 8) + CLOCKDAT1bits.B0; temp2 = CLOCKDAT1bits.B3; temp2 = (temp2 << 8) + CLOCKDAT1bits.B2;
    temp3 = CLOCKDAT1bits.B5; temp3 = (temp3 << 8) + CLOCKDAT1bits.B4; temp4 = CLOCKDAT1bits.B7; temp4 = (temp4 << 8) + CLOCKDAT1bits.B6;
    if (CLOCKSET1bits.can_number == 1) {
        ecan1WriteTxMsgBufId ( 0, (long) CLOCKSET1bits.id, (unsigned int) 0, (unsigned int) 0 );
        ecan1WriteTxMsgBufData( 0, (unsigned int)CLOCKSET1bits.len, temp1, temp2, temp3, temp4 );
        settxtransmit( 0 );                                
    }
    if (CLOCKSET1bits.can_number == 2) {
        ecan2WriteTxMsgBufId ( 0, (long) CLOCKSET1bits.id, (unsigned int) 0, (unsigned int) 0 );
        ecan2WriteTxMsgBufData( 0, (unsigned int)CLOCKSET1bits.len, temp1, temp2, temp3, temp4 );
        settxtransmit2( 0 );                                
    } 
                            
}
void send_lock_command2 ( void ) {
    unsigned int temp1 = 0, temp2 = 0, temp3 = 0, temp4 = 0;    
    
    temp1 = CLOCKDAT2bits.B1; temp1 = (temp1 << 8) + CLOCKDAT2bits.B0; temp2 = CLOCKDAT2bits.B3; temp2 = (temp2 << 8) + CLOCKDAT2bits.B2;
    temp3 = CLOCKDAT2bits.B5; temp3 = (temp3 << 8) + CLOCKDAT2bits.B4; temp4 = CLOCKDAT2bits.B7; temp4 = (temp4 << 8) + CLOCKDAT2bits.B6;
    if (CLOCKSET2bits.can_number == 1) {
        ecan1WriteTxMsgBufId ( 0, (long) CLOCKSET2bits.id, (unsigned int) 0, (unsigned int) 0 );
        ecan1WriteTxMsgBufData( 0, (unsigned int)CLOCKSET2bits.len, temp1, temp2, temp3, temp4 );
        settxtransmit( 0 );                                
    }
    if (CLOCKSET2bits.can_number == 2) {
        ecan2WriteTxMsgBufId ( 0, (long) CLOCKSET2bits.id, (unsigned int) 0, (unsigned int) 0 );
        ecan2WriteTxMsgBufData( 0, (unsigned int)CLOCKSET2bits.len, temp1, temp2, temp3, temp4 );
        settxtransmit2( 0 );                                
    } 
                            
}
void send_lock_command3 ( void ) {
    unsigned int temp1 = 0, temp2 = 0, temp3 = 0, temp4 = 0;    
    
    temp1 = CLOCKDAT3bits.B1; temp1 = (temp1 << 8) + CLOCKDAT3bits.B0; temp2 = CLOCKDAT3bits.B3; temp2 = (temp2 << 8) + CLOCKDAT3bits.B2;
    temp3 = CLOCKDAT3bits.B5; temp3 = (temp3 << 8) + CLOCKDAT3bits.B4; temp4 = CLOCKDAT3bits.B7; temp4 = (temp4 << 8) + CLOCKDAT3bits.B6;
    if (CLOCKSET3bits.can_number == 1) {
        ecan1WriteTxMsgBufId ( 0, (long) CLOCKSET3bits.id, (unsigned int) 0, (unsigned int) 0 );
        ecan1WriteTxMsgBufData( 0, (unsigned int)CLOCKSET3bits.len, temp1, temp2, temp3, temp4 );
        settxtransmit( 0 );                                
    }
    if (CLOCKSET3bits.can_number == 2) {
        ecan2WriteTxMsgBufId ( 0, (long) CLOCKSET3bits.id, (unsigned int) 0, (unsigned int) 0 );
        ecan2WriteTxMsgBufData( 0, (unsigned int)CLOCKSET3bits.len, temp1, temp2, temp3, temp4 );
        settxtransmit2( 0 );                                
    } 
                            
}

void send_unlock_command1 ( void ) {
    unsigned int temp1 = 0, temp2 = 0, temp3 = 0, temp4 = 0;    
    
    temp1 = CUNLOCKDAT1bits.B1; temp1 = (temp1 << 8) + CUNLOCKDAT1bits.B0; temp2 = CUNLOCKDAT1bits.B3; temp2 = (temp2 << 8) + CUNLOCKDAT1bits.B2;
    temp3 = CUNLOCKDAT1bits.B5; temp3 = (temp3 << 8) + CUNLOCKDAT1bits.B4; temp4 = CUNLOCKDAT1bits.B7; temp4 = (temp4 << 8) + CUNLOCKDAT1bits.B6;
    if (CUNLOCKSET1bits.can_number == 1) {
        ecan1WriteTxMsgBufId ( 0, (long) CUNLOCKSET1bits.id, (unsigned int) 0, (unsigned int) 0 );
        ecan1WriteTxMsgBufData( 0, (unsigned int)CUNLOCKSET1bits.len, temp1, temp2, temp3, temp4 );
        settxtransmit( 0 );                                
    }
    if (CUNLOCKSET1bits.can_number == 2) {
        ecan2WriteTxMsgBufId ( 0, (long) CUNLOCKSET1bits.id, (unsigned int) 0, (unsigned int) 0 );
        ecan2WriteTxMsgBufData( 0, (unsigned int)CUNLOCKSET1bits.len, temp1, temp2, temp3, temp4 );
        settxtransmit2( 0 );                                
    } 
                            
}
void send_unlock_command2 ( void ) {
    unsigned int temp1 = 0, temp2 = 0, temp3 = 0, temp4 = 0;    
    
    temp1 = CUNLOCKDAT2bits.B1; temp1 = (temp1 << 8) + CUNLOCKDAT2bits.B0; temp2 = CUNLOCKDAT2bits.B3; temp2 = (temp2 << 8) + CUNLOCKDAT2bits.B2;
    temp3 = CUNLOCKDAT2bits.B5; temp3 = (temp3 << 8) + CUNLOCKDAT2bits.B4; temp4 = CUNLOCKDAT2bits.B7; temp4 = (temp4 << 8) + CUNLOCKDAT2bits.B6;
    if (CUNLOCKSET2bits.can_number == 1) {
        ecan1WriteTxMsgBufId ( 0, (long) CUNLOCKSET2bits.id, (unsigned int) 0, (unsigned int) 0 );
        ecan1WriteTxMsgBufData( 0, (unsigned int)CUNLOCKSET2bits.len, temp1, temp2, temp3, temp4 );
        settxtransmit( 0 );                                
    }
    if (CUNLOCKSET2bits.can_number == 2) {
        ecan2WriteTxMsgBufId ( 0, (long) CUNLOCKSET2bits.id, (unsigned int) 0, (unsigned int) 0 );
        ecan2WriteTxMsgBufData( 0, (unsigned int)CUNLOCKSET2bits.len, temp1, temp2, temp3, temp4 );
        settxtransmit2( 0 );                                
    } 
                            
}
void send_unlock_command3 ( void ) {
    unsigned int temp1 = 0, temp2 = 0, temp3 = 0, temp4 = 0;    
    
    temp1 = CUNLOCKDAT3bits.B1; temp1 = (temp1 << 8) + CUNLOCKDAT3bits.B0; temp2 = CUNLOCKDAT3bits.B3; temp2 = (temp2 << 8) + CUNLOCKDAT3bits.B2;
    temp3 = CUNLOCKDAT3bits.B5; temp3 = (temp3 << 8) + CUNLOCKDAT3bits.B4; temp4 = CUNLOCKDAT3bits.B7; temp4 = (temp4 << 8) + CUNLOCKDAT3bits.B6;
    if (CUNLOCKSET3bits.can_number == 1) {
        ecan1WriteTxMsgBufId ( 0, (long) CUNLOCKSET3bits.id, (unsigned int) 0, (unsigned int) 0 );
        ecan1WriteTxMsgBufData( 0, (unsigned int)CUNLOCKSET3bits.len, temp1, temp2, temp3, temp4 );
        settxtransmit( 0 );                                
    }
    if (CUNLOCKSET3bits.can_number == 2) {
        ecan2WriteTxMsgBufId ( 0, (long) CUNLOCKSET3bits.id, (unsigned int) 0, (unsigned int) 0 );
        ecan2WriteTxMsgBufData( 0, (unsigned int)CUNLOCKSET3bits.len, temp1, temp2, temp3, temp4 );
        settxtransmit2( 0 );                                
    } 
                            
}

void send_btunlock_command1 ( void ) {
    unsigned int temp1 = 0, temp2 = 0, temp3 = 0, temp4 = 0;    
    
    temp1 = CBTUNLOCKDAT1bits.B1; temp1 = (temp1 << 8) + CBTUNLOCKDAT1bits.B0; temp2 = CBTUNLOCKDAT1bits.B3; temp2 = (temp2 << 8) + CBTUNLOCKDAT1bits.B2;
    temp3 = CBTUNLOCKDAT1bits.B5; temp3 = (temp3 << 8) + CBTUNLOCKDAT1bits.B4; temp4 = CBTUNLOCKDAT1bits.B7; temp4 = (temp4 << 8) + CBTUNLOCKDAT1bits.B6;
    if (CBTUNLOCKSET1bits.can_number == 1) {
        ecan1WriteTxMsgBufId ( 0, (long) CBTUNLOCKSET1bits.id, (unsigned int) 0, (unsigned int) 0 );
        ecan1WriteTxMsgBufData( 0, (unsigned int)CBTUNLOCKSET1bits.len, temp1, temp2, temp3, temp4 );
        settxtransmit( 0 );                                
    }
    if (CBTUNLOCKSET1bits.can_number == 2) {
        ecan2WriteTxMsgBufId ( 0, (long) CBTUNLOCKSET1bits.id, (unsigned int) 0, (unsigned int) 0 );
        ecan2WriteTxMsgBufData( 0, (unsigned int)CBTUNLOCKSET1bits.len, temp1, temp2, temp3, temp4 );
        settxtransmit2( 0 );                                
    } 
                            
}
void send_btunlock_command2 ( void ) {
    unsigned int temp1 = 0, temp2 = 0, temp3 = 0, temp4 = 0;    
    
    temp1 = CUNLOCKDAT2bits.B1; temp1 = (temp1 << 8) + CUNLOCKDAT2bits.B0; temp2 = CUNLOCKDAT2bits.B3; temp2 = (temp2 << 8) + CUNLOCKDAT2bits.B2;
    temp3 = CUNLOCKDAT2bits.B5; temp3 = (temp3 << 8) + CUNLOCKDAT2bits.B4; temp4 = CUNLOCKDAT2bits.B7; temp4 = (temp4 << 8) + CUNLOCKDAT2bits.B6;
    if (CUNLOCKSET2bits.can_number == 1) {
        ecan1WriteTxMsgBufId ( 0, (long) CUNLOCKSET2bits.id, (unsigned int) 0, (unsigned int) 0 );
        ecan1WriteTxMsgBufData( 0, (unsigned int)CUNLOCKSET2bits.len, temp1, temp2, temp3, temp4 );
        settxtransmit( 0 );                                
    }
    if (CUNLOCKSET2bits.can_number == 2) {
        ecan2WriteTxMsgBufId ( 0, (long) CUNLOCKSET2bits.id, (unsigned int) 0, (unsigned int) 0 );
        ecan2WriteTxMsgBufData( 0, (unsigned int)CUNLOCKSET2bits.len, temp1, temp2, temp3, temp4 );
        settxtransmit2( 0 );                                
    } 
                            
}
void send_btunlock_command3 ( void ) {
    unsigned int temp1 = 0, temp2 = 0, temp3 = 0, temp4 = 0;    
    
    temp1 = CUNLOCKDAT3bits.B1; temp1 = (temp1 << 8) + CUNLOCKDAT3bits.B0; temp2 = CUNLOCKDAT3bits.B3; temp2 = (temp2 << 8) + CUNLOCKDAT3bits.B2;
    temp3 = CUNLOCKDAT3bits.B5; temp3 = (temp3 << 8) + CUNLOCKDAT3bits.B4; temp4 = CUNLOCKDAT3bits.B7; temp4 = (temp4 << 8) + CUNLOCKDAT3bits.B6;
    if (CUNLOCKSET3bits.can_number == 1) {
        ecan1WriteTxMsgBufId ( 0, (long) CUNLOCKSET3bits.id, (unsigned int) 0, (unsigned int) 0 );
        ecan1WriteTxMsgBufData( 0, (unsigned int)CUNLOCKSET3bits.len, temp1, temp2, temp3, temp4 );
        settxtransmit( 0 );                                
    }
    if (CUNLOCKSET3bits.can_number == 2) {
        ecan2WriteTxMsgBufId ( 0, (long) CUNLOCKSET3bits.id, (unsigned int) 0, (unsigned int) 0 );
        ecan2WriteTxMsgBufData( 0, (unsigned int)CUNLOCKSET3bits.len, temp1, temp2, temp3, temp4 );
        settxtransmit2( 0 );                                
    } 
                            
}
*/

void send_arm_blink_thru_can (void) {
//static unsigned char counter = 0;

#if defined (MAZDA_CX5)    

    if ( CAN2SETTINGSbits.on == 0 || CAN2SETTINGSbits.bitrate != 500 ) return;

    
    if (blink_arm_event_flag == 0) {
        counter = 0;
        return;
    }

    if ( counter  < 3 ) counter ++;
    else {
        counter = 0;
        C2TR23CONbits.TXREQ2 = 0;
        blink_arm_event_flag = 0;
    }

    if (counter == 1) {
        Nop();Nop();Nop();
        ecan2WriteTxMsgBufId ( 2, (long) 0x43E, (unsigned int) 0, (unsigned int) 0 );
        ecan2WriteTxMsgBufData( 2, (unsigned int) 8, (unsigned int) 0x0209, (unsigned int) 0x20F4, (unsigned int) 0x40C0, (unsigned int) 0x2408 );
        settxtransmit2( 2 );
    }
    
#endif
    
}
void send_disarm_blink_thru_can (void) {
//static unsigned char counter = 0;

#if defined (MAZDA_CX5)    

    if ( CAN2SETTINGSbits.on == 0 || CAN2SETTINGSbits.bitrate != 125 ) return;

    
    if (blink_disarm_event_flag == 0) {
        counter = 0;
        return;
    }

    if ( counter  < 6 ) counter ++;
    else {
        counter = 0;
        C1TR01CONbits.TXREQ1 = 0;
        blink_disarm_event_flag = 0;
    }

    if (counter == 1 || counter == 5) {
        Nop();Nop();Nop();
        ecan1WriteTxMsgBufId ( 2, (long) 0x43E, (unsigned int) 0, (unsigned int) 0 );
        ecan1WriteTxMsgBufData( 2, (unsigned int) 8, (unsigned int) 0x0209, (unsigned int) 0x20F4, (unsigned int) 0x40C0, (unsigned int) 0x2408 );
        settxtransmit( 2 );
    }
    
#endif      
    
}

void run_webasto_task (void) {

        static unsigned int check_status_duration_after_stop;
        //unsigned int i, max_time; 
    
    if (WEBASTObits.task_start == 0) {
        WEBASTObits.WEBASTO = 0;
        return;
    }
    if (WEBASTObits.start == 0 && WEBASTObits.start_done == 0 && WEBASTObits.counter > 200) {       
        Nop();Nop();Nop();
        WEBASTObits.start = 1;
        
# if defined (MCP23S08)

# else        
        if ( OUTFUNCbits.pin15 == 0x0D ) L_OUT = 1;
        if ( OUTFUNCbits.pin9 == 0x0D ) AUTO_START = 1;
# endif
        if (WBSTRSET1bits.can_number == 1 || WBSTRSET1bits.can_number == 2) {// Если проверка статуса настроена, вычисление времени для запроса статуса вебасто
//WBSTSTARTTIMEbits            
//            WBSTR_TIME_buf[0] = (unsigned int)WBSTRTIME1bits.B0 * 10; WBSTR_TIME_buf[1] = (unsigned int)WBSTRTIME1bits.B1 * 10; WBSTR_TIME_buf[2] = (unsigned int)WBSTRTIME1bits.B2 * 10; WBSTR_TIME_buf[3] = (unsigned int)WBSTRTIME1bits.B3 * 10;
//            WBSTR_TIME_buf[4] = (unsigned int)WBSTRTIME1bits.B4 * 10; WBSTR_TIME_buf[5] = (unsigned int)WBSTRTIME1bits.B5 * 10; WBSTR_TIME_buf[6] = (unsigned int)WBSTRTIME1bits.B6 * 10; WBSTR_TIME_buf[7] = (unsigned int)WBSTRTIME1bits.B7 * 10; 
//
//            max_time = WBSTR_TIME_buf[0];
//            for ( i = 0; i < 8; i ++ ) {
//                if (WBSTR_TIME_buf[i] > max_time) max_time = WBSTR_TIME_buf[i];
//            }
            Nop();Nop();Nop();
            check_status_duration_after_stop = WBSTCANWAKETIMEbits.after_delay + 200;
            check_status_duration = WBSTCANWAKETIMEbits.after_delay + 100;
            
        } else {
            check_status_duration_after_stop = 400;
            check_status_duration = 300;
        }
   }        
        
/*    
    if (WEBASTObits.start == 0 && WEBASTObits.start_done == 0 && WEBASTObits.counter > 200) {
        Nop();Nop();Nop();
        WEBASTObits.start = 1;
        if (WBSTRSET1bits.can_number == 1 || WBSTRSET1bits.can_number == 2) {// Если проверка статуса настроена, вычисление времени для запроса статуса вебасто
            
            WBSTR_TIME_buf[0] = (unsigned int)WBSTRTIME1bits.B0 * 10; WBSTR_TIME_buf[1] = (unsigned int)WBSTRTIME1bits.B1 * 10; WBSTR_TIME_buf[2] = (unsigned int)WBSTRTIME1bits.B2 * 10; WBSTR_TIME_buf[3] = (unsigned int)WBSTRTIME1bits.B3 * 10;
            WBSTR_TIME_buf[4] = (unsigned int)WBSTRTIME1bits.B4 * 10; WBSTR_TIME_buf[5] = (unsigned int)WBSTRTIME1bits.B5 * 10; WBSTR_TIME_buf[6] = (unsigned int)WBSTRTIME1bits.B6 * 10; WBSTR_TIME_buf[7] = (unsigned int)WBSTRTIME1bits.B7 * 10; 

            max_time = WBSTR_TIME_buf[0];
            for ( i = 0; i < 8; i ++ ) {
                if (WBSTR_TIME_buf[i] > max_time) max_time = WBSTR_TIME_buf[i];
            }
            Nop();Nop();Nop();
            check_status_duration_after_stop = max_time + 200;
            check_status_duration = max_time + 100;
            
        } else {
            check_status_duration_after_stop = 400;
            check_status_duration = 300;
        }
   }
*/        
//    check_status_duration_after_stop = 400;
//#if defined (VW_MMULTIVAN_T6_2017_WEBASTO)
//    check_status_duration_after_stop = 1500;
//# endif 
    
    if (WEBASTObits.stop == 0 && WEBASTObits.stop_done == 0 && WEBASTObits.counter <= check_status_duration_after_stop) {
        Nop();Nop();Nop();
        WEBASTObits.stop = 1;
        
# if defined (MCP23S08)

# else        
        if ( OUTFUNCbits.pin15 == 0x0D ) L_OUT = 0;
        if ( OUTFUNCbits.pin9 == 0x0D ) AUTO_START = 0;  
# endif
    }    
    
    if (WEBASTObits.counter > 0) WEBASTObits.counter --;
    else {
        Nop();Nop();Nop();
        WEBASTObits.WEBASTO = 0;
    }
    
}
void run_webasto_thru_can (void) {
    static unsigned int counter = 0, counter1 = 0, can1_flag = 0, can2_flag = 0;// check_status_duration;
//    static unsigned int time0, time1, time2, time3, time4, time5, time6, time7;

    if (WEBASTObits.start == 0 && WEBASTObits.stop == 0) { counter1 = 0; counter = 0; return; }



/*VOLVO_XC70D*/
#if defined (VOLVO_XC70D_WEBASTO)
    if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.bitrate == 125 ) { //125
        can2_flag = 1;
        
        if ( WEBASTObits.start == 1 ) {

                if (counter1 == 1 || counter1 == 11) {
                    LOCKUNLOCKbits.counter = 2;
                    ecan2WriteTxMsgBufId ( 3, (long) 0x315, (unsigned int) 0, (unsigned int) 0 );
                    ecan2WriteTxMsgBufData( 3, (unsigned int) 8, (unsigned int) 0x00A2, (unsigned int) 0xABF1, (unsigned int) 0x8063, (unsigned int) 0x0400 );
                    settxtransmit2( 3 );
                }

        }//if ( LOCKUNLOCKbits.lock == 1 )

        if ( WEBASTObits.stop == 1 ) { 
            
                if (counter1 == 1 || counter1 == 11) {
                    ecan2WriteTxMsgBufId ( 3, (long) 0x315, (unsigned int) 0, (unsigned int) 0 );
                    ecan2WriteTxMsgBufData( 3, (unsigned int) 8, (unsigned int) 0x00A2, (unsigned int) 0xABF1, (unsigned int) 0x0063, (unsigned int) 0x0400 );
                    settxtransmit2( 3 );
                }            

        }//if ( LOCKUNLOCKbits.unlock == 1 )
    
    }
#endif 
#if defined (VOLVO_XC60_WEBASTO)
    if ( CAN2SETTINGSbits.on == 1 ) { //125
        can2_flag = 1;
        
        if ( WEBASTObits.start == 1 ) {

                if ( counter1 == 1 ) {
                    LOCKUNLOCKbits.counter = 2;
                    ecan2WriteTxMsgBufId ( 3, (long) 0x2C3, (unsigned int) 0, (unsigned int) 0 );
                    ecan2WriteTxMsgBufData( 3, (unsigned int) 8, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0000 );
                    settxtransmit2( 3 );
                }
                if ( counter1 == 11 ) {
                    LOCKUNLOCKbits.counter = 2;
                    ecan2WriteTxMsgBufId ( 3, (long) 0x2C3, (unsigned int) 0, (unsigned int) 0 );
                    ecan2WriteTxMsgBufData( 3, (unsigned int) 8, (unsigned int) 0x0500, (unsigned int) 0x005D, (unsigned int) 0xF601, (unsigned int) 0xFE00 );
                    settxtransmit2( 3 );
                }                
                if ( counter1 == 21 ) {
                    LOCKUNLOCKbits.counter = 2;
                    ecan2WriteTxMsgBufId ( 3, (long) 0x2C3, (unsigned int) 0, (unsigned int) 0 );
                    ecan2WriteTxMsgBufData( 3, (unsigned int) 8, (unsigned int) 0x0712, (unsigned int) 0x0055, (unsigned int) 0xF401, (unsigned int) 0xFE00 );
                    settxtransmit2( 3 );
                }
                if ( counter1 == 31 ) {
                    LOCKUNLOCKbits.counter = 2;
                    ecan2WriteTxMsgBufId ( 3, (long) 0x2C3, (unsigned int) 0, (unsigned int) 0 );
                    ecan2WriteTxMsgBufData( 3, (unsigned int) 8, (unsigned int) 0x0732, (unsigned int) 0x0055, (unsigned int) 0xF401, (unsigned int) 0x0080 );
                    settxtransmit2( 3 );
                }                
        }//if ( LOCKUNLOCKbits.lock == 1 )

        if ( WEBASTObits.stop == 1 ) { 
            
                if (counter1 == 1 || counter1 == 11 || counter1 == 21 || counter1 == 31 || counter1 == 41) {
                    ecan2WriteTxMsgBufId ( 3, (long) 0x2C3, (unsigned int) 0, (unsigned int) 0 );
                    ecan2WriteTxMsgBufData( 3, (unsigned int) 8, (unsigned int) 0x0700, (unsigned int) 0x0019, (unsigned int) 0xF501, (unsigned int) 0xFE00 );
                    settxtransmit2( 3 );
                }            

        }//if ( LOCKUNLOCKbits.unlock == 1 )
    
    }
#endif 
    
#if defined (VW_MMULTIVAN_T6_2017_WEBASTO)
    if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.bitrate == 100 ) { //100
        can2_flag = 1;
        
        if ( WEBASTObits.start == 1 ) {

                if (counter1 == 1 || counter1 == 91) {
                    LOCKUNLOCKbits.counter = 2;
                    ecan2WriteTxMsgBufId ( 3, (long) 0x76A, (unsigned int) 0, (unsigned int) 0 );
                    ecan2WriteTxMsgBufData( 3, (unsigned int) 8, (unsigned int) 0x3107, (unsigned int) 0x0401, (unsigned int) 0x047C, (unsigned int) 0x0000 );
                    settxtransmit2( 3 );
                }

        }//if ( LOCKUNLOCKbits.lock == 1 )

        if ( WEBASTObits.stop == 1 ) { 
            
                if (counter1 == 1 || counter1 == 91) {
                    ecan2WriteTxMsgBufId ( 3, (long) 0x76A, (unsigned int) 0, (unsigned int) 0 );
                    ecan2WriteTxMsgBufData( 3, (unsigned int) 8, (unsigned int) 0x3107, (unsigned int) 0x0401, (unsigned int) 0x047E, (unsigned int) 0x0000 );
                    settxtransmit2( 3 );
                }            

        }//if ( LOCKUNLOCKbits.unlock == 1 )
    
    }
#endif     
#if defined (VW_MMULTIVAN_T6_2017_OTOPITEL)
    if ( CAN2SETTINGSbits.on == 1 ) { //100
        can2_flag = 1;
        
        if ( WEBASTObits.start == 1 ) {

                if (counter1 == 1 || counter1 == 91) {
                    LOCKUNLOCKbits.counter = 2;
                    ecan2WriteTxMsgBufId ( 3, (long) 0x3E5, (unsigned int) 0, (unsigned int) 0 );
                    ecan2WriteTxMsgBufData( 3, (unsigned int) 8, (unsigned int) 0x8800, (unsigned int) 0x0401, (unsigned int) 0x7F8B, (unsigned int) 0x0002 );
                    settxtransmit2( 3 );
                }

        }//if ( LOCKUNLOCKbits.lock == 1 )

        if ( WEBASTObits.stop == 1 ) { 
            
                if (counter1 == 1 || counter1 == 91) {
                    ecan2WriteTxMsgBufId ( 3, (long) 0x3E5, (unsigned int) 0, (unsigned int) 0 );
                    ecan2WriteTxMsgBufData( 3, (unsigned int) 8, (unsigned int) 0x8A00, (unsigned int) 0x4000, (unsigned int) 0x6D00, (unsigned int) 0x0000 );
                    settxtransmit2( 3 );
                }            

        }//if ( LOCKUNLOCKbits.unlock == 1 )
    
    }
#endif     
    
#if defined (PORSHE_CAENE)
    if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.ide == 0 && CAN2SETTINGSbits.bitrate == 100 ) { //125
        can2_flag = 1;
        
        if ( WEBASTObits.start == 1 ) {

                if (counter1 == 1 || counter1 == 11 || counter1 == 21 || counter1 == 31 || counter1 == 41) {
                    LOCKUNLOCKbits.counter = 2;
                    ecan2WriteTxMsgBufId ( 3, (long) 0x6AA, (unsigned int) 0, (unsigned int) 0 );
                    ecan2WriteTxMsgBufData( 3, (unsigned int) 8, (unsigned int) 0x0800, (unsigned int) 0x0801, (unsigned int) 0x0000, (unsigned int) 0x0000 );
                    settxtransmit2( 3 );
                }

        }//if ( LOCKUNLOCKbits.lock == 1 )

        if ( WEBASTObits.stop == 1 ) { 
            
                if (counter1 == 1 || counter1 == 11 || counter1 == 21 || counter1 == 31 || counter1 == 41) {
                    ecan2WriteTxMsgBufId ( 3, (long) 0x6AA, (unsigned int) 0, (unsigned int) 0 );
                    ecan2WriteTxMsgBufData( 3, (unsigned int) 8, (unsigned int) 0x0800, (unsigned int) 0x1001, (unsigned int) 0x0000, (unsigned int) 0x0000 );
                    settxtransmit2( 3 );
                }            

        }//if ( LOCKUNLOCKbits.unlock == 1 )
    
    }
#endif 

#if defined (TOUAREG_2016_WEBASTO)
    if ( CAN1SETTINGSbits.on == 1 && CAN1SETTINGSbits.ide == 0 && CAN1SETTINGSbits.bitrate == 500 ) { //125
        can2_flag = 1;
        
        if ( WEBASTObits.start == 1 ) {

                if ( counter1 == 1 || counter1 == 6 || counter1 == 11 ) {
                    LOCKUNLOCKbits.counter = 2;
                    ecan1WriteTxMsgBufId ( 3, (long) 0x100, (unsigned int) 0, (unsigned int) 0 );
                    ecan1WriteTxMsgBufData( 3, (unsigned int) 8, (unsigned int) 0xD145, (unsigned int) 0x003F, (unsigned int) 0x0000, (unsigned int) 0x0000 );
                    settxtransmit( 3 );
                }
                if ( counter1 == 16 || counter1 == 26 || counter1 == 36 ) {
                    LOCKUNLOCKbits.counter = 2;
                    ecan1WriteTxMsgBufId ( 3, (long) 0x521, (unsigned int) 0, (unsigned int) 0 );
                    ecan1WriteTxMsgBufData( 3, (unsigned int) 8, (unsigned int) 0x0002, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x0053 );
                    settxtransmit( 3 );
                }
        }//if ( LOCKUNLOCKbits.lock == 1 )

        if ( WEBASTObits.stop == 1 ) { 
            
                if ( counter1 == 1 || counter1 == 6 || counter1 == 11 ) {
                    ecan1WriteTxMsgBufId ( 3, (long) 0x100, (unsigned int) 0, (unsigned int) 0 );
                    ecan1WriteTxMsgBufData( 3, (unsigned int) 8, (unsigned int) 0xD145, (unsigned int) 0x003F, (unsigned int) 0x0000, (unsigned int) 0x0000 );
                    settxtransmit( 3 );
                }            
               if ( counter1 == 16 || counter1 == 26 || counter1 == 36 ) {
                    LOCKUNLOCKbits.counter = 2;
                    ecan1WriteTxMsgBufId ( 3, (long) 0x521, (unsigned int) 0, (unsigned int) 0 );
                    ecan1WriteTxMsgBufData( 3, (unsigned int) 8, (unsigned int) 0x0001, (unsigned int) 0x0000, (unsigned int) 0x0000, (unsigned int) 0x2053 );
                    settxtransmit( 3 );
                }
        }//if ( LOCKUNLOCKbits.unlock == 1 )
    
    }
#endif 

    
#if defined (VW_Tiguan_2017)
    if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.ide == 0 && CAN2SETTINGSbits.bitrate == 500 ) { //500
        can2_flag = 1;
        
        if ( WEBASTObits.start == 1 ) {

                if ( counter1 == 1 || counter1 == 11 ) {
                    LOCKUNLOCKbits.counter = 2;
                    ecan2WriteTxMsgBufId ( 3, (long) 0x521, (unsigned int) 0, (unsigned int) 0 );
                    ecan2WriteTxMsgBufData( 3, (unsigned int) 8, (unsigned int) 0x0201, (unsigned int) 0x0002, (unsigned int) 0x0000, (unsigned int) 0x2855 );
                    settxtransmit2( 3 );
                }

        }//if ( LOCKUNLOCKbits.lock == 1 )

        if ( WEBASTObits.stop == 1 ) { 
            
                if ( counter1 == 1 || counter1 == 11 ) {
                    ecan2WriteTxMsgBufId ( 3, (long) 0x521, (unsigned int) 0, (unsigned int) 0 );
                    ecan2WriteTxMsgBufData( 3, (unsigned int) 8, (unsigned int) 0x0312, (unsigned int) 0x0703, (unsigned int) 0xDC00, (unsigned int) 0x2866 );
                    settxtransmit2( 3 );
                }            

        }//if ( LOCKUNLOCKbits.unlock == 1 )
    
    }
#endif 

//    check_status_duration = 300;
//#if defined (VW_MMULTIVAN_T6_2017_WEBASTO)
//    check_status_duration = 1050;
//# endif 


        if ( WEBASTObits.start == 1 ) {

                if ( counter1 != 0 ) {
                    if (WBSTSTARTSET1bits.can_number != 0) {
                        if ( WBSTSTARTTIME1bits.B0 == counter1 || WBSTSTARTTIME1bits.B1 == counter1 || WBSTSTARTTIME1bits.B2 == counter1 || WBSTSTARTTIME1bits.B3 == counter1 ||
                             WBSTSTARTTIME1bits.B4 == counter1 || WBSTSTARTTIME1bits.B5 == counter1 || WBSTSTARTTIME1bits.B6 == counter1 || WBSTSTARTTIME1bits.B7 == counter1 ) 
                        {
                            if (WBSTSTARTSET1bits.can_number == 1) can1_flag = 1; if (WBSTSTARTSET1bits.can_number == 2) can2_flag = 1;
                            send_webasto_command (1);
                        }
                    }
                    if (WBSTSTARTSET2bits.can_number != 0) {
                        if ( WBSTSTARTTIME2bits.B0 == counter1 || WBSTSTARTTIME2bits.B1 == counter1 || WBSTSTARTTIME2bits.B2 == counter1 || WBSTSTARTTIME2bits.B3 == counter1 ||
                             WBSTSTARTTIME2bits.B4 == counter1 || WBSTSTARTTIME2bits.B5 == counter1 || WBSTSTARTTIME2bits.B6 == counter1 || WBSTSTARTTIME2bits.B7 == counter1 ) 
                        {
                            if (WBSTSTARTSET2bits.can_number == 1) can1_flag = 1; if (WBSTSTARTSET2bits.can_number == 2) can2_flag = 1;
                            send_webasto_command (2);
                        }
                    }
                    if (WBSTSTARTSET3bits.can_number != 0) {
                        if ( WBSTSTARTTIME3bits.B0 == counter1 || WBSTSTARTTIME3bits.B1 == counter1 || WBSTSTARTTIME3bits.B2 == counter1 || WBSTSTARTTIME3bits.B3 == counter1 ||
                             WBSTSTARTTIME3bits.B4 == counter1 || WBSTSTARTTIME3bits.B5 == counter1 || WBSTSTARTTIME3bits.B6 == counter1 || WBSTSTARTTIME3bits.B7 == counter1 ) 
                        {
                            if (WBSTSTARTSET3bits.can_number == 1) can1_flag = 1; if (WBSTSTARTSET3bits.can_number == 2) can2_flag = 1;
                            send_webasto_command (3);
                        }
                    }
                    if (WBSTSTARTSET4bits.can_number != 0) {
                        if ( WBSTSTARTTIME4bits.B0 == counter1 || WBSTSTARTTIME4bits.B1 == counter1 || WBSTSTARTTIME4bits.B2 == counter1 || WBSTSTARTTIME4bits.B3 == counter1 ||
                             WBSTSTARTTIME4bits.B4 == counter1 || WBSTSTARTTIME4bits.B5 == counter1 || WBSTSTARTTIME4bits.B6 == counter1 || WBSTSTARTTIME4bits.B7 == counter1 ) 
                        {
                            if (WBSTSTARTSET4bits.can_number == 1) can1_flag = 1; if (WBSTSTARTSET4bits.can_number == 2) can2_flag = 1;
                            send_webasto_command (4);
                        }
                    }
                    if (WBSTSTARTSET5bits.can_number != 0) {
                        if ( WBSTSTARTTIME5bits.B0 == counter1 || WBSTSTARTTIME5bits.B1 == counter1 || WBSTSTARTTIME5bits.B2 == counter1 || WBSTSTARTTIME5bits.B3 == counter1 ||
                             WBSTSTARTTIME5bits.B4 == counter1 || WBSTSTARTTIME5bits.B5 == counter1 || WBSTSTARTTIME5bits.B6 == counter1 || WBSTSTARTTIME5bits.B7 == counter1 ) 
                        {
                            if (WBSTSTARTSET5bits.can_number == 1) can1_flag = 1; if (WBSTSTARTSET5bits.can_number == 2) can2_flag = 1;
                            send_webasto_command (5);
                        }
                    }
                    if (WBSTSTARTSET6bits.can_number != 0) {
                        if ( WBSTSTARTTIME6bits.B0 == counter1 || WBSTSTARTTIME6bits.B1 == counter1 || WBSTSTARTTIME6bits.B2 == counter1 || WBSTSTARTTIME6bits.B3 == counter1 ||
                             WBSTSTARTTIME6bits.B4 == counter1 || WBSTSTARTTIME6bits.B5 == counter1 || WBSTSTARTTIME6bits.B6 == counter1 || WBSTSTARTTIME6bits.B7 == counter1 ) 
                        {
                            if (WBSTSTARTSET6bits.can_number == 1) can1_flag = 1; if (WBSTSTARTSET6bits.can_number == 2) can2_flag = 1;
                            send_webasto_command (6);
                        }
                    }                    
                }
                
                
        }//if ( LOCKUNLOCKbits.lock == 1 )
        if ( WEBASTObits.stop == 1 ) {

                if ( counter1 != 0 ) {
                    if (WBSTSTOPSET1bits.can_number != 0) {
                        if ( WBSTSTOPTIME1bits.B0 == counter1 || WBSTSTOPTIME1bits.B1 == counter1 || WBSTSTOPTIME1bits.B2 == counter1 || WBSTSTOPTIME1bits.B3 == counter1 ||
                             WBSTSTOPTIME1bits.B4 == counter1 || WBSTSTOPTIME1bits.B5 == counter1 || WBSTSTOPTIME1bits.B6 == counter1 || WBSTSTOPTIME1bits.B7 == counter1 ) 
                        {
                            if (WBSTSTOPSET1bits.can_number == 1) can1_flag = 1; if (WBSTSTOPSET1bits.can_number == 2) can2_flag = 1;
                            send_webasto_command (7);
                        }
                    }
                    if (WBSTSTOPSET2bits.can_number != 0) {
                        if ( WBSTSTOPTIME2bits.B0 == counter1 || WBSTSTOPTIME2bits.B1 == counter1 || WBSTSTOPTIME2bits.B2 == counter1 || WBSTSTOPTIME2bits.B3 == counter1 ||
                             WBSTSTOPTIME2bits.B4 == counter1 || WBSTSTOPTIME2bits.B5 == counter1 || WBSTSTOPTIME2bits.B6 == counter1 || WBSTSTOPTIME2bits.B7 == counter1 ) 
                        {
                            if (WBSTSTOPSET2bits.can_number == 1) can1_flag = 1; if (WBSTSTOPSET2bits.can_number == 2) can2_flag = 1;
                            send_webasto_command (8);
                        }
                    }
                    if (WBSTSTOPSET3bits.can_number != 0) {
                        if ( WBSTSTOPTIME3bits.B0 == counter1 || WBSTSTOPTIME3bits.B1 == counter1 || WBSTSTOPTIME3bits.B2 == counter1 || WBSTSTOPTIME3bits.B3 == counter1 ||
                             WBSTSTOPTIME3bits.B4 == counter1 || WBSTSTOPTIME3bits.B5 == counter1 || WBSTSTOPTIME3bits.B6 == counter1 || WBSTSTOPTIME3bits.B7 == counter1 ) 
                        {
                            if (WBSTSTOPSET3bits.can_number == 1) can1_flag = 1; if (WBSTSTOPSET3bits.can_number == 2) can2_flag = 1;
                            send_webasto_command (9);
                        }
                    }
                    if (WBSTSTOPSET4bits.can_number != 0) {
                        if ( WBSTSTOPTIME4bits.B0 == counter1 || WBSTSTOPTIME4bits.B1 == counter1 || WBSTSTOPTIME4bits.B2 == counter1 || WBSTSTOPTIME4bits.B3 == counter1 ||
                             WBSTSTOPTIME4bits.B4 == counter1 || WBSTSTOPTIME4bits.B5 == counter1 || WBSTSTOPTIME4bits.B6 == counter1 || WBSTSTOPTIME4bits.B7 == counter1 ) 
                        {
                            if (WBSTSTOPSET4bits.can_number == 1) can1_flag = 1; if (WBSTSTOPSET4bits.can_number == 2) can2_flag = 1;
                            send_webasto_command (10);
                        }
                    }
                    if (WBSTSTOPSET5bits.can_number != 0) {
                        if ( WBSTSTOPTIME5bits.B0 == counter1 || WBSTSTOPTIME5bits.B1 == counter1 || WBSTSTOPTIME5bits.B2 == counter1 || WBSTSTOPTIME5bits.B3 == counter1 ||
                             WBSTSTOPTIME5bits.B4 == counter1 || WBSTSTOPTIME5bits.B5 == counter1 || WBSTSTOPTIME5bits.B6 == counter1 || WBSTSTOPTIME5bits.B7 == counter1 ) 
                        {
                            if (WBSTSTOPSET5bits.can_number == 1) can1_flag = 1; if (WBSTSTOPSET5bits.can_number == 2) can2_flag = 1;
                            send_webasto_command (11);
                        }
                    } 
                    if (WBSTSTOPSET6bits.can_number != 0) {
                        if ( WBSTSTOPTIME6bits.B0 == counter1 || WBSTSTOPTIME6bits.B1 == counter1 || WBSTSTOPTIME6bits.B2 == counter1 || WBSTSTOPTIME6bits.B3 == counter1 ||
                             WBSTSTOPTIME6bits.B4 == counter1 || WBSTSTOPTIME6bits.B5 == counter1 || WBSTSTOPTIME6bits.B6 == counter1 || WBSTSTOPTIME6bits.B7 == counter1 ) 
                        {
                            if (WBSTSTOPSET6bits.can_number == 1) can1_flag = 1; if (WBSTSTOPSET6bits.can_number == 2) can2_flag = 1;
                            send_webasto_command (12);
                        }
                    }                    
                }
                
                
        }
    

    
/*    
        if (WBSTRSET1bits.can_number == 1 || WBSTRSET1bits.can_number == 2) {

            if ( counter1 != 0 ) { // Запрос статуса вебасто
                if ( counter1 != 0 ) {
                    if ( WBSTR_TIME_buf[0] == counter1 || WBSTR_TIME_buf[1] == counter1 || WBSTR_TIME_buf[2] == counter1 || WBSTR_TIME_buf[3] == counter1 ||
                         WBSTR_TIME_buf[4] == counter1 || WBSTR_TIME_buf[5] == counter1 || WBSTR_TIME_buf[6] == counter1 || WBSTR_TIME_buf[7] == counter1 ) 
                    {
                        if (WBSTRSET1bits.can_number == 1) can1_flag = 1; if (WBSTRSET1bits.can_number == 2) can2_flag = 1;
                        send_webasto_command ( 13 );
                    }
                }
            } else {
            
            }    
        }    
*/    
    if (counter1 < check_status_duration) {counter1 ++;}
    else {
    Nop();Nop();Nop();
    
        counter1 = 0;
        //if (WBSTRSET1bits.can_number == 1 || WBSTRSET1bits.can_number == 2)
        if (can1_flag == 1) {can1_flag = 0; C1TR23CONbits.TXREQ3 = 0; }
        if (can2_flag == 1) {can2_flag = 0; C2TR23CONbits.TXREQ3 = 0; }
        if ( WEBASTObits.start == 1 ) { WEBASTObits.start = 0; WEBASTObits.start_done = 1; } //send_lock_comand_status (1);
        if ( WEBASTObits.stop  == 1 ) { WEBASTObits.stop = 0;  WEBASTObits.stop_done = 1; } //send_lock_comand_status (0);
        
    }


#if defined (PORSHE_CAENE)
    if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.ide == 0 && CAN2SETTINGSbits.bitrate == 100 ) { //100    
        if (counter1 == 300) {  // Проверка
            LOCKUNLOCKbits.counter = 2;
            ecan2WriteTxMsgBufId ( 3, (long) 0x363, (unsigned int) 0, (unsigned int) 0 );
            ecan2WriteTxMsgBufData( 3, (unsigned int) 4, (unsigned int) 0x0000, (unsigned int) 0x0001, (unsigned int) 0x0000, (unsigned int) 0x0000 );
            settxtransmit2( 3 );    
        }
    }
# endif
#if defined (VW_MMULTIVAN_T6_2017_WEBASTO)
    if ( CAN2SETTINGSbits.on == 1 && CAN2SETTINGSbits.ide == 0 && CAN2SETTINGSbits.bitrate == 100 ) { //100    
        if (counter1 == 250 || counter1 == 500 || counter1 == 750 || counter1 == 1000) {  // Проверка
            LOCKUNLOCKbits.counter = 2;
            ecan2WriteTxMsgBufId ( 3, (long) 0x76A, (unsigned int) 0, (unsigned int) 0 );
            ecan2WriteTxMsgBufData( 3, (unsigned int) 8, (unsigned int) 0x2203, (unsigned int) 0x0018, (unsigned int) 0x5555, (unsigned int) 0x5555 );
            settxtransmit2( 3 );    
        }
    }
# endif 
    

}
void check_webasto_status_thru_can (void) {
    static unsigned long counter1 = 0;
    static unsigned int can1_flag = 0, can2_flag = 0;
    
    if ( WEBASTObits.task_start == 0 ) { counter1 = 0; return; }
    
    counter1 ++;

    if (WBSTRSET1bits.can_number == 1 || WBSTRSET1bits.can_number == 2) {

        if ( counter1 != 0 ) { // Запрос статуса вебасто
            if ( counter1 != 0 ) {
                if ( ( counter1 % WBSTCANWAKETIMEbits.period ) == 0 ) 
                { //C1TR23CONbits.TXREQ3=1;

                    if (WBSTRSET1bits.can_number == 1) can1_flag = 1; if (WBSTRSET1bits.can_number == 2) can2_flag = 1;

                    if ( can1_flag == 1 && C1TR23CONbits.TXREQ3 == 0) {
                        send_webasto_command ( 13 );
                    }
                    if ( can2_flag == 1 && C2TR23CONbits.TXREQ3 == 0) {
                        send_webasto_command ( 13 );
                    }                        
                }
            }
        } else {

        }    
    }    


    if ( WEBASTObits.counter == 1 ) {
    Nop();Nop();Nop();
    
        counter1 = 0;
        if (can1_flag == 1) {can1_flag = 0; C1TR23CONbits.TXREQ3 = 0; }
        if (can2_flag == 1) {can2_flag = 0; C2TR23CONbits.TXREQ3 = 0; }
        
    }
    
}
void send_webasto_command ( int command_number ) {
    
    unsigned int temp1 = 0, temp2 = 0, temp3 = 0, temp4 = 0; 

    unsigned long ID        = 0x0;
    unsigned int len        = 0x0;
    unsigned int can_number = 0x0;
    
        switch (command_number)
        {
            case 1:
                can_number = WBSTSTARTSET1bits.can_number;
                ID = WBSTSTARTSET1bits.id;
                len = WBSTSTARTSET1bits.len;
                temp1 = WBSTSTARTDAT1bits.B1; temp1 = (temp1 << 8) + WBSTSTARTDAT1bits.B0; temp2 = WBSTSTARTDAT1bits.B3; temp2 = (temp2 << 8) + WBSTSTARTDAT1bits.B2;
                temp3 = WBSTSTARTDAT1bits.B5; temp3 = (temp3 << 8) + WBSTSTARTDAT1bits.B4; temp4 = WBSTSTARTDAT1bits.B7; temp4 = (temp4 << 8) + WBSTSTARTDAT1bits.B6;
                break;
            case 2:
                can_number = WBSTSTARTSET2bits.can_number;
                ID = WBSTSTARTSET2bits.id;
                len = WBSTSTARTSET2bits.len;
                temp1 = WBSTSTARTDAT2bits.B1; temp1 = (temp1 << 8) + WBSTSTARTDAT2bits.B0; temp2 = WBSTSTARTDAT2bits.B3; temp2 = (temp2 << 8) + WBSTSTARTDAT2bits.B2;
                temp3 = WBSTSTARTDAT2bits.B5; temp3 = (temp3 << 8) + WBSTSTARTDAT2bits.B4; temp4 = WBSTSTARTDAT2bits.B7; temp4 = (temp4 << 8) + WBSTSTARTDAT2bits.B6;
                break;
            case 3:
                can_number = WBSTSTARTSET3bits.can_number;
                ID = WBSTSTARTSET3bits.id;
                len = WBSTSTARTSET3bits.len;
                temp1 = WBSTSTARTDAT3bits.B1; temp1 = (temp1 << 8) + WBSTSTARTDAT3bits.B0; temp2 = WBSTSTARTDAT3bits.B3; temp2 = (temp2 << 8) + WBSTSTARTDAT3bits.B2;
                temp3 = WBSTSTARTDAT3bits.B5; temp3 = (temp3 << 8) + WBSTSTARTDAT3bits.B4; temp4 = WBSTSTARTDAT3bits.B7; temp4 = (temp4 << 8) + WBSTSTARTDAT3bits.B6;
                break;
            case 4:
                can_number = WBSTSTARTSET4bits.can_number;
                ID = WBSTSTARTSET4bits.id;
                len = WBSTSTARTSET4bits.len;
                temp1 = WBSTSTARTDAT4bits.B1; temp1 = (temp1 << 8) + WBSTSTARTDAT4bits.B0; temp2 = WBSTSTARTDAT4bits.B3; temp2 = (temp2 << 8) + WBSTSTARTDAT4bits.B2;
                temp3 = WBSTSTARTDAT4bits.B5; temp3 = (temp3 << 8) + WBSTSTARTDAT4bits.B4; temp4 = WBSTSTARTDAT4bits.B7; temp4 = (temp4 << 8) + WBSTSTARTDAT4bits.B6;
                break;
            case 5:
                can_number = WBSTSTARTSET5bits.can_number;
                ID = WBSTSTARTSET5bits.id;
                len = WBSTSTARTSET5bits.len;
                temp1 = WBSTSTARTDAT5bits.B1; temp1 = (temp1 << 8) + WBSTSTARTDAT5bits.B0; temp2 = WBSTSTARTDAT5bits.B3; temp2 = (temp2 << 8) + WBSTSTARTDAT5bits.B2;
                temp3 = WBSTSTARTDAT5bits.B5; temp3 = (temp3 << 8) + WBSTSTARTDAT5bits.B4; temp4 = WBSTSTARTDAT5bits.B7; temp4 = (temp4 << 8) + WBSTSTARTDAT5bits.B6;
                break;
            case 6:
                can_number = WBSTSTARTSET6bits.can_number;
                ID = WBSTSTARTSET6bits.id;
                len = WBSTSTARTSET6bits.len;
                temp1 = WBSTSTARTDAT6bits.B1; temp1 = (temp1 << 8) + WBSTSTARTDAT6bits.B0; temp2 = WBSTSTARTDAT6bits.B3; temp2 = (temp2 << 8) + WBSTSTARTDAT6bits.B2;
                temp3 = WBSTSTARTDAT6bits.B5; temp3 = (temp3 << 8) + WBSTSTARTDAT6bits.B4; temp4 = WBSTSTARTDAT6bits.B7; temp4 = (temp4 << 8) + WBSTSTARTDAT6bits.B6;
                break;                
            case 7:
                can_number = WBSTSTOPSET1bits.can_number;
                ID  = WBSTSTOPSET1bits.id;
                len = WBSTSTOPSET1bits.len;                
                temp1 = WBSTSTOPDAT1bits.B1; temp1 = (temp1 << 8) + WBSTSTOPDAT1bits.B0; temp2 = WBSTSTOPDAT1bits.B3; temp2 = (temp2 << 8) + WBSTSTOPDAT1bits.B2;
                temp3 = WBSTSTOPDAT1bits.B5; temp3 = (temp3 << 8) + WBSTSTOPDAT1bits.B4; temp4 = WBSTSTOPDAT1bits.B7; temp4 = (temp4 << 8) + WBSTSTOPDAT1bits.B6;
                break;
            case 8:
                can_number = WBSTSTOPSET2bits.can_number;
                ID  = WBSTSTOPSET2bits.id;
                len = WBSTSTOPSET2bits.len;                
                temp1 = WBSTSTOPDAT2bits.B1; temp1 = (temp1 << 8) + WBSTSTOPDAT2bits.B0; temp2 = WBSTSTOPDAT2bits.B3; temp2 = (temp2 << 8) + WBSTSTOPDAT2bits.B2;
                temp3 = WBSTSTOPDAT2bits.B5; temp3 = (temp3 << 8) + WBSTSTOPDAT2bits.B4; temp4 = WBSTSTOPDAT2bits.B7; temp4 = (temp4 << 8) + WBSTSTOPDAT2bits.B6;
                break;
            case 9:
                can_number = WBSTSTOPSET3bits.can_number;
                ID  = WBSTSTOPSET3bits.id;
                len = WBSTSTOPSET3bits.len;                
                temp1 = WBSTSTOPDAT3bits.B1; temp1 = (temp1 << 8) + WBSTSTOPDAT3bits.B0; temp2 = WBSTSTOPDAT3bits.B3; temp2 = (temp2 << 8) + WBSTSTOPDAT3bits.B2;
                temp3 = WBSTSTOPDAT3bits.B5; temp3 = (temp3 << 8) + WBSTSTOPDAT3bits.B4; temp4 = WBSTSTOPDAT3bits.B7; temp4 = (temp4 << 8) + WBSTSTOPDAT3bits.B6;
                break;
            case 10:
                can_number = WBSTSTOPSET4bits.can_number;
                ID  = WBSTSTOPSET4bits.id;
                len = WBSTSTOPSET4bits.len;                
                temp1 = WBSTSTOPDAT4bits.B1; temp1 = (temp1 << 8) + WBSTSTOPDAT4bits.B0; temp2 = WBSTSTOPDAT4bits.B3; temp2 = (temp2 << 8) + WBSTSTOPDAT4bits.B2;
                temp3 = WBSTSTOPDAT4bits.B5; temp3 = (temp3 << 8) + WBSTSTOPDAT4bits.B4; temp4 = WBSTSTOPDAT4bits.B7; temp4 = (temp4 << 8) + WBSTSTOPDAT4bits.B6;
                break;
            case 11:
                can_number = WBSTSTOPSET5bits.can_number;
                ID  = WBSTSTOPSET5bits.id;
                len = WBSTSTOPSET5bits.len;                
                temp1 = WBSTSTOPDAT5bits.B1; temp1 = (temp1 << 8) + WBSTSTOPDAT5bits.B0; temp2 = WBSTSTOPDAT5bits.B3; temp2 = (temp2 << 8) + WBSTSTOPDAT5bits.B2;
                temp3 = WBSTSTOPDAT5bits.B5; temp3 = (temp3 << 8) + WBSTSTOPDAT5bits.B4; temp4 = WBSTSTOPDAT5bits.B7; temp4 = (temp4 << 8) + WBSTSTOPDAT5bits.B6;

                break;
            case 12:
                can_number = WBSTSTOPSET6bits.can_number;
                ID  = WBSTSTOPSET6bits.id;
                len = WBSTSTOPSET6bits.len;                
                temp1 = WBSTSTOPDAT6bits.B1; temp1 = (temp1 << 8) + WBSTSTOPDAT6bits.B0; temp2 = WBSTSTOPDAT6bits.B3; temp2 = (temp2 << 8) + WBSTSTOPDAT6bits.B2;
                temp3 = WBSTSTOPDAT6bits.B5; temp3 = (temp3 << 8) + WBSTSTOPDAT6bits.B4; temp4 = WBSTSTOPDAT6bits.B7; temp4 = (temp4 << 8) + WBSTSTOPDAT6bits.B6;

                break;
            case 13:
                can_number = WBSTRSET1bits.can_number;
                ID = WBSTRSET1bits.id;
                len = WBSTRSET1bits.len;
                temp1 = WBSTRDAT1bits.B1; temp1 = (temp1 << 8) + WBSTRDAT1bits.B0; temp2 = WBSTRDAT1bits.B3; temp2 = (temp2 << 8) + WBSTRDAT1bits.B2;
                temp3 = WBSTRDAT1bits.B5; temp3 = (temp3 << 8) + WBSTRDAT1bits.B4; temp4 = WBSTRDAT1bits.B7; temp4 = (temp4 << 8) + WBSTRDAT1bits.B6;
                break;
//            case 12:
//                can_number = WBSTRSET2bits.can_number;
//                ID = WBSTRSET2bits.id;
//                len = WBSTRSET2bits.len;
//                temp1 = WBSTRDAT2bits.B1; temp1 = (temp1 << 8) + WBSTRDAT2bits.B0; temp2 = WBSTRDAT2bits.B3; temp2 = (temp2 << 8) + WBSTRDAT2bits.B2;
//                temp3 = WBSTRDAT2bits.B5; temp3 = (temp3 << 8) + WBSTRDAT2bits.B4; temp4 = WBSTRDAT2bits.B7; temp4 = (temp4 << 8) + WBSTRDAT2bits.B6;
//                break;
//            case 13:
//                can_number = WBSTRSET3bits.can_number;
//                ID = WBSTRSET3bits.id;
//                len = WBSTRSET3bits.len;
//                temp1 = WBSTRDAT3bits.B1; temp1 = (temp1 << 8) + WBSTRDAT3bits.B0; temp2 = WBSTRDAT3bits.B3; temp2 = (temp2 << 8) + WBSTRDAT3bits.B2;
//                temp3 = WBSTRDAT3bits.B5; temp3 = (temp3 << 8) + WBSTRDAT3bits.B4; temp4 = WBSTRDAT3bits.B7; temp4 = (temp4 << 8) + WBSTRDAT3bits.B6;
//                break;

                
            default:
                break;
        }

        unsigned int ide;
        if ( ID <= 0x7FF ) ide = 0;
        else ide = 1;
    if (can_number == 1) {
        ecan1WriteTxMsgBufId ( 3, (long) ID, (unsigned int) ide, (unsigned int) 0 );//CAN1SETTINGSbits.ide
        ecan1WriteTxMsgBufData( 3, (unsigned int) len, temp1, temp2, temp3, temp4 );
        settxtransmit( 3 );                                
    }
    if (can_number == 2) {
        ecan2WriteTxMsgBufId ( 3, (long) ID, (unsigned int) ide, (unsigned int) 0 );//CAN2SETTINGSbits.ide
        ecan2WriteTxMsgBufData( 3, (unsigned int) len, temp1, temp2, temp3, temp4 );
        settxtransmit2( 3 );                                
    }    

//    ecan2WriteTxMsgBufId ( 3, (long) 0x521, (unsigned int) 0, (unsigned int) 0 );
//    ecan2WriteTxMsgBufData( 3, (unsigned int) 8, (unsigned int) 0x0201, (unsigned int) 0x0002, (unsigned int) 0x0000, (unsigned int) 0x2855 );
//    settxtransmit2( 3 );        
        
}




void request_can_data (void) {

static unsigned int counter = 0;
unsigned int temp1, temp2, temp3, temp4;

    if ( ignition == 0 ||  OUTbits.serv_flag == 1 ) {
        counter = 0;
        C1TR45CONbits.TXREQ4 = 0;
        C2TR45CONbits.TXREQ4 = 0;                
        return;
    }

    if ( counter < 300 ) counter ++;
    else counter = 0;

    temp1 =0; temp2 =0; temp3 =0; temp4 =0;

        switch (counter)
        {
            case 10:
                if (CANREQ1SETbits.can_number == 1 || CANREQ1SETbits.can_number == 2) {
                    temp1 = CANREQ1DATbits.B1; temp1 = (temp1 << 8) + CANREQ1DATbits.B0;
                    temp2 = CANREQ1DATbits.B3; temp2 = (temp2 << 8) + CANREQ1DATbits.B2;
                    temp3 = CANREQ1DATbits.B5; temp3 = (temp3 << 8) + CANREQ1DATbits.B4;
                    temp4 = CANREQ1DATbits.B7; temp4 = (temp4 << 8) + CANREQ1DATbits.B6;
                    if (CAN1SETTINGSbits.on == 1 && CANREQ1SETbits.can_number == 1 ) {
                        ecan1WriteTxMsgBufId  ( 4, (long) CANREQ1SETbits.id, (unsigned int) CAN1SETTINGSbits.ide, (unsigned int) 0 );
                        ecan1WriteTxMsgBufData( 4, (unsigned int) CANREQ1SETbits.len, (unsigned int) temp1, (unsigned int) temp2, (unsigned int) temp3, (unsigned int) temp4 );
                        settxtransmit( 4 );
                    }
                    if (CAN2SETTINGSbits.on == 1 && CANREQ1SETbits.can_number == 2) {
                        ecan2WriteTxMsgBufId  ( 4, (long) CANREQ1SETbits.id, (unsigned int) CAN2SETTINGSbits.ide, (unsigned int) 0 );
                        ecan2WriteTxMsgBufData( 4, (unsigned int) CANREQ1SETbits.len, (unsigned int) temp1, (unsigned int) temp2, (unsigned int) temp3, (unsigned int) temp4 );
                        settxtransmit2( 4 );
                    }
                }
                break;
            case 19:
                    C1TR45CONbits.TXREQ4 = 0;
                    C2TR45CONbits.TXREQ4 = 0;                
                break;
            
            case 20:
                if (CANREQ2SETbits.can_number == 1 || CANREQ2SETbits.can_number == 2) {
                    temp1 = CANREQ2DATbits.B1; temp1 = (temp1 << 8) + CANREQ2DATbits.B0;
                    temp2 = CANREQ2DATbits.B3; temp2 = (temp2 << 8) + CANREQ2DATbits.B2;
                    temp3 = CANREQ2DATbits.B5; temp3 = (temp3 << 8) + CANREQ2DATbits.B4;
                    temp4 = CANREQ2DATbits.B7; temp4 = (temp4 << 8) + CANREQ2DATbits.B6;
                    if (CAN1SETTINGSbits.on == 1 && CANREQ2SETbits.can_number == 1) {
                        ecan1WriteTxMsgBufId  ( 4, (long) CANREQ2SETbits.id, (unsigned int) CAN1SETTINGSbits.ide, (unsigned int) 0 );
                        ecan1WriteTxMsgBufData( 4, (unsigned int) CANREQ2SETbits.len, (unsigned int) temp1, (unsigned int) temp2, (unsigned int) temp3, (unsigned int) temp4 );
                        settxtransmit( 4 );
                    }
                    if (CAN2SETTINGSbits.on == 1 && CANREQ2SETbits.can_number == 2) {
                        ecan2WriteTxMsgBufId  ( 4, (long) CANREQ2SETbits.id, (unsigned int) CAN2SETTINGSbits.ide, (unsigned int) 0 );
                        ecan2WriteTxMsgBufData( 4, (unsigned int) CANREQ2SETbits.len, (unsigned int) temp1, (unsigned int) temp2, (unsigned int) temp3, (unsigned int) temp4 );
                        settxtransmit2( 4 );
                    }
                }
                break;
            case 29:
                    C1TR45CONbits.TXREQ4 = 0;
                    C2TR45CONbits.TXREQ4 = 0;
                break;
            
            case 30:
                if (CANREQ3SETbits.can_number == 1 || CANREQ3SETbits.can_number == 2) {
                    temp1 = CANREQ3DATbits.B1; temp1 = (temp1 << 8) + CANREQ3DATbits.B0;
                    temp2 = CANREQ3DATbits.B3; temp2 = (temp2 << 8) + CANREQ3DATbits.B2;
                    temp3 = CANREQ3DATbits.B5; temp3 = (temp3 << 8) + CANREQ3DATbits.B4;
                    temp4 = CANREQ3DATbits.B7; temp4 = (temp4 << 8) + CANREQ3DATbits.B6;
                    if (CAN1SETTINGSbits.on == 1 && CANREQ3SETbits.can_number == 1) {
                        ecan1WriteTxMsgBufId  ( 4, (long) CANREQ3SETbits.id, (unsigned int) CAN1SETTINGSbits.ide, (unsigned int) 0 );
                        ecan1WriteTxMsgBufData( 4, (unsigned int) CANREQ3SETbits.len, (unsigned int) temp1, (unsigned int) temp2, (unsigned int) temp3, (unsigned int) temp4 );
                        settxtransmit( 4 );
                    }
                    if (CAN2SETTINGSbits.on == 1 && CANREQ3SETbits.can_number == 2) {
                        ecan2WriteTxMsgBufId  ( 4, (long) CANREQ3SETbits.id, (unsigned int) CAN2SETTINGSbits.ide, (unsigned int) 0 );
                        ecan2WriteTxMsgBufData( 4, (unsigned int) CANREQ3SETbits.len, (unsigned int) temp1, (unsigned int) temp2, (unsigned int) temp3, (unsigned int) temp4 );
                        settxtransmit2( 4 );
                    }
                }
                break;
            case 39:
                    C1TR45CONbits.TXREQ4 = 0;
                    C2TR45CONbits.TXREQ4 = 0;
                break;
            
            case 40:

                break;
            case 49:

                break;
            
            case 50:

                break;
            case 59:

                break;                

            default:
                break;
        }
}

void fire_lock_close_during_autorun (void) {

//# if defined (HYUDAI_I40)
    
    static unsigned char ign_tmp = 0, start_delay = 0;
    
    if ( lock_close_autorun_enable == 0 ) {
        LOCKAUTORUNbits.LOCKAUTORUN = 0;
        ign_tmp = 0;
        start_delay = 0;
        return;        
    }
    
//LOCKAUTORUNbits
    if (LOCKAUTORUNbits.start == 0) {
        LOCKAUTORUNbits.LOCKAUTORUN = 0;
        ign_tmp = 0;
        start_delay = 0;
        return;
    }
        if (ign_tmp == 1 && ignition == 0) {
            Nop();Nop();Nop();
            start_delay = 1;
        }
        ign_tmp = ignition;
        
    if (STARTENGINEbits.start == 1 || STARTENGINEPbits.start == 1 || STARTENGINESbits.start == 1 || STARTENGINEDLbits.start == 1) {
        LOCKAUTORUNbits.counter = 200;
    }

    if (LOCKAUTORUNbits.counter > 0) {
        LOCKAUTORUNbits.counter --;
        
        if (start_delay == 1) {
            if (LOCKAUTORUNbits.delay_counter < 25) LOCKAUTORUNbits.delay_counter ++;
            else {
                start_delay = 0;
                LOCKAUTORUNbits.delay_counter = 0;
                
                LOCKUNLOCKbits.LOCKUNLOCK = 0;
                LOCKUNLOCKbits.start = 1; 
                LOCKUNLOCKbits.lock = 1;                
            }
        } else {
            start_delay = 0;
            LOCKAUTORUNbits.delay_counter = 0;            
        }
        
        
        
    }
    else {
        Nop();Nop();Nop();
        LOCKAUTORUNbits.LOCKAUTORUN = 0;
        ign_tmp = 0;
        return;
    }


//# endif
    
}
int disable_ignition_intrusion_during_autorun (void) {

    if (IGNINTROFFAUTORUNbits.start == 0) return 0;
    
    if (IGNINTROFFAUTORUNbits.counter < 1800) IGNINTROFFAUTORUNbits.counter ++;
    else {
        IGNINTROFFAUTORUNbits.IGNINTROFFAUTORUN = 0;
        return 0;
    }

return 1;    
}
void fire_door_open_during_autorun (void) {

//# if defined (HYUDAI_I40)
    
    static unsigned char ign_tmp = 0, start_delay = 0;
    
    if ( DOPENSET1bits.can_number == 0 ) {
        DOORAUTORUNbits.DOORAUTORUN = 0;
        ign_tmp = 0;
        start_delay = 0;
        return;        
    }
    
//LOCKAUTORUNbits
    if (DOORAUTORUNbits.start == 0) {
        DOORAUTORUNbits.DOORAUTORUN = 0;
        ign_tmp = 0;
        start_delay = 0;
        return;
    }
        if (ign_tmp == 1 && ignition == 0) {
            Nop();Nop();Nop();
            start_delay = 1;
        }
        ign_tmp = ignition;
        
    if ( STARTENGINEbits.start == 1 || STARTENGINEPbits.start == 1 || STARTENGINESbits.start == 1 || STARTENGINEDLbits.start == 1 || STARTENGINEObits.start == 1 || STARTENGINEO1bits.start == 1 ) {
        DOORAUTORUNbits.counter = 200;
    }
    if ( DOORAUTORUNbits.engine_start_fail == 1 ) {
        DOORAUTORUNbits.counter = 200;
    }

    if (DOORAUTORUNbits.counter > 0) {
        DOORAUTORUNbits.counter --;
        
        if (start_delay == 1) {
            if (DOORAUTORUNbits.delay_counter < 25) DOORAUTORUNbits.delay_counter ++;
            else {
                start_delay = 0;
                DOORAUTORUNbits.delay_counter = 0;
                
                DOORAUTORUNbits.DOORAUTORUN = 0;
                DOOROPENbits.start = 1;
                
            }
        } else {
            start_delay = 0;
            DOORAUTORUNbits.delay_counter = 0;            
        }
        
        
        
    }
    else {
        Nop();Nop();Nop();
        DOORAUTORUNbits.DOORAUTORUN = 0;
        ign_tmp = 0;
        return;
    }


//# endif
    
}


void voltage_mesuare (void) {
    
static unsigned int car_volt_counter = 0, car_volt = 0, car_volt_fall = 0, temp_volt = 0;
static unsigned int /*battery_volt_counter = 0,*/ battery_volt = 0;


//    if ( _AD1IF ) {
//        _AD1IF = 0;
//        if (car_volt_counter < 10) {
//            car_volt_counter ++;
//            car_volt = car_volt + ADC1BUF0;
////            Nop();Nop();Nop();
//        }
//        else {
//            car_voltage = (unsigned char)((car_volt + 20) / 40);
//            car_volt = 0;
//            car_volt_counter = 0;
//        }
//    }

    if ( _AD1IF ) {
        _AD1IF = 0;
        if (car_volt_counter < 100) {
            car_volt_counter ++;
        }
        else {
            car_volt_counter = 0;
        }
        
        if (   car_volt_counter == 0  || car_volt_counter == 10 || car_volt_counter == 20 || car_volt_counter == 30
            || car_volt_counter == 40 || car_volt_counter == 50 || car_volt_counter == 60 || car_volt_counter == 70
            || car_volt_counter == 80 || car_volt_counter == 90) {
            
            temp_volt = ADC1BUF0;
            Nop();Nop();Nop();
            car_volt_fall = car_volt_fall + temp_volt;
            car_volt = car_volt + temp_volt;
            
            AD1CHS0bits.CH0SA   = 3;
        }
        
        if (   car_volt_counter == 5  || car_volt_counter == 15 || car_volt_counter == 25 || car_volt_counter == 35
            || car_volt_counter == 45 || car_volt_counter == 55 || car_volt_counter == 65 || car_volt_counter == 75
            || car_volt_counter == 85 || car_volt_counter == 95) {
            
            battery_volt = battery_volt + ADC1BUF0;
            AD1CHS0bits.CH0SA   = 2;
        }        
        
        if ( car_volt_counter == 99 ) {
            
            car_voltage = (unsigned char)((car_volt + 20) / 40);
            car_volt = 0;
            
            battery_voltage = (unsigned char)((battery_volt + 20) / 40);
            battery_volt = 0;
            
        }
        if (   car_volt_counter == 10 || car_volt_counter == 30 || car_volt_counter == 50 || 
               car_volt_counter == 70 || car_volt_counter == 90) {
            Nop();Nop();Nop();
            car_voltage_fall = (unsigned char)((car_volt_fall + 4) / 8);
            car_volt_fall = 0;
           
        }
    }


    AD1CON1bits.SAMP = 1;    
    
//    Nop();Nop();Nop();


    
}
unsigned int CRC16(void * buff, unsigned int byte_count) {
  union
   {
     struct
      {
        unsigned char lo;
        unsigned char hi;
      };
     unsigned int value;
   } crc_dat;

   unsigned int temp;
    
//    if(CRCCON1bits.CRCEN == 0) {
    
        PMD3bits.CRCMD  = 0;
        CRCCON1bits.CRCEN   = 1;    // Module is enabled
        CRCCON1bits.LENDIAN = 0;    // 0 = starting with the MSb
        CRCCON1bits.CRCISEL = 0;

        CRCCON2bits.PLEN   = 15;    // Length of polynomial - 1
        CRCCON2bits.DWIDTH =  7;    // width of the data    - 1

        CRCXORL  = 0x1021;          // generator Polynomial
        CRCXORH  = 0x0000;
//     }

    CRCWDATL = 0x0000;
    CRCWDATH = 0x0000;

    CRCCON1bits.CRCGO = 1;

    if(byte_count & 1)
     {
        crc_dat.hi =  0;
        crc_dat.lo =  * (unsigned char *) buff++;

        CRCDAT = crc_dat.value;

        byte_count--;
     }

    while(byte_count)
     {
        crc_dat.hi =  * (unsigned char *) buff++;
        crc_dat.lo =  * (unsigned char *) buff++;

        while(CRCCON1bits.CRCFUL);

        CRCDAT  = crc_dat.value;

        byte_count -= 2;
     }

    while(CRCCON1bits.CRCFUL);

    CRCDAT  = 0;

    while(CRCCON1bits.CRCMPT != 1);

    Nop();
    Nop();
    Nop();
    Nop();
    Nop();

    CRCCON1bits.CRCGO = 0;

    Nop();
    temp = CRCWDATL; 
    CRCCON1bits.CRCEN = 0;    // Module is enabled    
    PMD3bits.CRCMD    = 1;

    return temp;
}


void initCRC (void) {
    
    
    CRCCON1bits.CRCEN = 1;    
    CRCCON2bits.PLEN = 0x0F; // CRC16
    CRCCON2bits.DWIDTH = 0x07; // 16 бит - длина данных
    
    CRCXORL = 0x1021;// //x16 + x12 + x5 + 1
    CRCXORH = 0b0000000000000000;

    CRCCON1bits.CSIDL = 0; // Стоп в IDLE
    CRCCON1bits.CRCISEL = 0; // Прерывание когда FIFO пуст
    CRCCON1bits.LENDIAN = 1; // Младшим байтом вперед
    
}
void generate_fwversion_dowloaded_message (void) {

    if (fwversion_message_flag == 1) {
//    if (nav_trigger == 0) return;
    
    
    fwversion_message_flag = 0;
    
        FW_version = FM25_read_4 (2026);
//        generate_content_of_message ( 41, 1 );
        reload_GPRS_header ( 4, 41, 0x0011); // N = 3, name = 38, type = 1, ACK = 1
        memmove ( command_temp_buf, GPRS_header_buf, 12 );
        unsigned int ACK_counter = 0xFFFF;
        command_temp_buf[12] = (unsigned char) (ACK_counter >> 8); command_temp_buf[13] = (unsigned char) ACK_counter; // ACK
        command_temp_buf[14] = 0xFF; command_temp_buf[15] = 0x01; command_temp_buf[16] = 0x24; // Dataflags
        memmove  ( &command_temp_buf[17], Navi_bin, 22 );

        command_temp_buf[39] = (unsigned char)(FW_version >> 16);
        command_temp_buf[40] = (unsigned char)(FW_version >> 8);
        command_temp_buf[41] = (unsigned char)(FW_version );
        
        sequence_number = get_sequence_number ();
        command_temp_buf[ 42 ] = (unsigned char)(sequence_number >> 24);
        command_temp_buf[ 43 ] = (unsigned char)(sequence_number >> 16);
        command_temp_buf[ 44 ] = (unsigned char)(sequence_number >> 8);
        command_temp_buf[ 45 ] = (unsigned char)(sequence_number);            
        
        command_temp_buf[113] = 46; //38
        write_data_into_save_to_flash_bufs ( command_temp_buf, 46 ); 
        Nop();Nop();Nop();
    }
    if (fw_dowloaded_flag == 1) {
        fw_dowloaded_flag = 0;
        
        FW_version = FM25_read_4 (2026);
        reload_GPRS_header ( 4, 42, 0x0011); // N = 3, name = 38, type = 1, ACK = 1
        memmove ( command_temp_buf, GPRS_header_buf, 12 );
        unsigned int ACK_counter = 0xFFFF;
        command_temp_buf[12] = (unsigned char) (ACK_counter >> 8); command_temp_buf[13] = (unsigned char) ACK_counter; // ACK
        command_temp_buf[14] = 0xFF; command_temp_buf[15] = 0x01; command_temp_buf[16] = 0x28; // Dataflags
        memmove  ( &command_temp_buf[17], Navi_bin, 22 );

        command_temp_buf[39] = FM25_read_1 (2032); command_temp_buf[40] = FM25_read_1 (2033);  command_temp_buf[41] = FM25_read_1 (2034);
        command_temp_buf[42] = FM25_read_1 (2035); command_temp_buf[43] = FM25_read_1 (2036);

        command_temp_buf[44] = FM25_read_1 (2037); command_temp_buf[45] = FM25_read_1 (2038); command_temp_buf[46] = FM25_read_1 (2039); 
        command_temp_buf[47] = FM25_read_1 (2040); command_temp_buf[48] = FM25_read_1 (2041); 
        
        command_temp_buf[49] = FM25_read_1 (2042); command_temp_buf[50] = FM25_read_1 (2043); command_temp_buf[51] = FM25_read_1 (2044); 
        command_temp_buf[52] = FM25_read_1 (2045); command_temp_buf[53] = FM25_read_1 (2046);

        sequence_number = get_sequence_number ();
        command_temp_buf[ 54 ] = (unsigned char)(sequence_number >> 24);
        command_temp_buf[ 55 ] = (unsigned char)(sequence_number >> 16);
        command_temp_buf[ 56 ] = (unsigned char)(sequence_number >> 8);
        command_temp_buf[ 57 ] = (unsigned char)(sequence_number);            
        

        command_temp_buf[113] = 58; //38
        write_data_into_save_to_flash_bufs ( command_temp_buf, 58 ); 
        Nop();Nop();Nop();        
        
    }



        
}

void generate_fw_request_message (void) {
    
    if (fw_request_flag != 1) return;
    Nop();Nop();Nop();
    fw_request_flag = 0;
    
        reload_GPRS_header ( 1, 00, 0x0003); // N = 1, name = 0, type = 3, ACK = 0
        memmove ( &command_temp_buf, GPRS_header_buf, 12 );
        memmove ( &command_temp_buf[12], fw_req_buf, 20 );

        command_temp_buf[113] = 32; //38
        write_data_to_GPRS_buf ( &command_temp_buf, 32 );
//        write_data_into_save_to_flash_bufs ( command_temp_buf, 32 ); 
        
        Nop();Nop();Nop();
    
}
void generate_type0_message (void) {
//unsigned int crc;    
    if (type0_send_flag == 0) return;
    
    type0_send_flag = 0;
    
//    crc = CRC16 (&TYPE0, 9);
//    TYPE0[9] = (unsigned char) (crc >> 8);
//    TYPE0[10] = (unsigned char) crc;
    write_data_to_GPRS_buf ( TYPE0, 9 );
    
}
void generate_reset_reason_message (int connection_status ) {
    
    if (connection_status != 4) return;
    if (RESETREASONbits.reset_flag ==  0) return;
    
    if (RESETREASONbits.BOR )    load_answer ( 2, "reset BOR", 0, 0 );
    if (RESETREASONbits.EXTR )   load_answer ( 2, "reset EXTR", 0, 0 );
    if (RESETREASONbits.IOPUWR ) load_answer ( 2, "reset IOPUWR", 0, 0 );
    if (RESETREASONbits.POR )    load_answer ( 2, "reset POR", 0, 0 );
    if (RESETREASONbits.SWR )    load_answer ( 2, "reset SWR", 0, 0 );
    if (RESETREASONbits.TRAPR )  load_answer ( 2, "reset TRAPR", 0, 0 );    
    if (RESETREASONbits.WDTO )   load_answer ( 2, "reset WDTO", 0, 0 );
    RESETREASONbits.RESETREASON = 0;
    
}
void generate_panic_message (void) {

    static int counter = 0;
    
    if (generate_panic_flag == 0) {counter = 0; return;}
    
    if (counter < 20) counter ++;
    else {
        counter = 0;
        generate_panic_flag = 0;
        Nop();Nop();Nop();
        
// Формирование сообщения паника
/*        
            reload_GPRS_header ( 3, 46, 0x0011); // N = 3, name = 30, type = 1, ACK = 1
            memmove ( command_temp_buf, GPRS_header_buf, 12 );
            unsigned int ACK_counter = 0xFFFF;
            command_temp_buf[12] = (unsigned char) (ACK_counter >> 8); command_temp_buf[13] = (unsigned char) ACK_counter; // ACK
            command_temp_buf[14] = 0xFF; command_temp_buf[15] = 0x01; // Dataflags
            memmove  ( &command_temp_buf[16], Navi_bin, 22 );
            command_temp_buf[113] = 38; //38
            write_data_into_save_to_flash_bufs ( command_temp_buf, 38 );
*/            
            generate_content_of_message ( 46, 1 );
            
    }
    
}


void generate_status_message_responce (int connection_status) {
    
    if (status_mesage_flag == 1 || status_mesage_flag == 2) {
        if ( connection_status == 4 ) {
            if (status_mesage_flag == 1) generate_content_of_message ( 49, 1 ); // Ответ с записью в память
            if (status_mesage_flag == 2) generate_content_of_ack_free_message ( 49, 1 ); // Ответ без записи в память
            status_mesage_flag = 0;
        }
    }
    if (status_mesage_flag == 3) {
        
    }
}

# if defined (K_LINE)
void get_91412_data (void) {

//    return;
static unsigned int counter = 0, start = 0;
int res;

    if (ignition == 0 || OUTbits.serv_flag == 1) {
        counter = 0;
        KTASCKSbits.start = 1;
        return;
    }
//    if ( ignition == 1 && KTASCKSbits.start == 0 ) KTASCKSbits.start = 1;
    if ( KTASCKSbits.start == 0 ) return;

    if (counter < 1000) counter ++;
    else {
        counter = 0;
        start = 1;
    }
// Запрос VIN        
        if (KTASCKSbits.vin_running == 0 && KTASCKSbits.vin_done == 0 && start == 1) {
            start = 0;
            KTASCKSbits.vin_running = 1;
            type_of_K_line_request = 0x09;
//            if (type_of_K_line == 1) {UART3_Tx_buf[0] = 0x68; UART3_Tx_buf[1] = 0x6a; UART3_Tx_buf[2] = 0xF1; UART3_Tx_buf[3] = 0x09; UART3_Tx_buf[4] = 0x02;} 
//            else                     {UART3_Tx_buf[0] = 0xC2; UART3_Tx_buf[1] = 0x33; UART3_Tx_buf[2] = 0xF1; UART3_Tx_buf[3] = 0x09; UART3_Tx_buf[4] = 0x02;} 
            KINITTASKSbits.length = 5;
            KINITTASKSbits.start = 1;
            KFASTINITTASKSbits.start = 1;
        }
        if (KTASCKSbits.vin_running == 1 && KTASCKSbits.vin_done == 0 && KINITTASKSbits.tasck_complete == 1) {
            KTASCKSbits.vin_done = 1;
            KTASCKSbits.vin_running = 0;
            KINITTASKSbits.KINITTASKS = 0;
            res = check_KVIN ();
            generate_KVIN_message (res);
//            start = 1;
        }

// Запрос ошибок mode3        
        if (KTASCKSbits.mode3_running == 0 && KTASCKSbits.mode3_done == 0 && start == 1) {
            start = 0;
            KTASCKSbits.mode3_running = 1;
            type_of_K_line_request = 0x03;
//            if (type_of_K_line == 1) UART3_Tx_buf[0] = 0x68; UART3_Tx_buf[1] = 0x6a; UART3_Tx_buf[2] = 0xF1; UART3_Tx_buf[3] = 0x03; 
            KINITTASKSbits.length = 4;
            KINITTASKSbits.start = 1;
        }
        if (KTASCKSbits.mode3_running == 1 && KTASCKSbits.mode3_done == 0 && KINITTASKSbits.tasck_complete == 1) {
            KTASCKSbits.mode3_done = 1;
            KTASCKSbits.mode3_running = 0;
            KINITTASKSbits.KINITTASKS = 0;
            kdtc_W_ptr = 0;
            extract_k_dtc (0x03);
        }
        
  
// Запрос ошибок mode7        
        if (KTASCKSbits.mode7_running == 0 && KTASCKSbits.mode7_done == 0 && start == 1) {
            start = 0;
            KTASCKSbits.mode7_running = 1;
            type_of_K_line_request = 0x07;
//            if (type_of_K_line == 1) UART3_Tx_buf[0] = 0x68; UART3_Tx_buf[1] = 0x6a; UART3_Tx_buf[2] = 0xF1; UART3_Tx_buf[3] = 0x07; 
            KINITTASKSbits.length = 4;
            KINITTASKSbits.start = 1;
        } 
        if (KTASCKSbits.mode7_running == 1 && KTASCKSbits.mode7_done == 0 && KINITTASKSbits.tasck_complete == 1) {
            KTASCKSbits.mode7_done = 1;
            KTASCKSbits.mode7_running = 0;
            KINITTASKSbits.KINITTASKS = 0;
            extract_k_dtc (0x07);
        }
                
// Запрос ошибок modeA        
        if (KTASCKSbits.modeA_running == 0 && KTASCKSbits.modeA_done == 0 && start == 1) {
            start = 0;
            KTASCKSbits.modeA_running = 1;
            type_of_K_line_request = 0x0A;
//            if (type_of_K_line == 1) UART3_Tx_buf[0] = 0x68; UART3_Tx_buf[1] = 0x6a; UART3_Tx_buf[2] = 0xF1; UART3_Tx_buf[3] = 0x0A; 
            KINITTASKSbits.length = 4;
            KINITTASKSbits.start = 1;
        }
        if (KTASCKSbits.modeA_running == 1 && KTASCKSbits.modeA_done == 0 && KINITTASKSbits.tasck_complete == 1) {
            KTASCKSbits.modeA_done = 1;
            KTASCKSbits.modeA_running = 0;
            KINITTASKSbits.KINITTASKS = 0;
            extract_k_dtc (0x0A);
            generate_KDTCs_message ();
        }
              
if (KTASCKSbits.vin_done && KTASCKSbits.mode3_done && KTASCKSbits.mode7_done && KTASCKSbits.modeA_done) {
    KINITTASKSbits.KINITTASKS = 0;
    KTASCKSbits.KTASCKS = 0;
}

    
}
int iso_91412_5baud_init (void) {

static unsigned int counter = 0, kw_counter = 0;
unsigned char i;

    if (KINITTASKSbits.start == 0) {
        if (Rx3_DataAvailable == 1) { // По К-лайн что-то принято вне общения с машиной
            Rx3_DataAvailable = 0;
        }
        return;
    }

Nop();Nop();Nop();

        if (counter == 0) {
            _TRISD3 = 0;
            switch_on_off_u3tx_output ( 0 );
        }
        if (counter >= 0   && counter < 20)  _LATD3 = 0;
        if (counter >= 20  && counter < 60)  _LATD3 = 1;
        if (counter >= 60  && counter < 100) _LATD3 = 0;
        if (counter >= 100 && counter < 140) _LATD3 = 1;
        if (counter >= 140 && counter < 180) _LATD3 = 0;    
        if (counter >= 180 && counter < 200) _LATD3 = 1;
        if (counter == 200) {
            _TRISD3 = 1;
            switch_on_off_u3tx_output ( 1 );
            U3_Rx_copy_buf_W = 0;
            U3_Rx_num_of_pages = 0;
            kw_counter = 0;
            set_U3_Rx_timeout (3);
        }

    if (counter < 800) counter ++;
    else {
        Nop();Nop();Nop();
        counter = 0;
        KINITTASKSbits.start = 0;
        KINITTASKSbits.tasck_complete = 1;
    }

    if (Rx3_DataAvailable == 1) { // По К-лайн что-то принято вне общения с машиной
        Rx3_DataAvailable = 0;
        
        if (KINITTASKSbits.ini == 0 && UART3_Rx_buf[0] == 0x55) {    
            Nop();Nop();Nop();
            UART3_Rx_buf[0] = 0;
            KINITTASKSbits.sync = 1;
        }
        if (KINITTASKSbits.ini == 0 && KINITTASKSbits.sync == 1 && UART3_Rx_buf[0] == 0x08) {    
            Nop();Nop();Nop();
            kw_counter ++;
            KINITTASKSbits.kw1 = 1;
            KINITTASKSbits.type = 1;
        }
        if (KINITTASKSbits.ini == 0 && KINITTASKSbits.sync == 1 && UART3_Rx_buf[0] == 0xE9) {    
            Nop();Nop();Nop();
            kw_counter = 2;
            KINITTASKSbits.kw1 = 1;
            KINITTASKSbits.type = 2;
        }
        if (KINITTASKSbits.ini == 0 && kw_counter == 2 && KINITTASKSbits.sync == 1 && KINITTASKSbits.kw1 == 1 && ( UART3_Rx_buf[0] == 0x08 || UART3_Rx_buf[0] == 0x8F)) {    
            Nop();Nop();Nop();
            KINITTASKSbits.kw1 = 1;
            KINITTASKSbits.kw2 = 1;
            if (KINITTASKSbits.type == 1) UART3_Tx_buf[0] = 0xF7;
            else UART3_Tx_buf[0] = 0x70;//16
            start_UART3_transmission (1);
        }
   
        if (KINITTASKSbits.ini == 0 && UART3_Rx_buf[0] == 0xCC) {
            Nop();Nop();Nop(); 
            KINITTASKSbits.ini = 1;
            KINITTASKSbits.done = 1;
            type_of_K_line = KINITTASKSbits.type;
            set_U3_Rx_timeout (25);
        }
        
        if (KINITTASKSbits.waiting_response == 1) {
            for (i = 0; i < U3_num_W_tmp; i ++) { // Расчет контрольной суммы
                UART3_Rx_copy_buf[U3_Rx_copy_buf_W][i] = UART3_Rx_buf[i];
            }
            UART3_Rx_copy_buf[U3_Rx_copy_buf_W][14] = U3_num_W_tmp;
            U3_Rx_copy_buf_W ++;
            U3_Rx_num_of_pages ++;
        }
        

    }


            if (KFASTINITTASKSbits.done == 1) {
                KFASTINITTASKSbits.done = 0;
                KFASTINITTASKSbits.waiting_response = 1;
                
                load_K_line_request (type_of_K_line_request);
                
                UART3_Tx_buf[KFASTINITTASKSbits.length] = 0;
                for (i = 0; i < KFASTINITTASKSbits.length; i ++) { // Расчет контрольной суммы
                    UART3_Tx_buf[KFASTINITTASKSbits.length] = UART3_Tx_buf[KFASTINITTASKSbits.length] + UART3_Tx_buf[i];
                }
                start_UART3_transmission ( KFASTINITTASKSbits.length + 1 );
            }            


}
void get_91412_fast_data (void) {

//    return;
static unsigned int counter = 0, start = 0;
int res;

    if (ignition == 0 || OUTbits.serv_flag == 1) {
        counter = 0;
        KFASTTASCKSbits.start = 1;
        return;
    }
//    if ( ignition == 1 && KTASCKSbits.start == 0 ) KTASCKSbits.start = 1;
    if ( KFASTTASCKSbits.start == 0 ) return;

    if (counter < 1000) counter ++;
    else {
        counter = 0;
        start = 1;
    }
// Запрос VIN        
        if (KFASTTASCKSbits.vin_running == 0 && KFASTTASCKSbits.vin_done == 0 && start == 1) {
            start = 0;
            KFASTTASCKSbits.vin_running = 1;
            type_of_K_line_request = 0x09;
//            if (type_of_K_line == 1) {UART3_Tx_buf[0] = 0x68; UART3_Tx_buf[1] = 0x6a; UART3_Tx_buf[2] = 0xF1; UART3_Tx_buf[3] = 0x09; UART3_Tx_buf[4] = 0x02;} 
//            else                     {UART3_Tx_buf[0] = 0xC2; UART3_Tx_buf[1] = 0x33; UART3_Tx_buf[2] = 0xF1; UART3_Tx_buf[3] = 0x09; UART3_Tx_buf[4] = 0x02;} 
            KFASTINITTASKSbits.length = 5;
            KFASTINITTASKSbits.start = 1;
            KFASTINITTASKSbits.start = 1;
        }
        if (KFASTTASCKSbits.vin_running == 1 && KFASTTASCKSbits.vin_done == 0 && KFASTINITTASKSbits.tasck_complete == 1) {
            KFASTTASCKSbits.vin_done = 1;
            KFASTTASCKSbits.vin_running = 0;
            KFASTINITTASKSbits.KFASTINITTASKS = 0;
            res = check_KVIN ();
            generate_KVIN_message (res);
//            start = 1;
        }

// Запрос ошибок mode3        
        if (KFASTTASCKSbits.mode3_running == 0 && KFASTTASCKSbits.mode3_done == 0 && start == 1) {
            start = 0;
            KFASTTASCKSbits.mode3_running = 1;
            type_of_K_line_request = 0x03;
//            if (type_of_K_line == 1) UART3_Tx_buf[0] = 0x68; UART3_Tx_buf[1] = 0x6a; UART3_Tx_buf[2] = 0xF1; UART3_Tx_buf[3] = 0x03; 
            KFASTINITTASKSbits.length = 4;
            KFASTINITTASKSbits.start = 1;
        }
        if (KFASTTASCKSbits.mode3_running == 1 && KFASTTASCKSbits.mode3_done == 0 && KFASTINITTASKSbits.tasck_complete == 1) {
            KFASTTASCKSbits.mode3_done = 1;
            KFASTTASCKSbits.mode3_running = 0;
            KFASTINITTASKSbits.KFASTINITTASKS = 0;
            kdtc_W_ptr = 0;
            extract_k_fast_dtc (0x03);
        }
        
  
// Запрос ошибок mode7        
        if (KFASTTASCKSbits.mode7_running == 0 && KFASTTASCKSbits.mode7_done == 0 && start == 1) {
            start = 0;
            KFASTTASCKSbits.mode7_running = 1;
            type_of_K_line_request = 0x07;
//            if (type_of_K_line == 1) UART3_Tx_buf[0] = 0x68; UART3_Tx_buf[1] = 0x6a; UART3_Tx_buf[2] = 0xF1; UART3_Tx_buf[3] = 0x07; 
            KFASTINITTASKSbits.length = 4;
            KFASTINITTASKSbits.start = 1;
        } 
        if (KFASTTASCKSbits.mode7_running == 1 && KFASTTASCKSbits.mode7_done == 0 && KFASTINITTASKSbits.tasck_complete == 1) {
            KFASTTASCKSbits.mode7_done = 1;
            KTASCKSbits.mode7_running = 0;
            KFASTINITTASKSbits.KFASTINITTASKS = 0;
            extract_k_fast_dtc (0x07);
        }
                
// Запрос ошибок modeA        
        if (KFASTTASCKSbits.modeA_running == 0 && KFASTTASCKSbits.modeA_done == 0 && start == 1) {
            start = 0;
            KFASTTASCKSbits.modeA_running = 1;
            type_of_K_line_request = 0x0A;
//            if (type_of_K_line == 1) UART3_Tx_buf[0] = 0x68; UART3_Tx_buf[1] = 0x6a; UART3_Tx_buf[2] = 0xF1; UART3_Tx_buf[3] = 0x0A; 
            KFASTINITTASKSbits.length = 4;
            KFASTINITTASKSbits.start = 1;
        }
        if (KFASTTASCKSbits.modeA_running == 1 && KFASTTASCKSbits.modeA_done == 0 && KFASTINITTASKSbits.tasck_complete == 1) {
            KFASTTASCKSbits.modeA_done = 1;
            KFASTTASCKSbits.modeA_running = 0;
            KFASTINITTASKSbits.KFASTINITTASKS = 0;
            extract_k_fast_dtc (0x0A);
            generate_KDTCs_message ();
        }
              
if (KFASTTASCKSbits.vin_done && KFASTTASCKSbits.mode3_done && KFASTTASCKSbits.mode7_done && KFASTTASCKSbits.modeA_done) {
    KFASTINITTASKSbits.KFASTINITTASKS = 0;
    KFASTTASCKSbits.KFASTTASCKS = 0;
}

    
}
int iso_91412_fast_init (void) {

static unsigned int counter = 0; 
unsigned char temp = 0;
unsigned char i;

    if (KFASTINITTASKSbits.start == 0) {
//        if (Rx3_DataAvailable == 1) { // По К-лайн что-то принято вне общения с машиной
//            Rx3_DataAvailable = 0;
//        }
        return;
    }

//Nop();Nop();Nop();

        if (counter == 0) {
            Nop();Nop();Nop();
            switch_on_off_u3tx_output ( 0 );
            fast_init_start_flag = 1;
        }


        if (counter == 6) {
//            KFASTINITTASKSbits.waiting_response = 1;
            switch_on_off_u3tx_output ( 1 );
            U3_Rx_copy_buf_W = 0;
            U3_Rx_num_of_pages = 0;
//            kw_counter = 0;
            set_U3_Rx_timeout (3);
            UART3_Tx_buf[0] = 0xC1; UART3_Tx_buf[1]= 0x33; UART3_Tx_buf[2] = 0xF1;
            UART3_Tx_buf[3] = 0x81; UART3_Tx_buf[4] = 0x66;
            start_UART3_transmission ( 5 );
        }
//if ()
    if (counter < 800) counter ++;
    else {
        Nop();Nop();Nop();
        counter = 0;
        KFASTINITTASKSbits.start = 0;
        KFASTINITTASKSbits.tasck_complete = 1;
    }

    if (Rx3_DataAvailable == 1) { // По К-лайн что-то принято вне общения с машиной
        Rx3_DataAvailable = 0;
        
        if (KFASTINITTASKSbits.ini == 0) {    
            Nop();Nop();Nop();
            if ( U3_num_W_tmp > 6 ) {
                for ( i = 0; i < (U3_num_W_tmp - 1); i ++ ) {
                    temp = temp + UART3_Rx_buf[i];
                }
                if ( temp == UART3_Rx_buf[U3_num_W_tmp - 1] ) {
    //            if (UART3_Rx_buf[0] == 0x83 && UART3_Rx_buf[1] == 0xF1 && UART3_Rx_buf[2] == 0x11 && //10
    //                UART3_Rx_buf[3] == 0xC1 && UART3_Rx_buf[4] == 0xE9 && UART3_Rx_buf[5] == 0x8F &&
    //                UART3_Rx_buf[6] == 0xBE ) {//bd             
                    UART3_Rx_buf[0] = 0;
                    KFASTINITTASKSbits.ini = 1;
                    KFASTINITTASKSbits.done = 1;
                    type_of_K_line == 2;
                } 
            }
        }

        
        if (KFASTINITTASKSbits.waiting_response == 1) {
            
            
            for (i = 0; i < U3_num_W_tmp; i ++) { // Расчет контрольной суммы
                UART3_Rx_copy_buf[U3_Rx_copy_buf_W][i] = UART3_Rx_buf[i];
            }
            UART3_Rx_copy_buf[U3_Rx_copy_buf_W][14] = U3_num_W_tmp;
            U3_Rx_copy_buf_W ++;
            U3_Rx_num_of_pages ++;
        }
        

    }


            if (KFASTINITTASKSbits.done == 1) {
                KFASTINITTASKSbits.done = 0;
                KFASTINITTASKSbits.waiting_response = 1;
                
                load_K_line_request (type_of_K_line_request);
                
                UART3_Tx_buf[KFASTINITTASKSbits.length] = 0;
                for (i = 0; i < KFASTINITTASKSbits.length; i ++) { // Расчет контрольной суммы
                    UART3_Tx_buf[KFASTINITTASKSbits.length] = UART3_Tx_buf[KFASTINITTASKSbits.length] + UART3_Tx_buf[i];
                }
                start_UART3_transmission ( KFASTINITTASKSbits.length + 1 );
            }            


}
int iso_91412_fast_reset_dtc (void) {

static unsigned int counter = 0; 
unsigned char temp = 0;
unsigned char i;

    if ( KFASTDTCRESETTASKbits.start == 0 ) {

        return;
    }

    if ( ignition == 0 ) return;

//Nop();Nop();Nop();

        if (counter == 0) {
            Nop();Nop();Nop();
            switch_on_off_u3tx_output ( 0 );
            fast_init_start_flag = 1;
        }


        if (counter == 6) {
            switch_on_off_u3tx_output ( 1 );
            U3_Rx_copy_buf_W = 0;
            U3_Rx_num_of_pages = 0;
            KFASTDTCRESETTASKbits.ini_running = 1;
            set_U3_Rx_timeout (3);
            UART3_Tx_buf[0] = 0xC1; UART3_Tx_buf[1]= 0x33; UART3_Tx_buf[2] = 0xF1;
            UART3_Tx_buf[3] = 0x81; UART3_Tx_buf[4] = 0x66;
            start_UART3_transmission ( 5 );
        }

    if (counter < 80) counter ++;
    else {
        Nop();Nop();Nop();
        counter = 0;
        KFASTDTCRESETTASKbits.KFASTDTCRESETTASK = 0;
        KFASTTASCKSbits.start = 1;
        KDTC_buf_tmp[0] = 1 ;
        return;
//        KFASTDTCRESETTASKbits.tasck_complete = 1;
    }
if (counter == 40) {
    Nop();Nop();Nop();
}
    if (Rx3_DataAvailable == 1) { // По К-лайн что-то принято вне общения с машиной
        Rx3_DataAvailable = 0;
        
        if (KFASTDTCRESETTASKbits.ini == 0) {    
            Nop();Nop();Nop();
            if ( U3_num_W_tmp > 6 ) {
                for ( i = 0; i < (U3_num_W_tmp - 1); i ++ ) {
                    temp = temp + UART3_Rx_buf[i];
                }
                if ( temp == UART3_Rx_buf[U3_num_W_tmp - 1] ) {
                    UART3_Rx_buf[0] = 0;
                    KFASTDTCRESETTASKbits.ini = 1;
                    KFASTDTCRESETTASKbits.done = 1;
                    type_of_K_line == 2;
                    UART3_Tx_buf[0] = 0xC1; UART3_Tx_buf[1] = 0x33; 
                    UART3_Tx_buf[2] = 0xF1; UART3_Tx_buf[3] = 0x04; 
                    UART3_Tx_buf[4] = 0xE9;// UART3_Tx_buf[5] = 0xEB;
                    start_UART3_transmission ( 5 );
                } 
            }
        }

        
//        if (KFASTINITTASKSbits.waiting_response == 1) {
//            
//            
//            for (i = 0; i < U3_num_W_tmp; i ++) { // Расчет контрольной суммы
//                UART3_Rx_copy_buf[U3_Rx_copy_buf_W][i] = UART3_Rx_buf[i];
//            }
//            UART3_Rx_copy_buf[U3_Rx_copy_buf_W][14] = U3_num_W_tmp;
//            U3_Rx_copy_buf_W ++;
//            U3_Rx_num_of_pages ++;
//        }
        

    }


           


}
int iso_91412_fast_request_mil (void) {

static unsigned int counter = 0, mil_fast_status = 0, mil_fast_status_tmp = 0; 
unsigned char temp = 0;
unsigned char i;

//    if ( KFASTDTCRESETTASKbits.start == 1 ) {
//
//        return;
//    }

    if ( ignition == 0 || KFASTTASCKSbits.start == 1 )  {
        KFASTMILTASKbits.KFASTMILTASK = 0;
        return;
    }
//Nop();Nop();Nop();

        if ( KFASTMILTASKbits.request_timer == 5900 ) {
            Nop();Nop();Nop();
            switch_on_off_u3tx_output ( 0 );
            fast_init_start_flag = 1;
        }


        if ( KFASTMILTASKbits.request_timer == 5906 ) {
            switch_on_off_u3tx_output ( 1 );
            U3_Rx_copy_buf_W = 0;
            U3_Rx_num_of_pages = 0;
            KFASTDTCRESETTASKbits.ini_running = 1;
            set_U3_Rx_timeout (3);
            UART3_Tx_buf[0] = 0xC1; UART3_Tx_buf[1]= 0x33; UART3_Tx_buf[2] = 0xF1;
            UART3_Tx_buf[3] = 0x81; UART3_Tx_buf[4] = 0x66;
            start_UART3_transmission ( 5 );
        }

        if ( KFASTMILTASKbits.request_timer < 6000 ) KFASTMILTASKbits.request_timer ++;
        else {
            Nop();Nop();Nop();
//            counter = 0;
            KFASTMILTASKbits.KFASTMILTASK = 0;
            return;
        }

    if (Rx3_DataAvailable == 1) { // По К-лайн что-то принято вне общения с машиной
        Rx3_DataAvailable = 0;
        
        if (KFASTMILTASKbits.ini == 0) {    
            Nop();Nop();Nop();
            if ( U3_num_W_tmp > 6 ) {
                temp = 0;
                for ( i = 0; i < (U3_num_W_tmp - 1); i ++ ) {
                    temp = temp + UART3_Rx_buf[i];
                }
                if ( temp == UART3_Rx_buf[U3_num_W_tmp - 1] ) {
                    UART3_Rx_buf[0] = 0;
                    KFASTMILTASKbits.ini = 1;
                    KFASTMILTASKbits.done = 1;
                    type_of_K_line == 2;
                    UART3_Tx_buf[0] = 0xC2; UART3_Tx_buf[1] = 0x33; 
                    UART3_Tx_buf[2] = 0xF1; UART3_Tx_buf[3] = 0x01; 
                    UART3_Tx_buf[4] = 0x01; UART3_Tx_buf[5] = 0xE8;
                    start_UART3_transmission ( 6 );
                } 
            }
        }
//            mil_fast_status
            if ( U3_num_W_tmp > 6 ) {
                temp = 0;
                for ( i = 0; i < (U3_num_W_tmp - 1); i ++ ) {
                    temp = temp + UART3_Rx_buf[i];
                }
                if ( temp == UART3_Rx_buf[U3_num_W_tmp - 1] ) {
                    if ( UART3_Rx_buf[3] == 0x41 ) { 
                        mil_fast_status = UART3_Rx_buf[5] & 0x80;
                        if ( mil_fast_status != mil_fast_status_tmp ) {
                            if ( mil_fast_status ) generate_content_of_message ( 57, 1 ); 
                            else generate_content_of_message ( 58, 1 );
                        }
                        mil_fast_status_tmp = mil_fast_status;
                    }
                } 
            }
            
            


       

    }


           


}
void load_K_line_request (unsigned char type) {

if (type == 0x09) {    
    if (type_of_K_line == 1) {UART3_Tx_buf[0] = 0x68; UART3_Tx_buf[1] = 0x6a; UART3_Tx_buf[2] = 0xF1; UART3_Tx_buf[3] = 0x09; UART3_Tx_buf[4] = 0x02;} 
    else                     {UART3_Tx_buf[0] = 0xC2; UART3_Tx_buf[1] = 0x33; UART3_Tx_buf[2] = 0xF1; UART3_Tx_buf[3] = 0x09; UART3_Tx_buf[4] = 0x02;} 
}    
if (type == 0x03) {    
    if (type_of_K_line == 1) {UART3_Tx_buf[0] = 0x68; UART3_Tx_buf[1] = 0x6a; UART3_Tx_buf[2] = 0xF1; UART3_Tx_buf[3] = 0x03;} 
    else                     {UART3_Tx_buf[0] = 0xC1; UART3_Tx_buf[1] = 0x33; UART3_Tx_buf[2] = 0xF1; UART3_Tx_buf[3] = 0x03;}                      
}if (type == 0x07) {    
    if (type_of_K_line == 1) {UART3_Tx_buf[0] = 0x68; UART3_Tx_buf[1] = 0x6a; UART3_Tx_buf[2] = 0xF1; UART3_Tx_buf[3] = 0x07;}  
    else                     {UART3_Tx_buf[0] = 0xC1; UART3_Tx_buf[1] = 0x33; UART3_Tx_buf[2] = 0xF1; UART3_Tx_buf[3] = 0x07;} 
}    
if (type == 0x0A) {    
    if (type_of_K_line == 1) {UART3_Tx_buf[0] = 0x68; UART3_Tx_buf[1] = 0x6a; UART3_Tx_buf[2] = 0xF1; UART3_Tx_buf[3] = 0x0A;} 
    else                     {UART3_Tx_buf[0] = 0xC1; UART3_Tx_buf[1] = 0x33; UART3_Tx_buf[2] = 0xF1; UART3_Tx_buf[3] = 0x0A;}                      
}    


}
void set_U3_Rx_timeout (unsigned int delay) {
    IFS0bits.T3IF = 0;
    U3_Rx_timeout = delay;
    IFS0bits.T3IF = 1;
}
int check_KVIN (void) {
    int i;
    
    if (U3_Rx_num_of_pages != 6) return -1;
    KVIN[0]  = UART3_Rx_copy_buf[1][9];
    KVIN[1]  = UART3_Rx_copy_buf[2][6]; KVIN[2]  = UART3_Rx_copy_buf[2][7]; KVIN[3]  = UART3_Rx_copy_buf[2][8]; KVIN[4]  = UART3_Rx_copy_buf[2][9];
    KVIN[5]  = UART3_Rx_copy_buf[3][6]; KVIN[6]  = UART3_Rx_copy_buf[3][7]; KVIN[7]  = UART3_Rx_copy_buf[3][8]; KVIN[8]  = UART3_Rx_copy_buf[3][9];
    KVIN[9]  = UART3_Rx_copy_buf[4][6]; KVIN[10] = UART3_Rx_copy_buf[4][7]; KVIN[11] = UART3_Rx_copy_buf[4][8]; KVIN[12] = UART3_Rx_copy_buf[4][9];
    KVIN[13] = UART3_Rx_copy_buf[5][6]; KVIN[14] = UART3_Rx_copy_buf[5][7]; KVIN[15] = UART3_Rx_copy_buf[5][8]; KVIN[16] = UART3_Rx_copy_buf[5][9];
    Nop();Nop();Nop();

    for (i = 0; i < 17; i++) {
        if (KVIN[i] != KVIN_TMP[i]) break;
    }
    if (i < 17) {
        for (i = 0; i < 17; i++) {
            KVIN_TMP[i] = KVIN[i];
        }
        return 1;
    }
    
return 0;    
}
int extract_k_dtc (int req) {

    unsigned int i, j, num10, num18, num28;
    
    num10 = 0; num18 = 0; num28 = 0;
    
    for ( i = 1; i < U3_Rx_num_of_pages; i++ ) {
        if ( UART3_Rx_copy_buf[i][2] == 0x10 ) num10++;//10
        if ( UART3_Rx_copy_buf[i][2] == 0x18 ) num18++;
        if ( UART3_Rx_copy_buf[i][2] == 0x28 ) num28++;
    }
Nop();Nop();Nop();    
if (req == 0x0A && num10 == 0 && num18 == 0 && num28 == 0 && kdtc_W_ptr == 0) {
    for (i = 0; i < 93; i++) { KDTC_buf_tmp[i] = 0; }
    return;
}

//    if ( num10 != 0 ) {
        for (i = 1; i < U3_Rx_num_of_pages; i ++) {
            if ( UART3_Rx_copy_buf[i][2] == 0x11 ) {//10
                if ( UART3_Rx_copy_buf[i][4] == 0 && UART3_Rx_copy_buf[i][5] == 0 );// break;
                else {
                    KDTC_buf_tmp[kdtc_W_ptr] = UART3_Rx_copy_buf[i][4]; KDTC_buf_tmp[kdtc_W_ptr + 1] = UART3_Rx_copy_buf[i][5]; 
                    if ( kdtc_W_ptr < 91) kdtc_W_ptr = kdtc_W_ptr + 2;
                } 
                if ( UART3_Rx_copy_buf[i][6] == 0 && UART3_Rx_copy_buf[i][7] == 0 );// break;
                else { 
                    KDTC_buf_tmp[kdtc_W_ptr] = UART3_Rx_copy_buf[i][6]; KDTC_buf_tmp[kdtc_W_ptr + 1] = UART3_Rx_copy_buf[i][7]; 
                    if ( kdtc_W_ptr < 91) kdtc_W_ptr = kdtc_W_ptr + 2;
                }
                if ( UART3_Rx_copy_buf[i][8] == 0 && UART3_Rx_copy_buf[i][9] == 0 );// break; 
                else { 
                    KDTC_buf_tmp[kdtc_W_ptr] = UART3_Rx_copy_buf[i][8]; KDTC_buf_tmp[kdtc_W_ptr + 1] = UART3_Rx_copy_buf[i][9]; 
                    if ( kdtc_W_ptr < 91) kdtc_W_ptr = kdtc_W_ptr + 2;
                }                
            }
            if ( UART3_Rx_copy_buf[i][2] == 0x18 ) {
                if ( UART3_Rx_copy_buf[i][4] == 0 && UART3_Rx_copy_buf[i][5] == 0 );// break;
                else {
                    KDTC_buf_tmp[kdtc_W_ptr] = UART3_Rx_copy_buf[i][4]; KDTC_buf_tmp[kdtc_W_ptr + 1] = UART3_Rx_copy_buf[i][5]; 
                    if ( kdtc_W_ptr < 91) kdtc_W_ptr = kdtc_W_ptr + 2;
                } 
                if ( UART3_Rx_copy_buf[i][6] == 0 && UART3_Rx_copy_buf[i][7] == 0 );// break;
                else { 
                    KDTC_buf_tmp[kdtc_W_ptr] = UART3_Rx_copy_buf[i][6]; KDTC_buf_tmp[kdtc_W_ptr + 1] = UART3_Rx_copy_buf[i][7]; 
                    if ( kdtc_W_ptr < 91) kdtc_W_ptr = kdtc_W_ptr + 2;
                }
                if ( UART3_Rx_copy_buf[i][8] == 0 && UART3_Rx_copy_buf[i][9] == 0 );// break; 
                else { 
                    KDTC_buf_tmp[kdtc_W_ptr] = UART3_Rx_copy_buf[i][8]; KDTC_buf_tmp[kdtc_W_ptr + 1] = UART3_Rx_copy_buf[i][9]; 
                    if ( kdtc_W_ptr < 91) kdtc_W_ptr = kdtc_W_ptr + 2;
                }                
            }
            if ( UART3_Rx_copy_buf[i][2] == 0x28 ) {
                if ( UART3_Rx_copy_buf[i][4] == 0 && UART3_Rx_copy_buf[i][5] == 0 );// break;
                else {
                    KDTC_buf_tmp[kdtc_W_ptr] = UART3_Rx_copy_buf[i][4]; KDTC_buf_tmp[kdtc_W_ptr + 1] = UART3_Rx_copy_buf[i][5]; 
                    if ( kdtc_W_ptr < 91) kdtc_W_ptr = kdtc_W_ptr + 2;
                } 
                if ( UART3_Rx_copy_buf[i][6] == 0 && UART3_Rx_copy_buf[i][7] == 0 );// break;
                else { 
                    KDTC_buf_tmp[kdtc_W_ptr] = UART3_Rx_copy_buf[i][6]; KDTC_buf_tmp[kdtc_W_ptr + 1] = UART3_Rx_copy_buf[i][7]; 
                    if ( kdtc_W_ptr < 91) kdtc_W_ptr = kdtc_W_ptr + 2;
                }
                if ( UART3_Rx_copy_buf[i][8] == 0 && UART3_Rx_copy_buf[i][9] == 0 );// break; 
                else { 
                    KDTC_buf_tmp[kdtc_W_ptr] = UART3_Rx_copy_buf[i][8]; KDTC_buf_tmp[kdtc_W_ptr + 1] = UART3_Rx_copy_buf[i][9]; 
                    if ( kdtc_W_ptr < 91) kdtc_W_ptr = kdtc_W_ptr + 2;
                }                
            }            
        }
//    }
Nop();Nop();Nop(); 
}
int extract_k_fast_dtc (int req) {

    unsigned int i, j, num, num1, num28;
    
    num = req + 0x40; num1 = 0; num28 = 0;

    for ( i = 1; i < U3_Rx_num_of_pages; i++ ) {
        if ( UART3_Rx_copy_buf[i][3] == num ) num1 ++;//10
    }
Nop();Nop();Nop();    
if ( num1 == 0 && kdtc_W_ptr == 0 ) {
    for (i = 0; i < 93; i++) { KDTC_buf_tmp[i] = 0; }
    return;
}

        for (i = 1; i < U3_Rx_num_of_pages; i ++) {
//            if ( UART3_Rx_copy_buf[i][2] == 0x11 ) {//10
                if ( UART3_Rx_copy_buf[i][4] == 0 && UART3_Rx_copy_buf[i][5] == 0 );// break;
                else {
                    KDTC_buf_tmp[kdtc_W_ptr] = UART3_Rx_copy_buf[i][4]; KDTC_buf_tmp[kdtc_W_ptr + 1] = UART3_Rx_copy_buf[i][5]; 
                    if ( kdtc_W_ptr < 91) kdtc_W_ptr = kdtc_W_ptr + 2;
                } 
                if ( UART3_Rx_copy_buf[i][6] == 0 && UART3_Rx_copy_buf[i][7] == 0 );// break;
                else { 
                    KDTC_buf_tmp[kdtc_W_ptr] = UART3_Rx_copy_buf[i][6]; KDTC_buf_tmp[kdtc_W_ptr + 1] = UART3_Rx_copy_buf[i][7]; 
                    if ( kdtc_W_ptr < 91) kdtc_W_ptr = kdtc_W_ptr + 2;
                }
                if ( UART3_Rx_copy_buf[i][8] == 0 && UART3_Rx_copy_buf[i][9] == 0 );// break; 
                else { 
                    KDTC_buf_tmp[kdtc_W_ptr] = UART3_Rx_copy_buf[i][8]; KDTC_buf_tmp[kdtc_W_ptr + 1] = UART3_Rx_copy_buf[i][9]; 
                    if ( kdtc_W_ptr < 91) kdtc_W_ptr = kdtc_W_ptr + 2;
                }                
//            }
        }

Nop();Nop();Nop(); 
}
void switch_on_off_u3tx_output (int on_off) {
    
    // Unlock Registers
    asm volatile (
                "MOV #OSCCON, w1 \n"
                "MOV #0x46, w2 \n"
                "MOV #0x57, w3 \n"
                "MOV.b w2, [w1] \n"
                "MOV.b w3, [w1] \n"
                "BCLR OSCCON,#6");
          
    //Configure Output Functions
        if (on_off == 1)  RPOR1bits.RP67R = 27;   // Assign U3TX To Pin RP67  
        else RPOR1bits.RP67R = 0; 

          
    // Lock Registers
    asm volatile (
                "MOV #OSCCON, w1 \n"
                "MOV #0x46, w2 \n"
                "MOV #0x57, w3 \n"
                "MOV.b w2, [w1] \n"
                "MOV.b w3, [w1] \n"
                "BSET OSCCON, #6");
    
}
void start_UART3_transmission ( int length ) {
// Data transmit the data using interrupts
    U3_Tx_length = length;
    Tx3_DataAvailable = 0;
    IEC5bits.U3TXIE = 1;
    IFS5bits.U3TXIF = 1;
//    if (wait == 1) {
//        while(Tx3_DataAvailable != 1); //wait till data is transmitted
//        Tx3_DataAvailable = 0;
//    }
}
void generate_KVIN_message (int res) {
    unsigned char len;
    
    if (res == 1) {
        reload_GPRS_header ( 4, 48, 0x0011); // N = 3, name = 38, type = 1, ACK = 1
        memmove ( command_temp_buf, GPRS_header_buf, 12 );
        unsigned int ACK_counter = 0xFFFF;
        command_temp_buf[12] = (unsigned char) (ACK_counter >> 8); command_temp_buf[13] = (unsigned char) ACK_counter; // ACK
unsigned long long temp;
        temp = FM25_read_8( 1268 ); // 
        command_temp_buf[14] = 0xFF; command_temp_buf[15] = 0x01; 
        if ( temp & 0x0000000000200000 ) {command_temp_buf[16] = 0x21;} else command_temp_buf[16] = 0x01; // Dataflags
        memmove  ( &command_temp_buf[17], Navi_bin, 22 );
        
        for (res = 0; res < 17; res ++) {
            command_temp_buf[res + 39] = KVIN_TMP [res];
        }

        if ( temp & 0x0000000000200000 ) {
            sequence_number = get_sequence_number ();
            command_temp_buf[ 56 ] = (unsigned char)(sequence_number >> 24);
            command_temp_buf[ 57 ] = (unsigned char)(sequence_number >> 16);
            command_temp_buf[ 58 ] = (unsigned char)(sequence_number >> 8);
            command_temp_buf[ 59 ] = (unsigned char)(sequence_number);            
            len = 60;
        }
        else { len = 56; }
        
        command_temp_buf[113] = len; //38
        if ( VINDATbits.queue == 1 ) write_data_into_save_to_flash_bufs ( command_temp_buf, len );    
    }
    
}
void generate_KDTCs_message (void) {
    
    unsigned int i, res;
    unsigned char len;
//    static unsigned char DTC_buf_tmp[93];
    
    res = 0;
    for (i = 0; i < 93; i ++) {
        if (KDTC_buf[i] != KDTC_buf_tmp[i]) res = 1;
        KDTC_buf[i] = KDTC_buf_tmp[i];
    }
    Nop();Nop();Nop();
    if (res == 0) return;
    
        reload_GPRS_header ( 1, 26, 0x0012 ); // 27 - dtcs from K
        memmove ( command_temp_buf, GPRS_header_buf, 12 );
        command_temp_buf[12] = 0xff; command_temp_buf[13] = 0xff; // ACK
        memmove  ( &command_temp_buf[14], Navi_bin, 6 ); // Время и дата

        command_temp_buf[20] = kdtc_W_ptr;

        memmove ( &command_temp_buf[21], KDTC_buf, kdtc_W_ptr );

unsigned long long temp;
        temp = FM25_read_8( 1276 ); //         
        if (  temp & 0x0000000000200000  ) {
            sequence_number = get_sequence_number ();
            command_temp_buf[ 21 + kdtc_W_ptr ] = (unsigned char)(sequence_number >> 24);
            command_temp_buf[ 21 + kdtc_W_ptr + 1 ] = (unsigned char)(sequence_number >> 16);
            command_temp_buf[ 21 + kdtc_W_ptr + 2 ] = (unsigned char)(sequence_number >> 8);
            command_temp_buf[ 21 + kdtc_W_ptr + 3 ] = (unsigned char)(sequence_number);            
            len = 21 + kdtc_W_ptr + 4;
        }
        else { len = 21 + kdtc_W_ptr; }        
        
        Nop();Nop();Nop();
        if ( DTCDATbits.queue == 1 ) write_data_into_save_to_flash_bufs ( command_temp_buf, len );    
    
    
}
# endif
#if defined (WBUS)
void switch_on_off_u3tx_output (int on_off) {
    
    // Unlock Registers
    asm volatile (
                "MOV #OSCCON, w1 \n"
                "MOV #0x46, w2 \n"
                "MOV #0x57, w3 \n"
                "MOV.b w2, [w1] \n"
                "MOV.b w3, [w1] \n"
                "BCLR OSCCON,#6");
          
    //Configure Output Functions
        if (on_off == 1)  RPOR1bits.RP67R = 27;   // Assign U3TX To Pin RP67  
        else RPOR1bits.RP67R = 0; 

          
    // Lock Registers
    asm volatile (
                "MOV #OSCCON, w1 \n"
                "MOV #0x46, w2 \n"
                "MOV #0x57, w3 \n"
                "MOV.b w2, [w1] \n"
                "MOV.b w3, [w1] \n"
                "BSET OSCCON, #6");
    
}
void start_UART3_transmission ( int length ) {
// Data transmit the data using interrupts
    U3_Tx_length = length;
    Tx3_DataAvailable = 0;
    IEC5bits.U3TXIE = 1;
    IFS5bits.U3TXIF = 1;
}
#endif
int generate_content_of_message ( unsigned char name, unsigned char type ) {
unsigned long long data_flags, temp;
volatile unsigned char /*tmp,*/ N, i, /*j,*/ length, /* *byte_ptr, flag,*/ queue, sms_en, sms_only, sms_sent, enaible_in_serv;
int result;

/**/
    STATUSFLAGS1bits.ignition = ignition;
    if ( name == 37 ) {// запуск таймера в момент генерации команды о выполнении автозапуска
        unlock_message_off_timer = (unsigned int) FM25_read_1 ( (unsigned int)1902 );
        unlock_message_off_timer = unlock_message_off_timer * 100;
    }
    if ( name == 35 ) { if ( unlock_message_off_timer > 0 ) return 0; }// откл сообщения об открытии замков дверей на период автозапуска
Nop();Nop();Nop();
    
    data_flags = get_dataflags_by_name ( name );
 // Обнуление недопустимых флагов, ЗАВИСИТ ОТ ПРОШИВКИ!!!    
    data_flags = data_flags & 0xFF0000007FE2F7FF; //0xFF0000000002F7FF;
    
//    data_flags = check_flags_correctness ( name, (unsigned long long)data_flags);
    
    if ( data_flags == 0) {return 0;} //нет такого имени
    if ( (data_flags & 0x0300000000000000) == 0 ) {if ( name == 4 ) fuel_consumption = 0; fuel_consumption_counter_tmp = 0; return 0;} //сообщение выключено (очередь равна нулю)// сброс расхода при выключении зажигания  
    queue = (data_flags & 0x0F00000000000000) >> 56;
    sms_en = (data_flags & 0x1000000000000000) >> 60;
    sms_only = (data_flags & 0x4000000000000000) >> 62;
    enaible_in_serv = (data_flags & 0x2000000000000000) >> 61;
    data_flags = data_flags & 0x00FFFFFFFFFFFFFF;
    if ( data_flags == 0 ) return 0; //нет ни одного флага данных
    if (SERVFLAGSbits.serv_status == 1) {
        if ( enaible_in_serv == 0 ) return 0; //отключено в сервисном режиме
    }
    
// Определение количества значащих байт dataflags
    if ( (data_flags & 0x00000000000000FF) != 0 ) N = 1;
    if ( (data_flags & 0x000000000000FF00) != 0 ) N = 2;
    if ( (data_flags & 0x0000000000FF0000) != 0 ) N = 3;
    if ( (data_flags & 0x00000000FF000000) != 0 ) N = 4;
    if ( (data_flags & 0x000000FF00000000) != 0 ) N = 5;
    if ( (data_flags & 0x0000FF0000000000) != 0 ) N = 6;
    if ( (data_flags & 0x00FF000000000000) != 0 ) N = 7;
Nop();Nop();Nop();

        
// Загрузка имея и навигационной строки
        reload_GPRS_header ( N + 1, name, 0x0015); // N = 4, name = 1, type = 1, ACK = 1, CRC = 1
        memmove ( command_temp_buf, GPRS_header_buf, 12 );
        command_temp_buf[12] = 0xFF; command_temp_buf[13] = 0xFF; // ACK
//        command_temp_buf[14] = 0xFF; command_temp_buf[15] = 0x77; command_temp_buf[16] = 0x02; // Dataflags
        temp = data_flags;
        for (W_ptr = 14; W_ptr < 14 + N; W_ptr ++) {
            command_temp_buf[ W_ptr ] = (unsigned char) temp & 0x00000000000000FF;
            temp = temp >> 8;
        }
        Nop();Nop();Nop();
        memmove  ( &command_temp_buf[W_ptr], Navi_bin, 22 );
        W_ptr = W_ptr + 22;
        
        data_flags = data_flags >> 9; // вытеснение флага
        
        if ( name == 4 ) { fuel_consumption = 0; fuel_consumption_counter_tmp = 0; }// сброс расхода при выключении зажигания
        
        for  (i = 1; i <= 47; i++ ) { // 47 возможных видов данных в сообщениях
//            flag = data_flags & 0x0000000000000001;
            if ( data_flags & 0x0000000000000001 )result = extract_data_portion ( i + 8 );
            data_flags = data_flags >> 1;
            if ( data_flags == 0 ) break;
        }
        command_temp_buf[113] = W_ptr; //W_ptr - 1
        
        if ( name == 4 ) { fuel_consumption = 0; fuel_consumption_counter_tmp = 0; }// сброс расхода при выключении зажигания
        
//            if (result == 1) {
                length = command_temp_buf[113];
                if (queue == 1) write_data_into_save_to_flash_bufs ( command_temp_buf, length );
                if (queue == 2) {
                    Nop();Nop();Nop();
                    sms_sent = 0;
                    if ( sms_en == 1) {
                        if ( flash2_ptr_R != flash2_ptr_W || sms_only == 1 ) {
                            Nop();Nop();Nop();
                            sms_sent = 1;
                            load_content_event_by_sms ( name, &Navi_bin, &sms_temp_buf1 );
                            write_text_to_SMS_buf ( &sms_temp_buf1, &PHONE_to_send_buf ); //&PHONES_buf[5][0]
                        }
                    }
                    if (name == 73) sms_sent = 1;// IMSI всегда отослан по СМС
                    if ( sms_only == 0 ) write_data_into_save_to_flash2_bufs ( command_temp_buf, length, sms_sent );
                }
//            }        
        
    Nop();Nop();Nop();
    return 1;
}
void load_content_event_by_sms ( char name, char *navi_ptr, char *destination_buf_ptr ) {
    
//    unsigned char sms_temp_buf1[100];
    unsigned char i;
    unsigned int hex_str_word;
//IMEI_str [16]
    memmove  ( destination_buf_ptr, IMEI_str, 15 );
    destination_buf_ptr = destination_buf_ptr + 15;
    
    *destination_buf_ptr ++ = ',';
    bin_2_bcd ( (long) name );
    *destination_buf_ptr ++ = bin_2_bcd_buf [7];
    *destination_buf_ptr ++ = bin_2_bcd_buf [8];
    *destination_buf_ptr ++ = ',';
    
//    memmove  ( destination_buf_ptr, navi_ptr, 22 );
    for (i = 0; i < 22; i ++) {
        hex_str_word = convert_hex_to_hexstr ( navi_ptr );
        *destination_buf_ptr = hex_str_word >> 8;
        *(destination_buf_ptr + 1) = hex_str_word;
        destination_buf_ptr = destination_buf_ptr + 2;
        navi_ptr ++;
    }
    
    if ( name == 29 ) { // intrusion
        unsigned char temp = 0;
        Nop();Nop();Nop();
        temp = (unsigned char) INTRREASONbits.INTRREASON;
        hex_str_word = convert_hex_to_hexstr ( &temp );
        *destination_buf_ptr = hex_str_word >> 8;
        *(destination_buf_ptr + 1) = hex_str_word;
        destination_buf_ptr = destination_buf_ptr + 2;        
    }
    
    *destination_buf_ptr = 0;
    
    for (i = 0; i < 16; i ++) {
        PHONE_to_send_buf[i + 1] = PHONES_buf[5][i];
        if (PHONES_buf[5][i] == 0 ) break;
    }
    i++;
    

    
    PHONE_to_send_buf[0] = '"'; PHONE_to_send_buf[i] = '"'; PHONE_to_send_buf[i + 1] = 0;
//    PHONENUMPTR = &PHONE_to_send_buf; // указатель на массив с номером для отправки смс    
    
//    write_text_to_SMS_buf ( &sms_temp_buf, &PHONE_to_send_buf ); //&PHONES_buf[5][0]
    
}
void load_content_IMSI_event_by_sms ( char name, char *navi_ptr, char *destination_buf_ptr ) {
    
//    unsigned char sms_temp_buf1[100];
    unsigned char i;
    //unsigned int hex_str_word;
//IMEI_str [16]
    memmove  ( destination_buf_ptr, IMEI_str, 15 );
    destination_buf_ptr = destination_buf_ptr + 15;
    
    *destination_buf_ptr ++ = ',';
    bin_2_bcd ( (long) name );
    *destination_buf_ptr ++ = bin_2_bcd_buf [7];
    *destination_buf_ptr ++ = bin_2_bcd_buf [8];
    *destination_buf_ptr ++ = ',';
    
//    memmove  ( destination_buf_ptr, navi_ptr, 22 );
    for (i = 0; i < 15; i ++) {
//        hex_str_word = convert_hex_to_hexstr ( navi_ptr );
        *destination_buf_ptr = *navi_ptr;
        destination_buf_ptr ++;
        navi_ptr ++;
    }
    *destination_buf_ptr = 0;
    
    for (i = 0; i < 16; i ++) {
        PHONE_to_send_buf[i + 1] = PHONES_buf[5][i];
        if (PHONES_buf[5][i] == 0 ) break;
    }
    i++;
    PHONE_to_send_buf[0] = '"'; PHONE_to_send_buf[i] = '"'; PHONE_to_send_buf[i + 1] = 0;
//    PHONENUMPTR = &PHONE_to_send_buf; // указатель на массив с номером для отправки смс    
    
//    write_text_to_SMS_buf ( &sms_temp_buf, &PHONE_to_send_buf ); //&PHONES_buf[5][0]
    
}
unsigned int convert_hex_to_hexstr ( char *ptr ) {

    unsigned int temp;
    unsigned char nibble_1, nibble_0;
    
    nibble_0 = *ptr & 0x0F;
    nibble_1 = (*ptr & 0xF0) >> 4;
    
    if (nibble_0 >= 0 && nibble_0 <= 9) nibble_0 = nibble_0 + 0x30;
    else {
        if (nibble_0 >= 10 && nibble_0 <= 15) nibble_0 = nibble_0 + 55; 
    }
    if (nibble_1 >= 0 && nibble_1 <= 9) nibble_1 = nibble_1 + 0x30;
    else {
        if (nibble_1 >= 10 && nibble_1 <= 15) nibble_1 = nibble_1 + 55; 
    }
    
    temp = 0;
    temp = ((temp + nibble_1) << 8);
    temp = temp + nibble_0;
 
 return temp;
}
int extract_data_portion ( unsigned number_of_flag ) {
    
int result;
volatile long fuel_tmp; 
unsigned char tmp;
    
    switch (number_of_flag)
    {
        case 9: // максимальная скорость за период 
            if ((W_ptr + 1) > 112) { result = -1; break; } // Контроль
            command_temp_buf[ W_ptr++ ] = max_speed_to_send;
            result = 1;
        break;
            
        case 10: // пробег по GPS
            Nop();Nop();Nop();
            if ((W_ptr + 4) > 112) { result = -1; break; }
            GPS_odometer_to_send = ( GPS_odometer + 5 )/10;
            command_temp_buf[ W_ptr++ ] = (unsigned char)(GPS_odometer_to_send >> 24);
            command_temp_buf[ W_ptr++ ] = (unsigned char)(GPS_odometer_to_send >> 16);
            command_temp_buf[ W_ptr++ ] = (unsigned char)(GPS_odometer_to_send >> 8);
            command_temp_buf[ W_ptr++ ] = (unsigned char)(GPS_odometer_to_send);
            result = 1;
        break;
            
        case 11: // ACCDATA
//            if ((W_ptr + 9) > 112) { result = -1; break; }
            result = 0;
        break;
            
        case 12: // CVLEV напряжение бортовой сети 
            if ((W_ptr + 1) > 112) { result = -1; break; } // Контроль
            command_temp_buf[ W_ptr++ ] = (unsigned char)(car_voltage);
            result = 1;            
        break;
        
        case 13: // FLEV уровень топлива из кана
            if ((W_ptr + 1) > 112) { result = -1; break; } // Контроль
//            fuel_level = 64;
//            CANFLPRMSbits.can_number = 1;
            fuel_tmp = (unsigned long)fuel_level;
            if ( fuel_sensor_enable != 0 ) {
//                fuel_level_lin = 250;
                fuel_tmp = (unsigned long)fuel_level_lin; 
                fuel_tmp = (long)(((fuel_tmp * (long)FEQUbits.a  + (long)(FEQUbits.b >> 1)))/(long)FEQUbits.b);// + (long)FEQUbits.c;
//                if ( fuel_tmp > 100 ) fuel_tmp = 100;
                fuel_tmp = fuel_tmp + (long)FEQUbits.c;
                if ( fuel_tmp < 0 ) fuel_tmp = -1 * fuel_tmp;
                Nop();Nop();Nop();
            }            
            if (CANFLPRMSbits.can_number != 0 || CANFL2PRMSbits.can_number != 0 || CANFL3PRMSbits.can_number != 0) {            
                # if defined (NISSAN)
                    fuel_tmp = (unsigned char)((fuel_tmp * 100 + 127)/255);
                #endif
                # if defined (INFINITY_FX35)
                    fuel_tmp = (unsigned char)((fuel_level * 100 + 127)/255);
                #endif
                # if defined (INFINITY_FX37)
                    fuel_tmp = (unsigned char)((fuel_tmp * 100 + 127)/255);
                #endif 
                # if defined (FUEL_RECALC)
                    fuel_tmp = (unsigned char)((fuel_tmp * 100 + 127)/255);
                #endif 
//                fuel_tmp = (unsigned long)(((fuel_tmp * (unsigned long)FEQUbits.a  + (unsigned long)(FEQUbits.b >> 1)))/(unsigned long)FEQUbits.b);// + (unsigned long)FEQUbits.c;
//                volatile unsigned char c;
//                c = (unsigned char)FEQUbits.c;
//                fuel_tmp = fuel_tmp + c;
                fuel_tmp = (long)(((fuel_tmp * (long)FEQUbits.a  + (long)(FEQUbits.b >> 1)))/(long)FEQUbits.b);// + (long)FEQUbits.c;
//                if ( fuel_tmp > 100 ) fuel_tmp = 100;
                fuel_tmp = fuel_tmp + (long)FEQUbits.c;
                if ( fuel_tmp < 0 ) fuel_tmp = -1 * fuel_tmp;                    
            }            
            command_temp_buf[ W_ptr++ ] = (unsigned char)(fuel_tmp);
            result = 1;
        break;
        
        case 14: // STATFLGS1 байт флагов состояния 1
            if ((W_ptr + 1) > 112) { result = -1; break; } // Контроль
            command_temp_buf[ W_ptr++ ] = (unsigned char)(STATUSFLAGS1bits.STATUSFLAGS1);
            result = 1;    
        break;
        
        case 15: // INTRFLGS флаги причин вторжения
            if ((W_ptr + 1) > 112) { result = -1; break; } // Контроль
            command_temp_buf[ W_ptr++ ] = INTRREASONbits.INTRREASON;
            result = 1;            
        break;    
            
        case 16:// VIN
        
            result = 0;    
        break;

        case 17:// Пробег из CAN
            if ((W_ptr + 4) > 112) { result = -1; break; }
            
            # if defined (PORSHE_CAENE) 
            CANODObits.B2 = CANODObits.B2 & 0x0F; 
            # endif 
            # if defined (AUDI_A5)      
            CANODObits.B2 = CANODObits.B2 & 0x0F; 
            # endif
            # if defined (AUDI_A6)      
            CANODObits.B2 = CANODObits.B2 & 0x0F; 
            # endif
            # if defined (PORSHE_PANAMERA_2010) 
                CANODObits.B2 = CANODObits.B2 & 0x0F; 
            # endif
            # if defined (ODO_FIX)      
            CANODObits.B2 = CANODObits.B2 & 0x0F; 
            # endif
                
                
            GPS_odometer_to_send = 0;
            GPS_odometer_to_send = 1000 * CANODObits.CANODO;
            command_temp_buf[ W_ptr++ ] = (unsigned char)(GPS_odometer_to_send >> 24);
            command_temp_buf[ W_ptr++ ] = (unsigned char)(GPS_odometer_to_send >> 16);
            command_temp_buf[ W_ptr++ ] = (unsigned char)(GPS_odometer_to_send >> 8);
            command_temp_buf[ W_ptr++ ] = (unsigned char)(GPS_odometer_to_send);        
            result = 1;    
        break;        

        case 18:// Версия прошивки
        
            result = 0;    
        break;

        case 19:// Успешное скачивание прошивки версия, кол-во строк и тп
        
            result = 0;    
        break;

        case 20:// Номера меток
        
            result = 0;    
        break;        

        case 21:// sequence number
            if ((W_ptr + 4) > 112) { result = -1; break; }
            sequence_number = get_sequence_number ();
            command_temp_buf[ W_ptr++ ] = (unsigned char)(sequence_number >> 24);
            command_temp_buf[ W_ptr++ ] = (unsigned char)(sequence_number >> 16);
            command_temp_buf[ W_ptr++ ] = (unsigned char)(sequence_number >> 8);
            command_temp_buf[ W_ptr++ ] = (unsigned char)(sequence_number);        
            result = 1;    
        break;
        case 22:// number of crash
            if ((W_ptr + 2) > 112) { result = -1; break; }
            command_temp_buf[ W_ptr++ ] = (unsigned char)(number_of_crash >> 8);
            command_temp_buf[ W_ptr++ ] = (unsigned char)(number_of_crash);        
            result = 1;    
        break;
        case 23:// number of crash
            if ((W_ptr + 1) > 112) { result = -1; break; } // Контроль
            command_temp_buf[ W_ptr++ ] = (unsigned char)( battery_voltage );        
            result = 1;    
        break; 
        case 24:// number of crash
            if ((W_ptr + 1) > 112) { result = -1; break; } // Контроль
            command_temp_buf[ W_ptr++ ] = (unsigned char)( CANDOORSbits.CANDOORS );        
            result = 1;    
        break;
        case 25:// number of crash
            if ((W_ptr + 1) > 112) { result = -1; break; } // Контроль
            command_temp_buf[ W_ptr++ ] = (unsigned char)( GSMSINGLALLEVELbits.rssi ); 
            command_temp_buf[ W_ptr++ ] = (unsigned char)( GSMSINGLALLEVELbits.ber );
            result = 1;    
        break;
        case 26:// number of crash
            if ((W_ptr + 1) > 112) { result = -1; break; } // Контроль
            command_temp_buf[ W_ptr++ ] = (unsigned char)( temperaturaC ); 
            result = 1;    
        break; 
        case 27:// number of crash
            if ((W_ptr + 1) > 106) { result = -1; break; } // Контроль
            command_temp_buf[ W_ptr++ ] = (unsigned char)SPEEDTRHSET1bits.treshold;
            command_temp_buf[ W_ptr++ ] = (unsigned char)SPEEDTRHSET1bits.histeresis;
            command_temp_buf[ W_ptr++ ] = (unsigned char)SPEEDTRHSET2bits.treshold;
            command_temp_buf[ W_ptr++ ] = (unsigned char)SPEEDTRHSET2bits.histeresis;
            command_temp_buf[ W_ptr++ ] = (unsigned char)SPEEDTRHSET3bits.treshold;
            command_temp_buf[ W_ptr++ ] = (unsigned char)SPEEDTRHSET3bits.histeresis;            
            result = 1;    
        break; 
        case 28:// IMSI
            if ((W_ptr + 1) > 96) { result = -1; break; } // Контроль
            command_temp_buf[ W_ptr++ ] = IMSI_buf[0]; command_temp_buf[ W_ptr++ ] = IMSI_buf[1];
            command_temp_buf[ W_ptr++ ] = IMSI_buf[2]; command_temp_buf[ W_ptr++ ] = IMSI_buf[3];
            command_temp_buf[ W_ptr++ ] = IMSI_buf[4]; command_temp_buf[ W_ptr++ ] = IMSI_buf[5];
            command_temp_buf[ W_ptr++ ] = IMSI_buf[6]; command_temp_buf[ W_ptr++ ] = IMSI_buf[7];
            command_temp_buf[ W_ptr++ ] = IMSI_buf[8]; command_temp_buf[ W_ptr++ ] = IMSI_buf[9];
            command_temp_buf[ W_ptr++ ] = IMSI_buf[10]; command_temp_buf[ W_ptr++ ] = IMSI_buf[11];
            command_temp_buf[ W_ptr++ ] = IMSI_buf[12]; command_temp_buf[ W_ptr++ ] = IMSI_buf[13];
            command_temp_buf[ W_ptr++ ] = IMSI_buf[14];
            
            result = 1;    
        break;
        case 29:// sequence number
            if ((W_ptr + 4) > 112) { result = -1; break; }

            command_temp_buf[ W_ptr++ ] = (unsigned char)(fuel_consumption >> 24);
            command_temp_buf[ W_ptr++ ] = (unsigned char)(fuel_consumption >> 16);
            command_temp_buf[ W_ptr++ ] = (unsigned char)(fuel_consumption >> 8);
            command_temp_buf[ W_ptr++ ] = (unsigned char)(fuel_consumption);        
            result = 1;    
        break;
        case 30:// sequence number
            if ((W_ptr + 4) > 112) { result = -1; break; }
            tmp = 0;
            tmp =       WEBASTOSTATUSbits.FD; tmp = tmp << 1;
            tmp = tmp + WEBASTOSTATUSbits.CAF; tmp = tmp << 1;
            tmp = tmp + WEBASTOSTATUSbits.ST; tmp = tmp << 1;
            tmp = tmp + WEBASTOSTATUSbits.FP; tmp = tmp << 1;
            tmp = tmp + WEBASTOSTATUSbits.CP; tmp = tmp << 1;
            tmp = tmp + WEBASTOSTATUSbits.VFR; tmp = tmp << 1;
            tmp = tmp + WEBASTOSTATUSbits.NSH; tmp = tmp << 1;
            tmp = tmp + WEBASTOSTATUSbits.FI;
            command_temp_buf[ W_ptr++ ] = (unsigned char) tmp;
            command_temp_buf[ W_ptr++ ] = (unsigned char)WEBASTOSTATUSbits.TEMP;
       
            result = 1;    
        break;        
        default:
            result = 0; 
            break;
    }
    
return result;    
}
unsigned long long get_dataflags_by_name (unsigned char name) {
unsigned long long temp, temp1;

    if ( name >= 66 && name <= 71 ) name = 66;
    if ( name == 75 )               name = 74;
    if ( name >= 77 && name <= 79 ) name = 76;
    if ( name == 81 )               name = 80;
    if ( name >= 83 && name <= 86 ) name = 83;
    if ( name == 87 )               name = 33;
    if ( name == 89 )               name = 88;
    if ( name == 91 )               name = 90;


    switch (name)
    {

        
        case 1:
            temp = FM25_read_8( 1004 ); // 1  timed
            break;
        case 2:
            temp = FM25_read_8( 1012 ); // 2  distance
            break;
        case 3:
            temp = FM25_read_8( 1020 ); // 3  heading
            break;
        case 4:
            temp = FM25_read_8( 1028 ); // 4  ignition on
            break;
        case 5:
            temp = FM25_read_8( 1036 ); // 5  ignition off
            break;
        case 6:
            temp = FM25_read_8( 1044 ); // 6  power on
            break;
        case 7:
            temp = FM25_read_8( 1052 ); // 7  power off
            break;
        case 8:
            temp = FM25_read_8( 1060 ); // 8  idle start
            break;
        case 9:
            temp = FM25_read_8( 1068 ); // 9  idle end
            break;
        case 26:
            temp = FM25_read_8( 1076 );// 26 dinamic cal
            break;
        case 27:
            temp = FM25_read_8( 1084 );// 27 arm
            break;
        case 28:
            temp = FM25_read_8( 1092 );// 28 disarm
            break;
        case 29:
            temp = FM25_read_8( 1100 );// 29 intrusion
            break;
        case 30:
            temp = FM25_read_8( 1108 );// 30 serv on
            break;
        case 31:
            temp = FM25_read_8( 1116 );// 31 serv off
            break;
        case 32:
            temp = FM25_read_8( 1124 );// 32 serv auto off
            break;
        case 33:
            temp = FM25_read_8( 1132 );// 33 start unsuccess
            break;
        case 34:
            temp = FM25_read_8( 1140 );// 34 start success
            break;
        case 35:
            temp = FM25_read_8( 1148 );// 35 lock open
            break;
        case 36:
            temp = FM25_read_8( 1156 );// 36 lock close
            break;
        case 37:
            temp = FM25_read_8( 1164 );// 37 autorun command
            break;
        case 39:
            temp = FM25_read_8( 1172 );// 39 robbery
            break;
        case 40:
            temp = FM25_read_8( 1180 );// 40 tilt
            break;
        case 41:
            temp = FM25_read_8( 1188 );// 41 fwrnw
            break;
        case 42:
            temp = FM25_read_8( 1196 );// 42 fw dounloaded
            break;
        case 43:
            temp = FM25_read_8( 1204 );// 43 lock command
            break;
        case 44:
            temp = FM25_read_8( 1212 );// 44 unlock command
            break;
        case 45:
            temp = FM25_read_8( 1220 );// 45 transp nums
            break;
        case 46:
            temp = FM25_read_8( 1228 );// 46 panic
            break;
        case 47:
            temp = FM25_read_8( 1236 );// 47 static cal  
            break;
        case 49:
            temp = FM25_read_8( 1244 );// 47 static cal  
            break;            
        case 50:
            temp = FM25_read_8( 1298 );// 50 crash event message 
            break;
        case 51:
            temp = FM25_read_8( 1306 );// 51 webasto 
            break;
        case 52:
            temp = FM25_read_8( 1314 );// 52 webasto 
            break;
        case 53:
            temp = FM25_read_8( 1326 );// 53 report message 
            break; 
        case 54:
            temp = FM25_read_8( 1475 );// 53 report message 
            break; 
        case 55:
            temp = FM25_read_8( 1483 );// 53 report message 
            break; 
        case 56:
            temp = FM25_read_8( 1491 );// 53 report message 
            break;
        case 57:
            temp = FM25_read_8( 1503 );// 57 mil message 
            break;
        case 58:
            temp = FM25_read_8( 1503 );// 58 mil message 
            break;
        case 59:
            temp = FM25_read_8( 1842 );// 59 АКПП статус 
            break;
        case 60:
            temp = FM25_read_8( 1521 );// 59 АКПП статус 
            break;
        case 61:
            temp = FM25_read_8( 1594 );// 59 АКПП статус 
            break;
        case 62:
            temp = FM25_read_8( 1602 );// 59 АКПП статус 
            break;
        case 63:
            temp = FM25_read_8( 1703 );// 59 АКПП статус 
            break; 
        case 64:
            temp = FM25_read_8( 1894 );// 59 АКПП статус 
            break;
        case 65:
            temp = FM25_read_8( 1894 );// 59 АКПП статус 
            break;
        case 66:
            temp = FM25_read_8( 1909 );// 66 - 71 пороги скорости 
            break;
        case 72:
            temp = FM25_read_8( 1634 );// 72 сообщение о сне с меткой в зоне 
            break; 
        case 73:
            temp = FM25_read_8( 1934 );// 72 сообщение о сне с меткой в зоне 
            break; 
        case 74:
            temp = FM25_read_8( 879 );//  
            break;
        case 76:
            temp = FM25_read_8( 887 );// 
            break; 
        case 80:
            temp = FM25_read_8( 1642 );// belt 
            break;
        case 82:
            temp = FM25_read_8( 1947 );// belt 
            break;
        case 83:
            temp = FM25_read_8( 1642 );// CAN sleep набор данных как у 80 belt 
            break;
        case 88:
            temp = 0x12000000062081FF;// набор данных как у вторжения 
            break;
        case 90:
            temp = FM25_read_8( 1148 );// набор данных как сообщения замки открылись 
            break;
        case 92:
            temp = FM25_read_8( 1100 );// набор данных как у вторжения
            temp = temp & 0x00FFFFFFFFFFFFFF;
            temp1 = (unsigned long long)SECONDAUTHORDATbits.SECONDAUTHORDAT;
            temp1 = temp1 << 56;
            temp = temp + temp1;
            Nop();Nop();Nop();
            break;
        case 93:
            temp = FM25_read_8( 1100 );// набор данных как у вторжения
            temp = temp & 0x00FFFFFFFFFFFFFF;
            temp1 = (unsigned long long)SECONDAUTHORDATFAILbits.SECONDAUTHORDATFAIL;
            temp1 = temp1 << 56;
            temp = temp + temp1;
            Nop();Nop();Nop();
            break;            
        default:
            temp = 0;
            break;
    }


return temp;    
}
int save_dataflags_by_name (unsigned char name, char *ptr ) {
unsigned long long temp;    
int result = 0x0;
char nibble, i, type;

    if ( *ptr != 0x31 && *ptr != 0x32 ) return 0;

    type = *ptr - 0x30;
    
    ptr = ptr + 2;

    temp = 0;
    for (i = 0; i < 16; i ++) {
        nibble = get_fw_nibble ( ptr );
        if (nibble < 0) return 0;
        ptr ++;
        temp = temp + nibble;
        if (i == 15) break;
        temp = temp << 4;
    }
    
    if (type == 1) {
        if (name >= 10 && name <= 25) name = 10; // Все ускорения при маневрах - одна настройка
        if (name == 38 || name == 48) name = 38; // VIN по разным шинам - одна настройка
        if (name == 64 || name == 65) name = 64;
        if ( name >= 66 && name <= 71 ) name = 66;
        if ( name == 75 )               name = 74;
        if ( name >= 77 && name <= 79 ) name = 76;
        if ( name == 81 )               name = 80;
        if ( name == 89 )               name = 88;
        if ( name == 91 )               name = 90;

        
        switch (name)
        {
            case 1:
                FM25_write_8( 1004, (unsigned long long)temp ); // 1  timed
                TIMEDDATbits.TIMEDDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 2:
                FM25_write_8( 1012, (unsigned long long)temp  ); // 2  distance
                DISTDATbits.DISTDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 3:
                FM25_write_8( 1020, (unsigned long long)temp  ); // 3  heading
                HEADINGDATbits.HEADINGDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 4:
                FM25_write_8( 1028, (unsigned long long)temp  ); // 4  ignition on
                IGNONDATbits.IGNONDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 5:
                FM25_write_8( 1036, (unsigned long long)temp  ); // 5  ignition off
                IGNOFFDATbits.IGNOFFDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 6:
                FM25_write_8( 1044, (unsigned long long)temp  ); // 6  power on
                POWERONDATbits.POWERONDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 7:
                FM25_write_8( 1052, (unsigned long long)temp  ); // 7  power off
                POWEROFFDATbits.POWEROFFDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 8:
                FM25_write_8( 1060, (unsigned long long)temp  ); // 8  idle start
                IDLESTARTDATbits.IDLESTARTDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 9:
                FM25_write_8( 1068, (unsigned long long)temp  ); // 9  idle end
                IDLEENDDATbits.IDLEENDDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 10:
                FM25_write_8( 1260, (unsigned long long)temp  ); // 9  idle end
                ACCDATbits.ACCDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;            
            case 26:
                FM25_write_8( 1076, (unsigned long long)temp  );// 26 dinamic cal
                DINAMICCALDATbits.DINAMICCALDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 27:
                FM25_write_8( 1084, (unsigned long long)temp  );// 27 arm
                ARMDATbits.ARMDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 28:
                FM25_write_8( 1092, (unsigned long long)temp  );// 28 disarm
                DISARMDATbits.DISARMDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 29:
                FM25_write_8( 1100, (unsigned long long)temp  );// 29 intrusion
                INTRUSIONDATbits.INTRUSIONDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 30:
                FM25_write_8( 1108, (unsigned long long)temp  );// 30 serv on
                SERVONDATbits.SERVONDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 31:
                FM25_write_8( 1116, (unsigned long long)temp  );// 31 serv off
                SERVOFFDATbits.SERVOFFDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 32:
                FM25_write_8( 1124, (unsigned long long)temp  );// 32 serv auto off
                SERVAUTOOFFDATbits.SERVAUTOOFFDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 33:
                FM25_write_8( 1132, (unsigned long long)temp  );// 33 start unsuccess
                STARTUNSUCCESSDATbits.STARTUNSUCCESSDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 34:
                FM25_write_8( 1140, (unsigned long long)temp  );// 34 start success
                STARTSUCCESSDATbits.STARTSUCCESSDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 35:
                FM25_write_8( 1148, (unsigned long long)temp  );// 35 lock open
                LOCKOPENDATbits.LOCKOPENDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 36:
                FM25_write_8( 1156, (unsigned long long)temp  );// 36 lock close
                LOCKCLOSEDATbits.LOCKCLOSEDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 37:
                FM25_write_8( 1164, (unsigned long long)temp  );// 37 autorun command
                AUTORUNCOMMANDDATbits.AUTORUNCOMMANDDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 38:
                FM25_write_8( 1268, (unsigned long long)temp  );// 37 autorun command
                VINDATbits.VINDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;            
            case 39:
                FM25_write_8( 1172, (unsigned long long)temp  );// 39 robbery
                ROBBERYDATbits.ROBBERYDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 40:
                FM25_write_8( 1180, (unsigned long long)temp  );// 40 tilt
                TILTDATbits.TILTDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 41:
                FM25_write_8( 1188, (unsigned long long)temp  );// 41 fwrnw
                FWRNWDATbits.FWRNWDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 42:
                FM25_write_8( 1196, (unsigned long long)temp  );// 42 fw dounloaded
                FWDLDDATbits.FWDLDDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 43:
                FM25_write_8( 1204, (unsigned long long)temp  );// 43 lock command
                LOCKCOMMANDDATbits.LOCKCOMMANDDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 44:
                FM25_write_8( 1212, (unsigned long long)temp  );// 44 unlock command
                UNLOCKCOMMANDDATbits.UNLOCKCOMMANDDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 45:
                FM25_write_8( 1220, (unsigned long long)temp  );// 45 transp nums
                TNUMSDATbits.TNUMSDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 46:
                FM25_write_8( 1228, (unsigned long long)temp  );// 46 panic
                PANICDATbits.PANICDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 47:
                FM25_write_8( 1236, (unsigned long long)temp  );// 47 static cal
                STATICCALDATbits.STATICCALDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 49:
                FM25_write_8( 1244, (unsigned long long)temp  );// 49 unit status message
                UNITSTATUSDATbits.UNITSTATUSDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 50:
                FM25_write_8( 1298, (unsigned long long)temp  );// 49 unit status message
                CRASHDATbits.CRASHDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 51:
                FM25_write_8( 1306, (unsigned long long)temp  );// 49 unit status message
                WEBASTOONDATbits.WEBASTOONDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 52:
                FM25_write_8( 1314, (unsigned long long)temp  );// 49 unit status message
                WEBASTOOFFDATbits.WEBASTOOFFDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 53:
                FM25_write_8( 1326, (unsigned long long)temp  );// 49 unit status message
                REPORTDATbits.REPORTDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break; 
            case 54:
                FM25_write_8( 1475, (unsigned long long)temp  );// 49 unit status message
                TESTMSGSETbits.TESTMSGSET = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 55:
                FM25_write_8( 1483, (unsigned long long)temp  );// 49 unit status message
                ALARMDATbits.ALARMDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 56:
                FM25_write_8( 1491, (unsigned long long)temp  );// 49 unit status message
                PWOFFMSGDATbits.PWOFFMSGDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break; 
            case 57:
                FM25_write_8( 1503, (unsigned long long)temp  );// 57, 58 check engine message
                MILMSGDATbits.MILMSGDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 58:
                FM25_write_8( 1503, (unsigned long long)temp  );// 57, 58 check engine message
                MILMSGDATbits.MILMSGDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 59:
                FM25_write_8( 1842, (unsigned long long)temp  );// 57, 58 check engine message
                GEARBOXDATbits.GEARBOXDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 60:
                FM25_write_8( 1521, (unsigned long long)temp  );// 57, 58 check engine message
                BATLOWDATbits.BATLOWDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 61:
                FM25_write_8( 1594, (unsigned long long)temp  );// 61 boot open message
                BOOTLOCKOPENDATbits.BOOTLOCKOPENDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break; 
            case 62:
                FM25_write_8( 1602, (unsigned long long)temp  );// 61 boot close message
                BOOTLOCKCLOSEDATbits.BOOTLOCKCLOSEDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break; 
            case 63:
                FM25_write_8( 1703, (unsigned long long)temp  );// 61 boot close message
                SPEEDDATbits.SPEEDDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 64:
                FM25_write_8( 1894, (unsigned long long)temp  );// 61 boot close message
                BLINKRPTRDATbits.BLINKRPTRDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break; 
            case 66:
                FM25_write_8( 1909, (unsigned long long)temp  );// 61 boot close message
                SPEEDTRHDATbits.SPEEDTRHDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 72:
//                TRANSPPRESDATbits
                FM25_write_8( 1634, (unsigned long long)temp  );// 61 boot close message
                TRANSPPRESSLPDATbits.TRANSPPRESSLPDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;                
                break;
            case 73:
                temp = temp & 0xEFFFFFFFFFFFFFFF; // SMS канал этого сообщения отключен, СМС отсылается в функции чтения IMSI
                FM25_write_8( 1934, (unsigned long long)temp  );// 61 boot close message
                IMSIDATbits.IMSIDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;                
                break; 
                
            case 74:
                FM25_write_8( 879, (unsigned long long)temp  ); // 74
                LIGTSDATbits.LIGTSDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;               
                break;
            case 76:
                FM25_write_8( 887, (unsigned long long)temp  ); // 76
                TRTLLIGTSDATbits.TRLIGTSDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;               
                break;
            case 80:
                FM25_write_8( 1642, (unsigned long long)temp  ); // 80
                BELTCHANGEDATbits.BELTCHANGEDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;               
                break;
            case 82:
                FM25_write_8( 1947, (unsigned long long)temp ); // 1  timed
                TIMEDWBSTDATbits.TIMEDWBSTDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 88:
                RBLKDATbits.RBLKDAT = (unsigned char) ((temp >> 56) & 0xFF);
                FM25_write_1( 1973, (unsigned char)RBLKDATbits.RBLKDAT ); // 1  timed
                result = 1;
                break;                
            case 90:
                HF2DATbits.HF2DAT = (unsigned char) ((temp >> 56) & 0xFF);
                FM25_write_1( 1976, (unsigned char)HF2DATbits.HF2DAT ); // 1  timed
                result = 1;
                break;
            case 92:
                SECONDAUTHORDATbits.SECONDAUTHORDAT = (unsigned char) ((temp >> 56) & 0xFF);
                FM25_write_1( 1978, (unsigned char)SECONDAUTHORDATbits.SECONDAUTHORDAT ); // 
                result = 1;
                break;                
            case 93:
                SECONDAUTHORDATFAILbits.SECONDAUTHORDATFAIL = (unsigned char) ((temp >> 56) & 0xFF);
                FM25_write_1( 1979, (unsigned char)SECONDAUTHORDATFAILbits.SECONDAUTHORDATFAIL ); // 
                result = 1;
                break;                
            default:                
                result = 0;
                break;
        }
    }

    if (type == 2) {
        if (name >= 10 && name <= 25) name = 10; // Все графики ускорений при маневрах - одна настройка
        if (name == 26 || name == 27) name = 26; // Все графики ускорений при маневрах - одна настройка
        
        switch (name)
        {
            case 10:
                FM25_write_8( 1284, (unsigned long long)temp ); // 1  timed
                ACCCHARTSDATbits.ACCCHARTSDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break;
            case 26:
                FM25_write_8( 1276, (unsigned long long)temp ); // 1  timed
                DTCDATbits.DTCDAT = (unsigned char) ((temp >> 56) & 0xFF);
                result = 1;
                break; 
            case 28://
                DTCWBUSDATbits.DTCWBUSDAT = (unsigned char) ((temp >> 56) & 0xFF);
                FM25_write_1( 1980, (unsigned char)DTCWBUSDATbits.DTCWBUSDAT );
                result = 1;
                break;                
            default:
                result = 0;
                break;
                
        }
    }
    
return result;    
}
int save_settings_by_name (unsigned char name, char *ptr ) {
unsigned long long temp;    
int result;
unsigned int tmp1, tmp2, tmp3;
char /*nibble, i,*/ type;

    if ( *ptr != 0x31 && *ptr != 0x32 ) return 0;

    type = *ptr - 0x30;
    
//    ptr = ptr + 2;

    temp = 0;
    result = 0;
    
    if (type == 1) {
        
        if ( name >= 66 && name <= 71 ) name = 66;

        
        switch (name)
        {
            case 1:
            if (*(ptr + 1) == ',' && *(ptr + 4) == ';' ) { // xx,y,z,

                    temp = convert_str_to_hex ( ptr + 2, 2 );
                    if (temp == -1) { result = 0; break; }
                    timed_period = (unsigned char) temp;
                    FM25_write_1( 1975, (unsigned int) timed_period );// 1 timed

                result = 1;
            }  else result = 0;                
                break;
                
            case 39: // ROBBERY
            if (*(ptr + 1) == ',' && *(ptr + 4) == ',' && *(ptr + 7) == ';' ) { // xx,y,z,

                    temp = convert_str_to_hex ( ptr + 2, 2 );
                    if (temp == -1) { result = 0; break; }
                    tmp1 = (unsigned int) (temp * 10);
                    temp = convert_str_to_hex ( ptr + 5, 2 );
                    if (temp == -1) { result = 0; break; }
                    tmp2 = (unsigned int) temp;
                    
                    ROBBERYSETbits.duration = (unsigned int) tmp1;
                    ROBBERYSETbits.speed  = (unsigned char) tmp2;
                    
                    FM25_write_4( 1511, (unsigned long) ROBBERYSETbits.ROBBERYSET  );// 40 tilt

                result = 1;
            }  else result = 0;                 
            break;
            
            case 40: // TILT
            if (*(ptr + 1) == ',' && *(ptr + 4) == ',' && *(ptr + 9) == ',' && *(ptr + 12) == ';' ) { // xx,y,z,

                    temp = convert_str_to_hex ( ptr + 2, 2 );
                    if (temp == -1) { result = 0; break; }
                    tmp1 = (unsigned int) temp;
                    temp = convert_str_to_hex ( ptr + 5, 4 );
                    if (temp == -1) { result = 0; break; }
                    temp = (temp * 256 + 500)/1000 ;
                    tmp2 = (unsigned int) temp;
                    temp = convert_str_to_hex ( ptr + 10, 2 );
                    if (temp == -1) { result = 0; break; }
                    tmp3 = (unsigned int) temp;
                    
                    TILTSETbits.duration = (unsigned char) tmp1;
                    TILTSETbits.treshold  = (unsigned int) tmp2;
                    tilt_off_timer_setting = (unsigned char) tmp3;
                    
                    FM25_write_2( 1296, (unsigned int) TILTSETbits.TILTSET  );// 40 tilt
                    FM25_write_1( 1944, (unsigned int) tilt_off_timer_setting );//
                result = 1;
            }  else result = 0;                 
            break;
            
            case 50: // CRASH
                Nop();Nop();Nop();
            if (*(ptr + 1) == ',' && *(ptr + 3) == ',' && *(ptr + 6) == ',' && *(ptr + 11) == ',' && *(ptr + 16) == ';' ) { // xx,y,z,

                    temp = convert_str_to_hex ( ptr + 4, 2 );
                    if (temp == -1) { result = 0; break; }
                    tmp1 = (unsigned int) temp;
                    temp = convert_str_to_hex ( ptr + 7, 4 );
                    if (temp == -1) { result = 0; break; }
                    temp = (temp * 256 + 500)/1000 ;
                    tmp2 = (unsigned int) temp;
                    temp = convert_str_to_hex ( ptr + 12, 4 );
                    if (temp == -1) { result = 0; break; }
                    temp = (temp * 256 + 500)/1000 ;
                    tmp3 = (unsigned int) temp;
                    
                    if (*(ptr + 2) == '1'){ // при вкл зажигании
                        CRASHSETbits.CRASHSET = 0;
                        CRASHSETbits.duration = (unsigned char) tmp1;
                        CRASHSETbits.gxy  = (unsigned int) tmp2;
                        CRASHSETbits.gxyz = (unsigned int) tmp3;
                        temp = 0;
                        temp = CRASHSETbits.gxyz;
                        temp = temp << 13;
                        temp = temp + CRASHSETbits.gxy;
                        temp = temp << 6;
                        temp = temp + CRASHSETbits.duration;
                        FM25_write_4( 1292, (unsigned long) temp  );// 50 crash
                        result = 1;    
                    }
                    if (*(ptr + 2) == '0'){ // при выкл зажигании
                        CRASHSETIGNOFFbits.CRASHSETIGNOFF = 0;
                        CRASHSETIGNOFFbits.duration = (unsigned char) tmp1;
                        CRASHSETIGNOFFbits.gxy  = (unsigned int) tmp2;
                        CRASHSETIGNOFFbits.gxyz = (unsigned int) tmp3;
                        temp = 0;
                        temp = CRASHSETIGNOFFbits.gxyz;
                        temp = temp << 13;
                        temp = temp + CRASHSETIGNOFFbits.gxy;
                        temp = temp << 6;
                        temp = temp + CRASHSETIGNOFFbits.duration;
                        FM25_write_4( 1582, (unsigned long) temp  );// 50 crash
                        result = 1;    
                    }                    
            }  else result = 0;    
            break;

            case 53: // отчетное сообщение
            if (*(ptr + 1) == ','&& *(ptr + 6) == ';' ) { // xx,y,z,
                    temp = convert_str_to_hex ( ptr + 2, 4 );
                    if (temp == -1) { result = 0; break; }
                    if (temp < 2) { result = 0; break; }
                    REPORTSETbits.period = (unsigned long) (temp * 600);
                    FM25_write_4( 1322, (unsigned long) REPORTSETbits.REPORTSET  );// 40 tilt
                    result = 1;
            }  else result = 0;    
            break;
            
            case 56: // отчетное сообщение
            if (*(ptr + 1) == ','&& *(ptr + 6) == ';' ) { // xx,y,z,
                    temp = convert_str_to_hex ( ptr + 2, 4 );
                    if (temp == -1) { result = 0; break; }
                    if (temp < 1) { result = 0; break; }
                    PWOFFMSGSETbits.period = (unsigned long) (temp * 600);
                    FM25_write_4( 1499, (unsigned long) PWOFFMSGSETbits.PWOFFMSGSET  );// 40 tilt
                    result = 1;
            }  else result = 0;    
            break;

            case 60: // CRASH
            if (*(ptr + 1) == ',' && *(ptr + 4) == ',' && *(ptr + 7) == ',' && *(ptr + 10) == ';' ) { // xx,y,z,

                    temp = convert_str_to_hex ( ptr + 2, 2 );
                    if (temp == -1) { result = 0; break; }
                    tmp1 = (unsigned int) temp;
                    temp = convert_str_to_hex ( ptr + 5, 2 );
                    if (temp == -1) { result = 0; break; }
                    tmp2 = (unsigned int) temp;
                    temp = convert_str_to_hex ( ptr + 8, 2 );
                    if (temp == -1) { result = 0; break; }
                    temp = temp * 600 ;
                    tmp3 = (unsigned int) temp;
                    
                    BATLOWSETbits.BATLOWSET = 0;
                    BATLOWSETbits.on_treshold = (unsigned char) tmp1;
                    BATLOWSETbits.off_treshold = (unsigned char) tmp2;
                    BATLOWSETbits.delay = (unsigned int)  tmp3;

                    FM25_write_4( 1517, (unsigned long) BATLOWSETbits.BATLOWSET  );// 60 батарея разряжена
                    
                    

                    result = 1;
            }  else result = 0;    
            break;

            case 63: // SPEED
            if (*(ptr + 1) == ',' && *(ptr + 4) == ',' && *(ptr + 7) == ';' ) { // xx,yy;

                    temp = convert_str_to_hex ( ptr + 2, 2 );
                    if (temp == -1) { result = 0; break; }
                    tmp1 = (unsigned int) temp;
                    temp = convert_str_to_hex ( ptr + 5, 2 );
                    if (temp == -1) { result = 0; break; }
                    tmp2 = (unsigned int) temp;
                    
                    SPEEDSETbits.SPEEDSET = 0;
                    SPEEDSETbits.speed = (unsigned char) tmp1;
                    SPEEDSETbits.time = (unsigned char) tmp2;
                    FM25_write_2( 1711, (unsigned int) SPEEDSETbits.SPEEDSET  );// 63 speed changed

                    result = 1;
            }  else result = 0;    
            break;            

            case 66: // Пороги скорости
            if (*(ptr + 1)  == ',' && *(ptr + 4)  == ',' && *(ptr + 6)  == ','  && *(ptr + 9) == ',' &&  
                *(ptr + 11) == ',' && *(ptr + 14) == ',' && *(ptr + 16) == ';' ) { // at$mset=42,1,XX,Y,ZZ,K,MM,L;

                    temp = convert_str_to_hex ( ptr + 2, 2 );
                    if (temp == -1) { result = 0; break; }
                    tmp1 = (unsigned int) temp;
                    temp = convert_str_to_hex ( ptr + 5, 1 );
                    if (temp == -1) { result = 0; break; }
                    tmp2 = (unsigned int) temp;
                    SPEEDTRHSET1bits.SPEEDTRHSET1 = 0;
                    SPEEDTRHSET1bits.treshold = (unsigned char) tmp1;
                    SPEEDTRHSET1bits.histeresis = (unsigned char) tmp2;
                    
                    temp = convert_str_to_hex ( ptr + 7, 2 );
                    if (temp == -1) { result = 0; break; }
                    tmp1 = (unsigned int) temp;
                    temp = convert_str_to_hex ( ptr + 10, 1 );
                    if (temp == -1) { result = 0; break; }
                    tmp2 = (unsigned int) temp;
                    SPEEDTRHSET2bits.SPEEDTRHSET2 = 0;
                    SPEEDTRHSET2bits.treshold = (unsigned char) tmp1;
                    SPEEDTRHSET2bits.histeresis = (unsigned char) tmp2;

                    temp = convert_str_to_hex ( ptr + 12, 2 );
                    if (temp == -1) { result = 0; break; }
                    tmp1 = (unsigned int) temp;
                    temp = convert_str_to_hex ( ptr + 15, 1 );
                    if (temp == -1) { result = 0; break; }
                    tmp2 = (unsigned int) temp;
                    SPEEDTRHSET3bits.SPEEDTRHSET3 = 0;
                    SPEEDTRHSET3bits.treshold = (unsigned char) tmp1;
                    SPEEDTRHSET3bits.histeresis = (unsigned char) tmp2;
                    
                    FM25_write_2( 1903, (unsigned int) SPEEDTRHSET1bits.SPEEDTRHSET1  );// 66 0550 
                    FM25_write_2( 1905, (unsigned int) SPEEDTRHSET2bits.SPEEDTRHSET2  );// 66 0578
                    FM25_write_2( 1907, (unsigned int) SPEEDTRHSET3bits.SPEEDTRHSET3  );// 66 0582

                    result = 1;
            }  else result = 0;    
            break; 
            
            default:
                result = 0;
                break;
        }
    }

    if (type == 2) {
        
        switch (name)
        {
            case 1:
                result = 0;
                break;
            case 2:
                result = 0;
                break;                
            default:
                result = 0;
                break;
                
        }
    }
    
return result;    
}
int check_sms_enable_by_name ( char name ) {
int result = 0;    
    
        if (name >= 10 && name <= 25) name = 10; // Все ускорения при маневрах - одна настройка
        if (name == 38 || name == 48) name = 38; // VIN по разным шинам - одна настройка
        switch (name)
        {
            case 1:
                result = TIMEDDATbits.sms_en;
                break;
            case 2:
                result = DISTDATbits.sms_en;
                break;
            case 3:
                result = HEADINGDATbits.sms_en;
                break;
            case 4:
                result = IGNONDATbits.sms_en;
                break;
            case 5:
                result = IGNOFFDATbits.sms_en;
                break;
            case 6:
                result = POWERONDATbits.sms_en;
                break;
            case 7:
                result = POWEROFFDATbits.sms_en;
                break;
            case 8:
                result = IDLESTARTDATbits.sms_en;
                break;
            case 9:
                result = IDLEENDDATbits.sms_en;
                break;
            case 10:
                result = ACCDATbits.sms_en;
                break;            
            case 26:
                result = DINAMICCALDATbits.sms_en;
                break;
            case 27:
                result = ARMDATbits.sms_en;
                break;
            case 28:
                result = DISARMDATbits.sms_en;
                break;
            case 29:
                result = INTRUSIONDATbits.sms_en;
                break;
            case 30:
                result = SERVONDATbits.sms_en;
                break;
            case 31:
                result = SERVOFFDATbits.sms_en;
                break;
            case 32:
                result = SERVAUTOOFFDATbits.sms_en;
                break;
            case 33:
                result = STARTUNSUCCESSDATbits.sms_en;
                break;
            case 34:
                result = STARTSUCCESSDATbits.sms_en;
                break;
            case 35:
                result = LOCKOPENDATbits.sms_en;
                break;
            case 36:
                result = LOCKCLOSEDATbits.sms_en;
                break;
            case 37:
                result = AUTORUNCOMMANDDATbits.sms_en;
                break;
            case 38:
                result = VINDATbits.sms_en;
                break;            
            case 39:
                result = ROBBERYDATbits.sms_en;
                break;
            case 40:
                result = TILTDATbits.sms_en;
                break;
            case 41:
                result = FWRNWDATbits.sms_en;
                break;
            case 42:
                result = FWDLDDATbits.sms_en;
                break;
            case 43:
                result = LOCKCOMMANDDATbits.sms_en;
                break;
            case 44:
                result = UNLOCKCOMMANDDATbits.sms_en;
                break;
            case 45:
                result = TNUMSDATbits.sms_en;
                break;
            case 46:
                result = PANICDATbits.sms_en;
                break;
            case 47:
                result = STATICCALDATbits.sms_en;
                break;
            case 49:
                result = UNITSTATUSDATbits.sms_en;
                break;
            case 50:
                result = CRASHDATbits.sms_en;
                break;
            case 51:
                result = WEBASTOONDATbits.sms_en;
                break;
            case 52:
                result = WEBASTOOFFDATbits.sms_en;
                break;
            case 53:
                result = REPORTDATbits.sms_en;
                break;                 
            default:
                result = 0;
                break;
        }
    
return result;    
}
long long convert_str_to_hex ( char *ptr, unsigned char len ) {
long long result = 0;
char nibble = 0x0;//, i;

    nibble = hex_2_bin ( *ptr ++);
    if (nibble >= 0) { result = result + nibble; } else return -1;
    if (len == 1) return result;
    
    result = result << 4;
    nibble = hex_2_bin ( *ptr ++);
    if (nibble >= 0) { result = result + nibble; } else return -1;
    if (len == 2) return result;

    result = result << 4;
    nibble = hex_2_bin ( *ptr ++);
    if (nibble >= 0) { result = result + nibble; } else return -1;
    if (len == 3) return result; 
    
    result = result << 4;
    nibble = hex_2_bin ( *ptr ++);
    if (nibble >= 0) { result = result + nibble; } else return -1;
    if (len == 4) return result;    

    result = result << 4;
    nibble = hex_2_bin ( *ptr ++);
    if (nibble >= 0) { result = result + nibble; } else return -1;
    if (len == 5) return result;

    result = result << 4;
    nibble = hex_2_bin ( *ptr ++);
    if (nibble >= 0) { result = result + nibble; } else return -1;
    if (len == 6) return result;

    result = result << 4;
    nibble = hex_2_bin ( *ptr ++);
    if (nibble >= 0) { result = result + nibble; } else return -1;
    if (len == 7) return result;

    result = result << 4;
    nibble = hex_2_bin ( *ptr ++);
    if (nibble >= 0) { result = result + nibble; } else return -1;
    if (len == 8) return result;

    result = result << 4;
    nibble = hex_2_bin ( *ptr ++);
    if (nibble >= 0) { result = result + nibble; } else return -1;
    if (len == 9) return result;

    result = result << 4;
    nibble = hex_2_bin ( *ptr ++);
    if (nibble >= 0) { result = result + nibble; } else return -1;
    if (len == 10) return result;

    result = result << 4;
    nibble = hex_2_bin ( *ptr ++);
    if (nibble >= 0) { result = result + nibble; } else return -1;
    if (len == 11) return result;

    result = result << 4;
    nibble = hex_2_bin ( *ptr ++);
    if (nibble >= 0) { result = result + nibble; } else return -1;
    if (len == 12) return result;

    result = result << 4;
    nibble = hex_2_bin ( *ptr ++);
    if (nibble >= 0) { result = result + nibble; } else return -1;
    if (len == 13) return result;

    result = result << 4;
    nibble = hex_2_bin ( *ptr ++);
    if (nibble >= 0) { result = result + nibble; } else return -1;
    if (len == 14) return result;

    result = result << 4;
    nibble = hex_2_bin ( *ptr ++);
    if (nibble >= 0) { result = result + nibble; } else return -1;
    if (len == 15) return result;

    result = result << 4;
    nibble = hex_2_bin ( *ptr ++);
//    if (nibble == 0x0F) return -1; // Контроль старшего бита
    if (nibble >= 0) { result = result + nibble; } else return -1;
    if (len == 16) return result;

return -1;    
}
int generate_content_of_ack_free_message ( unsigned char name, unsigned char type ) {
unsigned long long data_flags, temp;
unsigned char /*tmp,*/ N, i, length;//, j, *byte_ptr, flag;
int result;


/**/
    STATUSFLAGS1bits.ignition = ignition;

Nop();Nop();Nop();
    
    data_flags = get_dataflags_by_name ( name );
 // Обнуление недопустимых флагов, ЗАВИСИТ ОТ ПРОШИВКИ!!!    
    data_flags = data_flags & 0xFF0000007FE2F7FF;
    
//    data_flags = check_flags_correctness ( name, (unsigned long long)data_flags);
    
    if ( data_flags == 0) return 0; //нет такого имени
//    if ( (data_flags & 0x0300000000000000) == 0 ) return 0; //сообщение выключено (очередь равна нулю)    
    data_flags = data_flags & 0x00FFFFFFFFFFFFFF;
    if ( data_flags == 0 ) return 0; //нет ни одного флага данных

    
// Определение количества значащих байт dataflags
    if ( (data_flags & 0x00000000000000FF) != 0 ) N = 1;
    if ( (data_flags & 0x000000000000FF00) != 0 ) N = 2;
    if ( (data_flags & 0x0000000000FF0000) != 0 ) N = 3;
    if ( (data_flags & 0x00000000FF000000) != 0 ) N = 4;
    if ( (data_flags & 0x000000FF00000000) != 0 ) N = 5;
    if ( (data_flags & 0x0000FF0000000000) != 0 ) N = 6;
    if ( (data_flags & 0x00FF000000000000) != 0 ) N = 7;
Nop();Nop();Nop();

// Загрузка имея и навигационной строки
        reload_GPRS_header ( N + 1, name, 0x0005); // N = 4, name = 1, type = 1, ACK = 1, CRC = 1
        memmove ( command_temp_buf, GPRS_header_buf, 12 );
        command_temp_buf[12] = 0xFF; command_temp_buf[13] = 0xFD; // ACK
//        command_temp_buf[14] = 0xFF; command_temp_buf[15] = 0x77; command_temp_buf[16] = 0x02; // Dataflags
        temp = data_flags;
        for (W_ptr = 14; W_ptr < 14 + N; W_ptr ++) {
            command_temp_buf[ W_ptr ] = (unsigned char) temp & 0x00000000000000FF;
            temp = temp >> 8;
        }
        Nop();Nop();Nop();
        memmove  ( &command_temp_buf[W_ptr], Navi_bin, 22 );
        W_ptr = W_ptr + 22;
        
        data_flags = data_flags >> 9; // вытеснение флага
        
        for  (i = 1; i <= 47; i++ ) { // 47 возможных видов данных в сообщениях
//            flag = data_flags & 0x0000000000000001;
            if ( data_flags & 0x0000000000000001 )result = extract_data_portion ( i + 8 );
            data_flags = data_flags >> 1;
            if ( data_flags == 0 ) break;
        }
        command_temp_buf[113] = W_ptr; //W_ptr - 1
        
        length = command_temp_buf[113];
        write_data_to_GPRS_buf ( command_temp_buf, length );
                
//                write_data_into_save_to_flash_bufs ( command_temp_buf, length );
//            }        
        
    Nop();Nop();Nop();
    return 1;
}
unsigned long get_sequence_number (void) {

    //unsigned long temp;
    
//    temp = FM25_read_4( 1252 );
//    
//    temp ++;
//    
//    FM25_write_4( 1252, (unsigned long)temp  );
    
    
    sequence_number ++;
    
    FM25_write_4( 1252, (unsigned long)sequence_number  );    
    
return sequence_number;
    
}

void transponder_and_power_presence_monitor (void) {
    
    if (transp_presence_counter < 50) { transp_presence_counter ++; }
    else {
        STATUSFLAGS1bits.transp_present = 0;
    }
    
    if (power_presence_counter < 650) { power_presence_counter ++; }
    else {
        STATUSFLAGS1bits.power_stable = 1;
    }
    
}
int generate_message_during_ignition_off (void) {
    
static unsigned long counter = 0;

    if (ignition == 1 || REPORTDATbits.queue == 0) {
        counter = 0;
        return 0;
    }

    if ( counter < REPORTSETbits.period ) counter ++;
    else {
        counter = 0;
//        generate_content_of_message ( 53, 1 );
        message_during_ignition_off_flag = 1;
        return 1;
    }

return 0;     
}
void delayed_message_during_ignition_off (void) {
static unsigned char counter = 0;

    if ( message_during_ignition_off_flag == 0 ) { counter = 0; return; }

    if (counter < 50) counter++;
    else {
        counter = 0;
        message_during_ignition_off_flag = 0;
        generate_content_of_message ( 53, 1 );
    }
    
    
}
int generate_message_during_power_off(void) {
    
static unsigned long counter = 0;

    if ( power == 1 || PWOFFMSGDATbits.queue == 0 ) {
        counter = 0;
        return 0;
    }

    if ( counter < PWOFFMSGSETbits.period ) counter ++;
    else {
        counter = 0;
        generate_content_of_message ( 56, 1 );
        return 1;
    }
return 0;     
}
int generate_test_message (void) {
    
    static int counter = 0;
    
    if (TESTMSGSETbits.start == 0) {
        TESTMSGSETbits.TESTMSGSET = 0;
        
        return;
    }
    
    if (TESTMSGSETbits.number_of_attempts > 0) {
        Nop();Nop();Nop();
        sleep_counter = 0;
        
        if (counter < (TESTMSGSETbits.period * 10)) counter ++;
        else {
            Nop();Nop();Nop();
            counter = 0;
            if (TESTMSGSETbits.mem == 1) {
                generate_content_of_message ( 54, 1 );
            }
            if (TESTMSGSETbits.mem == 2) {
                generate_content_of_ack_free_message ( 54, 1 );
            }
            TESTMSGSETbits.number_of_attempts --;
            
        }
        
    }
    else {
        TESTMSGSETbits.TESTMSGSET = 0;
    }
    
}

int check_fisical_doors (void) {
    
    if (fisical_input_enable != 2) return;

    unsigned char tmp;
# if defined (MCP23S08)
    unsigned char number_of_input;
    
    number_of_input = get_number_of_input ( 2 ); // с какого входа читать?
    tmp = get_input_status_MCP23S08 ( number_of_input );
# else    
    tmp = read_inputs ( 1 );
# endif     
    
// Обработка дверей
    if ( tmp == 0 ) {
            if (doors_counter < 4) {
                doors_counter ++;
                if (doors_counter >= 4) {
                    doors_status = 0;
                }
            }
    }
    else {
        if (doors_counter > 0) {
            doors_counter --;
            if (doors_counter == 0) {
                doors_status = 1;
            }
		}
    }
    

    if (ARMFLAGSbits.arm_status == 1) {
        if (INTRREASONbits.INTRREASON == 0) {
            if (( doors_status != doors_status_tmp )  && ( doors_status  == 1 )) {
                ARMFLAGSbits.intr_event_trigg = 1; 
                INTRREASONbits.all_doors = 1;
            
            }
        }
 // Запрет вторжения по водительской двери после окончания автозапуска        
        if ( dd_intrusion_off_timer > 0 || intrusion_off_by_input_flag == 1 ) ARMFLAGSbits.intr_event_trigg = 0;
        INTRREASONbits.all_doors = 0;
    }
    
    if ( doors_status != doors_status_tmp ) {
        doors_status_changed = 1;
    }
    
    doors_status_tmp = doors_status;
    
    CANDOORSbits.all_doors = doors_status;
    
}
int fisical_boot_detection (void) {

    int res;
    
    res = 0;
    
    if (fisical_input_enable != 4) return res;

    unsigned char tmp;
# if defined (MCP23S08)
    unsigned char number_of_input;
    
    number_of_input = get_number_of_input ( 2 ); // с какого входа читать?
    tmp = get_input_status_MCP23S08 ( number_of_input );
# else    
    tmp = read_inputs ( 1 );
# endif     
    
    if (  tmp == 1  ) {

        if (fisical_boot_counter < 5) fisical_boot_counter ++;
        else {
            fisical_boot_counter = 5;
            boot_status = 1;
        }

    }
    else {
        
        if (fisical_boot_counter > 0) fisical_boot_counter --;
        else {
            boot_status = 0;
        } 
        
    }
    
    if (boot_status != boot_status_tmp) {
        
        
        
        boot_status_tmp = boot_status;
        
        if (boot_status == 1) {
            generate_content_of_message ( 61, 1 );
        } else {
            generate_content_of_message ( 62, 1 );
        }
        res = 1;
    }
    
return res;    
}
int generate_car_battery_low_message (void) {

    static unsigned int counter = 0, res;


//BATLOWSETbits.on_treshold = 0x5A; BATLOWSETbits.off_treshold = 0x62; BATLOWSETbits.delay = 1200;
res = 0;    
    if (BATLOWSETbits.triggered == 0) {
        if ( car_voltage <= BATLOWSETbits.on_treshold ) {
            if (counter < BATLOWSETbits.delay) counter ++;
            else {
                Nop();Nop();Nop();
                counter = 0;
                BATLOWSETbits.triggered = 1;
                generate_content_of_message ( 60, 1 );
                res = 1;
            }
        } else {
                Nop();Nop();Nop();
                counter = 0;        
        }
    } else {
        if (car_voltage >= BATLOWSETbits.off_treshold) {
            BATLOWSETbits.triggered = 0;
            counter = 0;
        }
    }
return res;    
}

void fisical_ignition_detection (void) {

//fisical_input_enable = 1;
    
    if (CANIGNPRMSbits.can_number != 0 || CANIGNPRMS2bits.can_number != 0) return;
    if (fisical_input_enable != 1) return;

    unsigned char tmp;

# if defined (MCP23S08)
    unsigned char number_of_input;
    
    number_of_input = get_number_of_input ( 1 ); // с какого входа читать?
    Nop();Nop();Nop();
    tmp = get_input_status_MCP23S08 ( number_of_input );
# else    
    tmp = read_inputs ( 1 );
# endif
    
    if ( tmp == 1 ) { //_RB11

        if (fisical_ignition_counter < 5) fisical_ignition_counter ++;
        else {
            fisical_ignition_counter = 5;
            ignition = 1;
        }

    }
    else {
        
        if (fisical_ignition_counter > 0) fisical_ignition_counter --;
        else {
            ignition = 0;
            if (start_engine_success_flag == 1) { // 
                start_engine_success_flag = 0;
                dd_intrusion_off_timer = dd_intrusion_off_setting; // 5 секундный таймер игнорирования вторжения по дверям
            }            
        } 
        
    }
}
void intrusion_off_by_input (void) {

    static unsigned int counter = 0;
    
    if (fisical_input_enable != 5) {
        counter = 0;
        return;
    }
  
    unsigned char tmp;
# if defined (MCP23S08)
    unsigned char number_of_input;
    
    number_of_input = get_number_of_input ( 5 ); // с какого входа читать?
    tmp = get_input_status_MCP23S08 ( number_of_input );
# else    
    tmp = read_inputs ( 1 );
# endif    

    if ( tmp == 1 ) {
        counter = 12000;
    }
    
    if ( counter > 0 ) {
        intrusion_off_by_input_flag = 1;
        counter --;
    }
    else {
        intrusion_off_by_input_flag = 0;
    }
    
}
void generate_puls_after_autorun_off ( unsigned char start_tasck ) {

    static unsigned int counter = 0, start = 0;// input_on_counter = 0, input_status = 0, input_status_tmp = 0;// 
    
//    PULSAFTERAUOTORUNPRMSbits.delay = 100;
//    PULSAFTERAUOTORUNPRMSbits.puls_duration = 20;
    
    if ( PULSAFTERAUOTORUNPRMSbits.delay == 0 || PULSAFTERAUOTORUNPRMSbits.puls_duration == 0 ) { //fisical_input_enable != 5 || 
        return;
    }
/*
    if ( read_inputs ( 1 ) == 1 ) { //_RB11

        if (input_on_counter < 2) input_on_counter ++;
        else {
            input_on_counter = 2;
            input_status = 1;
        }

    }
    else {
        
        if (input_on_counter > 0) input_on_counter --;
        else {
            input_status = 0;
        } 
        
    }
    
    if ( input_status == 0 && input_status_tmp == 1 ) {
        if ( start == 0 ) {
            start = 1;
            counter = PULSAFTERAUOTORUNPRMSbits.delay;
        }
    }
    input_status_tmp = input_status;

    if ( start == 0 ) return;
*/  
    
    if ( start_tasck == 1 ) {
        start = 1;
        counter = PULSAFTERAUOTORUNPRMSbits.delay;
    }

    if ( start == 1 ) {   
        if (counter > 0) counter --;
        else {
            start = 0;
# if defined (MCP23S08)
    
# else            
            if (OUTFUNCbits.pin15 == 0x0E) L_OUT = 0;
            if (OUTFUNCbits.pin10 == 0x0E) OUT2 = 0; 
# endif            
        }


        if (  start == 1 && (counter <= PULSAFTERAUOTORUNPRMSbits.puls_duration) ) {
# if defined (MCP23S08)
    
# else            
            if (OUTFUNCbits.pin15 == 0x0E) L_OUT = 1;
            if (OUTFUNCbits.pin10 == 0x0E) OUT2 = 1;
# endif            
        } 
        else {
# if defined (MCP23S08)
    
# else            
            if (OUTFUNCbits.pin15 == 0x0E) L_OUT = 0;
            if (OUTFUNCbits.pin10 == 0x0E) OUT2 = 0;
# endif            
        }
    }
    
}

void voltage_fall_detection (void) {
    
    if (IGNPULSVFALLTASCKbits.start == 0 ) {
        if ( car_voltage_fall < IGNPULSVFALLTSETbits.voltage_treshold  )  {
            IGNPULSVFALLTASCKbits.timer = IGNPULSVFALLTSETbits.timer_value;
            IGNPULSVFALLTASCKbits.start = 1;
        }
    }
    
    if (IGNPULSVFALLTASCKbits.timer > 0) IGNPULSVFALLTASCKbits.timer --;
    else {
        Nop();Nop();Nop();
        IGNPULSVFALLTASCKbits.IGNPULSVFALLTASCK = 0;
    }
    
}
void lock_bytes_learn_tasck3 (int call_source) {

static unsigned char temp;
//unsigned char i, num_of_same_bytes;
    
    if (LOCKBYTESTASCKbits.start == 0) { LOCKBYTESTASCKbits.LOCKBYTESTASCK = 0; return; }
    
    if ( call_source == 0) { // вызов из periodic_tascks() с периодом 100 мс
        
        if ( LOCKBYTESTASCKbits.timer < 150 ) LOCKBYTESTASCKbits.timer ++;
        else {
            Nop();Nop();Nop();
            start_beep_task (10, 20, 3); // неуспех 3 писк
            
            LOCKBYTESTASCKbits.LOCKBYTESTASCK = 0;
            return;
        }
        
        if ( LOCKBYTESTASCKbits.timer == 1 ) {
            start_beep_task (100, 2, 1); // писк начала процедуры 
        }
        
    } else { // вызов из apply_can_data() при приеме данных из кана с соответствующего ID
        temp = 0;
        if ( CANLOCKCHECKBYTESbits.num0 < 8 ) {
            if ( CANLOCKCHECKBYTESbits.byte0 == LOCK_BYTES_buf[CANLOCKCHECKBYTESbits.num0]) temp ++; 
        } else temp ++;
        if ( CANLOCKCHECKBYTESbits.num1 < 8 ) {
            if ( CANLOCKCHECKBYTESbits.byte1 == LOCK_BYTES_buf[CANLOCKCHECKBYTESbits.num1]) temp ++; 
        } else temp ++;        
        if ( CANLOCKCHECKBYTESbits.num2 < 8 ) {
            if ( CANLOCKCHECKBYTESbits.byte2 == LOCK_BYTES_buf[CANLOCKCHECKBYTESbits.num2]) temp ++; 
        } else temp ++;

        if (temp == 3) {
            LOCKBYTESTASCKbits.LOCKBYTESTASCK = 0;
            lockbytes_learned = 1;
            FM25_write_1 ( 1747, (unsigned int) lockbytes_learned );
            FM25_write_1 ( 1748, (unsigned int) LOCK_BYTES_buf[0] );FM25_write_1 ( 1749, (unsigned int) LOCK_BYTES_buf[1] );
            FM25_write_1 ( 1750, (unsigned int) LOCK_BYTES_buf[2] );FM25_write_1 ( 1751, (unsigned int) LOCK_BYTES_buf[3] );
            FM25_write_1 ( 1752, (unsigned int) LOCK_BYTES_buf[4] );FM25_write_1 ( 1753, (unsigned int) LOCK_BYTES_buf[5] );
            FM25_write_1 ( 1754, (unsigned int) LOCK_BYTES_buf[6] );FM25_write_1 ( 1755, (unsigned int) LOCK_BYTES_buf[7] );
            delayed_beep_start = 1;
            
        }
        
    }    
    
}
void lock_bytes_learn_tasck (int call_source) {
    
static unsigned char temp;
unsigned char i, num_of_same_bytes;


    if (LOCKBYTESTASCKbits.start == 0) { LOCKBYTESTASCKbits.LOCKBYTESTASCK = 0; return; }

    if ( lockbytes_learn_param == 3 ) {
        
        lock_bytes_learn_tasck3 ( call_source );
        return;
    } 
    
    if ( call_source == 0) { // вызов из periodic_tascks() с периодом 100 мс
        
        if ( LOCKBYTESTASCKbits.timer < 150 ) LOCKBYTESTASCKbits.timer ++;
        else {
            Nop();Nop();Nop();
            start_beep_task (10, 20, 3); // неуспех 3 писк
            
            LOCKBYTESTASCKbits.LOCKBYTESTASCK = 0;
            return;
        }
        
        if (lockbytes_learn_param == 2 && LOCKBYTESTASCKbits.timer == 1) {
            start_beep_task (100, 2, 1); // 
        }
        
    } else { // вызов из apply_can_data() при приеме данных из кана с соответствующего ID
        
        if ( LOCKBYTESTASCKbits.timer < 150 ) {
            temp = 0;
            if (LOCKBYTESTASCKbits.preliminary_done == 0) {    
                if (CANLOCKBYTESPRMSbits.byte0 < 8) {
                    if (LOCK_BYTES_buf_tmp1[CANLOCKBYTESPRMSbits.byte0] == LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte0]) temp ++; 
                } else temp ++;
                if (CANLOCKBYTESPRMSbits.byte1 < 8) {
                    if (LOCK_BYTES_buf_tmp1[CANLOCKBYTESPRMSbits.byte1] == LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte1]) temp ++; 
                } else temp ++;            
                if (CANLOCKBYTESPRMSbits.byte2 < 8) {
                    if (LOCK_BYTES_buf_tmp1[CANLOCKBYTESPRMSbits.byte2] == LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte2]) temp ++; 
                } else temp ++;
                if (CANLOCKBYTESPRMS2bits.byte3 < 8) {
                    if (LOCK_BYTES_buf_tmp1[CANLOCKBYTESPRMS2bits.byte3] == LOCK_BYTES_buf[CANLOCKBYTESPRMS2bits.byte3]) temp ++; 
                } else temp ++;
                
                LOCK_BYTES_buf_tmp1[CANLOCKBYTESPRMSbits.byte0]  = LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte0];
                LOCK_BYTES_buf_tmp1[CANLOCKBYTESPRMSbits.byte1]  = LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte1];        
                LOCK_BYTES_buf_tmp1[CANLOCKBYTESPRMSbits.byte2]  = LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte2];
                LOCK_BYTES_buf_tmp1[CANLOCKBYTESPRMS2bits.byte3] = LOCK_BYTES_buf[CANLOCKBYTESPRMS2bits.byte3];
                
                if (lockbytes_learn_param == 2) num_of_same_bytes = 1;
                else num_of_same_bytes = 3;
                
                if (temp == 4) {
                    Nop();Nop();Nop();
                    if (LOCKBYTESTASCKbits.counter < num_of_same_bytes) LOCKBYTESTASCKbits.counter ++;
                    else {
                        if (LOCKBYTESTASCKbits.preliminary_done == 0) {
                            if (lockbytes_learn_param == 1) start_beep_task (100, 2, 1); // успешное обнаружение исходного состояния байтов, 1 писк - команда нажать на кнопку
                            LOCKBYTESTASCKbits.preliminary_done = 1;
                            LOCKBYTESTASCKbits.accomplished = 1;
                        } 

                    }

                } else {
                    LOCKBYTESTASCKbits.counter = 0;
                }                
                
                
            }
            if (LOCKBYTESTASCKbits.accomplished == 1 && LOCKBYTESTASCKbits.accomplished_done == 0) {
                temp = 0;
                if (CANLOCKBYTESPRMSbits.byte0 < 8) {
                    if (LOCK_BYTES_buf_tmp2[CANLOCKBYTESPRMSbits.byte0] == LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte0]) temp ++; 
                } else temp ++;
                if (CANLOCKBYTESPRMSbits.byte1 < 8) {
                    if (LOCK_BYTES_buf_tmp2[CANLOCKBYTESPRMSbits.byte1] == LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte1]) temp ++; 
                } else temp ++;            
                if (CANLOCKBYTESPRMSbits.byte2 < 8) {
                    if (LOCK_BYTES_buf_tmp2[CANLOCKBYTESPRMSbits.byte2] == LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte2]) temp ++; 
                } else temp ++;
                if (CANLOCKBYTESPRMS2bits.byte3 < 8) {
                    if (LOCK_BYTES_buf_tmp2[CANLOCKBYTESPRMS2bits.byte3] == LOCK_BYTES_buf[CANLOCKBYTESPRMS2bits.byte3]) temp ++; 
                } else temp ++;
                
                    if (lockbytes_learn_param == 2) num_of_same_bytes = 2;
                    else num_of_same_bytes = 3;
                
                    if (temp == 4) {
                        Nop();Nop();Nop();
                        if (LOCKBYTESTASCKbits.counter < num_of_same_bytes) LOCKBYTESTASCKbits.counter ++;
                        else {
                            for (i = 0; i < 8; i ++) {
                                if (LOCK_BYTES_buf[i] != LOCK_BYTES_buf_tmp1[i]) break;
                            }
                            if (i != 8) { 
                            
                                if (LOCKBYTESTASCKbits.preliminary_done == 1 && LOCKBYTESTASCKbits.accomplished_done == 0) {
                                    LOCKBYTESTASCKbits.accomplished_done = 1;
                                    LOCKBYTESTASCKbits.LOCKBYTESTASCK = 0;                            
                                    lockbytes_learned = 1;
                                    FM25_write_1 ( 1747, (unsigned int) lockbytes_learned );
                                    FM25_write_1 ( 1748, (unsigned int) LOCK_BYTES_buf[0] );FM25_write_1 ( 1749, (unsigned int) LOCK_BYTES_buf[1] );
                                    FM25_write_1 ( 1750, (unsigned int) LOCK_BYTES_buf[2] );FM25_write_1 ( 1751, (unsigned int) LOCK_BYTES_buf[3] );
                                    FM25_write_1 ( 1752, (unsigned int) LOCK_BYTES_buf[4] );FM25_write_1 ( 1753, (unsigned int) LOCK_BYTES_buf[5] );
                                    FM25_write_1 ( 1754, (unsigned int) LOCK_BYTES_buf[6] );FM25_write_1 ( 1755, (unsigned int) LOCK_BYTES_buf[7] );
                                    delayed_beep_start = 1;
//                                    start_beep_task (10, 20, 2); // успешное обнаружение исходного состояния байтов, 1 писк - команда нажать на кнопку
                                } 
                            }
                        }

                    } else {
                        LOCKBYTESTASCKbits.counter = 0;
                    }
                LOCK_BYTES_buf_tmp2[CANLOCKBYTESPRMSbits.byte0]  = LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte0];
                LOCK_BYTES_buf_tmp2[CANLOCKBYTESPRMSbits.byte1]  = LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte1];        
                LOCK_BYTES_buf_tmp2[CANLOCKBYTESPRMSbits.byte2]  = LOCK_BYTES_buf[CANLOCKBYTESPRMSbits.byte2];                
                LOCK_BYTES_buf_tmp2[CANLOCKBYTESPRMS2bits.byte3] = LOCK_BYTES_buf[CANLOCKBYTESPRMS2bits.byte3];
            }

        }       
        
    }
    
}

void delayed_beep (void) {

    static unsigned int counter = 0;
    
    if (delayed_beep_start == 0) {counter = 0; return; }
    
    if (counter < 30) counter ++;
    else {
        counter = 0;
        delayed_beep_start = 0;
        start_beep_task (10, 20, 2); // успешное обнаружение исходного состояния байтов, 1 писк - команда нажать на кнопку
    }
    
}

void check_gprs_connection (void) {
    
//static unsigned int counter = 0;

    if (GPRSCHECKbits.start == 0) { GPRSCHECKbits.GPRSCHECK = 0;  return;}
    
    if (GPRSCHECKbits.counter < 650) GPRSCHECKbits.counter ++;
    else {
        GPRSCHECKbits.GPRSCHECK = 0;
        close_udp_tcp_connection ( 1 );
    }
    
}

char Si4461_temperature_mesuare ( char sleep_on ) {
    
unsigned char CTS;//, j;
unsigned int voltage_temp;
static unsigned int counter = 0;

    if ( TEMPERATURESETbits.enable == 0 ) return 0;

//    if ( sleep_on == 0 ) {
        
        if (counter < 300) { 
            counter ++; 
            return;
        }
        counter = 0;

        if ( RFSTATEbits.waiting_inquiry == 0 ) return;
        
//    }

	CS_SI4461 = 0;

		SPI3BUF = 0x14;
		while (!SPI3STATbits.SPIRBF);
		CTS = SPI3BUF;

		SPI3BUF = 0x10;
		while (!SPI3STATbits.SPIRBF);
		CTS = SPI3BUF;

		SPI3BUF = 0xA0;
		while (!SPI3STATbits.SPIRBF);
		CTS = SPI3BUF;
	CS_SI4461 = 1;

	__delay_us (20);



		while (1) {
			CS_SI4461 = 0;
				SPI3BUF = 0x44;
				while (!SPI3STATbits.SPIRBF);
				CTS = SPI3BUF;
				CTS = 0;
				SPI3BUF = 0;
				while (!SPI3STATbits.SPIRBF);
				CTS = SPI3BUF;
			CS_SI4461 = 1;

			__delay_us (20);

			if (CTS == 0xFF) break; 
		}

	voltage_temp = 0;

	CS_SI4461 = 0;

		SPI3BUF = 0x44;
		while (!SPI3STATbits.SPIRBF);
		CTS = SPI3BUF;

		SPI3BUF = 0;
		while (!SPI3STATbits.SPIRBF);
		CTS = SPI3BUF;

		SPI3BUF = 0;
		while (!SPI3STATbits.SPIRBF);
		CTS = SPI3BUF;

		SPI3BUF = 0;
		while (!SPI3STATbits.SPIRBF);
		CTS = SPI3BUF;

		SPI3BUF = 0;
		while (!SPI3STATbits.SPIRBF);
		CTS = SPI3BUF;

		SPI3BUF = 0;
		while (!SPI3STATbits.SPIRBF);
		CTS = SPI3BUF;        
        
		SPI3BUF = 0;
		while (!SPI3STATbits.SPIRBF);
		CTS = SPI3BUF;
		voltage_temp = CTS;
		voltage_temp = voltage_temp << 8;

		SPI3BUF = 0;
		while (!SPI3STATbits.SPIRBF);
		CTS = SPI3BUF;
		voltage_temp = voltage_temp + CTS;

//        temperatura = (unsigned int)voltage_temp;


	CS_SI4461 = 1;

    temperatura = (int)((( (long)voltage_temp * 899 )/4096) - 293);
    
    if ( sleep_on == 1 ) {
        temperatura = temperatura - TEMPERATURESETbits.delta2;
    } else {
        if ( temperatura_correct_timer == 0 ) {
            temperatura = temperatura - TEMPERATURESETbits.delta1;
        } else temperatura = temperatura - TEMPERATURESETbits.delta2;
        
    }
    
    if ( temperatura < -50 ) temperatura = -50;
    if ( temperatura > 120 ) temperatura = 120;
    
    if ( temperatura != -50 ) {
        temperaturaC = (char)temperatura;
    }

    
//    bin_2_bcd ( (long) temperaturaC );
//    command_temp_buf[0] = 't'; command_temp_buf[1] = '='; command_temp_buf[2] = bin_2_bcd_buf[0]; 
//    command_temp_buf[3] = bin_2_bcd_buf[7]; command_temp_buf[4] = bin_2_bcd_buf[8]; 
//    command_temp_buf[5] = 0x0D; command_temp_buf[5] = 0;
//    
//    load_UART4_Tx_buf (command_temp_buf);
//    start_UART4_transmission (WAITOFF);    
    
Nop();Nop();Nop();

return temperaturaC;
    
} 
char Si4461_temperature_mesuare_during_sleep ( char sleep_on ) {
    
unsigned char CTS;//, j;
unsigned int voltage_temp;
//static unsigned int counter = 0;

//    if ( TEMPERATURESETbits.enable == 0 ) return 0;
//
////    if ( sleep_on == 0 ) {
//        
//        if (counter < 300) { 
//            counter ++; 
//            return;
//        }
//        counter = 0;
//
//        if ( RFSTATEbits.waiting_inquiry == 0 ) return;
//        
////    }

	CS_SI4461 = 0;

		SPI3BUF = 0x14;
		while (!SPI3STATbits.SPIRBF);
		CTS = SPI3BUF;

		SPI3BUF = 0x10;
		while (!SPI3STATbits.SPIRBF);
		CTS = SPI3BUF;

		SPI3BUF = 0xA0;
		while (!SPI3STATbits.SPIRBF);
		CTS = SPI3BUF;
	CS_SI4461 = 1;

	__delay_us (20);



		while (1) {
			CS_SI4461 = 0;
				SPI3BUF = 0x44;
				while (!SPI3STATbits.SPIRBF);
				CTS = SPI3BUF;
				CTS = 0;
				SPI3BUF = 0;
				while (!SPI3STATbits.SPIRBF);
				CTS = SPI3BUF;
			CS_SI4461 = 1;

			__delay_us (20);

			if (CTS == 0xFF) break; 
		}

	voltage_temp = 0;

	CS_SI4461 = 0;

		SPI3BUF = 0x44;
		while (!SPI3STATbits.SPIRBF);
		CTS = SPI3BUF;

		SPI3BUF = 0;
		while (!SPI3STATbits.SPIRBF);
		CTS = SPI3BUF;

		SPI3BUF = 0;
		while (!SPI3STATbits.SPIRBF);
		CTS = SPI3BUF;

		SPI3BUF = 0;
		while (!SPI3STATbits.SPIRBF);
		CTS = SPI3BUF;

		SPI3BUF = 0;
		while (!SPI3STATbits.SPIRBF);
		CTS = SPI3BUF;

		SPI3BUF = 0;
		while (!SPI3STATbits.SPIRBF);
		CTS = SPI3BUF;        
        
		SPI3BUF = 0;
		while (!SPI3STATbits.SPIRBF);
		CTS = SPI3BUF;
		voltage_temp = CTS;
		voltage_temp = voltage_temp << 8;

		SPI3BUF = 0;
		while (!SPI3STATbits.SPIRBF);
		CTS = SPI3BUF;
		voltage_temp = voltage_temp + CTS;

//        temperatura = (unsigned int)voltage_temp;


	CS_SI4461 = 1;

    temperatura = (int)((( (long)voltage_temp * 899 )/4096) - 293);
    
    if (sleep_on == 1) {
        temperatura = temperatura - TEMPERATURESETbits.delta2;
    } else temperatura = temperatura - TEMPERATURESETbits.delta1;
    
    if ( temperatura < -50 ) temperatura = -50;
    if ( temperatura > 120 ) temperatura = 120;
    
    if ( temperatura != -50 ) {
        temperaturaC = (char)temperatura;
    }
    
    SDN_SI4461 = 1;

//    bin_2_bcd ( (long) temperaturaC );
//    command_temp_buf[0] = 't'; command_temp_buf[1] = '='; command_temp_buf[2] = bin_2_bcd_buf[0]; 
//    command_temp_buf[3] = bin_2_bcd_buf[7]; command_temp_buf[4] = bin_2_bcd_buf[8]; 
//    command_temp_buf[5] = 0x0D; command_temp_buf[5] = 0;
//    
//    load_UART4_Tx_buf (command_temp_buf);
//    start_UART4_transmission (WAITOFF);    
    
Nop();Nop();Nop();

return temperaturaC;
    
} 

void charge_battery_task ( char sleep_flag ) {
    
    static unsigned int charge_timer = 0;
    static unsigned char delay_timer = 0;    
    
    if ( battery_charge_type == 0 ) return;
    
    if ( delay_timer < 20 ) { // Задержка на запуск функции при первом включении и сбросе
        delay_timer ++; 
        return;
    }

    if ( battery_voltage < 153 ) BATTCHRGTASKbits.low_trh_trigg = 1; // нижний порог 3.95В
    
    if ( BATTCHRGTASKbits.low_trh_trigg == 0 ) {
        BATTCHRGTASKbits.BATTCHRGTASK = 0; 
        return;
    }
    
    if ( BATTCHRGTASKbits.low_trh_trigg == 1 ) {
        if (sleep_flag == 0) CHARGE_ONOFF = 1;
        else CHARGE_ONOFF = 0;
    }
    
    if ( battery_voltage >= 159 ) BATTCHRGTASKbits.hihg_trh_trigg = 1; // верхний порог 4.1В 
    
    if (BATTCHRGTASKbits.hihg_trh_trigg == 1) {
        if (sleep_flag == 0) { 
            if ( charge_timer < 36000 ) { // Задержка на отключение заряда после достижения верхнего порога
                charge_timer ++; 
            } else {
                charge_timer = 0;
                CHARGE_ONOFF = 0;
                BATTCHRGTASKbits.BATTCHRGTASK = 0;
            }
        }
    }
    
}
void blinkrptr_task (void) {
    
static unsigned char blink_counter = 0;    
    
    if ( BLINKRPTRTASKbits.start == 0 ) {
        BLINKRPTRTASKbits.BLINKRPTRTASK = 0;
        blink_counter = 0;
# if defined (MCP23S08)
    
# else        
        if ( OUTFUNCbits.pin15 == 0x0A ) L_OUT = 0;
# endif        
        return;
    }
    
    if (BLINKRPTRTASKbits.timer > 0) {
        BLINKRPTRTASKbits.timer --;
        
        if ( BLINKRPTRTASKbits.type == 0 ) {
# if defined (MCP23S08)
    
# else            
            if ( OUTFUNCbits.pin15 == 0x0A ) L_OUT = 1;
# endif            
        } else {
            if ( blink_counter < 3 ) blink_counter ++;
            else {
                blink_counter = 0;
# if defined (MCP23S08)
    
# else                
                if ( OUTFUNCbits.pin15 == 0x0A ) L_OUT = ! L_OUT;
# endif                
            }
//            if ( blink_counter < 3 ) {
//                if ( OUTFUNCbits.pin15 == 0x0A ) L_OUT = 1;
//            } else {
//                if ( OUTFUNCbits.pin15 == 0x0A ) L_OUT = 0;
//            }
            
        }
        
    } else {
        generate_content_of_message ( 65, 1 );
        BLINKRPTRTASKbits.BLINKRPTRTASK = 0;
        blink_counter = 0;
# if defined (MCP23S08)
    
# else        
        if ( OUTFUNCbits.pin15 == 0x0A ) L_OUT = 0;
# endif        
    }
    
}
void car_waike_task (void) {
    
    
    
}
void unlock_message_off_during_autorun (void) {
    
    if ( unlock_message_off_timer > 0 ) unlock_message_off_timer --;
    
}
void send_message_from_memory ( int connection_status )  {
    
    if ( GETMEMMSGTASKbits.start == 0 ) return;
    if ( connection_status != 4 ) return;
    if ( FLASHBUSYbits.FLASHBUSY != 0 ) return;
    
    unsigned char len;
    
    len = (unsigned int) SST25_read_var_from_page ( GETMEMMSGTASKbits.addr, 113, 1 );
    SST25_read_page_to_buf ( GETMEMMSGTASKbits.addr, command_temp_buf, len );
    command_temp_buf[12] = 0xFF; command_temp_buf[13] = 0xFC;
    write_data_to_GPRS_buf ( command_temp_buf, len ); 
    
    GETMEMMSGTASKbits.GETMEMMSGTASK = 0;
    
}
void send_transponder_not_valid_message ( unsigned char source, unsigned char *ptr, int connection_status )  {

    static unsigned char counter = 0, buf[5], /*i,*/ tr_not_valid_flag = 0;


        
    if ( source == 1 ) {
        if ( counter == 0 ) counter = 100;
        memmove ( buf, ptr, 5 );
        tr_not_valid_flag = 1;
        return;
    }
    
    
        if ( tr_not_valid_flag == 0 ) return;
//        if ( source == 0 ) return;
//        if ( connection_status != 4 ) return;

        if ( counter == 100 ) {
            if ( connection_status == 4 ) {    
                if (DIAGNSIGNALSbits.not_valid_transp == 1) load_answer ( 2, "transponder not valid ", &buf, 0 );
            }
        }
    
        if ( counter > 0 ) counter --;
        else {
            tr_not_valid_flag = 0;
        }
    
    

}

# if defined (SELFPROGR)
void  periodic_self_prog_fw (void) {
    
    if ( start_engine_volt_trh != 0xFF ) return;

static unsigned int period = 0;

    if ( period < 900 ) period ++;
    else {
        Nop();Nop();Nop();
        period = 0;
        check_setting ( 2, "at$fwrnw=0000;");
    }
    
    
}
void send_fw_refresh_counter ( int connection_status ) {
    
    if ( fw_refresh_flag != 1 ) return;
    if ( connection_status != 4 ) return;

    unsigned char number_buf[5] = { 0, 0, 0, 0, 0, };


    fw_refresh_flag = 0;
    fw_refresh_counter = (unsigned int) FM25_read_2 ( 1931 );
    bin_2_bcd ( (long)fw_refresh_counter );
    number_buf[0] = bin_2_bcd_buf[5]; number_buf[1] = bin_2_bcd_buf[6];
    number_buf[2] = bin_2_bcd_buf[7]; number_buf[3] = bin_2_bcd_buf[8];
    
    Nop();Nop();Nop();
    load_answer ( 2, "fw refrash counter = ", number_buf, 0 );
    
}
# endif

unsigned char LIN_CRC_calc( unsigned char *array_crc, unsigned char length, unsigned char inv ) {
   //calc and return CRC for bytes from first_byte to last_byte in array for sending
    unsigned int CRC = 0, i;
   
    for ( i = 0; i < length; i++ ) {
       CRC = CRC + *array_crc;
       if ( CRC > 0xFF ) { // if CRC > 0xFF we need to drop MSB and +1 to LSB
           CRC = CRC & 0x00FF;
           CRC ++;      // add carry
       }
       array_crc++;              // inc pointer of current element in array        
    }
   
    if (inv == 1) CRC = (~CRC);
   
    return (unsigned char)(CRC & 0xFF);
}
#if defined (WBUS)
void webasto_wbus_task (void) { //func that manage start_stop WEBASTO by WBUS
    
    if ( WBSWTASKbits.start == 0 ) return; //no start command from check_setting() func 
    #define send_pause 10 // pause between send start packet before ACK will be received (1sec) (if WBUS_HEATER doesn't answer)
    #define start_attemp 5 // try to send 3 start_packet, if no answer with ACK - stop and generate error msg
    static unsigned char send_pause_cnt = 0;
    static unsigned char start_attemp_cnt = 0;
    static unsigned int  send_packet_timer = 150; // timer for packet sending in different time
    unsigned int wtime = WBSWTASKbits.counter / 600; //convert time to Minutes for wbus start packet generation
    sleep_counter = 0; // reset sleep cnt to disable sleep while task is active
    if ( WBSWTASKbits.stop == 1 ) {         //stop cmd from check_setting()
        WBSWTASKbits.WBSWTASK = 0;          //reset all bits to 0
        WEBASTOSTATUSbits.WEBASTOSTATUS = 0;//reset temp&flame detector to 0
        generate_content_of_message ( 52, 1 ); //Webasto was stoped
        send_wbus_stop();
        return;
    }    
            
    if ( WBSWTASKbits.counter > 0 ) WBSWTASKbits.counter --;
       
    //send BREAK wbus packet & start wbus packet if not ACK response received every 1s
    if ((WBSWTASKbits.start_ack == 0) && (send_pause_cnt == 0)) {
        start_attemp_cnt++; // increment cnt of attemps
        if (start_attemp_cnt > start_attemp + 1) {
            WBSWTASKbits.WBSWTASK = 0;          //reset all bits to 0
            WEBASTOSTATUSbits.WEBASTOSTATUS = 0;//reset statuses to 0
            start_attemp_cnt = 0;
            send_packet_timer = 150;
            send_pause_cnt = 0;
            //CHANGE TO ERROR OF WBUS CONNECT (no ACK on start packet)
            generate_content_of_message ( 52, 1 );
            //CHANGE TO ERROR OF WBUS CONNECT
            return;
        }
        //send_break in uart_timeout func//
        if (WBSWTASKbits.break_done == 0) {
            WBSWTASKbits.break_start = 1;
            return;
        }
        //send_break in uart_timeout func//
        
        if ((WBSWTASKbits.break_start == 0) && (WBSWTASKbits.break_done == 1) ) {
            if (send_pause_cnt == 0) {
                WBSWTASKbits.wbus_busy = 1; //set busy line flag
                send_wbus_start(wtime);
            }
            
        }
    }
    send_pause_cnt++; //pause between send wbus_start
    if ( send_pause_cnt > send_pause) send_pause_cnt = 0; //reset pause counter every 1secs
    ///////15secs packet sending/////// every cmd's sends every 15secs but shifted on timeline  
    send_packet_timer--;
    if (send_packet_timer == 0)  { 
        send_wbus_wakeup(); //send wake-up message every 15sec to support webasto working
        WBSWTASKbits.wbus_busy = 1; //wbus line is busy, block other commands to send
    }
    if (send_packet_timer == 75) { 
        send_wbus_temp_status_request(); //send temp&flame request every 15sec
        WBSWTASKbits.wbus_busy = 1; //wbus line is busy, block other commands to send
    }
    if (send_packet_timer == 95) { 
        send_wbus_onoff_subsystems_request(); //send temp&flame request every 15sec
        WBSWTASKbits.wbus_busy = 1; //wbus line is busy, block other commands to send
    }
    if (send_packet_timer == 100){
        DVRQWTASKbits.start = 1;  //through DVRQW TASK request
        //send_wbus_errors_request(); //direct request
        //WBSWTASKbits.wbus_busy = 1; //wbus line is busy, block other commands to send
    }
    if (send_packet_timer == 0) send_packet_timer = 150; //reset timer after 15secs
    ///////15secs packet sending/////// every cmd's sends every 15secs but shifted on timeline
    
    if ( WBSWTASKbits.counter == 0 ) { // stop TASK by timeout(time counter)
        WBSWTASKbits.WBSWTASK = 0;           //reset all bits to 0
        WEBASTOSTATUSbits.WEBASTOSTATUS = 0; //reset temp&flame&... status to 0
        generate_content_of_message ( 52, 1 );
        send_pause_cnt = 0;
        send_packet_timer = 150;
        start_attemp_cnt = 0;
        send_wbus_stop();
        Nop();Nop();Nop();
    }
}
/*
void webasto_wbus_errorreq_task (void) {// WBUS send error request task (dvrqw)
    if ( DVRQWTASKbits.stop  == 1 ) DVRQWTASKbits.DVRQWTASK = 0; //reset all bits to 0; TASK was stopped externally
    if ( DVRQWTASKbits.start == 0 ) return; //no start command from check_setting() func
    
    //send_break in uart_timeout func if WBSW TAsk isn't active//
    if ((WBSWTASKbits.break_done == 0) && (WBSWTASKbits.start == 0)) {
        WBSWTASKbits.break_start = 1;
        return;
    }
    //send_break in uart_timeout func if WBSW TAsk isn't active//
    
    if ( WBSWTASKbits.wbus_busy == 0 && DVRQWTASKbits.counter == 0 ) {
        WBSWTASKbits.wbus_busy = 1;
        send_wbus_errors_request();  
    }
    
    #define wbus_timeout 10 // receive error packet contains 3 error ~ 80ms. Now 10 - 1000ms ; >40 errors in packet
    DVRQWTASKbits.counter ++; //counter for timeout
    if ( DVRQWTASKbits.counter == wbus_timeout ) { // stop TASK by timeout(time counter)
        DVRQWTASKbits.DVRQWTASK = 0;           //reset all bits to 0
        WBSWTASKbits.wbus_busy = 0;
        WBSWTASKbits.break_done = 0;
        //generate_content_of_message ( 52, 1 );
        //GENERATE MSG THAT ERRORS WEREN'T RECEIVED in time after request
        Nop();Nop();Nop();
    }
}
*/
void webasto_wbus_errorreq_task (void) {// WBUS send error request task (dvrqw)
   if ( DVRQWTASKbits.stop  == 1 ) DVRQWTASKbits.DVRQWTASK = 0; //reset all bits to 0; TASK was stopped externally
   if ( DVRQWTASKbits.start == 0 ) return; //no start command from check_setting() func

   //send_break in uart_timeout func if WBSW TAsk isn't active//
   if ((WBSWTASKbits.break_done == 0) && (WBSWTASKbits.start == 0)) {
       WBSWTASKbits.break_start = 1;
       return;
   }
   //send_break in uart_timeout func if WBSW task isn't active//

   if ( WBSWTASKbits.wbus_busy == 0 && DVRQWTASKbits.counter == 0 ) {
       WBSWTASKbits.wbus_busy = 1;
       send_wbus_errors_request();
   }
   #define wbus_err_req_attempts 5 //number of attempts for wbus err request if there is no answer
   static unsigned char err_req_attempts_cnt = 0;
   #define wbus_timeout 10 // receive error packet contains 3 error ~ 80ms. Now 10 - 1000ms ; >40 errors in packet
   DVRQWTASKbits.counter ++; //counter for timeout
   if ( DVRQWTASKbits.counter == wbus_timeout ) { // stop TASK by timeout(time counter)
       DVRQWTASKbits.DVRQWTASK = 0;           //reset all bits to 0
       WBSWTASKbits.wbus_busy = 0;
       WBSWTASKbits.break_done = 0;
       if (err_req_attempts_cnt < wbus_err_req_attempts) {
           DVRQWTASKbits.start = 1;
           err_req_attempts_cnt++;
       } else
       {
           err_req_attempts_cnt = 0;
       }
       //generate_content_of_message ( 52, 1 );
       //GENERATE MSG THAT ERRORS WEREN'T RECEIVED in time after request
       Nop();Nop();Nop();
   }
}
void webasto_wbus_errorclr_task (void) {// WBUS send error clear task (drstw)
    if ( DRSTWTASKbits.stop  == 1 ) DRSTWTASKbits.DRSTWTASK = 0; //reset all bits to 0; TASK was stopped externally
    if ( DRSTWTASKbits.start == 0 ) return; //no start command from check_setting() func
   
    //send_break in uart_timeout func if WBSW TAsk isn't active//
    if ((WBSWTASKbits.break_done == 0) && (WBSWTASKbits.start == 0)) {
        WBSWTASKbits.break_start = 1;
        return;
    }
    //send_break in uart_timeout func if WBSW TAsk isn't active//
    
    if ( WBSWTASKbits.wbus_busy == 0 && DRSTWTASKbits.counter == 0 ) {
        WBSWTASKbits.wbus_busy = 1;
        send_wbus_errors_clear();  
    }
    
    #define wbus_timeout 10 // receive error clr ack packet timeout (1s))
    DRSTWTASKbits.counter ++; //counter for timeout
    if ( DRSTWTASKbits.counter == wbus_timeout ) { // stop TASK by timeout(time counter)
        DRSTWTASKbits.DRSTWTASK = 0;    //reset all bits to 0
        WBSWTASKbits.wbus_busy = 0;
        WBSWTASKbits.break_done = 0;
        //generate_content_of_message ( 52, 1 );
        //GENERATE MSG THAT ERRORS WEREN'T CLEARED in time after clear request
        Nop();Nop();Nop();
    }
}
void generate_WBUS_DTC_message ( unsigned char dtc_len ) {
    
    unsigned int i, res;
    unsigned char len;
//    static unsigned char DTC_buf_tmp[93];
    
//    res = 0;
//    for (i = 0; i < 93; i ++) {
//        if (DTC_buf[i] != DTC_buf_tmp[i]) res = 1;
//        DTC_buf_tmp[i] = DTC_buf[i];
//    }
//    
//    if (res == 0) return;
    
        reload_GPRS_header ( 1, 32, 0x0012 ); // N = 1, name = 32, type = 2, ACK = 1
        memmove ( command_temp_buf, GPRS_header_buf, 12 );
        command_temp_buf[12] = 0xff; command_temp_buf[13] = 0xff; // ACK
        memmove  ( &command_temp_buf[14], Navi_bin, 6 ); // Время и дата

        if ( dtc_len > 85 ) dtc_len = 85;
        command_temp_buf[20] = dtc_len;

        memmove ( &command_temp_buf[21], &WBUS_Rx_copy_buf[4], command_temp_buf[20] );

unsigned long long temp;
//        temp = FM25_read_8( 1980 ); // 
        temp = 0x0000000000200000; // сиквенс намбер всегда включен
        if ( temp & 0x0000000000200000 ) {
            sequence_number = get_sequence_number ();
            command_temp_buf[ 21 + command_temp_buf[20] ] = (unsigned char)(sequence_number >> 24);
            command_temp_buf[ 21 + command_temp_buf[20] + 1 ] = (unsigned char)(sequence_number >> 16);
            command_temp_buf[ 21 + command_temp_buf[20] + 2 ] = (unsigned char)(sequence_number >> 8);
            command_temp_buf[ 21 + command_temp_buf[20] + 3 ] = (unsigned char)(sequence_number);            
            len = 21 + command_temp_buf[20] + 4;
        }
        else { len = 21 + command_temp_buf[20]; }        
        
        Nop();Nop();Nop();
        if ( DTCDATbits.queue == 1 ) write_data_into_save_to_flash_bufs ( command_temp_buf, len );    
    
    
}
#endif
void start_webasto_analog (void) {
    
    if ( WBSATASKbits.start == 0 ) return;
    
    if ( WBSATASKbits.stop == 1 ) {
        WBSATASKbits.WBSATASK = 0;
        generate_content_of_message ( 52, 1 );
# if defined (MCP23S08)

# else        
        if (OUTFUNCbits.pin15 == 0x0C) L_OUT = 0;
        if (OUTFUNCbits.pin9 == 0x0C)  AUTO_START = 0; 
        if ( OUTFUNCbits.pin10 == 0x0C ) OUT2 = 0;
# endif
        
        return;
    }    
    
    if ( WBSATASKbits.counter > 0 ) WBSATASKbits.counter --;

# if defined (MCP23S08)

# else    
        if (OUTFUNCbits.pin15 == 0x0C) L_OUT = 1;
        if (OUTFUNCbits.pin9 == 0x0C)  AUTO_START = 1;
        if ( OUTFUNCbits.pin10 == 0x0C ) OUT2 = 1;
# endif    
    if ( WBSATASKbits.counter == 0 ) {
        WBSATASKbits.WBSATASK = 0;
        generate_content_of_message ( 52, 1 );
        
# if defined (MCP23S08)

# else        
        if (OUTFUNCbits.pin15 == 0x0C) L_OUT = 0;
        if (OUTFUNCbits.pin9 == 0x0C)  AUTO_START = 0;
        if ( OUTFUNCbits.pin10 == 0x0C ) OUT2 = 0;
# endif
    }
    
//    
    
}
void start_webasto_analog2 (void) {

    static unsigned int timer;
    
    if ( WBSATASK2bits.start == 0 ) return;

    if ( timer == 0 ) {
        timer = WBSATASK2bits.counter;
    }
    
    if ( timer > 0 ) timer --;
    if ( timer == 0 ) {
        WBSATASK2bits.WBSATASK2 = 0;

# if defined (MCP23S08)

# else        
        if (OUTFUNCbits.pin15 == 0x0C) L_OUT = 0;
        if (OUTFUNCbits.pin9 == 0x0C)  AUTO_START = 0;
        if ( OUTFUNCbits.pin10 == 0x0C ) OUT2 = 0;
# endif
        generate_content_of_message ( 52, 1 );
        return;
    }
    
    if ( WBSATASK2bits.stop == 1 ) {
        WBSATASK2bits.stop = 0;
        timer = WBSATASK2bits.stop_pulse + 1;
    }
    
    if ( (timer > (WBSATASK2bits.counter - WBSATASK2bits.start_puls) ) || (timer < WBSATASK2bits.stop_pulse) ) {
        
# if defined (MCP23S08)

# else        
        if (OUTFUNCbits.pin15 == 0x0C) L_OUT = 1;
        if (OUTFUNCbits.pin9 == 0x0C)  AUTO_START = 1;
        if ( OUTFUNCbits.pin10 == 0x0C ) OUT2 = 1;
# endif
    } else {
        
# if defined (MCP23S08)

# else        
        if (OUTFUNCbits.pin15 == 0x0C) L_OUT = 0;
        if (OUTFUNCbits.pin9 == 0x0C)  AUTO_START = 0;
        if ( OUTFUNCbits.pin10 == 0x0C ) OUT2 = 0;
# endif
    }
    
  
}

unsigned char read_inputs ( unsigned char input ) {

    //unsigned char result = 0;
    union __attribute__ ((far))  {
    unsigned char INPSTATE;
    struct
    {
		unsigned char in1_p1:1;
        unsigned char in2_p8:1;
		unsigned char in3_p13:1;
        unsigned char in4_p12:1;        
        unsigned int  :4;
    };    
    } INPSTATEbits;
    
    switch (input) {
        
        case 1:
            INPSTATEbits.in1_p1 = _RB11;
            if ( INPPOLbits.in1_p1 == 1 ) INPSTATEbits.in1_p1 = ! INPSTATEbits.in1_p1;
            break;
            
            
        default:
            break;
        
        
    }

    return INPSTATEbits.in1_p1;
    
}
void temperatura_correct_after_sleep (void) {
    
    if ( temperatura_correct_timer > 0 ) temperatura_correct_timer --;
    
}

void generate_turn_lights_message ( char sours ) {
    
    volatile static unsigned int counter_tl = 0, counter_tr = 0, tr_on_sent = 0, tl_on_sent = 0;
    
// t_lights_off_timeout
// trlights_status_tmp 
    
    if ( CANTRLIGHTSPRMSbits.can_number != 0 ) {
        if ( sours == 1 ) {
            if ( trlights_status != trlights_status_tmp ) {
                if ( trlights_status_tmp == 1 ) {
                   if (tr_on_sent == 0) {
                       tr_on_sent = 1;
                       if ( ignition == 1 ) generate_content_of_message ( 76, 1 );
                   }
                }
            }
            if ( trlights_status_tmp == 1 ) counter_tr = t_lights_off_timeout;
        } 
        else {
            if ( counter_tr > 0 ) counter_tr --;
            if ( counter_tr == 1 ) {
                tr_on_sent = 0; 
                if ( ignition == 1 ) generate_content_of_message ( 77, 1 );
            } 
        }
    }

    if ( CANTLLIGHTSPRMSbits.can_number != 0 ) {
        if ( sours == 1 ) {
            if ( tllights_status != tllights_status_tmp ) {
                Nop();Nop();Nop();
                if ( tllights_status_tmp == 1 ) {
                   if (tl_on_sent == 0) {
                       tl_on_sent = 1;
                       if ( ignition == 1 ) generate_content_of_message ( 78, 1 );
                   }
                }
            }
            if ( tllights_status_tmp == 1 ) counter_tl = t_lights_off_timeout;
        } 
        else {
            if ( counter_tl > 0 ) counter_tl --;
            if ( counter_tl == 1 ) {
                tl_on_sent = 0; 
                if ( ignition == 1 ) generate_content_of_message ( 79, 1 );
            } 
        }
    } 
    
    if ( sours == 1 ) {    
        trlights_status = trlights_status_tmp;
        tllights_status = tllights_status_tmp;
    }
    
}

void stop_engine_during_autorun_due_intrusion (void) {

    static unsigned int counter = 0, rblk_done_flag = 0;
    
    if ( OUTbits.arm_flag == 0 ) {
        if (rblk_done_flag == 1) {
            rblk_done_flag = 0;
            doors_intr_autorun_flag = 0;
            RELOUTbits.block_flag = 0;
            fire_rel_transaction_flag = 1;            
        }
    }
    
    if ( doors_intr_autorun_flag == 0 ) {
        return;
    }
    
    if ( ARMFLAGSbits.intrusion_timer == 590 ) {
        RELOUTbits.block_flag = 1;
        fire_rel_transaction_flag = 1;
        rblk_done_flag = 1;
        load_answer ( 2, "rblk on due to intrusion during autorun", 0, 0 );
        counter = 100;
    }
    
    if ( counter > 0 ) counter --;
    
    if( counter == 1 ) {
//        rblk_done_flag = 0;
        doors_intr_autorun_flag = 0;
        RELOUTbits.block_flag = 0;
        fire_rel_transaction_flag = 1;
        load_answer ( 2, "rblk off due to intrusion during autorun", 0, 0 );        
    }
    
}

void modem_reset_due_sim_not_ready_during_sleep ( int connection_status ) {
//    MODEMRESINSLPMSGTASCKbits.counter ++;
    
    if ( connection_status != 4 ) return;

    if ( MODEMRESINSLPMSGTASCKbits.start == 0 ) return;
    
    
    bin_2_bcd ( (long) MODEMRESINSLPMSGTASCKbits.counter );
    
    load_answer ( 2, "SIM not ready during sleep ", &bin_2_bcd_buf [5], 0 );

    
    MODEMRESINSLPMSGTASCKbits.MODEMRESINSLPMSGTASCK = 0;
}
void generate_dflt_message ( int connection_status ) {
    
    if ( dflt_flag == 0 ) return;    
    if ( connection_status != 4 ) return;
    dflt_flag = 0;
    load_answer ( 2, "ok:at$dflt", 0, 0 );
    
}
void short_period_of_reports_timer (void) {
    
    if ( ignition == 1 ) short_period_of_reports_counter = 162000;

    if ( short_period_of_reports_counter > 0 ) {
        REPORTSETbits.period = 36000;
        short_period_of_reports_counter --;
    } else {
        REPORTSETbits.period = FM25_read_4( 1322 );
    }
    
}

void generate_message_during_webasto_running (void) {

    static unsigned int period = 0;
    
    if ( WEBASTObits.task_start == 0 && WBSATASKbits.start == 0 && WBSATASK2bits.start == 0 && WBSWTASKbits.start == 0 ) {
        period = 0;
        return;
    }
    
    if (period < 300) period ++;
    else {
        period = 0;
        generate_content_of_message ( 82, 1 );
    }
    
}

void generate_transponder_list_message ( int connection_status ) {
    
    if ( sent_transponed_list_flag == 0 ) return;    
    if ( connection_status != 4 ) return;
    sent_transponed_list_flag = 0;
    
unsigned char temp_buf[31]; 
unsigned char temp;
unsigned int temp1;
	
	temp = FM25_read_1( 32 );
    temp1 = convert_hex_to_hexstr ( &temp );
    temp_buf[0] = (temp1 >> 8); temp_buf[1] = temp1 & 0xFF;
    temp_buf[2] = ',';
    
	temp = FM25_read_1( 33 );
    temp1 = convert_hex_to_hexstr ( &temp );
    temp_buf[3] = (temp1 >> 8); temp_buf[4] = temp1 & 0xFF;
    temp_buf[5] = ',';

	temp = FM25_read_1( 34 );
    temp1 = convert_hex_to_hexstr ( &temp );
    temp_buf[6] = (temp1 >> 8); temp_buf[7] = temp1 & 0xFF;
    temp_buf[8] = ',';
    
	temp = FM25_read_1( 35 );
    temp1 = convert_hex_to_hexstr ( &temp );
    temp_buf[9] = (temp1 >> 8); temp_buf[10] = temp1 & 0xFF;
    temp_buf[11] = ',';

	temp = FM25_read_1( 36 );
    temp1 = convert_hex_to_hexstr ( &temp );
    temp_buf[12] = (temp1 >> 8); temp_buf[13] = temp1 & 0xFF;
    temp_buf[14] = ' '; temp_buf[15] = ' ';   
    

    temp1 = convert_hex_to_hexstr ( &Transp_flags[1] );
    temp_buf[16] = (temp1 >> 8); temp_buf[17] = temp1 & 0xFF;
    temp_buf[18] = ',';

    temp1 = convert_hex_to_hexstr ( &Transp_flags[2] );
    temp_buf[19] = (temp1 >> 8); temp_buf[20] = temp1 & 0xFF;
    temp_buf[21] = ',';

    temp1 = convert_hex_to_hexstr ( &Transp_flags[3] );
    temp_buf[22] = (temp1 >> 8); temp_buf[23] = temp1 & 0xFF;
    temp_buf[24] = ',';
    
    temp1 = convert_hex_to_hexstr ( &Transp_flags[4] );
    temp_buf[25] = (temp1 >> 8); temp_buf[26] = temp1 & 0xFF;
    temp_buf[27] = ',';

    temp1 = convert_hex_to_hexstr ( &Transp_flags[5] );
    temp_buf[28] = (temp1 >> 8); temp_buf[29] = temp1 & 0xFF;
    temp_buf[30] = 0;

    
    load_answer ( 2, &temp_buf, 0, 0 );
    
}
int generate_canbus_sleep_message ( unsigned char source ) {
    static unsigned int counter1 = 0, counter2 = 0, can1_sleep_flag = 0, can2_sleep_flag = 0, can1_waike_flag = 0, can2_waike_flag = 0;
    static unsigned int counter_wake1 = 0, counter_wake2 = 0, can1_msg = 0, can2_msg = 0;
    int res;
    
    res = 0;
    
    if ( source == 0 ) {
        if ( counter1 < 600 ) counter1 ++;
        if ( counter1 == 589 ) {
            can1_sleep_flag = 1;
            can1_waike_flag = 0;
            res = 1;
            generate_content_of_message ( 83, 1 );
        }
        if ( counter2 < 600 ) counter2 ++;
        if ( counter2 == 599 ) {
            can2_sleep_flag = 1;
            can2_waike_flag = 0;
            res = 1;
            generate_content_of_message ( 85, 1 );
        }        
    } 
    
    
    if ( can1_sleep_flag == 1 ) {
        if ( source == 1 ) {
            if (can1_msg < 0xFFFF) can1_msg ++;
        }
        if (counter_wake1 < 50) counter_wake1 ++;
        else {
            if ( can1_msg > 5 ) {
                counter_wake1 = 0;
                can1_msg = 0;
                can1_sleep_flag = 0;
                counter1 = 0;
                can1_waike_flag = 1;
                res = 1;
                generate_content_of_message ( 84, 1 );
            } else {
                can1_msg = 0;
                counter_wake1 = 0;
            }
        }
    }

    if ( can2_sleep_flag == 1 ) {
        if ( source == 2 ) {
            if (can2_msg < 0xFFFF) can2_msg ++;
        }
        if (counter_wake2 < 60) counter_wake2 ++;
        else {
            if ( can2_msg > 5 ) {
                counter_wake2 = 0;
                can2_msg = 0;
                can2_sleep_flag = 0;
                counter2 = 0;
                can2_waike_flag = 1;
                res = 1;
                generate_content_of_message ( 86, 1 );
            } else {
                can2_msg = 0;
                counter_wake2 = 0;
            }
        }
    }
    
    if (can1_waike_flag == 1) {
        if ( source == 1 ) {
            counter1 = 0;
        }
    }
    if (can2_waike_flag == 1) {
        if ( source == 2 ) {
            counter2 = 0;
        }
    }
    
return res;    
}
void check_engine_rpm_status (void) {

    static unsigned char counter = 0;
//RPM_status; //remove after CAN func insertion
//engine_rpm;    
    
    if (ignition == 0) {
        counter = 0;
        engine_rpm = 0;
        RPM_status = 0;
        return;
    }

    if ( engine_rpm >= 400 ) {
        if  ( counter < 15 ) counter ++;
    } else {
        if ( counter > 0 ) counter --;
    }
    
    if ( counter >= 15 ) {
        if (RPM_status == 0) start_beep_task ( 7, 7, 2 );
        RPM_status = 1; 
    }
    if ( counter == 0 )  RPM_status = 0;
    
}

void hands_free_2_tasck () {

    if ( hands_free_enable != 2 ) {
        HANDSFREETASCK2bits.HANDSFREETASCK2 = 0;
        return;
    }
// запуск задачи если заработал автозапуск
    if ((STARTENGINEbits.start   == 1 || STARTENGINESbits.start == 1 || STARTENGINEDLbits.start == 1 ||
         STARTENGINEPbits.start  == 1 || STARTENGINECbits.start_tasck == 1 || STARTENGINEObits.start == 1 || 
         STARTENGINEO1bits.start == 1) && HANDSFREETASCK2bits.start == 0) {
        
            if (HANDSFREETASCK2bits.transp_trigger_flag == 1) HANDSFREETASCK2bits.start = 1;
            
    }
// выход из задачи
    if ( HANDSFREETASCK2bits.start == 0 ) {
        HANDSFREETASCK2bits.HANDSFREETASCK2 = 0;
        return;
    }
// сброс задачи по окончанию автозапуска    
    if (STARTENGINEbits.start  == 0  && STARTENGINESbits.start == 0 && STARTENGINEDLbits.start == 0 &&
        STARTENGINEPbits.start == 0  && STARTENGINECbits.start_tasck == 0 && 
        STARTENGINEObits.start == 0  && STARTENGINEO1bits.start == 0 ) {
        
            HANDSFREETASCK2bits.HANDSFREETASCK2 = 0;
            return;
    }    
    
    if (HANDSFREETASCK2bits.open_done == 0 && HANDSFREETASCK2bits.timer < 3) {
        HANDSFREETASCK2bits.open_done = 1;
        HANDSFREETASCK2bits.close_done = 0;
        LOCKUNLOCKbits.LOCKUNLOCK = 0;
        LOCKUNLOCKbits.start = 1; // Открытие замков
        LOCKUNLOCKbits.unlock = 1; // Открытие замков  
//        generate_content_of_message ( 90, 1 );
    }
    
    if ( HANDSFREETASCK2bits.timer < 65 ) {HANDSFREETASCK2bits.timer ++;} 
    else {
        if (HANDSFREETASCK2bits.close_done == 0) {
            HANDSFREETASCK2bits.close_done = 1;
            HANDSFREETASCK2bits.open_done = 0;
            LOCKUNLOCKbits.LOCKUNLOCK = 0;
            LOCKUNLOCKbits.start = 1; // Закрытие замков
            LOCKUNLOCKbits.lock = 1; // Закрытие замков
//            generate_content_of_message ( 91, 1 );
        }
    } 
    
//    if (STARTENGINEbits.start == 0  && STARTENGINESbits.start == 0 && STARTENGINEDLbits.start == 0 &&
//        STARTENGINEPbits.start == 0 && STARTENGINECbits.start_tasck == 0 && 
//        STARTENGINEObits.start == 0 && STARTENGINEO1bits.start == 0) {
//        
//            HANDSFREETASCK2bits.HANDSFREETASCK2 = 0;
//            return;
//    }
//
//
//    
//    if (HANDSFREETASCK2bits.open_done == 0) {
//        HANDSFREETASCK2bits.open_done = 1;
//        LOCKUNLOCKbits.LOCKUNLOCK = 0;
//        LOCKUNLOCKbits.start = 1; // Открытие замков
//        LOCKUNLOCKbits.unlock = 1; // Открытие замков        
//    }
//    
//    if ( HANDSFREETASCK2bits.timer < 65 ) {HANDSFREETASCK2bits.timer ++;} 
//    else {
//        HANDSFREETASCK2bits.HANDSFREETASCK2 = 0;
//        LOCKUNLOCKbits.LOCKUNLOCK = 0;
//        LOCKUNLOCKbits.start = 1; // Закрытие замков
//        LOCKUNLOCKbits.lock = 1; // Закрытие замков
//    }    
    
}

# if defined ( PRODUCTION_MODE )
void beep_after_test (void) {
    
    if ( beep_after_test_flag == 0 ) return;

    static unsigned int counter = 0, counter_tmp = 0;
    
    if ( counter < 400 ) {
        counter ++;
        if ( (counter - counter_tmp) == 20 ) {
            counter_tmp = counter;
            if ( beep_after_test_flag == 1 ) { 
                start_beep_task ( 3, 1, 1 ); // нет ошибок
                load_UART4_Tx_buf ("\r\nPRODUCTION TEST OK\0"); start_UART4_transmission (WAITOFF);
            }
            if ( beep_after_test_flag == 2 ) {
                start_beep_task ( 3, 6, 2 ); // есть ошибки 
                if (PRODERRORSbits.autostart) { load_UART4_Tx_buf ("\r\nPIN_9 out1 error\0"); start_UART4_transmission (WAITON); }
                if (PRODERRORSbits.lout) { load_UART4_Tx_buf ("\r\nPIN_15 out2 error\0"); start_UART4_transmission (WAITON); }
                if (PRODERRORSbits.out2) { load_UART4_Tx_buf ("\r\nPIN_10 out2 error\0"); start_UART4_transmission (WAITON); }
                if (PRODERRORSbits.can1) { load_UART4_Tx_buf ("\r\nCAN1 error\0"); start_UART4_transmission (WAITON); }
                if (PRODERRORSbits.can2) { load_UART4_Tx_buf ("\r\nCAN2 error\0"); start_UART4_transmission (WAITON); }
                if (PRODERRORSbits.gsm) { load_UART4_Tx_buf ("\r\nGSM error\0"); start_UART4_transmission (WAITON); }
                if (PRODERRORSbits.batt) { load_UART4_Tx_buf ("\r\nBATTERY error\0"); start_UART4_transmission (WAITON); }
                if (PRODERRORSbits.lin) { load_UART4_Tx_buf ("\r\nK-LINE error\0"); start_UART4_transmission (WAITON); }
            }
        }
    } 
//    else {
//        counter = 0; counter_tmp = 0;
//        beep_after_test_flag = 0;
//    }
    
}
void post_production_test (void) {
    
volatile unsigned char temp = 0;

    temp = (unsigned char)FM25_read_1 ( 1931 );
//    FM25_write_1 ( 1931, 1 );
//    temp = 1;
    if ( temp == 0 ) return;

    static unsigned int counter = 0, counter_tmp = 0, beep_flag = 0, err_result = 0;
    static unsigned char p, err1 = 0, err2 = 0, err3 = 0, err4 = 0, err5 = 0, err6 = 0, err7 = 0, err8 = 0, err9 = 0, err10 = 0;
    volatile float temp_y;
//    volatile float G = 0;
//    volatile float temp_x, temp_y, temp_z;

   
    
//    if ( counter < 201 ) counter ++;
//    else {
//
//        counter = 0;
//
//    }

    if ( beep_after_test_flag != 0 ) return;
    
    if ( counter < 200) counter ++;
    else {
        counter = 0;
        if (err1 != 0 || err2 != 0 || err3 != 0 || err4 != 0 ) err_result = 1;
        if ( can1_test_ok != 1 || can1_test_ok != 1 ) {
            if (can1_test_ok == 0) PRODERRORSbits.can1 = 1;
            if (can2_test_ok == 0) PRODERRORSbits.can2 = 1;
            err_result = 1;
        }
        for (p = 0; p < 15; p++) {// IMEI_str c 46 по 60 
            if (IMEI_str[p] > 0x39 || IMEI_str[p] < 0x30) {
                PRODERRORSbits.gsm = 1;
                err_result = 1;
            }
        }
        temp_y = (float)battery_voltage * 0.0258;
//        if ( temp_x > 10.0 && temp_x < 14.0 ) {} else save_test_error ('A');
//        temp_y = 3.0;
        if ( temp_y < 3.4 ) { 
            err_result = 1; // Есть напряжение заряда 
            PRODERRORSbits.batt = 1;
        }        
        
        
        if ( err_result == 0 ) { 
            FM25_write_1 ( 1931, 0 ); 
            beep_after_test_flag = 1; 
        } 
        else beep_after_test_flag = 2;
        Nop();Nop();Nop();
//        counter_tmp = counter;
        
    }
    
//    if ( counter >= 200 ) {
//        if ( (counter - counter_tmp) == 20 ) {
//            counter_tmp = counter;
//            if (err_result == 0) start_beep_task ( 3, 1, 1 ); else start_beep_task ( 3, 6, 2 );
//        }
//    }
    
        switch ( counter ) {
            
            case 1: // проверка выхода pin 9 
//                load_UART4_Tx_buf ("\r\nPRODUCTION TEST START\0"); start_UART4_transmission (WAITON);
# if defined (MCP23S08)

# else
                AUTO_START = 1;
# endif
                break;
                
            case 2: 
                if (_RB11 == 1) {
                    err1 = 1;
                    PRODERRORSbits.autostart = 1;
                }
                break;
                
            case 3:
# if defined (MCP23S08)

# else                
                AUTO_START = 0;
                OUT2 = 1; // проверка выхода pin 9
# endif
                break; 
                
            case 4: 
                if (_RB11 == 1) {
                    err2 = 1;
                    PRODERRORSbits.out2 = 1;
                }
                break;

            case 5:
# if defined (MCP23S08)

# else                
                OUT2 = 0;
                L_OUT = 1; // проверка выхода pin 15    
# endif
                break;
            case 6: 
                if (_RB11 == 1) { 
                    err3 = 1;
                    PRODERRORSbits.lout = 1;
                }
                break;                
            case 7: 
# if defined (MCP23S08)

# else                
                OUT2 = 0;
                L_OUT = 0;
# endif
                break;                
            case 8: 
                break;
                
            case 9: //5 
                
                UART3_Tx_buf[0] = 0x00; UART3_Tx_buf[1] = 0x55; UART3_Tx_buf[2] = 0x03;
                start_UART3_LIN_transmission ( 3 );                
                break;
                
            case 10://6 
                if ( LIN_Rx_copy_buf[0] == 0 && LIN_Rx_copy_buf[1] == 0x55 && LIN_Rx_copy_buf[2] == 0x03 ) {
                    
                } else { 
                    err4 = 1;
                    PRODERRORSbits.lin = 1;
                }// Ошибка LIN
                

                CAN1SETTINGSbits.CAN1SETTINGS   = 0x07D1;  // CAN1
                CAN2SETTINGSbits.CAN2SETTINGS   = 0x07D1;  // CAN2
                CANIGNPRMSbits.CANIGNPRMS       = 0x000004F000403001;// Ignition
                CANDDPRMSbits.CANDDPRMS         = 0x0000011000403102;// вод дверь 
                can1start();
                can2start();     
                init_CAN_filters ();                
                break;
                
            case 11://7
                ecan1WriteTxMsgBufId ( 0, (long) CANDDPRMSbits.id, (unsigned int) CAN1SETTINGSbits.ide, (unsigned int) 0 );
                ecan1WriteTxMsgBufData( 0, 8, 0x0000, 0x4000, 0x0000, 0x0000 );
                settxtransmit( 0 );                                
                break;
                
            case 12://8
                C1TR01CONbits.TXREQ0 = 0;
                ecan2WriteTxMsgBufId ( 0, (long) CANIGNPRMSbits.id, (unsigned int) CAN2SETTINGSbits.ide, (unsigned int) 0 );
                ecan2WriteTxMsgBufData( 0, 8, 0x0000, 0x4000, 0x0000, 0x0000 );
                settxtransmit2( 0 );                                
                break;
                
            case 13://9
                C2TR01CONbits.TXREQ0 = 0; 
                read_parameters (1);
                can1start();
                can2start();     
                init_CAN_filters ();                
                break;
                
            case 14: //10 Проверка АСС
                break;
                
            case 15: //11 Проверка FRAM
                break;

            case 16: //12 Проверка FLASH

                break;
            case 17://13

                break;                
            case 18://14

                break;
            case 19://15

                break;
            case 20://16
                break;
                
            case 34: //30 Проверка напряжения питания и напряжения внутренней батареи
//                temp_x = (float)car_voltage * 0.1168;
//                temp_y = (float)battery_voltage * 0.0258;
//                if ( temp_x > 10.0 && temp_x < 14.0 ) ;
                break;

            case 35: //31 Проверка напряжения питания и напряжения внутренней батареи
                
                Nop();Nop();Nop();
                break;                
                
            case 54://50
//                if ( GSMSTATUSbits.power == 0 ) ;// Не включился модем, нет Vdd ext
                break;
                
            case 79://75

                Nop();Nop();Nop();
                break;
                
            case 104://100

//                if ( IMEI_flag == 0 ) ;// Не получен IMEI
              
                break;
                
            case 105://101
                break;                
            case 106://102
            
                
                break;
            case 139://135

                break;
            case 169://165

                break;
                
            default: 
                break;
        }    

    
}
# endif

# if defined (MCP23S08)
unsigned char read_MCP23S08 (unsigned char addr ) {
unsigned char temp; 
    CS_23S08 = 0;
        SPI1BUF = 0x41;	while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = addr;	while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
        SPI1BUF = 0x00;	while (!SPI1STATbits.SPIRBF); temp = SPI1BUF;
    CS_23S08 = 1;

return temp;    
}
int wright_MCP23S08 (unsigned char addr, unsigned char data ) {
 
    CS_23S08 = 0;
        writeSPI1( 0x40 );
        writeSPI1( (int) addr );
        writeSPI1( (int) data );    
    CS_23S08 = 1;
Nop();Nop();Nop();    
}
int init_MCP23S08 (void) {
    
//    wright_MCP23S17 ( 0x0A, 0x20 ); // IOCON 
// установка выходов в соответствии с их полярностью
    Nop();Nop();Nop();
    switch_output_MCP23S08 ( 1, OUTPUTbits.out1_p9 );
    switch_output_MCP23S08 ( 2, OUT2 );
    switch_output_MCP23S08 ( 3, OUTPUTbits.out3_p15 );
    switch_output_MCP23S08 ( 4, OUTPUTbits.out4_p12 );
    switch_output_MCP23S08 ( 5, OUTPUTbits.out5_p13 );
    Nop();Nop();Nop();    
    wright_MCP23S08 ( 0x14, 0x00 ); // IOLATA
    wright_MCP23S08 ( 0x00, 0x0F ); // IODIRA
    Nop();Nop();Nop();    
}

unsigned char get_input_status_MCP23S08 ( unsigned char input ) {

    unsigned char result = 0;
    
    switch (input) {
        
        case 1:
            result = INPUTbits.in1_p1;
            if ( INPPOLbits.in1_p1 == 1 ) result = ! result;
        break;
        case 2:
            result = INPUTbits.in2_p8;
            if ( INPPOLbits.in2_p8 == 1 ) result = ! result;
        break;
        
        case 3:
            result = INPUTbits.in3_p13;
            if ( INPPOLbits.in3_p13 == 1 ) result = ! result;
        break;        

        case 4:
            result = INPUTbits.in4_p12;
            if ( INPPOLbits.in4_p12 == 1 ) result = ! result;
        break;        
        
        default:
        break;
        
        
    }

 return result & 0x01;
    
}
unsigned char get_number_of_input ( unsigned char function ) {

    if ( function == INFUNCbits.pin1 )  return 1;
    if ( function == INFUNCbits.pin8 )  return 2;
    if ( function == INFUNCbits.pin13 ) return 3;
    if ( function == INFUNCbits.pin12 ) return 4;

return 0;    
}
void switch_output_MCP23S08 ( unsigned char number, unsigned char state ) {


    switch (number)
    {
        case 1:
            if ( OUTPOLbits.out1_p9 == 0 ) OUTPUTbits.out1_p9 = state;
            else OUTPUTbits.out1_p9 = !state;
            wright_MCP23S08 ( 0x0A, OUTPUTbits.OUTPUT );
        break;
            
        case 2:
            if ( OUTPOLbits.out2_p10 == 0 ) OUT2 = state;
            else OUT2 = !state;            
        break;
        
        case 3:
            if ( OUTPOLbits.out3_p15 == 0 ) OUTPUTbits.out3_p15 = state;
            else OUTPUTbits.out3_p15 = !state;
            wright_MCP23S08 ( 0x0A, OUTPUTbits.OUTPUT );
        break;
        
        case 4:
            if ( OUTPOLbits.out4_p12 == 0 ) OUTPUTbits.out4_p12 = state;
            else OUTPUTbits.out4_p12 = !state;
            wright_MCP23S08 ( 0x0A, OUTPUTbits.OUTPUT );
        break;
        
        case 5:
            if ( OUTPOLbits.out5_p13 == 0 ) OUTPUTbits.out5_p13 = state;
            else OUTPUTbits.out5_p13 = !state;
            wright_MCP23S08 ( 0x0A, OUTPUTbits.OUTPUT );
        break;
                
        default:
            break;
            
    }
    
}
unsigned char get_number_of_output ( unsigned char function ) {
unsigned char number;

    number = 0;
    Nop();Nop();Nop();
    if ( function == OUTFUNCbits.pin9 )  number = 1;
    if ( function == OUTFUNCbits.pin10 ) number = 2;
    if ( function == OUTFUNCbits.pin15 ) number = 3;
    if ( function == OUTFUNCbits.pin12 ) number = 4;
    if ( function == OUTFUNCbits.pin13 ) number = 5;
    
return number;    
}
void output_pulses_tasck_MCP23S08 (void) {
    
static unsigned int puls = 0, pause = 0;
static unsigned char beep_num = 0;

    if ( OUTPLSTASCKbits.start != 1 ) return;
    
    if ( OUTPLSTASCKbits.running == 0 ) {
        OUTPLSTASCKbits.running = 1;
        puls = OUTPLSTASCKbits.pulse;
        pause = OUTPLSTASCKbits.pause;
        beep_num = OUTPLSTASCKbits.num;
    }

    if ( beep_num > 0 ) {
        if (puls > 0) {
            puls --;
            switch_output_MCP23S08 ( OUTPLSTASCKbits.output_number, 1 );
        } else {
            if ( pause > 0 ) { 
                pause --;
                switch_output_MCP23S08 ( OUTPLSTASCKbits.output_number, 0 );
            } else {
                        if ( beep_num > 0 ) {
                            beep_num --;                    
                            puls = OUTPLSTASCKbits.pulse;
                            pause = OUTPLSTASCKbits.pause;
                        } else {
                            OUTPLSTASCKbits.OUTPLSTASCK = 0;
                        }                    
                }
        }
    } 
    else {
        OUTPLSTASCKbits.OUTPLSTASCK = 0;
    } 
    
}
void apply_outputs_polarity ( unsigned char tmp ) {
    Nop();Nop();Nop();
static union __attribute__ ((far))  {
    unsigned char OUTPOLTMP;

    struct
    {
		unsigned char out1_p9:1;
        unsigned char out2_p10:1;
		unsigned char out3_p15:1;
        unsigned char out4_p12:1;
        unsigned char out5_p13:1;
        unsigned int  :3;

    };    
} OUTPOLTMPbits;

OUTPOLTMPbits.OUTPOLTMP = tmp;

if ( OUTPOLTMPbits.out1_p9 != OUTPOLbits.out1_p9 ) OUTPUTbits.out1_p9 = !OUTPUTbits.out1_p9;
if ( OUTPOLTMPbits.out2_p10 != OUTPOLbits.out2_p10 ) OUT2 = !OUT2;
if ( OUTPOLTMPbits.out3_p15 != OUTPOLbits.out3_p15 ) OUTPUTbits.out3_p15 = !OUTPUTbits.out3_p15;
if ( OUTPOLTMPbits.out4_p12 != OUTPOLbits.out4_p12 ) OUTPUTbits.out4_p12 = !OUTPUTbits.out4_p12;
if ( OUTPOLTMPbits.out5_p13 != OUTPOLbits.out5_p13 ) OUTPUTbits.out5_p13 = !OUTPUTbits.out5_p13;
//    OUTPUTbits.OUTPUT = read_MCP23S08 ( 0x0A );
    switch_output_MCP23S08 ( 1, OUTPUTbits.out1_p9 );
    switch_output_MCP23S08 ( 2, OUT2 );
    switch_output_MCP23S08 ( 3, OUTPUTbits.out3_p15 );
    switch_output_MCP23S08 ( 4, OUTPUTbits.out4_p12 );
    switch_output_MCP23S08 ( 5, OUTPUTbits.out5_p13 );
    Nop();Nop();Nop();
}
void reset_MCP23S08 (void) {
static unsigned char counter = 0;    
    if ( io_reset_flag == 0 ) { counter = 0; return; }

    if ( gps_reset_flag == 1 ) return;
    
    if ( counter == 0 ) {
        GSM_LED = 0;
        GNSSLED_green = 1;
        GPS_IO_RESET = 1;
        __delay_us (10);
        GPS_IO_RESET = 0;
    }

    if (counter == 1) {
        Nop();Nop();Nop();
        io_reset_flag = 0;
        counter = 0;
        init_MCP23S08 ();
        return;
    }

    counter ++;

}
void reset_GPS_modul (void) {
static unsigned char counter = 0;    
    if ( gps_reset_flag == 0 ) { counter = 0; return; }

    if ( io_reset_flag == 1 ) return;
    
    if ( counter == 0 ) {
        GNSSLED_green = 0;
        GSM_LED = 1;
        GPS_IO_RESET = 1;

        
    }

    if (counter == 2) {
        GPS_IO_RESET = 0;
        Nop();Nop();Nop();
        gps_reset_flag = 0;
        counter = 0;
        return;
    }

    counter ++;

}

# endif

void check_second_autorisation_button ( unsigned char sourse ) {
    static unsigned char timeout_counter = 0, can_button_tmp = 0, push_counter = 0;
    
    if (SECONDAUTHORbits.on == 0) {
        
        return;
    }
    
    if (sourse == 1) {
        Nop();Nop();Nop();
        if (can_button_tmp == 0 && can_button == 1) {
            timeout_counter = 100;
            push_counter ++;
        }
    }

    if (sourse == 0) {
        Nop();Nop();Nop();
        if (timeout_counter > 0) timeout_counter --;
    } 
    
    if (timeout_counter == 1) {
        Nop();Nop();Nop();
        if (push_counter == SECONDAUTHORbits.num) {
            Nop();Nop();Nop();
            if (SECONDAUTHORbits.type == 0) {
                Nop();Nop();Nop();
                button_pressed_flag = 1;
//                OUTbits.arm_flag = 0;
//                fire_rel_transaction_flag = 1;
            } else {
                Nop();Nop();Nop();
                
//                fire_rel_transaction_flag = 1;
            }
            
        }
        timeout_counter = 0;
        push_counter = 0;
    }
    
    can_button_tmp = can_button;  

}
void disarm_by_button_tasck (void) {
    
    
    if (OUTbits.arm_flag == 0) {
        if (button_pressed_flag == 1) {
            button_pressed_flag = 0;
            if ( disarmed_by_button_flag == 0 ) {
                if ( STARTENGINEbits.start  == 1 || STARTENGINESbits.start == 1 || STARTENGINEDLbits.start == 1 || 
                     STARTENGINEPbits.start == 1 || STARTENGINEObits.start == 1 || STARTENGINEO1bits.start == 1 || 
                     STARTENGINECbits.start_tasck == 1 ) 
                {
                    
                } else {               
                    start_beep_task ( 25, 1, 1 );
                }
                generate_content_of_message ( 92, 1 );
            }
            disarmed_by_button_flag = 1;
            RELTRANSFLGSbits.rel_disarm_by_button = 1;
            fire_rel_transaction_flag = 1;
# if defined (WIRED_ENJINE_BLOKING)
    # if defined (MCP23S08)

    # else
            if (wired_block == 0) {
                L_OUT = 0;
            }
    # endif    
# endif // Разблокировка проводной блокировки            
        }
    } else {
            button_pressed_flag = 0;
            disarmed_by_button_flag = 0;        
    }
    
}
void arm_second_authorisation (void) {
    static unsigned int counter;
    
    if ( ignition == 1 ) {
        counter = 0;
        return;
    }
    
    if ( counter < 600 ) counter ++;
    if ( counter == 599 ) {
        button_pressed_flag = 0;
        RELTRANSFLGSbits.rel_arm = 1;
        fire_rel_transaction_flag = 1;
        disarmed_by_button_flag = 0;
    }
    
}
void second_autorisation_warnings_tasck (void) {

    static unsigned char ignition_tmp = 0;
    static unsigned int timer = 0;
    
    if (SECONDAUTHORbits.on == 0) {
        timer = 0;
        return;
    }
    
    if ( STARTENGINEbits.start  == 1 || STARTENGINESbits.start == 1 || STARTENGINEDLbits.start == 1 || 
         STARTENGINEPbits.start == 1 || STARTENGINEObits.start == 1 || STARTENGINEO1bits.start == 1 || 
         STARTENGINECbits.start_tasck == 1 ) 
    {
        timer = 0;
        ignition_tmp = ignition;
        return;
    }
    
    if (ignition_tmp == 0 && ignition == 1) {
        if (timer == 0) timer = 450;
    }
    ignition_tmp = ignition;
    
    if (disarmed_by_button_flag == 1 || OUTbits.serv_flag == 1)  {
        timer = 0;
        return;
    }

    if (timer > 0) timer --;
    
    if (timer == 449) start_beep_task ( 5, 10, 2 );
    if (timer == 300) start_beep_task ( 5, 10, 2 );
    if (timer == 150) start_beep_task ( 5, 10, 2 );
    if (timer == 1) {
        generate_content_of_message ( 93, 1 );
        start_beep_task ( 5, 10, 2 );
    }
    
} 
/*
void can_button_simulation (void) {

static unsigned char button = 0, fisical_button_counter = 0, tmp, counter = 0;    
    
    
    tmp = read_inputs ( 1 );
    if ( tmp == 1 ) { //_RB11

        if (fisical_button_counter < 10) fisical_button_counter ++;
        else {
            fisical_button_counter = 5;
            button = 0x18;
        }

    }
    else {
        
        if (fisical_button_counter > 0) fisical_button_counter --;
        else {
            button = 0x00;
        } 
        
    }
    
    if (counter < 5) counter ++;
    else {
        counter = 0;
        ecan2WriteTxMsgBufId ( 3, (long) 0xAA, (unsigned int) 0, (unsigned int) 0 );//CAN2SETTINGSbits.ide
        ecan2WriteTxMsgBufData( 3, (unsigned int) 8, (unsigned int)button, 0, 0, 0 );
        settxtransmit2( 3 );        
    }
    
}
*/
/*
void redirect_can_to_uart ( unsigned long ID ) {
    
    unsigned char temp_buf[25], tmp;
    
    temp_buf[0] = (unsigned char)((ID >> 24) & 0x000000FF);
    temp_buf[1] = (unsigned char)((ID >> 16) & 0x000000FF);
    temp_buf[2] = (unsigned char)((ID >> 8) & 0x000000FF);
    temp_buf[3] = (unsigned char)( ID & 0x000000FF);
    
    tmp = CAN1_DATA_buf[0];
    temp_buf[4] = 0x20;
    temp_buf[5] = convert_byte_to_hex_str ( (unsigned char)((tpm >> 4)& 0x0F) );
    temp_buf[6] = convert_byte_to_hex_str ( (unsigned char)((tpm >> 4)& 0x0F) );
    
    tmp = CAN1_DATA_buf[1];
    temp_buf[7] = 0x20;
    temp_buf[8] = convert_byte_to_hex_str ( (unsigned char)((tpm >> 4)& 0x0F) );
    temp_buf[9] = convert_byte_to_hex_str ( (unsigned char)((tpm >> 4)& 0x0F) );    

    tmp = CAN1_DATA_buf[2];
    temp_buf[10] = 0x20;
    temp_buf[11] = convert_byte_to_hex_str ( (unsigned char)((tpm >> 4)& 0x0F) );
    temp_buf[12] = convert_byte_to_hex_str ( (unsigned char)((tpm >> 4)& 0x0F) );
    
    tmp = CAN1_DATA_buf[3];
    temp_buf[13] = 0x20;
    temp_buf[14] = convert_byte_to_hex_str ( (unsigned char)((tpm >> 4)& 0x0F) );
    temp_buf[15] = convert_byte_to_hex_str ( (unsigned char)((tpm >> 4)& 0x0F) );    

    tmp = CAN1_DATA_buf[4];
    temp_buf[16] = 0x20;
    temp_buf[17] = convert_byte_to_hex_str ( (unsigned char)((tpm >> 4)& 0x0F) );
    temp_buf[18] = convert_byte_to_hex_str ( (unsigned char)((tpm >> 4)& 0x0F) );

    tmp = CAN1_DATA_buf[5];
    temp_buf[19] = 0x20;
    temp_buf[20] = convert_byte_to_hex_str ( (unsigned char)((tpm >> 4)& 0x0F) );
    temp_buf[21] = convert_byte_to_hex_str ( (unsigned char)((tpm >> 4)& 0x0F) ); 

    tmp = CAN1_DATA_buf[7];
    temp_buf[22] = 0x20;
    temp_buf[23] = convert_byte_to_hex_str ( (unsigned char)((tpm >> 4)& 0x0F) );
    temp_buf[24] = convert_byte_to_hex_str ( (unsigned char)((tpm >> 4)& 0x0F) ); 

    load_UART4_Tx_buf (temp_buf);
    start_UART4_transmission (WAITOFF);    
   
}
unsigned char convert_byte_to_hex_str ( unsigned char nibble ) {

    unsigned char symbol;
    
    switch (nibble) {
        
        case 0:
            symbol = '0';
            break;
        case 1:
            symbol = '1';
            break;
        case 2:
            symbol = '2';
            break;
        case 3:
            symbol = '3';
            break;
        case 4:
            symbol = '4';
            break;
        case 5:
            symbol = '5';
            break;
        case 6:
            symbol = '6';
            break;
        case 7:
            symbol = '7';
            break;
        case 8:
            symbol = '8';
            break;
        case 9:
            symbol = '9';
            break;
        case 0xA:
            symbol = 'A';
            break;
        case 0xB:
            symbol = 'B';
            break;
        case 0xC:
            symbol = 'C';
            break;
        case 0xD:
            symbol = 'D';
            break;
        case 0xE:
            symbol = 'E';
            break;
        case 0xF:
            symbol = 'F';
            break;            
    }
    
}
*/
# if defined (DIRECTTX) 
void rf_direct_tx (void) {

    _LATD11 = !_LATD11;
    
}
# endif


int main(int argc, char** argv) {

    RCONbits.SWDTEN = 1;
/**/    
    ANSELBbits.ANSB6 = 0;
    _TRISB6 = 0;
    GNSSLED_green = 1; //  _LATB6
//    _TRISB7 = 0;
//    GSM_LED = 1; //  _LATB6    
//    while (1) {
//        asm("clrwdt");
//    }
    
//    ANSELBbits.ANSB7 = 0;
//    _TRISB7 = 0;
//    GSM_LED = 1; //  _LATB7
//    while (1) {
//    }
    
    pll_ON();
    switch_off_unused_periferals();
    init_analog();
    init_IO();
    init_ADC1();
    init_OC1();
    init_SPI();
    init_UART();
    configure_RP_RPI();
    init_timer1();
    init_timer2();
    init_timer3();
    init_timer4();
    init_timer5();    
    init_timer6();
    init_timer7();
    init_timer8();
    init_CNI();
    init_INT1();
//    initCRC();
//    init_can1 ();
    init_sms_ptrs_buf();
    init_GPRS_nums_to_send_buf();
    init_save_to_flash_ptrs_buf ();
/*    
unsigned char test_crc_buf[7] = { 0x00, 0x55, 0x03, 0x01, 0x0B, 0xFF, 0x10 };
Nop();Nop();Nop();
    LIN_CRC_calc( &test_crc_buf[3], 4, 1 );
*/    
//    init_MCP23S17 ();
/*    
m11 = 1; m12 = 0; m13 = 0;
m21 = 0; m22 = 1; m23 = 0;
m31 = 0; m32 = 0; m33 = 1;
sing = 0; cosg = 1;
Gx0 = -255; Gy0 = 0; Gz0 = 255;
        Nop();Nop();Nop();
save_autocal_results ();

Nop();Nop();Nop();
read_autocal_results ();

FM25_write_1 ( 1384, 1 ); // признак полной калибровки  
*/
/*    
// Перевод GPS модуля в спящий режим
const unsigned char set_standby_sentence[] = "$PMTK161,0*2D\r\n";    
unsigned char zz, check_summ, check_summ1, check_summ2, periodic_messege_flag;
    check_summ = 0; check_summ1 = 0; check_summ2 = 0;
    for (zz = 1; zz <= 9; zz ++) {
        check_summ = check_summ ^ set_standby_sentence[zz];
    }
    Nop();Nop();Nop();
    check_summ1 = (check_summ & 0xF0) >> 4;
    check_summ2 = check_summ & 0x0F;
    memmove ( UART2_Tx_buf, set_standby_sentence, 16 );
    if (check_summ1 >= 0 && check_summ1 <= 9) {UART2_Tx_buf[11] = check_summ1 + 0x30;}
    else {UART2_Tx_buf[11] = check_summ1 + 0x37;}
    if (check_summ2 >= 0 && check_summ2 <= 9) {UART2_Tx_buf[12] = check_summ2 + 0x30;}
    else {UART2_Tx_buf[12] = check_summ2 + 0x37;}
    Nop();Nop();Nop();
    start_UART2_transmission (1);
    __delay_ms (250);
CHARGE_ONOFF = 0;
CAN1_STB = 1;
CAN2_STB = 1;
SDN_SI4461 = 1;
    Nop();Nop();Nop();
    pll_switch_to_10MHz ();
    Nop();Nop();Nop();
    
asm("PWRSAV #0x1");
    PMD1bits.AD1MD  = 1;
    PMD1bits.C1MD   = 1;
    PMD1bits.C2MD   = 1;
    PMD1bits.SPI1MD = 1;
    PMD1bits.SPI2MD = 1;
    PMD1bits.T1MD   = 1;
    PMD1bits.T3MD   = 1;
    PMD1bits.T4MD   = 1;
    PMD1bits.U1MD   = 1;
    PMD1bits.U2MD   = 1;
    PMD2bits.OC1MD  = 1;
    PMD3bits.U3MD   = 1;
    PMD3bits.CMPMD  = 1;
    PMD3bits.T6MD   = 1;
    PMD3bits.T7MD   = 1;
    PMD4bits.U4MD   = 1;
    PMD6bits.SPI3MD = 1;
    PMD7bits.DMA0MD  = 1;
    PMD7bits.DMA4MD  = 1;
    PMD7bits.DMA1MD  = 1;
    PMD7bits.DMA5MD  = 1;
    PMD7bits.DMA2MD  = 1;
    PMD7bits.DMA3MD  = 1;
    
asm("PWRSAV #0x0");    
Nop();Nop();Nop();
*/

# if defined (SST26)
    hw_version = hw_version | 0b00000001;
# endif
# if defined (SST25)
    hw_version = hw_version | 0b00000000;
# endif
# if defined (L76_L)
    hw_version = hw_version | 0b00000010;
# endif
# if defined (MCP23S08)
    hw_version = hw_version | 0b00000100;
# endif    
    
SMS_ptr_R = 0;           SMS_ptr_W = 0; 
SMS_read_ptr_R = 0;      SMS_read_ptr_W = 0;
GPRS_send_ptr_R = 0;     GPRS_send_ptr_W = 0;
save_to_flash_ptr_R = 0; save_to_flash_ptr_W = 0;
ACK_ptr_R = 0;           ACK_ptr_W = 0;
SMSENbits.SMSEN = 0;

//    UART3_Tx_buf[0] = 0x00; UART3_Tx_buf[1] = 0x55; UART3_Tx_buf[2] = 0x03; UART3_Tx_buf[3] = 0x55;
//    UART3_Tx_buf[4] = 0x55; UART3_Tx_buf[5] = 0x55; UART3_Tx_buf[6] = 0x55; UART3_Tx_buf[7] = 0x3B;
//    start_UART3_LIN_transmission ( 8 );
//__delay_ms (10);

//IEC0bits.T3IE = 0;
//OUTFUNCbits.pin10 = 9;
//OUT2 = 1;
//LIN_switch_counter = 10;
//IEC0bits.T3IE = 1;
//__delay_ms (10);

Nop();Nop();Nop();

    GSMSTATUSbits.power = ! MODEMSTATUS;
    GSM_LED = GSMSTATUSbits.power;
    moden_off_puls_counter = 0;

    __delay_ms (100);
    init_ACC ();
//    fill_buffers ();
    
unsigned long addr = 0;// unsigned char speed, temp;
int temp1 = 0;

    addr = 0; max_of_gist = 0;
/*    
# if defined (SST26)    
    SST26_read_device_id ();
    SST26_Global_Block_Protection_Unlock (); // разрешение записи во все сектора 
//    temp1 = FM25_read_status ();
    SST25_sector_erase ( 0, 1 );
    for (temp1 = 0; temp1 < 256; temp1 ++) {
        SST26_buf[temp1] = (unsigned char) SST25_read_var_from_page ( 0, temp1, 1 );
    }    
Nop();Nop();Nop();    
    for (temp1 = 0; temp1 < 256; temp1 ++) {
        SST26_buf[temp1] = temp1;
    }
    SST26_write_page_to_flash ( 0, &SST26_buf );
    for (temp1 = 0; temp1 < 256; temp1 ++) {
        SST26_buf[temp1] = 0;
    }
    __delay_ms (5);
Nop();Nop();Nop();
    for (temp1 = 0; temp1 < 256; temp1 ++) {
        SST26_buf[temp1] = (unsigned char) SST25_read_var_from_page ( 0, temp1, 1 );
    }
    SST25_read_page_to_buf ( 0, command_temp_buf, 128 );
//    temp1 = (unsigned char) SST25_read_var_from_page ( 0, 1, 1 );
Nop();Nop();Nop();
# endif
*/

//CVRCONbits.CVR
unsigned long flash_temp;//, flash_temp1; 
int z; char reset_reason;
/*
reset_reason = FM25_read_1 (511);
if (reset_reason != 0) {
    if (reset_reason == 1) write_text_to_SMS_buf ( "FLASHBUSYbits.page_saving == 1", PHONE_NUMBER );
    if (reset_reason == 2) write_text_to_SMS_buf ( "FLASHBUSYbits.sector_erasing == 1", PHONE_NUMBER );
    if (reset_reason == 3) write_text_to_SMS_buf ( "FLASHBUSYbits.acc_saving== 1", PHONE_NUMBER );
    FM25_write_1 ( 511, 0);
}
*/
//Загрузка последнего известного положения из FRAM
    for (z = 0; z < 76; z++) { Navi_str_last_known[z] = FM25_read_1 (z + 434); }
//    memmove ( Navi_str_last_known, Navi_str_last_known_const, 76 );
    memmove ( Navi_str, Navi_str_last_known, 76 );
   
# if defined (SST25)
    SST25_write_status_reg ( FWEN ); // разрешение записи во все сектора
# endif    
# if defined (SST26)
    temp1 = SST26_read_configuration_register ();
    Nop();Nop();Nop();
//    SST26_reset ();
    SST26_Global_Block_Protection_Unlock (); // разрешение записи во все сектора 
    temp1 = SST26_read_configuration_register ();
    Nop();Nop();Nop();
# endif

# if defined (LIN)
     U3_Rx_timeout = 10;
# endif     
# if defined (WBUS) 
    U3_Rx_timeout = 14;    
# endif   
#if defined (MAZDA_LOCK) 
    U3_Rx_timeout = 2;    
#endif

    
// ПРОВЕРКА ПЕРЕЗАГРУЗКИ ПОСЛЕ ПЕРЕПРОШИВКИ ПО ВОЗДУХУ
//    unsigned char temp_1, temp_2, temp_3, temp_4, temp_5, temp_6;
    reset_reason = FM25_read_1 (2030);
    Nop();Nop();Nop();
    if (reset_reason == 1) {
        Nop();Nop();Nop();
        MEMRESFLAGSbits.MEMRESFLAGS = FM25_read_2 (2023);
        FM25_write_1 (2030, 0);
        SST25_sector_erase ( 1023, 1 );// стирание флэши
        FM25_write_1 (0, 0);// сброс всех настроек во fram
        fwversion_message_flag = 1;
# if defined (SELFPROGR)
        fw_refresh_counter = (unsigned int) FM25_read_2 ( 1931 );
        fw_refresh_counter ++;
        FM25_write_2 ( 1931, (unsigned int)fw_refresh_counter );
        fw_refresh_flag = 1;
# endif        
    }
    MEMRESFLAGSbits.MEMRESFLAGS = 0; // для обязательного стирания всех настроек и памяти после перепрошивки по воздуху
//        FW_version = (unsigned long)FM25_read_4 (2026);
        Nop();Nop();Nop();
        
# if defined ( PRODUCTION_MODE )
volatile unsigned char production_tmp;
//FM25_write_1 ( 1931, 1 );
Nop();Nop();Nop();
    production_tmp = (unsigned char)FM25_read_1 ( 1931 );
//    production_tmp = 1;
    Nop();Nop();Nop();
    if ( production_tmp == 1 ) {
        while (power == 0) {
            asm("clrwdt");
        }
        FM25_write_1(0x00, 0x00); // флаг начальной инициализации
        SST25_sector_erase ( 1023, 1 );        
    }
# endif
    
    unsigned char dflt_temp = 0;
    dflt_temp = (unsigned char) FM25_read_1 ( 1932 );
    if (dflt_temp == 1) {
        FM25_write_1( 1932, 0 );
        FM25_write_1(0x00, 0x0);
        SST25_sector_erase ( 1023, 0 ); 
        dflt_flag = 1;
    }
    
//    configure_GSM_modul ();
/*//    while (1) {
//        asm("clrwdt");
    }
*/        
    
//    FM25_write_1(0x00, 0x0); // флаг начальной инициализации
//    SST25_sector_erase ( 1023, 0 );  
/*
    while (1) {
        
        GNSSLED_green = 1;
        GSM_LED = 1; 
        asm("clrwdt");
    } 
*/ 
    flash_temp = (unsigned long) SST25_read_var_from_page ( 32767, 127, 1 ); // признак инициализации в последнем байте
//flash_temp = 0;
//SST25_sector_erase ( 800, 1 );

    Nop();Nop();Nop();
//    SST25_write_var_to_page   ( 32, 0, 0x55, 1 );
    if (flash_temp != 1) {

        Nop();Nop();Nop();
unsigned int i;
    if (MEMRESFLAGSbits.flash1 == 0) { // Стирание всех сообщений очереди 1, если нет команды защитить
        for ( i = 0; i < 625; i ++ ) {
            asm("clrwdt");
            SST25_sector_erase ( i, 1 );
        }
    }
        for ( i = 640; i < 790; i ++ ) { // Стирание всех сообщений очереди 2, если нет команды защитить
            asm("clrwdt");
            SST25_sector_erase ( i, 1 );
        }

        SST25_sector_erase ( 1023, 1 );
        SST25_sector_erase ( 1022, 1 );
        
//        memmove ( &SST26_buf[0] , "0250,0130;", 10 ); //ign_frq_trh_min, ign_frq_trh
//        memmove ( &SST26_buf[10], "05,15;",        6 ); //ign_on_time, ign_off_time
//        memmove ( &SST26_buf[16], "970,930;",      8 ); //ign_volt_trh_min, ign_volt_trh 960
//# if defined (SST25)        
//        SST25_write_page_to_flash ( 32704, SST26_buf );
//# endif        
//# if defined (SST26)        
//        SST26_write_page_to_flash ( 32704, &SST26_buf );
//        __delay_ms (5);
//# endif 
        type0_send_flag = 1;
        SST25_write_var_to_page  ( 32767, 127, 1, 1 );                          //
        __delay_ms (5);
        flash_ptr_R = 0x0000; flash_ptr_W = 0x0000;        
    } 

/* Поиск и последнего сообщения в памяти и считывание параметров */ 
    read_saved_parameters ();
// Чтение пробега по кану из FRAM    
    CANODObits.B0 = (unsigned int)FM25_read_1 (433);
    CANODObits.B1 = (unsigned int)FM25_read_1 (432);
    CANODObits.B2 = (unsigned int)FM25_read_1 (431);
    

    load_UART4_Tx_buf (STARTING_WORK);
    start_UART4_transmission (WAITON);
    Nop();Nop();Nop();    

unsigned char si_temp;    
    si_temp = (unsigned char) FM25_read_1 ( 0 );
//si_temp = 0;    
Nop(); Nop(); Nop(); 

// ЗАПИСЬ ДЕФОЛТНЫХ ПАРАМЕТРОВ КОНФИГУРАЦИИ В FRAM
    if (si_temp != 1) {
        Nop(); Nop(); Nop(); 
        if (MEMRESFLAGSbits.modem_init == 0) {
            si_temp = configure_GSM_modul (); 
    // если модем не инициализировался правильно (не выдал имей), через 3 секунды ресет
            if (si_temp == 0) {
                __delay_ms (250);__delay_ms (250);__delay_ms (250);__delay_ms (250);
                __delay_ms (250);__delay_ms (250);__delay_ms (250);__delay_ms (250);
                __delay_ms (250);__delay_ms (250);__delay_ms (250);__delay_ms (250);
                asm volatile ( "reset" ); 
            } 
        }
/* начальное заполнение генератора случайных чисел */
        FM25_write_4( 38, 0x80000047 );
/* текущее заполнение генератора случайных чисел*/
        FM25_write_4( 42, 0x80000047 );

/* IMEI_str c 46 по 60 */
        int p;
        for (p = 0; p < 15; p++) {// 
            FM25_write_1( p + 46, IMEI_str[p] );
        }
/* Указатели записи/четения(отсылки), номера крашей*/
        FM25_write_2( 61, (unsigned int) 0 );// 
        FM25_write_2( 63, (unsigned int) 0 );// 
        FM25_write_2( 65, (unsigned int) 0 );//
/*Обнуление указателей чтения и записи сообщений из поездки во флэш, если эта область флэшь стерта*/
    if (MEMRESFLAGSbits.flash1 == 0) { 
        flash_ptr_R = 0x0000; flash_ptr_W = 0x0000;
        FM25_write_2( 67, (unsigned int) 0 );//67,68
        FM25_write_2( 69, (unsigned int) 0 );//69,70
    } 
       
/*GPS пробег*/
//        FM25_write_4( 71, (unsigned int) 0 );// 71, 72, 73, 74
/*Обнуление указателей чтения и записи сообщений из очереди 2, если эта область флэшь стерта*/        
        flash2_ptr_R = 0x0000; flash2_ptr_W = 0x0000;
        FM25_write_2( 75, (unsigned int) 0 );//75,76
        FM25_write_2( 77, (unsigned int) 0 );//77,78         
/*Хэндс фри*/
        FM25_write_1( 1000, (unsigned int) 0 );
/*WRL*/
        FM25_write_1( 1001, (unsigned int) 0 );
/*ARMEN*/
        FM25_write_1( 1002, (unsigned int) 0 );
/*lock close during autorun*/        
        FM25_write_1( 1003, (unsigned int) 0 );
/*настройки состава сообщений*/        
        FM25_write_8( 1004, (unsigned long long) 0x21000000272277FF );//. 1  timed
        FM25_write_8( 1012, (unsigned long long) 0x21000000272277FF );//. 2  distance!!!!!!!!!!!!!
        FM25_write_8( 1020, (unsigned long long) 0x21000000272277FF );//. 3  heading !!!!!!!!!!!!!!!!
        FM25_write_8( 1028, (unsigned long long) 0x2100000027A277FF );//. 4  ignition on
        FM25_write_8( 1036, (unsigned long long) 0x2100000027A277FF );//. 5  ignition off
        FM25_write_8( 1044, (unsigned long long) 0x0200000006A277FF );// 6  power on
        FM25_write_8( 1052, (unsigned long long) 0x0200000006A277FF );// 7  power off
        FM25_write_8( 1060, (unsigned long long) 0x21000000062277FF );//. 8  idle start
        FM25_write_8( 1068, (unsigned long long) 0x21000000062277FF );//. 9  idle end
        FM25_write_8( 1076, (unsigned long long) 0x21000000062001FF );//. 26 dinamic cal
        FM25_write_8( 1084, (unsigned long long) 0x22000000062051FF );//. 27 arm
        FM25_write_8( 1092, (unsigned long long) 0x22000000062051FF );//. 28 disarm
        FM25_write_8( 1100, (unsigned long long) 0x12000000062081FF );//. 29 intrusion
        FM25_write_8( 1108, (unsigned long long) 0x32000000062001FF );//. 30 serv on
        FM25_write_8( 1116, (unsigned long long) 0x32000000062001FF );//. 31 serv off
        FM25_write_8( 1124, (unsigned long long) 0x32000000062001FF );//. 32 serv auto off
        FM25_write_8( 1132, (unsigned long long) 0x02000000062011FF );//. 33 start unsuccess
        FM25_write_8( 1140, (unsigned long long) 0x02000000062011FF );//. 34 start success
        FM25_write_8( 1148, (unsigned long long) 0x22000000062051FF );//. 35 lock open
        FM25_write_8( 1156, (unsigned long long) 0x22000000062051FF );//. 36 lock close
        FM25_write_8( 1164, (unsigned long long) 0x02000000062011FF );//. 37 autorun command
                                                                      // 38 VIN
        FM25_write_8( 1172, (unsigned long long) 0x12000000062001FF );//. 39 robbery
        FM25_write_8( 1180, (unsigned long long) 0x02000000062001FF );//. 40 tilt
        FM25_write_8( 1188, (unsigned long long) 0x20000000002001FF); // 41 fwrnw
        FM25_write_8( 1196, (unsigned long long) 0x20000000002001FF );// 42 fw dounloaded
        FM25_write_8( 1204, (unsigned long long) 0x20000000062001FF );// 43 lock command
        FM25_write_8( 1212, (unsigned long long) 0x20000000062001FF );// 44 unlock command
        FM25_write_8( 1220, (unsigned long long) 0x22000000002001FF );// 45 transp nums
        FM25_write_8( 1228, (unsigned long long) 0x12000000062001FF );//. 46 panic
        FM25_write_8( 1236, (unsigned long long) 0x21000000002001FF );//. 47 static cal
        FM25_write_8( 1244, (unsigned long long) 0x2100000007A277FF );// 49 status message 
        FM25_write_8( 1260, (unsigned long long) 0x0100000000200000 );// 10-25 ACC messages        
        FM25_write_8( 1268, (unsigned long long) 0x0100000000200000 );// VIN messages
        FM25_write_8( 1276, (unsigned long long) 0x0100000000200000 );//. DTCs messages
        FM25_write_8( 1284, (unsigned long long) 0x0100000000200000 );// 10 - 25 тип2 acc charts messages
        
        FM25_write_1 ( 1384, 0 ); // сброс признака полной калибровки 
        FM25_write_1 ( 1516, 0 ); // признак направления оси Z
        FM25_write_4( 1292, (unsigned long) 0x0B304CC3 );//0x0B304CC3 - наши  0x10004003 - ингос 50 тип1 CRASHSETbits       
        FM25_write_2( 1296, (unsigned int)  0x0CC8 );// 40 тип1 TILTSETbits
        
        FM25_write_8( 1298, (unsigned long long) 0x02000000076051FF );//. 50 тип1 CRASH event
        FM25_write_8( 1306, (unsigned long long) 0x02000000062011FF );//. 51 тип1 webasto on 
        FM25_write_8( 1314, (unsigned long long) 0x02000000062011FF );//. 52 тип1 webasto off 

        FM25_write_4( 1322, (unsigned long) 0x00034BC0 );// 53 тип1 REPORTSETbits отчетное сообщение каждые 6 часов        
        FM25_write_8( 1326, (unsigned long long) 0x2200000006A257FF );//. 53 тип1 REPORTDATbits
        FM25_write_8( 1475, (unsigned long long) 0x2100000007A277FF );// 54 тип1 TESTMSGSETbits
        FM25_write_8( 1483, (unsigned long long) 0x0200000007A277FF );// 55 тип1 ALARMDATbits
        FM25_write_8( 1491, (unsigned long long) 0x2100000006A277FF );//. 56 тип1 PWOFFMSGDATbits
        FM25_write_4( 1499, (unsigned long) 0x2008CA0 );// 56 тип1 PWOFFMSSETGbits каждый час 
        FM25_write_8( 1503, (unsigned long long) 0x0200000006A277FF );// 57, 58 тип1 MILMSGDATbits  
        FM25_write_4( 1511, (unsigned long) 0x1404B0 );// 39 тип1 ROBBERYSETbits
//        FM25_write_8( 1515, (unsigned long long) 0x02000000002001FF );// 59 АКПП yt d gfhrbyut
        FM25_write_4( 1517, (unsigned long) 0x04B06764 );// 60 тип1 BATLOWSETbits
        FM25_write_8( 1521, (unsigned long long) 0x0200000006A277FF );// 60 BATLOWDATbits
        FM25_write_2( 1529, (unsigned int)  50 ); // dd_intrusion_off_setting
//        FM25_write_4( 1530, (unsigned long) 0x08D02003 );// 50 тип1 CRASHSETIGNOFFbits
        FM25_write_8( 1534, 0 ); //CANREQ1SETbits
        FM25_write_8( 1542, 0 ); //CANREQ2SETbits
        FM25_write_8( 1550, 0 ); //CANREQ3SETbits
        FM25_write_8( 1558, 0 ); //CANREQ1DATbits
        FM25_write_8( 1566, 0 ); //CANREQ2DATbits
        FM25_write_8( 1574, 0 ); //CANREQ3DATbits
        FM25_write_4( 1582, (unsigned long) 0x0B304CC3 );//0x0B304CC3 - наши  0x8004003 - ингос 50 тип1 CRASHSETIGNOFFbits 
        
        FM25_write_1( 1586, (unsigned int) 0 ); //SERVFLAGSbits
        FM25_write_1( 1587, (unsigned int) 0 ); //fisical_input_enable
        FM25_write_4( 1588, (unsigned long) 0x4B05E01 ); //IGNPULSVFAULTSETbits
        FM25_write_2( 1592, (unsigned int) 0x03A2 ); // ign_volt_trh
        
        FM25_write_8( 1594, (unsigned long long) 0x22000000062051FF );//. 61 boot open
        FM25_write_8( 1602, (unsigned long long) 0x22000000062051FF );//. 62 boot close
        
        FM25_write_8( 1610, (unsigned long long) 0x0333032D06261420 );// ACELbits
        FM25_write_8( 1618, (unsigned long long) 0x03B305C014CD1EE0 );// DCELbits
        FM25_write_8( 1626, (unsigned long long) 0x054D0A4014331E26 );// LALLbit
        FM25_write_8( 1634, (unsigned long long) 0x0200000007A277FF );// 72 TRANSPPRESDATbits
        FM25_write_8( 1642, (unsigned long long) 0x21000000062011FF ); // 80
        FM25_write_8( 1650, (unsigned long long) 0 ); //DOPENSET1bits.DOPENSET1
        FM25_write_8( 1658, (unsigned long long) 0 ); //DOPENDAT1bits.DOPENDAT1
        FM25_write_4( 1666, (unsigned long) 0 ); //DOPENTIME1bits.DOPENTIME1 
        FM25_write_2( 1670, (unsigned int) 0 ); //fuel_consumption_quantum  
        FM25_write_8( 1672, (unsigned long long) 0 ); //CANBRPPRMSbits.CANBRPPRMS
        FM25_write_8( 1680, (unsigned long long) 0 ); //RPMPRMSbits.RPMPRMS
        FM25_write_4( 1688, (unsigned long) 0 ); //STARTENGINEOSETbits
        FM25_write_1( 1692, 0 ); //wbst_startenginecan_switch
        
        FM25_write_2( 1700, (unsigned int) 0 ); // PERIFSLEEPSETbits
        FM25_write_1( 1702, (unsigned char) 0 ); // crash_detection_type
        FM25_write_8( 1703, (unsigned long long) 0x21000000272257FF );// 63 speed changed   !!!!!!!!!!!     272277FF
        FM25_write_2( 1711, (unsigned int) 0x640A  );// 63 speed changed
        FM25_write_4( 1713, (unsigned long) 0x00000101 );
        
        FM25_write_8 ( 1717, (unsigned long long) 0 ); //
        FM25_write_1 ( 1725, (unsigned int) 0 ); //
        FM25_write_1 ( 1726, (unsigned int) 0 ); //
        FM25_write_1 ( 1727, (unsigned int) 0); //        
        FM25_write_8 ( 1728, (unsigned long long) 0 ); //
        FM25_write_1 ( 1736, (unsigned int) 0 ); //
        FM25_write_1 ( 1737, (unsigned int) 0 ); //
        FM25_write_1 ( 1738, (unsigned int) 0); //
        FM25_write_8 ( 1739, (unsigned long long) 0 ); //OUTFUNCbits        

//unsigned char apn_tmp[] = "internet";
//unsigned char log_tmp[] = "gdata";
//unsigned char pass_tmp[] = "gdata";
unsigned char apn_tmp[] = "m2m.msk";
unsigned char log_tmp[] = "mts";
unsigned char pass_tmp[] = "mts";
unsigned char server_tmp[] = "receiver.smartdriving.io";
unsigned char port_tmp[] = "8051";
unsigned int i;
        for ( i = 1756; i < 1837; i ++ ) {
            FM25_write_1 ( i, (unsigned int) 0);
        }
        for (i = 0; i < 8; i ++) {
            FM25_write_1 ( (i + 1756), (unsigned int) apn_tmp[i] );
        }
        for (i = 0; i < 5; i ++) {
            FM25_write_1 ( (i + 1781), (unsigned int) log_tmp[i] );
        }
        for (i = 0; i < 5; i ++) {
            FM25_write_1 ( (i + 1791), (unsigned int) pass_tmp[i] );
        }
        for (i = 0; i < 24; i ++) {
            FM25_write_1 ( (i + 1801), (unsigned int) server_tmp[i] );
        }
        for (i = 0; i < 4; i ++) {
            FM25_write_1 ( (i + 1831), (unsigned int) port_tmp[i] );
        }
        FM25_write_1 ( 1836, 1); // UDP/TCP
        
        FM25_write_4( 1837, 0 ); // LINLOCKPSTATPRMSbits
        FM25_write_1 ( 1841, 1 ); // mil_req_len
        FM25_write_8 ( 1842, (unsigned long long) 0x02000000002001FF );// 59 АКПП yt d gfhrbyut
        FM25_write_8 ( 1850, (unsigned long long) 0 );
        FM25_write_1 ( 1858, (unsigned int) 0 );
        FM25_write_1 ( 1859, (unsigned int) 0 );
        FM25_write_1 ( 1860, (unsigned int) 0 );

        FM25_write_8 ( 1861, (unsigned long long) 0 );
        FM25_write_1 ( 1869, (unsigned int) 0 );
        FM25_write_1 ( 1870, (unsigned int) 0 );
        FM25_write_1 ( 1871, (unsigned int) 0 );
        FM25_write_8 ( 1872, (unsigned long long) 0 );
        FM25_write_1 ( 1880, (unsigned int) 0 );
        FM25_write_1 ( 1881, (unsigned int) 0 );
        FM25_write_1 ( 1882, (unsigned int) 0 );
        FM25_write_1 ( 1883, (unsigned int) 0 ); 
        FM25_write_2 ( 1884, (unsigned int) 0 );
        FM25_write_1 ( 1886, (unsigned int) 1 );
        FM25_write_8 ( 1894, (unsigned long long) 0x02000000062001FF ); // 64, 65 повторитель поворотов запущен/остановлен
        FM25_write_1 ( 1902, (unsigned int) 0 ); //unlock_message_off_timer
//        FM25_write_1 ( 1903, (unsigned int) 1 );//rf_reset_enable
        FM25_write_2( 1903, (unsigned int) 0x0550  );// 66  
        FM25_write_2( 1905, (unsigned int) 0x0578  );// 68 
        FM25_write_2( 1907, (unsigned int) 0x0582  );// 70  
        FM25_write_8( 1909, (unsigned long long) 0x00000000082001FF );// 66 - 71
        FM25_write_1( 1917, (unsigned int) 0 ); //fuel_sensor_enable
        FM25_write_8( 1918, (unsigned long long) 0x0000000000010001 );// a = 1; b = 1; c = 0;
        FM25_write_4( 1926, (unsigned long) 0 );
        FM25_write_1( 1930, (unsigned char) 111 ); // start_engine_volt_trh 
#if defined (SELFPROGR)

#else

# endif
        FM25_write_1( 1933, (unsigned int) 0 );//INPPOLbits
        FM25_write_8( 1934, (unsigned long long) 0x21000000100001FF );// 66 - 71
        FM25_write_2( 1942, (unsigned int) 0 );
        FM25_write_1( 1944, (unsigned int) 0x05 );//tilt_off_timer_setting
        FM25_write_1( 1945, (unsigned int) 0x0F );//temperatura_correct_timer_setting
        FM25_write_1( 1946, 20 ); //t_lights_off_timeout
        FM25_write_8( 1947, (unsigned long long) 0x21000000272277FF );//. 82  timed webasto
        FM25_write_1 ( 1955, (unsigned int) 1 );//rf_reset_enable
        FM25_write_8 ( 1956, 0 );
        FM25_write_4( 1964, (unsigned long)0x000F47FC );//DIAGNSIGNALSbits
        FM25_write_1( 1969, 0xFF ); //OBDREQENbits.OBDREQEN
        FM25_write_1( 1970, 0x22 ); //crash_filt_cutoff_frq (low nibble),  acc_sampling_frequency (high nibble)
        FM25_write_1( 1971, 0 );//srvr_flag
        FM25_write_1( 1972, 30 ); // sleep_timer 
        FM25_write_1( 1973, 0x12 ); //RBLKDATbits 88, 89
        FM25_write_1( 1974, (unsigned int) 1 );//disarm_by_doors_unlock_enable
        FM25_write_1( 1975, (unsigned int) 60 );//timed_period
        FM25_write_1( 1976, 0x12 ); //HF2DATbits 88, 89
        FM25_write_1( 1977, (unsigned int) 0 ); //SECONDAUTHORbits.SECONDAUTHOR
        FM25_write_1( 1978, (unsigned int) 0x02 ); //SECONDAUTHORbits.SECONDAUTHOR
        FM25_write_1( 1979, (unsigned int) 0x12 ); //SECONDAUTHORDATFAILbits.SECONDAUTHORDATFAIL
        FM25_write_1( 1980, (unsigned int) 0x02);//DTCWBUSDATbits.DTCWBUSDAT
        FM25_write_1( 1981, (unsigned int) 0 );//fake_doors_open_type
        
        FM25_write_8( 879, 0x21000000062001FF  ); // 74
        FM25_write_8( 887, 0x21000000062001FF  ); // 76
        
/*Дефолтные настройки CAN, если нет команды их сохранить*/ 
        if (MEMRESFLAGSbits.can_set == 0) {
            FM25_write_2( 512, (unsigned int) 0x7D0 );// CAN1 - on = 0, ide = 0, bitrate = 500
            FM25_write_2( 514, (unsigned int) 0x1F4 );// 514, 515 CAN2 - on = 0, ide = 0, bitrate = 125
            FM25_write_4( 668, (unsigned long ) 0x094D0CBF );// bit timing can1
            FM25_write_4( 672, (unsigned long ) 0x094D0CBF );// bit timing can2
        }
        if (MEMRESFLAGSbits.can_dat == 0) {
            
            FM25_write_8( 422, (unsigned long long) 0 );
            FM25_write_8( 414, (unsigned long long) 0 );
            FM25_write_8( 406, (unsigned long long) 0 );
            FM25_write_8( 398, (unsigned long long) 0 );
            FM25_write_8( 390, (unsigned long long) 0 );       
            FM25_write_8( 382, (unsigned long long) 0 );
            FM25_write_8( 374, (unsigned long long) 0 );
            FM25_write_8( 366, (unsigned long long) 0 );        
            FM25_write_8( 358, (unsigned long long) 0 );
            FM25_write_8( 350, (unsigned long long) 0 );
            FM25_write_8( 342, (unsigned long long) 0 );
            FM25_write_8( 334, (unsigned long long) 0 );
            FM25_write_8( 326, (unsigned long long) 0 );
            FM25_write_8( 318, (unsigned long long) 0 );            
            FM25_write_8( 310, (unsigned long long) 0 );
            FM25_write_8( 302, (unsigned long long) 0 );
            FM25_write_8( 294, (unsigned long long) 0 );
            FM25_write_8( 286, (unsigned long long) 0 ); //WBSTSTARTSET2bits.WBSTSTARTSET2
            FM25_write_8( 278, (unsigned long long) 0 ); //(unsigned long long) WBSTSTARTDAT2bits.WBSTSTARTDAT2 
            FM25_write_8( 270, (unsigned long long) 0 );       
            FM25_write_8( 262, (unsigned long long) 0 );
            FM25_write_8( 254, (unsigned long long) 0 );
            FM25_write_8( 246, (unsigned long long) 0 );        
            FM25_write_8( 238, (unsigned long long) 0 );
            FM25_write_8( 230, (unsigned long long) 0 );
            FM25_write_8( 222, (unsigned long long) 0 );
            FM25_write_8( 214, (unsigned long long) 0 );
            FM25_write_8( 206, (unsigned long long) 0 );
            FM25_write_8( 198, (unsigned long long) 0 );        
            FM25_write_8( 190, (unsigned long long) 0 );
            FM25_write_8( 182, (unsigned long long) 0 );
            FM25_write_8( 174, (unsigned long long) 0 );        
            FM25_write_8( 166, (unsigned long long) 0 );

            FM25_write_8( 158, (unsigned long long) 0 );
            FM25_write_8( 150, (unsigned long long) 0 );        
            FM25_write_8( 142, (unsigned long long) 0 );
            FM25_write_8( 134, (unsigned long long) 0 );
            FM25_write_8( 126, (unsigned long long) 0 );        
            FM25_write_8( 118, (unsigned long long) 0 );

            
            FM25_write_8( 516, (unsigned long long) 0 );//Ignition
            FM25_write_8( 524, (unsigned long long) 0 );// вод дверь 
            FM25_write_8( 532, (unsigned long long) 0 );// прав передн дверь
            FM25_write_8( 540, (unsigned long long) 0 );// лев задн дверь
            FM25_write_8( 548, (unsigned long long) 0 );// прав задн дверь
            FM25_write_8( 556, (unsigned long long) 0 );// багажник
            FM25_write_8( 564, (unsigned long long) 0 );// капот
            FM25_write_8( 572, (unsigned long long) 0 );// пробег
            FM25_write_8( 580, (unsigned long long) 0 );// топливо
            FM25_write_8( 588, (unsigned long long) 0 );// ремень    
            FM25_write_8( 596, (unsigned long long) 0 );// замок дверей
            FM25_write_8( 604, (unsigned long long) 0 );// замок дверей тип 2   
            FM25_write_8( 612, (unsigned long long) 0 );// зажигание тип 2
            FM25_write_8( 620, (unsigned long long) 0 );// статус двигателя тип 2
            FM25_write_8( 628, (unsigned long long) 0 );// статус webasto тип 1
            FM25_write_8( 636, (unsigned long long) 0 );// статус сигнализации
            FM25_write_8( 644, (unsigned long long) 0 );// статус акпп тип 2
            FM25_write_8( 652, (unsigned long long) 0 );// статус акпп тип 2 
            FM25_write_8( 660, (unsigned long long) 0 );// статус замка багажника тип 1
//            FM25_write_4( 668, (unsigned long ) 0x094D0CBF );// bit timing can1
//            FM25_write_4( 672, (unsigned long ) 0x094D0CBF );// bit timing can2
            FM25_write_8( 676, (unsigned long long) 0 ); //CLOCKSET1bits
            FM25_write_8( 684, (unsigned long long) 0 ); //CLOCKDAT1bits
            FM25_write_8( 692, (unsigned long long) 0 ); //CLOCKTIME1bits
            FM25_write_8( 700, (unsigned long long) 0 ); //
            FM25_write_8( 708, (unsigned long long) 0 ); //
            FM25_write_8( 716, (unsigned long long) 0 ); //
            FM25_write_8( 724, (unsigned long long) 0 ); //
            FM25_write_8( 732, (unsigned long long) 0 ); //
            FM25_write_8( 740, (unsigned long long) 0 ); //
            FM25_write_8( 748, (unsigned long long) 0 ); //
            FM25_write_8( 756, (unsigned long long) 0 ); //
            FM25_write_8( 764, (unsigned long long) 0 ); //
            FM25_write_8( 772, (unsigned long long) 0 ); //
            FM25_write_8( 780, (unsigned long long) 0 ); //
            FM25_write_8( 788, (unsigned long long) 0 ); //
            FM25_write_8( 796, (unsigned long long) 0 ); //
            FM25_write_8( 804, (unsigned long long) 0 ); //
            FM25_write_8( 812, (unsigned long long) 0 ); //
            FM25_write_8( 820, (unsigned long long) 0 ); //
            FM25_write_8( 828, (unsigned long long) 0 ); //
            FM25_write_8( 836, (unsigned long long) 0 ); //
            FM25_write_8( 844, (unsigned long long) 0 ); //
            FM25_write_8( 852, (unsigned long long) 0 ); //
            FM25_write_8( 860, (unsigned long long) 0 ); //
            FM25_write_8( 868, (unsigned long long) 0 ); //
            FM25_write_1( 876, 0 ); //
            FM25_write_2( 877, (unsigned int) 0 );
            FM25_write_8( 895, (unsigned long long) 0 );
            FM25_write_8( 903, (unsigned long long) 0 );
            FM25_write_8( 911, (unsigned long long) 0 );
            FM25_write_8( 919, (unsigned long long) 0 );
            FM25_write_8( 927, (unsigned long long) 0 );
            FM25_write_8( 935, (unsigned long long) 0 );
            FM25_write_5( 943, (unsigned long long) 0 );
            FM25_write_8( 948, (unsigned long long) 0 );
            FM25_write_8( 956, (unsigned long long) 0 );
        }

        FM25_write_1(0x00, 0x1); // флаг начальной инициализации
    }
// Сброс флагов стирания памяти
    MEMRESFLAGSbits.MEMRESFLAGS = 0;
    FM25_write_2 (2023, MEMRESFLAGSbits.MEMRESFLAGS );

//    int i;
//FM25_write_2( 75, 0 );
//FM25_write_2( 77, 0 );
//for ( i = 640; i < 790; i ++ ) { // Стирание всех сообщений очереди 2, если нет команды защитить
//    SST25_sector_erase ( i, 1 );
//}
//FM25_write_4( 1292, (unsigned long) 0x10004003 );// 50 тип1 CRASHSETbits  2BC12C03 
//FM25_write_4( 1582, (unsigned long) 0x8004003 );// 50 тип1 CRASHSETIGNOFFbits
    Nop();Nop();Nop();    
	read_parameters (1);
    apply_acc_sampling_frequency ( acc_sampling_frequency );
    fill_buffers ();
//# if defined ( PRODUCTION_MODE )
//    CAN1SETTINGSbits.CAN1SETTINGS   = 0x07D1;  // CAN1
//    CAN2SETTINGSbits.CAN2SETTINGS   = 0x07D1;  // CAN2
//    CANIGNPRMSbits.CANIGNPRMS       = 0x000004F000403001;// Ignition
//    CANDDPRMSbits.CANDDPRMS         = 0x0000011000403102;// вод дверь 
//# endif    

#if defined(FOR_TRUCK)
    initTruckVariables();
#endif       
    
    Fp1 = 20; Fp2 = 20;
    can1start();
    can2start();     
    init_CAN_filters ();
    
    init_GPRS_header(); 

# if defined (MCP23S08)    
    init_MCP23S08 ();
# endif

    Nop();Nop();Nop();    
//    CANFLCNPNPRMSbits.can_number = 1; CANFLCNPNPRMSbits.id = 0x66A;
//    CANFLCNPNPRMSbits.byte0 = 3;
//    unsigned int c;
//    for (c = 0; c < 255; c ++ ) {
//        CAN1_DATA_buf[CANFLCNPNPRMSbits.byte0] = CAN1_DATA_buf[CANFLCNPNPRMSbits.byte0] + 2;
//        ID = 0x66A;
//        fuel_consumption_quantum = 0x50;
//        apply_can_data ();
//    
//        Nop();Nop();Nop();
//    }
Nop();Nop();Nop();    
    if ( battery_charge_type == 1 ) CHARGE_ONOFF = 0;
//    SYNC_BITS_SW2[1] = 0x00;
    if (reset_reason == 1) {
//        FM25_write_1 (2030, 0);

    }    
//FM25_write_1 ( 32,  0);  
//Transp_flags[1] = 1; // !!!!!!!!!!!! чтобы не прописывать 1 метку
Transp_flags[6] = 6; // !!!!!!!!!!!! чтобы не прописывать реле блокировки
	next_portion_255 ();
// Определение причины сброса
    if (RCONbits.TRAPR || RCONbits.IOPUWR || RCONbits.EXTR || RCONbits.SWR || RCONbits.WDTO || RCONbits.BOR || RCONbits.POR) {
        RESETREASONbits.RESETREASON = 0;
        RESETREASONbits.reset_flag = 1;
        RESETREASONbits.TRAPR  = RCONbits.TRAPR;
        RESETREASONbits.IOPUWR = RCONbits.IOPUWR;
        RESETREASONbits.EXTR   = RCONbits.EXTR;
        RESETREASONbits.SWR    = RCONbits.SWR;
        RESETREASONbits.WDTO   = RCONbits.WDTO;
        RESETREASONbits.BOR    = RCONbits.BOR;
        RESETREASONbits.POR    = RCONbits.POR;
        RCONbits.TRAPR = 0; RCONbits.IOPUWR = 0; RCONbits.EXTR = 0; 
        RCONbits.SWR = 0;   RCONbits.WDTO = 0;   RCONbits.BOR = 0;  RCONbits.POR = 0; 
    }
/* Влючение WDT */
    Nop();Nop();Nop();
    RCONbits.SWDTEN = 1;    

    xy_trh   = CRASHSETbits.gxy;
    xyz_trh  = CRASHSETbits.gxyz; 
    duration = CRASHSETbits.duration;         
    
    
// Включение и полный сброс SI4461 
    
//	SDN_SI4461 = 1;
//	__delay_us(50);
//	SDN_SI4461 = 0;
//	__delay_ms(10);
//	Si4461_CMD_stream ( POWER_UP, 7 );
//	__delay_ms(15);
//	wait_ready ();
//	Si4461_init (); 
//    __delay_ms (50);
//    
//	SW2 = SW2 & 0x0F;
//	SYNC_BITS [4] = 0x00; SYNC_BITS [5] = SW2;SYNC_BITS [6] = SW1;SYNC_BITS [7] = SW0;
//	Si4461_CMD_stream ( SYNC_BITS, 8 );
//	wait_ready ();
//    
//    RFSTATEbits.RFSTATE = 0;
//    RFSTATEbits.waiting_inquiry = 1;
//    
//    SYNC_BITS_SW2 [4] = SW2_receive1 | SW2;
//    Si4461_CMD_stream ( SYNC_BITS_SW2, 5 );
//    wait_ready ();
//	Si4461_interrupt_reset ();
//// Длина пакета 0 байт
//	PKT_LENTH[4]= 0;
//	Si4461_CMD_stream ( PKT_LENTH, 5 );
//	wait_ready ();
//// Запуск приема пакета из восьми байт данных
//	Si4461_CMD_stream ( START_RX, 3 );
//	wait_ready ();    

RFRESETbits.start = 1;  


//    SDN_SI4461 = 1;
//    __delay_ms (100); 
//    SDN_SI4461 = 0;        
//    __delay_ms (30);
//    Si4461_CMD_stream ( POWER_UP, 7 );
//    __delay_ms (30);
//    Si4461_init (); 
//    __delay_ms (100);
//    START_TX[2] = 0; //TX_to_READY
//    START_TX[4] = 0;
////    Si4461_CMD_stream ( START_TX, 5 );
//    while (1) {
//        CHANGE_STATE[1] = TX_STATE;
//        Si4461_CMD_stream ( CHANGE_STATE, 2 );
//        __delay_ms (10);
//        CHANGE_STATE[1] = READY;
//        Si4461_CMD_stream ( CHANGE_STATE, 2 );
//        while (Si4461_get_reply_stream ( READ_CMD_BUFF, 0 ) != 0xFF); //wait_ready ();
//        __delay_ms (10);        
//        asm("clrwdt");
//    }
    Nop();Nop();Nop();

    
//    Si4461_CMD_stream (GPIO_PIN_CFG, 1); // чтение конф. IO GPIO_PIN_CFG[8]= { 0x13, 0x07, 0x08, 0x20, 0x21, 0x27, 0x00, 0x00 };
//    while (Si4461_get_reply_stream ( READ_CMD_BUFF, 7 ) != 0xFF);
//    Unit_num = 0x0005CCD0; 
	OUTbits.unit_num = Unit_num;
	K0 = 0xA96051EB;
	K1 = 0x8F37DC24;
	K2 = 0xB39D2871;
	K3 = 0xA540ECF6;
	K4 = 0x250B3A4C;
	K5 = 0x968EF7D1;
	K6 = 0x516B0E8D;
	K7 = 0xC249F73A;  

    
    ignition = 0; ignition_by_pulse = 0;
    IGNEVENTSFLAGSbits.trigg_on = 0; IGNEVENTSFLAGSbits.trigg_off = 1;
    IGNEVENTSFLAGSbits.event_off_flag = 0;    
    char fr_freez_tmp;
//    FM25_write_1 ( 8, 0 );
fr_freez_tmp = FM25_read_1 ( 8 );
if ( fr_freez_tmp == 1 || fr_freez_tmp == 2 ) {
    Nop(); Nop(); Nop();
    FM25_write_1 ( 8, 0 );
    ARMFLAGSbits.ARMFLAGS     = (unsigned long)FM25_read_4( 9 );  // состояние и таймеры вторжения и охраны
    INTRREASONbits.INTRREASON =  (unsigned int)FM25_read_2( 13 );  // причина вторжения
    CANDOORSbits.CANDOORS     = (unsigned char)FM25_read_1( 15 );  // состояние дверей
    STATUSFLAGS1bits.STATUSFLAGS1 = (unsigned char)FM25_read_1( 16 );  // состояние двигателя
    ignition = STATUSFLAGS1bits.ignition; // Восстановление состояния зажигания
    if (STATUSFLAGS1bits.engine_running == 1) {
        ign_on_off_counter = ign_on_time;
        ignition_by_pulse = 1;
    } else {
        ign_on_off_counter = ign_off_time;
        ignition_by_pulse = 0;        
    }
    if (ignition == 1) {
        IGNEVENTSFLAGSbits.trigg_on = 1; IGNEVENTSFLAGSbits.trigg_off = 0; // Так как ignition on уже сформировано
        IGNEVENTSFLAGSbits.event_on_flag = 0; 
        fisical_ignition_counter = 5;
    }
    OUTbits.arm_flag = 1; // Эта перезагрузка происходит в охране
    
    if ( fr_freez_tmp == 2 ) {
        RF_freezed_monitor_run_flag = 1;
        ROBBFLAGSbits.ROBBFLAGS  = (unsigned int)FM25_read_2( 17 ); // состояние разбоя
    }
    
    Nop(); Nop(); Nop();
}
    
	N1 = 0; N2 = 0;    
//	OUTbits.arm_flag = 1;    
//	if (OUTbits.arm_flag == 1) {
		N1 = N1 | OUTbits.OUT;
        
//	}
	Gamma_H ();
	N2 = LFSRbits.LFSR;
	Gamma_L ();
	tempN1 = N1;
	tempN2 = N2;
	N1 = N1 ^ omega0; //Наложение гаммы
    
    Encription ();
	Decription ();	 // Дешифровка
	Gamma_L();
	N1 = N1 ^ omega0;
        
            UART4_Rx_buf[0] = 0;
            num_of_bytes4 = 0;
            num_of_bytes_tmp4 = 0;
            Rx4_DataAvailable = 0;
gsmdebug_ON = 1; // ###########################################################

__delay_ms (250);
__delay_ms (250);
__delay_ms (250);
__delay_ms (250);

    AD1CON1bits.SAMP = 1;
    while ( _AD1IF );
    _AD1IF = 0;
    car_voltage = (unsigned char)((ADC1BUF0 + 2)/4);

Nop(); Nop(); Nop();
IEC1bits.T4IE = 0;
    if (power_counter > 0) {
        power_counter == 1000;
        power = 1;
    } else power = 0;
IEC1bits.T4IE = 1;
    check_power_event ();
Nop(); Nop(); Nop();
    PWREVENTSFLAGSbits.event_on_flag = 0;
    PWREVENTSFLAGSbits.event_off_flag = 0;
    
//    ignition = 0; ignition_by_pulse = 0;
//    IGNEVENTSFLAGSbits.trigg_on = 0; IGNEVENTSFLAGSbits.trigg_off = 1;
//    IGNEVENTSFLAGSbits.event_off_flag = 0;    

//write_text_to_SMS_buf ( "Starting work\0", "\"+79032559788\"\0" ); // SMS о начале работы

//    write_data_to_GPRS_buf ( TYPE0, 9 );
    
    if (GSMSTATUSbits.power == 1) {modem_on_off (MODEM_EMERG_RST);}
    else {modem_on_off (MODEM_ON);}



//    int krit;

//    Si4461_CMD_stream (GPIO_PIN_CFG, 1); // чтение конф. IO GPIO_PIN_CFG[8]= { 0x13, 0x07, 0x08, 0x20, 0x21, 0x27, 0x00, 0x00 };
//    while (Si4461_get_reply_stream ( READ_CMD_BUFF, 4 ) != 0xFF);
//    int i = 0;
//    while (i==0) {
//        Nop(); Nop(); Nop();        
//    }
/*
volatile float *ptr_flt, flt_tmp;
ptr_flt = &Coeff_25Hz;
flt_tmp = *ptr_flt;
ptr_flt++;
flt_tmp = *ptr_flt;
ptr_flt++;
flt_tmp = *ptr_flt;
ptr_flt++;
flt_tmp = *ptr_flt;    
*/    
    
	Gamma_H (); N2 = LFSRbits.LFSR; Gamma_L ();
	N1 = OUTbits.OUT; N2 = LFSRbits.LFSR;
	tempN1 = N1; tempN2 = N2;
	N1 = N1 ^ omega0; //Наложение гаммы
	Encription ();
    
    

    
Tx2_DataAvailable = 0;
int nuv_res, check_res;

Gx_test = 0; Gy_test = 0; Gz_test = 255;

navi_wait_timer = 35;

/**/T8CONbits.TON = 1;
//sleep_counter = 17000;
//unsigned char tmp_flag = 0;
while (1) {

//        OUTPUTbits.out4_p12 = 1;
//        wright_MCP23S08 ( 0x0A, OUTPUTbits.OUTPUT );     
//L_OUT = 0;    
    while (1) {
        if (RF_DataAvailable == 1)         break;
        if (rel_timeout_flag == 1)         break;
        if (periodic_10ms_flag == 1)       { periodic_10ms_break_flag = 1; break; }
        if (acc_data_redy_flag == 1)       break; 
        if (Rx2_DataAvailable == 1)        break;
        if (Rx4_DataAvailable == 1)        break;
        if (Rx1_DataAvailable == 1)        break;
        if (Rx3_DataAvailable == 1)        break;
        if (modem_UART_check_flag == 1)    break;
        if (modem_UART_dead_flag == 1)     break;
        if (periodic_flag == 1) {
            asm("clrwdt");
//            L_OUT = 1;
//            to_sleep_mode ();
//            L_OUT = 0;
            periodic_break_flag = 1;
            break;
        }
        if (modem_tasck_timeout_flag == 1) break;
        if (GSMSTATUSbits.unexpected_off)  break;
        if (flash_write_monitor_flag == 1) break;

        if (flash_write_end_flag == 1)     break;

        if (CAN1AUX_R_ptr != CAN1AUX_W_ptr)break;
        if (CAN2AUX_R_ptr != CAN2AUX_W_ptr)break;
//        if ( rxmsg1 != 0 )                 break;
//        if ( rxmsg2 != 0 )                 break;
        if ( CAN1_fault == 1 )             break;
        if ( CAN2_fault == 1 )             break;  
#if defined (WBUS)
        //if ((WBSWTASKbits.break_done == 1) && (WBSWTASKbits.break_start == 1)) break;
        if ((WBSWTASKbits.break_done == 1) && (WBSWTASKbits.start == 1) && (WBSWTASKbits.break_start == 1)) break;
        if ((WBSWTASKbits.break_done == 1) && (DVRQWTASKbits.start == 1) && (WBSWTASKbits.break_start == 1)) break;
        if ((WBSWTASKbits.break_done == 1) && (DRSTWTASKbits.start == 1) && (WBSWTASKbits.break_start == 1)) break;
#endif
//        tmp_flag = 1;
//        if (tmp_flag == 1) break;
    }
    
/******************************************************************/
// ТЕСТ
# if defined (DIRECTTX)
sleep_counter = 0;    
# endif

static unsigned char navi_flag = 0;//, n;
//unsigned int crc_tmp = 0;
# if defined (TEST)
if (navi_flag == 1) {
    navi_flag = 0;
    UART3_Tx_buf[0] = 0xAA; UART3_Tx_buf[1] = 0x01; UART3_Tx_buf[2] = 0x12;

    UART3_Tx_buf[4]  = AVbits.S; 
    UART3_Tx_buf[5]  = Navi_bin[6]; UART3_Tx_buf[6]  = Navi_bin[7]; UART3_Tx_buf[7]  = Navi_bin[8]; UART3_Tx_buf[8]  = Navi_bin[9];
    UART3_Tx_buf[9]  = Navi_bin[10]; UART3_Tx_buf[10] = Navi_bin[11]; UART3_Tx_buf[11] = Navi_bin[12]; UART3_Tx_buf[12] = Navi_bin[13];
    UART3_Tx_buf[13] = Navi_bin[18]; UART3_Tx_buf[14] = Navi_bin[19]; 
    UART3_Tx_buf[15] = Navi_bin[17]; 
    UART3_Tx_buf[16] = Navi_bin[0]; UART3_Tx_buf[17] = Navi_bin[1]; UART3_Tx_buf[18] = Navi_bin[2];
    UART3_Tx_buf[19] = Navi_bin[3]; UART3_Tx_buf[20] = Navi_bin[4]; UART3_Tx_buf[21] = Navi_bin[5];
    
    crc_tmp = 0;
    for (n = 0; n < 18; n++) {
        crc_tmp = crc_tmp + UART3_Tx_buf[n + 4];
    }
    UART3_Tx_buf[3] = (unsigned char)(crc_tmp & 0x00FF);   
// Data transmit the data using interrupts
    U3_Tx_length = 22;
    Tx3_DataAvailable = 0;
    IEC5bits.U3TXIE = 1;
    IFS5bits.U3TXIF = 1;    
}
if (Rx3_DataAvailable == 1) { // По К-лайн что-то принято вне общения с машиной
    Rx3_DataAvailable = 0;
}
# endif
/******************************************************************/

        if (periodic_10ms_flag == 1 && periodic_10ms_break_flag == 1) { 
//            can_button_simulation ();
//            L_OUT = !L_OUT;
# if defined (DIRECTTX)
            rf_direct_tx ();
# endif
        }    
    
    if (periodic_flag == 1 && periodic_break_flag == 1) {
        to_sleep_mode ();
//        L_OUT = ! L_OUT;
    }


#if defined (WBUS)   
    //if ((WBSWTASKbits.break_done == 1) && (WBSWTASKbits.break_start == 1)) {
    if ((WBSWTASKbits.break_done == 1) && (WBSWTASKbits.start == 1) && (WBSWTASKbits.break_start == 1)) {
        WBSWTASKbits.break_start = 0; // reset break_start flag in global while(1) for immedeatly wbus_task() enter after 25ms BREAK on line
        webasto_wbus_task(); //run wbus_task if break on line is done
    } 
    if ((WBSWTASKbits.break_done == 1) && (DVRQWTASKbits.start == 1) && (WBSWTASKbits.break_start == 1)) {
        WBSWTASKbits.break_start = 0;
        webasto_wbus_errorreq_task();
    }
    if ((WBSWTASKbits.break_done == 1) && (DRSTWTASKbits.start == 1) && (WBSWTASKbits.break_start == 1)) {
        WBSWTASKbits.break_start = 0;
        webasto_wbus_errorclr_task();
    }
    
   if (Rx3_DataAvailable == 1) { // WBUS data received
        Rx3_DataAvailable = 0;
        if ((WBUS_Rx_copy_buf[0] == 0x43) && (WBUS_Rx_copy_buf[1] == 0x03) && (WBUS_Rx_copy_buf[2] == 0xA1)) { //check start answer packet header
            WBSWTASKbits.start_ack = 1; //received start acknowledge, flag to stop send start_cmd in webasto_wbus_task
            WBSWTASKbits.break_done= 0;
            WBSWTASKbits.wbus_busy = 0; //reset busy line flag
        }
        if ((WBUS_Rx_copy_buf[0] == 0x43) && (WBUS_Rx_copy_buf[1] == 0x03) && (WBUS_Rx_copy_buf[2] == 0xC4)) { //check wake-up answer packet header
            WBSWTASKbits.wbus_busy = 0; //reset busy line flag
        }
        if ((WBUS_Rx_copy_buf[0] == 0x4F) && (WBUS_Rx_copy_buf[1] == 0x0B) && (WBUS_Rx_copy_buf[2] == 0xD0) && (WBUS_Rx_copy_buf[3] == 0x05)) { //check status answer packet header
            if(wbus_CRC_check(U3_num_W_tmp)) { // if CRC is true - parse the status packet
                WEBASTOSTATUSbits.FD = WBUS_Rx_copy_buf[7]; // 1 - ON; 0 - OFF flame detector
                WEBASTOSTATUSbits.TEMP =  WBUS_Rx_copy_buf[4] - WEBASTO_t_offset;
                WBSWTASKbits.wbus_busy = 0; //reset busy line flag
                Nop();Nop();Nop();
            }
        } 
        if ((WBUS_Rx_copy_buf[0] == 0x4F) && (WBUS_Rx_copy_buf[1] == 0x04) && (WBUS_Rx_copy_buf[2] == 0xD0) && (WBUS_Rx_copy_buf[3] == 0x03)) { //check On/Off flags of different subsystems answer packet header
            if(wbus_CRC_check(U3_num_W_tmp)) { // if CRC is true - parse the On/Off flags of different subsystems packet
                //[0][FI][NSH][VFR][CP][FP][ST][CAF]
                //bits in flag's byte WBUS_Rx_copy_buf[4];
                WEBASTOSTATUSbits.CAF= (WBUS_Rx_copy_buf[4] & 0x01) >> 0;      //Combustion Air Fan (CAF)
                WEBASTOSTATUSbits.ST = (WBUS_Rx_copy_buf[4] & 0x02) >> 1;      //Glowplug / Spark transmitter (ST)
                WEBASTOSTATUSbits.FP = (WBUS_Rx_copy_buf[4] & 0x04) >> 2;      //Fuel Pump (FP)
                WEBASTOSTATUSbits.CP = (WBUS_Rx_copy_buf[4] & 0x08) >> 3;      //Circulation Pump (CP)
                WEBASTOSTATUSbits.VFR= (WBUS_Rx_copy_buf[4] & 0x10) >> 4;      //Vehicle Fan Relay (VFR)
                WEBASTOSTATUSbits.NSH= (WBUS_Rx_copy_buf[4] & 0x20) >> 5;      //Nozzle stock heating (NSH)
                WEBASTOSTATUSbits.FI = (WBUS_Rx_copy_buf[4] & 0x40) >> 6;      //Flame indicator (FI)
                WBSWTASKbits.wbus_busy = 0; //reset busy line flag
                Nop();Nop();Nop();
            }
        }
//static unsigned int wbus_err_crc = 0; 
//        wbus_err_crc = 0;
        if ((WBUS_Rx_copy_buf[0] == 0x4F) && (WBUS_Rx_copy_buf[2] == 0xD6) && (WBUS_Rx_copy_buf[3] == 0x01)) { //check error answer packet header
            if(wbus_CRC_check(U3_num_W_tmp)) { // if CRC is true - parse the error packet
                //check CRC of prev err request, if changed - send MSG to server with new errors
//                static unsigned int wbus_err_crc = 0;
                unsigned int wbus_err_crc_new = CRC16(&WBUS_Rx_copy_buf, U3_num_W_tmp);
                if (wbus_err_crc == wbus_err_crc_new) {
                    //errors not changed
                    Nop(); Nop(); Nop();
                } else {
                    //errors changed, generate and send MSG
                    generate_WBUS_DTC_message ( (unsigned char) (U3_num_W_tmp - 4) );
                    Nop(); Nop(); Nop();
                    wbus_err_crc = wbus_err_crc_new; //update current CRC var
                }
                /////
                WBSWTASKbits.wbus_busy = 0; //reset busy line flag
                if (WBSWTASKbits.start == 0) WBSWTASKbits.break_done = 0; //no break_FL reset if WBSWTask is active
                DVRQWTASKbits.stop  = 1; //stop DVRQW err request TASK 
            }
        }
        if ((WBUS_Rx_copy_buf[0] == 0x4F) && (WBUS_Rx_copy_buf[1] == 0x03) && (WBUS_Rx_copy_buf[2] == 0xD6) && (WBUS_Rx_copy_buf[3] == 0x03)) { //check error clear answer packet header
            if(wbus_CRC_check(U3_num_W_tmp)) { // if CRC is true - parse the error clear packet
                WBSWTASKbits.wbus_busy = 0; //reset busy line flag
                if (WBSWTASKbits.start == 0) WBSWTASKbits.break_done = 0; //no break_FL reset if WBSWTask is active
                DRSTWTASKbits.stop  = 1; //stop DRSTW err clear TASK 
                //send MSG to server that ERRORS were cleared
                DVRQWTASKbits.start = 1;
                wbus_err_crc ++;
            }
        }
    }
    if (Rx3_DataAvailable == 1) { 
        Rx3_DataAvailable = 0;
        Nop();Nop();Nop();
    }
#endif   
    
#if defined (MAZDA_LOCK)
    if (Rx3_DataAvailable == 1) { // По К-лайн что-то принято вне общения с машиной
        Rx3_DataAvailable = 0;
    }
#endif
//    if (periodic_10ms_flag == 1 && periodic_10ms_break_flag == 1) { // Чтение ускорений Gx, Gy, Gz
    if (acc_data_redy_flag == 1) {        
//    if (periodic_10ms_flag == 1) {
//        L_OUT = 1;
        Read_G_all ( 1 );
//        Gx = 255; Gy = 255; Gz = 255;
        Filt_crash ( Gx, Gy, Gz );
        Nop();Nop();Nop();
        Gx = Gxif2; Gy = Gyif2; Gz = Gzif2;
//        L_OUT = 0;
        
        if (AUTOCALSTATUSbits.staticcal == 1) {

            recalculation_to_XiYiZi ((float) Gx, (float) Gy, (float) Gz); 
            if ( AUTOCALSTATUSbits.finished == 1 && CRASHDATbits.queue != 0 ) { //!!!!!не забыть вернуть!
                plane_recalculation ( Gxi, Gyi ); 
//                Filt_crash ( Gxp, Gyp, Gzi );
                crash_detection ( Gxp, Gyp, Gzi );
//                crash_detection ( Gxif2, Gyif2, Gzif2 );
            }
            if ( TILTDATbits.queue != 0 ) tilt_detection ( 0 );
        }
        tilt_message_generator ();
    }
    
    if (RF_DataAvailable == 1) {
        Nop(); Nop(); Nop();
        RF_DataAvailable = 0;
        RF_data_handler ();
    }
    if (rel_timeout_flag == 1) {
        rel_timeout_flag = 0;
        relay_transactions_monitor ();
        
    }
    if (periodic_10ms_flag == 1 && periodic_10ms_break_flag == 1) { 
//    if (periodic_10ms_flag == 1) {    
        rel_learn_transactions_monitor ();
        transp_learn_transactions_monitor ();
        transp_learn_finish_monitor ();
        RF_wdt ();
        get_freez_timers ();
        voltage_mesuare ();
    }
/*
# if defined (MCP23S08) 
    static unsigned char outputs = 0x00;
    if (periodic_10ms_flag == 1 && periodic_10ms_break_flag == 1) INPUTbits.INPUT = (unsigned char)read_MCP23S08 ( 0x09 ); 
static unsigned char switch_counter = 0;
    
    
    if (periodic_flag == 1 && periodic_break_flag == 1) { 
        Nop(); Nop(); Nop();
        switch_output_MCP23S08 ( switch_counter, ignition );
        if ( switch_counter < 5 ) switch_counter ++;
        else switch_counter = 0;
    }
        
//    wright_MCP23S08 ( 0x0A, INPUTbits.in1_p1 );
//    OUT2 = INPUTbits.in1_p1;
    Nop(); Nop(); Nop();
//    if (periodic_flag == 1 && periodic_break_flag == 1) {
//        wright_MCP23S08 ( 0x0A, outputs );
//        INPUTbits.INPUT = (unsigned char)read_MCP23S08 ( 0x09 );
//        outputs = ~outputs;
//        OUT2 = INPUTbits.in1_p1;
//    }
# endif 
*/    
    if (periodic_10ms_flag == 1 && periodic_10ms_break_flag == 1) {
//    if (periodic_10ms_flag == 1) {    
        Si4461_reset();
# if defined (MCP23S08) 
        INPUTbits.INPUT = (unsigned char)read_MCP23S08 ( 0x09 );
        output_pulses_tasck_MCP23S08 ();
        reset_MCP23S08 ();
        reset_GPS_modul ();
# endif        
    }
# if defined (K_LINE)        
static int iso_delay_counter = 0;
        if ( (periodic_10ms_flag == 1  && periodic_10ms_break_flag == 1) || Rx3_DataAvailable == 1 ) {
//             if (Rx3_DataAvailable == 1) {
//                load_UART4_Tx_buf (UART3_Rx_buf);
//                start_UART4_transmission(WAITOFF);  
//            }           
            if (periodic_10ms_flag == 1 && periodic_10ms_break_flag == 1) get_91412_fast_data ();//get_91412_data ();
//            iso_91412_5baud_init();
            iso_91412_fast_init ();
            iso_91412_fast_reset_dtc ();
            iso_91412_fast_request_mil ();
        if (Rx3_DataAvailable == 1) {
            Rx3_DataAvailable = 0;
        }

        }
# endif
# if defined (LIN) 
//static int start_LIN_transmission = 0;//, LIN_counter = 0, en_flag = 0, count = 0;


        if (periodic_10ms_flag == 1 && periodic_10ms_break_flag == 1) {
            lock_unlock_doors_thru_lin ();
            unlock_boot_thru_lin_tasck ();
            unlock_boot_thru_lin ();
            check_lin_boot_status_debounce ();
/* */           
            if ( fuel_sensor_enable != 0 ) {
/*                 
                if ( count <= 9 ) count ++;
                else {
                    count = 0;
                    UART3_Tx_buf[0] = 0x00; UART3_Tx_buf[1] = 0x55; UART3_Tx_buf[2] = 0x03;
//                    UART3_Tx_buf[3] = 0x00; UART3_Tx_buf[4] = 0x00; UART3_Tx_buf[5] = 0x00;
//                    UART3_Tx_buf[6] = 0xC0; UART3_Tx_buf[7] = 0x3F;
                    start_UART3_LIN_transmission ( 3 );
                }                
*/                
/*                
                if ( count <= 99 ) count ++;
                else {
//                    OUT2 = ! OUT2;
                    count = 0;
                    UART3_Tx_buf[0] = 0x00; UART3_Tx_buf[1] = 0x55; UART3_Tx_buf[2] = 0xFE;
                    UART3_Tx_buf[3] = 0x01; UART3_Tx_buf[4] = 0x01;
                    
                    UART3_Tx_buf[5]  = 0x01; UART3_Tx_buf[6]  = 0x01; UART3_Tx_buf[7]  = 0x02;
                    UART3_Tx_buf[8]  = 0x02; UART3_Tx_buf[9]  = 0x03; UART3_Tx_buf[10] = 0x03;
                    UART3_Tx_buf[11] = 0x04; UART3_Tx_buf[12] = 0x04; UART3_Tx_buf[13] = 0x05;
                    UART3_Tx_buf[14] = 0x05; UART3_Tx_buf[15] = 0x06; UART3_Tx_buf[16] = 0x06;
                    UART3_Tx_buf[17] = 0x07; UART3_Tx_buf[18] = 0x07; UART3_Tx_buf[19] = 0x08;
                    UART3_Tx_buf[20] = 0x08; UART3_Tx_buf[21] = 0x09; UART3_Tx_buf[22] = 0x09;
                    UART3_Tx_buf[23] = 0x10; UART3_Tx_buf[24] = 0x10;
//                    volatile int crc, i;
//                    crc = 0;
//                    for (i = 0; i < 22; i ++) { //  расчет контрольной суммы
//                        crc = crc + UART3_Tx_buf[i + 3];
//                        if ( crc > 0xFF ) { 
//                            crc = crc & 0xFF;
//                            crc ++;
//                        }
//                    }
////                    i = crc % 0xFF;
//                    i = ~i;
                    
                    UART3_Tx_buf[25] = LIN_CRC_calc( &UART3_Tx_buf[3], 22, 1 );
                    
//                    UART3_Tx_buf[3] = 0x03; UART3_Tx_buf[4] = 0xff; UART3_Tx_buf[5] = 0x03;
//                    UART3_Tx_buf[6] = 0xfe; UART3_Tx_buf[7] = 0x03; UART3_Tx_buf[8] = 0xfd;
                    start_UART3_LIN_transmission ( 26 );            
                }
    //            if ( count == 470 || count == 480 || count == 490 ) {
    //                UART3_Tx_buf[0] = 0x00; UART3_Tx_buf[1] = 0x55; 
    //                if (count == 470) UART3_Tx_buf[2] = 0x03;
    //                if (count == 480) UART3_Tx_buf[2] = 0x04;
    //                if (count == 490) UART3_Tx_buf[2] = 0x05;
    //                start_UART3_LIN_transmission ( 3 );                
    //            }
*/                
                
                }
        
        }

        if (Rx3_DataAvailable == 1) { // По К-лайн что-то принято вне общения с машиной
            Rx3_DataAvailable = 0;

            lin_sleep_counter = 0; 
            lin_sleep = 0;
            apply_LIN_data ();
//            U3MODEbits.WAKE = 1;
//            U3MODEbits.ABAUD = 1;
/* */       
            if (lin_snif_enable == 1) {
                if ( LIN_Rx_copy_buf[2] == 0x03 || LIN_Rx_copy_buf[2] == 0xFF || LIN_Rx_copy_buf[2] == 0x00 ) { //|| LIN_Rx_copy_buf[2] == 0xFE 
                    Nop(); Nop(); Nop();
                    transmit_LIN_to_debug ( U3_num_W_tmp ); 

                }
            }   
                   
//            }
/*
        if (UART3_Rx_buf[2] == 0x03) {
            Nop();Nop();Nop();
            if (num_of_lin_transmittions > 0 ) {
                num_of_lin_transmittions --;
                
                    L_OUT = 1;
                    UART3_Tx_buf[0] = 0x00; UART3_Tx_buf[1] = 0x00; UART3_Tx_buf[2] = 0x00;
                    UART3_Tx_buf[3] = 0xC4; UART3_Tx_buf[4] = 0x3B;

                    start_UART3_LIN_transmission ( 5 );

            } else {
                L_OUT = 0;
                    UART3_Tx_buf[0] = 0x00; UART3_Tx_buf[1] = 0x00; UART3_Tx_buf[2] = 0x00;
                    UART3_Tx_buf[3] = 0xC0; UART3_Tx_buf[4] = 0x3F;

                    start_UART3_LIN_transmission ( 5 );                
                Nop();Nop();Nop();
            }            
            
        }
*/            
        }

        if (periodic_10ms_flag == 1 && periodic_10ms_break_flag == 1) key_unlock_during_ign_on_timeout ();

//            if (periodic_10ms_flag == 1 && periodic_10ms_break_flag == 1){
//                if (LIN_counter < 100) LIN_counter ++;
//                else {
//                    LIN_counter = 0;
//                        UART3_Tx_buf[0] = 0x00; UART3_Tx_buf[1] = 0x55; UART3_Tx_buf[2] = 0x03; UART3_Tx_buf[3] = 0xC0;
//                        UART3_Tx_buf[4] = 0xBE; //UART3_Tx_buf[5] = 0x00; UART3_Tx_buf[6] = 0xC4; UART3_Tx_buf[7] = 0x3B;
//                        start_UART3_LIN_transmission ( 3 );                    
//                }
//            }

//    if (periodic_10ms_flag == 1 && periodic_10ms_break_flag == 1){
//        if (LIN_counter < 100) LIN_counter ++;
//        else { LIN_counter = 0; start_LIN_transmission = 1; }
////        LIN_counter = 0;
////        en_flag = 1;
////        if (start_LIN_transmission == 1 && en_flag == 1 ) {
////                start_LIN_transmission = 0;
////                UART3_Tx_buf[0] = 0x00; UART3_Tx_buf[1] = 0x55; UART3_Tx_buf[2] = 0x03; UART3_Tx_buf[3] = 0x00;
////                UART3_Tx_buf[4] = 0x00; UART3_Tx_buf[5] = 0x00; UART3_Tx_buf[6] = 0xC4; UART3_Tx_buf[7] = 0x3B;
////                start_UART3_LIN_transmission ( 3 );
////        }
//    }
# endif

    if ( GSMSTATUSbits.unexpected_off ) {
        Nop(); Nop(); Nop();
        modem_on_off (MODEM_EMERG_RST);
//        write_text_to_SMS_buf ( "Emergency reset: unexpected off.", PHONE_NUMBER );//
        load_answer ( 2, "Emergency reset: unexpected modem off.", 0, 0 );
    }


        // Готовы данные от GNSS модуля
        if (periodic_flag == 1 && periodic_break_flag == 1) {
            if ( navi_wait_timer > 0 ) navi_wait_timer --;
        }
        if (Rx2_DataAvailable == 1) { 
            Rx2_DataAvailable = 0;
            nuv_res = get_navigation_data ();
            // Трансляция навигационных данных, если GNSS дебаг включен
            if ((nuv_res==1)&&(navistrout_ON)) {transmit_GNSSdata_to_debug ();}
            navi_flag = 1;
        }


//    if (periodic_flag == 0) {
/*        
        // Готовы данные от GNSS модуля
        if (Rx2_DataAvailable == 1) { 
            Rx2_DataAvailable = 0;
            nuv_res = get_navigation_data ();
            // Трансляция навигационных данных, если GNSS дебаг включен
            if ((nuv_res==1)&&(navistrout_ON)) {transmit_GNSSdata_to_debug ();}

        }
*/
        // Готовы данные из дебаг порта    
        if (Rx4_DataAvailable == 1) { 
            Rx4_DataAvailable = 0;
            check_res = check_UART4_command();
            if (check_res == 1 || check_res == 0) {start_UART4_transmission (WAITOFF);}
            
            if (check_res == 2) {
            } // Трансляция АТ команды в модем
            if (check_res == 3) { // 
                load_UART4_Tx_buf (command_temp_buf);
                start_UART4_transmission (WAITOFF);
            }
        }
        // Готовы данные от GSM модуля
        if (Rx1_DataAvailable == 1) { 
            Rx1_DataAvailable = 0;
            UART1_buf_to_UART1_copy_buf (U1_num_W);
            // Анализ данных от модема
            check_UART1_command();
            // Трансляция в дебаг порт ответов модема, если GSM дебаг включен
            if (gsmdebug_ON == 1) {transmit_GSMdata_to_debug ();}
        }

//    } //if (periodic_flag == 0)
    
    if (periodic_10ms_flag == 1 && periodic_10ms_break_flag == 1) intrusion_off_by_input();
//    if (periodic_10ms_flag == 1)  intrusion_off_by_input();

    if (periodic_flag == 1 && periodic_break_flag == 1) { 
        periodic_flag = 0; 
        periodic_break_flag = 0;
        periodic_tascks (); 
        
        static unsigned char rpm_tmp = 0;
        if ( RPM_status != rpm_tmp ) {
            if ( RPM_status == 1 ) { load_UART4_Tx_buf ("RPM ON"); start_UART4_transmission (WAITOFF); }
            else { load_UART4_Tx_buf ("RPM OFF"); start_UART4_transmission (WAITOFF); } 
        }
        rpm_tmp = RPM_status;
        
    } // Вызывается с периодом 100 мс.
    if (modem_tasck_timeout_flag == 1) gsm_tasck_timeout ();

unsigned char filtered_acc_ready;    
    
//    if (periodic_10ms_flag == 1 && periodic_10ms_break_flag == 1) {
    if (acc_data_redy_flag == 1) {
        acc_data_redy_flag = 0;
//        L_OUT = !L_OUT;
//    if (periodic_10ms_flag == 1) {    
//        periodic_10ms_flag = 0;
        filtered_acc_ready = Filter_behavior ( Gx, Gy, Gz ); //!!!!!!!!!!!!!!!!!!!!       
//        check_button ();
//        static_calibration ();
//        SLEEP_LED = !SLEEP_LED;
        
        if (AUTOCALSTATUSbits.finished == 0) {

            static_calibration ();
            if (ignition == 1) {
                
                if (filtered_acc_ready == 1) {
                calibration_duration ++;    
//                    Gxif1b = Gx; Gyif1b = Gy; Gzif1b = Gz;// ##############################
                    recalculation_to_XiYiZi ((float) Gxif1b, (float) Gyif1b, (float) Gzif1b);
                    orientation ();
                    if (AUTOCALSTATUSbits.orientation == 1) plane_recalculation ( Gxi, Gyi );
                    direction ();
//                    load_chart_U3_Tx_buf ( Gx  + 3000, Gy  + 3000, Gz  + 3000,
//                                           Gxi + 2000, Gyi + 2000, Gzi + 2000,
//                                           Gxp + 1000, Gyp + 1000, Gzi + 1000, 9 );                    
//                    start_UART3_transmission ( 0 ); 
                }  //if (filtered_acc_ready == 1)
            }   else { 
                    if (filtered_acc_ready == 1) {
//                        load_chart_U3_Tx_buf ( Gx  + 3000, Gy  + 3000, Gz  + 3000,
//                                           2000, 2000, 2000,
//                                           1000, 1000, 1000, 9 ); 
//                        start_UART3_transmission ( 0 ); 
                    }
            }
        }
        
        if (AUTOCALSTATUSbits.finished == 1) {
            if (filtered_acc_ready == 1) {
//                Gxif1b = Gx; Gyif1b = Gy; Gzif1b = Gz;// ###############################
                recalculation_to_XiYiZi ((float) Gxif1b, (float) Gyif1b, (float) Gzif1b);
                plane_recalculation ( Gxi, Gyi );
                if (ignition == 1) { check_acceleration_events ( Gxp, Gyp ); }
//                load_chart_U3_Tx_buf ( Gx  + 2000, Gy  + 2000, Gz  + 2000,
//                                       0, 0, 0,
//                                       Gxp + 1000, Gyp + 1000, Gzi + 1000, 9 ); 
//                start_UART3_transmission ( 0 );
            } //if (filtered_acc_ready == 1)   
        }
    }




// Каждые 10мс запуск функции записи сообщений во флеш
    if (flash_write_monitor_flag == 1) save_data_to_flash (); //periodic_10ms_flag == 1

    if (periodic_10ms_flag == 1 && periodic_10ms_break_flag == 1) beep_task ();
//    if (periodic_10ms_flag == 1)  beep_task ();

//unsigned int can1_fault_wdt = 0, can2_fault_wdt = 0;    
//    if ( rxmsg1 != 0 || rxmsg2 != 0 ) {
        check_can_data ();
//        if ( rxmsg1 != 0) can1_fault_wdt = 0;
//        if ( rxmsg2 != 0) can2_fault_wdt = 0;
//    }
/**/
    if (periodic_10ms_flag == 1 && periodic_10ms_break_flag == 1) {
//    if (periodic_10ms_flag == 1) {    
//        if (can1_fault_wdt < 2000) can1_fault_wdt ++;
//        else {
//            can1_fault_wdt = 0;
//            CAN1_fault = 1;
//        }
//        if (can2_fault_wdt < 2000) can2_fault_wdt ++;
//        else {
//            can2_fault_wdt = 0;
//            CAN2_fault = 1;
//        } 
        
    }


    if (periodic_10ms_flag == 1 && periodic_10ms_break_flag == 1) {
//    if (periodic_10ms_flag == 1) {    
        switch_output_during_unlock ();
        lock_unlock_doors_thru_can ();
        door_open_thru_can ();
        door_open_thru_can_type2 ();
        monitor_OBD ();
        if ( wbst_startenginecan_switch == 0 ) {
            run_webasto_task();
            run_webasto_thru_can ();
            check_webasto_status_thru_can ();
        } else {
            start_engine_can ();
            run_start_engine_can ();
        }
        check_second_autorisation_button ( 0 );
        disarm_by_button_tasck ();
    }
    
    if ( CAN1_fault == 1 || CAN2_fault == 1 ) {//CANRESETbits.start == 1
        
//        if (CANRESETbits.counter < 100) CANRESETbits.counter ++;
//        else {
//            write_text_to_SMS_buf ( "CAN reset event", PHONE_NUMBER );
            CANRESETbits.CANRESET = 0;
             
            if (CAN1_fault == 1) {CAN1_fault = 0; can1start();}
            if (CAN2_fault == 1) {CAN2_fault = 0; can2start();}
//            can1start();
//            can2start();
            init_CAN_filters ();
            Nop();Nop();Nop();
            start_beep_task (1, 1, 1);
        }
//    }
    
/**/    
//    wright_MCP23S17 ( 0x15, EXT_LATBbits.EXT_LATB );
        
    if (periodic_10ms_flag == 1 && periodic_10ms_break_flag == 1) {periodic_10ms_flag = 0; periodic_10ms_break_flag = 0;}
//    if (periodic_10ms_flag == 1) periodic_10ms_flag = 0;     

}




Nop();
Nop();
Nop();

//        __delay_us(100);


    return (EXIT_SUCCESS);
}

/*
int  send_through_udp (int start) {
    unsigned int temp;

    if (start == 1) GPRSSENDbits.start_sending = 1; // Запуск процесса передачи

        // Если AT+QISEND еще не отправлена в модем
        if ( GPRSSENDbits.start_sending == 1 && MODEMTASCKSbits.MODEMTASCKS == 0 ) {
                GPRSSENDbits.GPRSSEND = 0;
                GPRSSENDbits.at_qisend = 1;
                MODEMTASCKSbits.data_sending = 1; // Устанавливаем флаг занятости модема
                set_sgm_tasck_busy_timer (300); // Таймаут сообщения модема об отсылке 2 секунды
                AT_QISEND_LEN[10] = '0'; AT_QISEND_LEN[11] = '0';
                AT_QISEND_LEN[12] = '9'; AT_QISEND_LEN[13] = '0';
                load_UART1_Tx_buf (AT_QISEND_LEN);
                start_UART1_transmission (WAITOFF, 15);
        }
         // AT+QISEND уже отправлена в модем и от модема получено >
        if ( GPRSSENDbits.at_qisend && GPRSSENDbits.cntrlz ) {
                GPRSSENDbits.start_sending = 0;
                GPRSSENDbits.at_qisend = 0;
                GPRSSENDbits.cntrlz = 0;
                ACK_timer = 1;               // Запуск таймера акноледжа
                GPRSSENDbits.waiting_send_ok = 1;
                load_UART1_Tx_buf (telit_buf);
                start_UART1_transmission (WAITOFF, 90);
        }


        if (ACK_timer > 0) {
            if (GPRSSENDbits.ACK == 1) { // Пришел вовремя акноледж
                ACK_timer = 0;
                GPRSSENDbits.waiting_send_ok = 0;
                GPRSSENDbits.ACK = 1;    // Отсылка завершена успешно
            }
            else {
                if (ACK_timer < 50) {ACK_timer ++;} // Таймер акноледжа 5 секунд
                else {
                    ACK_timer = 0;
                    GPRSSENDbits.waiting_send_ok = 0;
                    GPRSSENDbits.ACK_timeout_flag = 1;
                }
            }
        } // (ACK_timer > 0)


    if (GPRSSENDbits.send_error || GPRSSENDbits.send_fail || GPRSSENDbits.send_timeout) {
        ACK_timer = 0;                                         return 4; }
    if (GPRSSENDbits.at_qisend || GPRSSENDbits.waiting_send_ok)    return 0;
    if (GPRSSENDbits.ACK && GPRSSENDbits.send_ok)              return 2;
    if (GPRSSENDbits.ACK_timeout_flag && GPRSSENDbits.send_ok) return 3;

    return 1;

}  // Предача через UDP
*/

//int  get_navigation_data (void) {
//
//unsigned char  *rmc_end_ptr, *rmc_start_ptr, *gga_end_ptr, *gga_start_ptr, *gsa1_end_ptr, *gsa1_start_ptr;
//unsigned char  *gsa2_end_ptr, *gsa2_start_ptr, *tmp_ptr, *tmp_ptr2, *tmp_ptr3, *tmp_ptr4, *speed_start_ptr, *speed_end_ptr, *course_start_ptr, *course_end_ptr;
//unsigned char *alt_start_ptr, *alt_end_ptr;
//unsigned int z, z1, z2, z3, z5, speed_point, course_point, alt_point, speed_len, course_len, alt_len;
////unsigned char z4, gga, gsa1, gsa2, rmc;
//int rmc_len, gga_len, gsa1_len, gsa2_len;
//
////_LATB6 = 1;
//
////z1 = 0; z2 = 0; z3 = 0, z5 = 0;
////gga = 0x30; gsa1 = 0x30; gsa2 = 0x30; rmc = 0x30;
//speed_point = 0;
//course_point = 0;
//
//const unsigned char str1[] = "\r\n\0";
//const unsigned char str2[] = ",\0";
//const unsigned char str3[] = ".\0";
//const unsigned char str4[] = "*\0";
//const unsigned char RMC[]  = "RMC\0";
//const unsigned char GGA[]  = "GGA\0";
//const unsigned char GSA[]  = "GSA\0";
//
//unsigned int rmc_comma_ptrs [17];
//unsigned int gga_comma_ptrs [18];
//unsigned int gsa2_comma_ptrs [21];
//
//
//if (UART2_buf[0] != '$') { restart_navdata_receiving(); return 0; }
//
//_LATB5 = 1;
//    IEC1bits.U2RXIE = 0;
//        memmove ( UART_Rx_copy_buf, UART2_buf, num_of_bytes_tmp ); //UART2_copy_buf
//        UART_Rx_copy_buf[num_of_bytes_tmp] = 0;
////        Start_accumulation = 0;
////        num_of_bytes = 0;
//    IEC1bits.U2RXIE = 1;
//_LATB5 = 0;
//
//	rmc_start_ptr = strstr(UART_Rx_copy_buf, RMC);	// start of RMC string
//	rmc_end_ptr = strstr(rmc_start_ptr + 40, str1);  // end of RMC string
//	rmc_len = (rmc_end_ptr + 2) - rmc_start_ptr;	// length of RMC string
//            if (rmc_len > 74) {  return 0; } // restart_navdata_receiving();
//	gga_start_ptr = strstr(UART_Rx_copy_buf + 1, GGA);	//start of GGA string
//	gga_end_ptr = strstr(gga_start_ptr + 40, str1);	// end of GGA string
//	gga_len = (gga_end_ptr + 2) - (gga_start_ptr - 3);//length of GGA string
//            if (gga_len > 83) {  return 0; }// restart_navdata_receiving();
//        gsa1_start_ptr = strstr(UART_Rx_copy_buf + 1 + 1, GSA); //start of GSA1 string
//        gsa1_end_ptr = strstr(gsa1_start_ptr + 15, str1); //end of GSA1 string
//        gsa1_len = (gsa1_end_ptr + 2) - (gsa1_start_ptr - 3); // length of GSA1 string
//            if (gsa1_len > 79) {  return 0; }// restart_navdata_receiving();
//	gsa2_start_ptr = strstr(gsa1_end_ptr, GSA); // start of GSA2
//	if (gsa2_start_ptr != 0) {		// if GSA2 string exists
//		gsa2_end_ptr = strstr(gsa2_start_ptr + 15, str1);// end of GSA2
//		gsa2_len = (gsa2_end_ptr + 2) - (gsa2_start_ptr - 3);//length ofGSA2
//		if (gsa2_len > 79) {  return 0; }// restart_navdata_receiving();
//	}
//
//
//unsigned char check_summ, check_summ1, check_summ2;
//int *cptr; // было int *cptr;
//check_summ = 0;
//check_summ1 = 0;
//check_summ2 = 0;
//
//
//// Check summ and comma's pointers of RMC string
//    cptr = rmc_comma_ptrs;
//    *cptr = 0;
//    cptr++;
//    tmp_ptr = rmc_start_ptr - 2;
//    tmp_ptr2 = rmc_end_ptr - 3;
//    while (tmp_ptr < tmp_ptr2) {
//            check_summ = check_summ ^ *tmp_ptr;
//            if (*tmp_ptr == ',') {*cptr = tmp_ptr; cptr++;} // здесь возникает трап аддресс
//            tmp_ptr++;
//    }
//    *cptr = 0;
//    check_summ1 = *(rmc_end_ptr - 2);
//    check_summ2 = *(rmc_end_ptr - 1);
//    if (check_summ1 > 0x40) check_summ1 = check_summ1 - 0x37;
//    else check_summ1 = check_summ1 - 0x30;
//    if (check_summ2 > 0x40) check_summ2 = check_summ2 - 0x37;
//    else check_summ2 = check_summ2 - 0x30;
//    check_summ1 = (check_summ1 << 4) + check_summ2;
//    if (check_summ != check_summ1) {  return 0; }// restart_navdata_receiving();
//
//
//// Check summ and comma's pointers of GSA2 string
//    check_summ = 0;
//    cptr = gsa2_comma_ptrs;
//    *cptr = 0;
//    cptr++;
//    tmp_ptr = gsa2_start_ptr - 2;
//    tmp_ptr2 = gsa2_end_ptr - 3;
//        while (tmp_ptr < tmp_ptr2) {
//            check_summ = check_summ ^ *tmp_ptr;
//            if (*tmp_ptr == ',') { *cptr = tmp_ptr; cptr++; }
//            tmp_ptr++;
//        }
//    if (gsa2_start_ptr != 0) { // GSA2 string exist
//        *cptr = 0;
//        check_summ1 = *(gsa2_end_ptr - 2);
//        check_summ2 = *(gsa2_end_ptr - 1);
//        if (check_summ1 > 0x40) check_summ1 = check_summ1 - 0x37;
//        else check_summ1 = check_summ1 - 0x30;
//        if (check_summ2 > 0x40) check_summ2 = check_summ2 - 0x37;
//        else check_summ2 = check_summ2 - 0x30;
//        check_summ1 = (check_summ1 << 4) + check_summ2;
//        if (check_summ != check_summ1) {  return 0; }// restart_navdata_receiving();
//    }
//
//// Check summ and comma's pointers of GGA string
//    check_summ = 0;
//    cptr = gga_comma_ptrs;
//    *cptr = 0;
//    cptr++;
//    tmp_ptr = gga_start_ptr - 2;
//    tmp_ptr2 = gga_end_ptr - 3;
//    while (tmp_ptr < tmp_ptr2) {
//            check_summ = check_summ ^ *tmp_ptr;
//            if (*tmp_ptr == ',') {*cptr = tmp_ptr; cptr++;}
//            tmp_ptr++;
//    }
//    *cptr = 0;
//    check_summ1 = *(gga_end_ptr - 2);
//    check_summ2 = *(gga_end_ptr - 1);
//    if (check_summ1 > 0x40) check_summ1 = check_summ1 - 0x37;
//    else check_summ1 = check_summ1 - 0x30;
//    if (check_summ2 > 0x40) check_summ2 = check_summ2 - 0x37;
//    else check_summ2 = check_summ2 - 0x30;
//    check_summ1 = (check_summ1 << 4) + check_summ2;
//    if (check_summ != check_summ1) {  return 0; }// restart_navdata_receiving();
//
//// Type of navigation P - GPS, L - GLONASS, N - GPS+GLONASS
//	tmp_ptr = gsa1_start_ptr;
//        Navi_str [66] = *(--tmp_ptr);
//        Navi_str [67] = ',';
//// Status of fix: V - not correct, A - correct
//	tmp_ptr = rmc_comma_ptrs[2];
////	Navigation_mode_ind = *(++tmp_ptr);
//        Navi_str [60] = *(++tmp_ptr);
//        Navi_str [61] = ',';
//// 1 - not correct fix, 2 - 2D fix, 3 - 3D fix
//       	tmp_ptr = gsa1_start_ptr;
////	Mode_of_operation = *(tmp_ptr + 6);
//        Navi_str [64] = *(tmp_ptr + 6);
//        Navi_str [65] = ',';
//// N - not correct, E - not anought satellites, A - autonomous, D - differential
//    tmp_ptr = rmc_comma_ptrs[12];
//        Navi_str [62] = *(++tmp_ptr);
//        Navi_str [63] = ',';
//
//// Time
//	tmp_ptr = rmc_comma_ptrs[1];
//        Navi_str [0] =  *(++tmp_ptr); Navi_str [1] = *(++tmp_ptr);
//        Navi_str [2] =  *(++tmp_ptr); Navi_str [3] = *(++tmp_ptr);
//        Navi_str [4] =  *(++tmp_ptr); Navi_str [5] = *(++tmp_ptr);
//        Navi_str [6] =  *(++tmp_ptr); Navi_str [7] = *(++tmp_ptr);
//        Navi_str [8] = ',';
//
///* Latitude*/
//    tmp_ptr = rmc_comma_ptrs[3];
//        Navi_str [16] = *(++tmp_ptr);	Navi_str [17] = *(++tmp_ptr);
//        Navi_str [18] = *(++tmp_ptr);	Navi_str [19] = *(++tmp_ptr);
//        Navi_str [20] = *(++tmp_ptr);	Navi_str [21] = *(++tmp_ptr);
//        Navi_str [22] = *(++tmp_ptr);	Navi_str [23] = *(++tmp_ptr);
//        Navi_str [24] = *(++tmp_ptr);
//        if (Navi_str [24] == ',') Navi_str [24] = '0';
//            Navi_str [25] = ',';
//        tmp_ptr = rmc_comma_ptrs[4];
//        Navi_str[26] = *(++tmp_ptr);
//            Navi_str[27] = ',';
//
///* Longitude*/
//	tmp_ptr = rmc_comma_ptrs[5];
//        Navi_str [28] = *(++tmp_ptr);	Navi_str [29] = *(++tmp_ptr);
//        Navi_str [30] = *(++tmp_ptr);	Navi_str [31] = *(++tmp_ptr);
//        Navi_str [32] = *(++tmp_ptr);	Navi_str [33] = *(++tmp_ptr);
//        Navi_str [34] = *(++tmp_ptr);	Navi_str [35] = *(++tmp_ptr);
//        Navi_str [36] = *(++tmp_ptr);	Navi_str [37] = *(++tmp_ptr);
//        if (Navi_str [37] == ',') Navi_str [37] = '0';
//            Navi_str [38] = ',';
//            tmp_ptr = rmc_comma_ptrs[6];
//        Navi_str [39] = *(++tmp_ptr);
//            Navi_str [40] = ',';
//
///* Speed*/
//	tmp_ptr = Navi_str; tmp_ptr = tmp_ptr + 48;
//	tmp_ptr3 = tmp_ptr + 4;
//	tmp_ptr2 = rmc_comma_ptrs[8];
//	tmp_ptr4 = rmc_comma_ptrs[7];
//	tmp_ptr--; tmp_ptr2--; tmp_ptr4++;
//	while (tmp_ptr2 >= tmp_ptr4) {
//            if (tmp_ptr3 == tmp_ptr) break;
//            *tmp_ptr3 = *tmp_ptr2;
//            tmp_ptr2--; tmp_ptr3--;
//	}
//	while (tmp_ptr3 > tmp_ptr) {
//            *tmp_ptr3 = '0';
//            tmp_ptr3--;
//	}
//	Navi_str[53] = ',';
//
///* Course*/
//       	tmp_ptr = Navi_str; tmp_ptr = tmp_ptr + 54;
//	tmp_ptr3 = tmp_ptr + 4;
//	tmp_ptr2 = rmc_comma_ptrs[9];
//	tmp_ptr4 = rmc_comma_ptrs[8];
//	tmp_ptr--; tmp_ptr2--; tmp_ptr4++;
//	while (tmp_ptr2 >= tmp_ptr4) {
//            if (tmp_ptr3 == tmp_ptr) break;
//            *tmp_ptr3 = *tmp_ptr2;
//            tmp_ptr2--; tmp_ptr3--;
//	}
//	while (tmp_ptr3 > tmp_ptr) {
//            *tmp_ptr3 = '0';
//            tmp_ptr3--;
//	}
//	Navi_str[59] = ',';
//
///* Date*/
//       	tmp_ptr = rmc_comma_ptrs[9];	tmp_ptr2 = rmc_comma_ptrs[10];
//	memmove(Navi_str + 9, tmp_ptr + 1, tmp_ptr2 - tmp_ptr - 1);
//        Navi_str [15] = ',';
//
///* Altitude*/
//	tmp_ptr = Navi_str; tmp_ptr = tmp_ptr + 41;
//        tmp_ptr3 = tmp_ptr + 5;
//	tmp_ptr2 = gga_comma_ptrs[10];	tmp_ptr4 = gga_comma_ptrs[9];
//	tmp_ptr--; tmp_ptr2--; tmp_ptr4++;
//
//	while (tmp_ptr2 >= tmp_ptr4) {
//            if (tmp_ptr3 == tmp_ptr) break;
//            *tmp_ptr3 = *tmp_ptr2;
//            tmp_ptr2--; tmp_ptr3--;
//	}
//	while (tmp_ptr3 > tmp_ptr) {
//            *tmp_ptr3 = '0';
//            tmp_ptr3--;
//	}
//	Navi_str[47] = ',';
//        
// /* Full number of satellits in view */
//      	tmp_ptr = gga_comma_ptrs[7];
//	Navi_str[68] = *(++tmp_ptr);
//	Navi_str[69] = *(++tmp_ptr);
//	Navi_str[70] = ',';
//
// /* Calculation number of GPS and GLONASS satellites separately */
//        if (Navi_str[66] == 'P') { // Only GPS using
//            Navi_str[71] = '0';
//            Navi_str[72] = '0';
//        }
//        if (Navi_str[66] == 'L') { // Only GLONASS using
//            Navi_str[71] = Navi_str[68];
//            Navi_str[72] = Navi_str[69];
//        }
//
//unsigned char i;        
//        if (Navi_str[66] == 'N') { // Combyne
//            GL_sat_number = 0;
//    // If second GSA string exists then colculate number of GLONASS satellites
//            if (gsa2_start_ptr != 0) {
//                i = 3;
//                while ((gsa2_comma_ptrs[i] + 1) != gsa2_comma_ptrs[i+1] ) {
//                    i++;
//                    GL_sat_number++;
//                }
//            }
//            bin_2_bcd ((long)GL_sat_number);
//            Navi_str[71] = bin_2_bcd_buf [7];
//            Navi_str[72] = bin_2_bcd_buf [8];
//        }
//	Navi_str[73] = 0;
//        nav_trigger = 1;
//        
//        load_nav_telit_buf ();
//
////unsigned char Sat_number1_tmp, Sat_number2_tmp;
//float navi_temp;
//unsigned long navi_tmp, navi_tmp1;
//	navi_tmp = 0; 	navi_temp = 0;
//	Lat1 = 10 * (Navi_str[16] - 0x30) + (Navi_str[17] - 0x30);
//	navi_tmp = 10*(Navi_str[18]-0x30)+(Navi_str[19]-0x30);
//	navi_tmp = 10 * navi_tmp + (Navi_str[21]-0x30);
//	navi_tmp = 10 * navi_tmp + (Navi_str[22]-0x30);
//	navi_tmp = 10 * navi_tmp + (Navi_str[23]-0x30);
//	navi_tmp = 10 * navi_tmp + (Navi_str[24]-0x30);
//	navi_temp = (float)navi_tmp;
//	navi_temp =	navi_temp / 600000.0;
//	Lat1 = 	Lat1 + navi_temp;
//
//	navi_tmp = 0; navi_tmp1 = 0;	navi_temp = 0;
//unsigned char dig1, dig2, dig3, dig4, dig5, dig6;    
//	navi_tmp1 = 1000000 * (Navi_str[28] - 0x30) + 100000 * (Navi_str[29] - 0x30) + 10000 * (Navi_str[30] - 0x30);
//
//	dig1 = (Navi_str[31] - 0x30); dig2 = (Navi_str[32] - 0x30); dig3 = (Navi_str[34] - 0x30);
//	dig4 = (Navi_str[35] - 0x30); dig5 = (Navi_str[36] - 0x30); dig6 = (Navi_str[37] - 0x30);
//	navi_tmp =            100000 * (unsigned long)dig1; navi_tmp = navi_tmp + 10000  * (unsigned long)dig2;
//    navi_tmp = navi_tmp + 1000   * (unsigned long)dig3; navi_tmp = navi_tmp + 100    * (unsigned long)dig4;
//    navi_tmp = navi_tmp + 10     * (unsigned long)dig5; navi_tmp = navi_tmp +          (unsigned long)dig6;
//    navi_tmp = (navi_tmp + 30)/60;
//    
//    navi_tmp = navi_tmp + navi_tmp1;
//    Long1 = (float) navi_tmp;
//    
////	Long1 = 100.0 * (Navi_str[28] - 0x30) + 10 * (Navi_str[29] - 0x30) + (Navi_str[30] - 0x30);
////	navi_tmp = 10*(10*(10*(10*(Navi_str[31]-0x30)+(Navi_str[32]-0x30))+(Navi_str[34]-0x30))+(Navi_str[35]-0x30))+(Navi_str[36]-0x30);
////	navi_tmp = navi_tmp * 10 + (Navi_str[37]-0x30);
////	navi_temp = (float)navi_tmp;
////	navi_temp =	navi_temp / 600000.0;
////	Long1 = 	Long1 + navi_temp;
//
///* Distance between two points*/
//float fi, lambda, sin2_fi, sin2_lambda, cos_lat1, cos_lat2;
//	Lat1 = Lat1 * 0.0174533;
//	Long1 = Long1 * 0.0174533;
//	fi = (Lat1 - Lat2) / 2;
//	lambda = (Long1 - Long2) / 2;
//	sin2_fi = sinf(fi);
//	sin2_fi = sin2_fi * sin2_fi;
//	sin2_lambda = sinf(lambda);
//	sin2_lambda = sin2_lambda * sin2_lambda;
//	cos_lat1 = cosf(Lat1);
//	cos_lat2 = cosf(Lat2);
//	distance = cos_lat1 * cos_lat2;
//	distance = distance * sin2_lambda;
//	distance = distance + sin2_fi;
//	distance = sqrtf(distance);
//	distance = asinf(distance);
//	distance = 2* distance;
//	distance = 57.2957795 * distance;
//	distance = distance * 111.12;	// kilometers
//	distance = distance * 1000.0;	// meters
//
//	fix_to_fix_mileage = fix_to_fix_mileage + distance;
//
//// Heading
//	course2 = (Course_str [0] - 0x30) * 100;
//	course2 = course2 + (Course_str [1] - 0x30) * 10;
//	course2 = course2 + (Course_str [2] - 0x30);
//
//// Speed
//	navi_tmp = (Speed_str[0] - 0x30) * 1000;
//	navi_tmp = navi_tmp + (Speed_str[1] - 0x30) * 100;
//	navi_tmp = navi_tmp + (Speed_str[2] - 0x30) * 10;
//	navi_tmp = navi_tmp + (Speed_str[4] - 0x30);
//
//	navi_tmp =	navi_tmp * 1852; // From knots to km/h
//	navi_tmp =	(navi_tmp + 5000) / 10000;// From knots to km/h
//	if (navi_tmp > 255) navi_tmp = 255;
//	speed2 = (unsigned char)navi_tmp;
//	bin_2_bcd ((long)speed2);
//	Speed_str [0] = bin_2_bcd_buf[5];
//	Speed_str [1] = bin_2_bcd_buf[6];
//	Speed_str [2] = bin_2_bcd_buf[7];
//	Speed_str [3] = '.';
//	Speed_str [4] = '0';
//
//// Time
//unsigned int c;
//	time2 = (Time_str[0] - 0x30) * 36000; c = (Time_str[1] - 0x30) * 3600;
//	time2 = time2 + c; c = (Time_str[2] - 0x30) * 600;
//	time2 = time2 + c; c = (Time_str[3] - 0x30) * 60;
//	time2 = time2 + c; c = (Time_str[4] - 0x30) * 10;
//	time2 = time2 + c; c = (Time_str[5] - 0x30);
//	time2 = time2 + c;
//        
//        Lat2 = Lat1;
//	Long2 = Long1;
//
////restart_navdata_receiving();
//return 1;
//}

/*
int  send_through_udp1 ( int start ) {
    unsigned int temp; 
    static unsigned int length;
    static unsigned char *ptr_to_send;

    if (start == 1) GPRSSENDbits.start_sending = 1; // Запуск процесса передачи

        // Если AT+QISEND еще не отправлена в модем
        if ( GPRSSENDbits.start_sending == 1 && MODEMTASCKSbits.MODEMTASCKS == 0 ) {
                GPRSSENDbits.GPRSSEND = 0;
                GPRSSENDbits.at_qisend = 1;
                MODEMTASCKSbits.data_sending = 1; // Устанавливаем флаг занятости модема
                
                ptr_to_send = GPRS_nums_to_send_buf[GPRS_send_ptr_R]; //SMS_ptr_R GPRS_send_ptr_R
                length = *(ptr_to_send + 495);
                length = *(ptr_to_send + 496) + (length << 8);
                bin_2_bcd ((long ) length);
                AT_QISEND_LEN[10] = '0'; AT_QISEND_LEN[11] = bin_2_bcd_buf[6];
                AT_QISEND_LEN[12] = bin_2_bcd_buf[7]; AT_QISEND_LEN[13] = bin_2_bcd_buf[8];
                
                set_sgm_tasck_busy_timer (500);  // Таймаут сообщения модема об отсылке 2 секунды                
                load_UART1_Tx_buf1 (AT_QISEND_LEN, 15);
                start_UART1_transmission (WAITOFF, 15);
        }
         // AT+QISEND уже отправлена в модем и от модема получено >
        if ( GPRSSENDbits.at_qisend && GPRSSENDbits.cntrlz ) {
                GPRSSENDbits.at_qisend = 0;
                ACK_timer = 1;               // Запуск таймера акноледжа
                GPRSSENDbits.waiting_send_ok = 1;
                
                load_UART1_Tx_buf1 (ptr_to_send, length);
                start_UART1_transmission (WAITOFF, length);
        }

        if (ACK_timer > 0) {
            if ( ACK_timer == 2 ) { clear_gsm_task_busy_timer (); }
            if (GPRSSENDbits.received_ACK == 1) { // Пришел вовремя акноледж
                ACK_timer = 0;
            } else {
                if (ACK_timer < 30) {ACK_timer ++;} // Таймер акноледжа 5 секунд
                else { ACK_timer = 0; GPRSSENDbits.ACK_timeout_flag = 1; }
             }
        } // (ACK_timer > 0)

//# define GPRSSENDIDLE       0
//# define GPRSSENDWAITING    1
//# define QISENDRUNNING      2
//# define WAITINGSENDOK      3    
//# define WAITINGACK         4
//# define GPRSSENDSUCCESS    5
//# define SENDERROR         -1     
//# define SENDFAILE         -2
//# define QISENDTIMEOUT     -3
//# define GPRSACKTIMEOUT    -4 
//# define GPRSSENDEXCEPTION -5 

    if (GPRSSENDbits.GPRSSEND == 0b0000000000000000)     return GPRSSENDIDLE;   //
    if (GPRSSENDbits.GPRSSEND == 0b0000000000000001)     return GPRSSENDWAITING;//start_sending
    if (GPRSSENDbits.GPRSSEND == 0b0000000000000010)     return QISENDRUNNING;  //at_qisend
    if (GPRSSENDbits.GPRSSEND == 0b0000000000001100)     return WAITINGSENDOK;  //cntrlz && wating_ACK
    if (GPRSSENDbits.GPRSSEND == 0b0000000000101100) {                          //cntrlz && wating_ACK && send_ok 
//        MODEMTASCKSbits.data_sending = 0;
                                                         return WAITINGACK;     
    }
    if (GPRSSENDbits.GPRSSEND == 0b0000000000111100) {                          //cntrlz && wating_ACK && received_ACK && send_ok 
        MODEMTASCKSbits.data_sending = 0;
                                                         return GPRSSENDSUCCESS;
    }     
    if (GPRSSENDbits.GPRSSEND == 0b0000000010000010) {                          //cntrlz && wating_ACK && send_error
        MODEMTASCKSbits.data_sending = 0;
                                                         return SENDERROR;    
    }   
    if (GPRSSENDbits.GPRSSEND == 0b0000000001001100) {                          //cntrlz && wating_ACK && send_faile
        MODEMTASCKSbits.data_sending = 0;
                                                         return SENDFAILE;    
    }   
    if (GPRSSENDbits.GPRSSEND == 0b0000000100000010) {                          //cntrlz && wating_ACK && qisend_timeout
        MODEMTASCKSbits.data_sending = 0;
                                                         return QISENDTIMEOUT;    
    }   
    if (GPRSSENDbits.GPRSSEND == 0b0000001000101100) {                          //cntrlz && wating_ACK && send_ok && ACK_timeout_flag
        MODEMTASCKSbits.data_sending = 0;
                                                         return GPRSACKTIMEOUT;    
    }   
    
    return GPRSSENDEXCEPTION;

}  // Предача через UDP
int  send_through_udp_monitor (int send_through_udp_status, int server_connection_status) {

    
    if (send_through_udp_status == GPRSSENDIDLE && server_connection_status == 4) {
        Nop();Nop();Nop();
        if ( GPRS_send_ptr_R != GPRS_send_ptr_W ) send_through_udp1 (1); // Если задача свободна и есть данные для отправки - запуск отсылки SMS
    }
    if (send_through_udp_status == GPRSSENDWAITING) {
        Nop();Nop();Nop();
    }
    if (send_through_udp_status == QISENDRUNNING) {
        Nop();Nop();Nop();
    }    
    if (send_through_udp_status == WAITINGSENDOK) {
        Nop();Nop();Nop();
    }
    if (send_through_udp_status == WAITINGACK) {
        Nop();Nop();Nop();
    }    
    if (send_through_udp_status == GPRSSENDSUCCESS) {
        Nop();Nop();Nop();
        GPRSSENDbits.GPRSSEND = 0;
        GPRS_send_ptr_R ++; GPRS_send_ptr_R %= 5;             // Если GPRS отослана - инкремент указателя отсылки
        
    }
    if (send_through_udp_status == SENDERROR ) {
        Nop();Nop();Nop();
        GPRSSENDbits.GPRSSEND = 0;
        modem_on_off (MODEM_RESTART);
    }
    if (send_through_udp_status == SENDFAILE ) {
        Nop();Nop();Nop();
        GPRSSENDbits.GPRSSEND = 0;
    }
    if (send_through_udp_status == QISENDTIMEOUT ) {
        Nop();Nop();Nop();
        GPRSSENDbits.GPRSSEND = 0;
        modem_on_off (MODEM_RESTART);
    }    
    if (send_through_udp_status == GPRSACKTIMEOUT ) {
        Nop();Nop();Nop();
        GPRSSENDbits.GPRSSEND = 0;
        GPRS_send_ptr_R ++; GPRS_send_ptr_R %= 5; // Чтобы не ждать акноледж        
    }
    if (send_through_udp_status == GPRSSENDEXCEPTION ) {
        Nop();Nop();Nop();
        write_text_to_SMS_buf ( "GPRS send exception: ", PHONE_NUMBER );
        Nop();Nop();Nop();        
        GPRSSENDbits.GPRSSEND = 0;
        modem_on_off (MODEM_RESTART);
    }    
        
}
*/

/*для ML8088*/
//void __attribute__ ((__interrupt__, no_auto_psv)) _U2RXInterrupt(void) {
//
//IFS1bits.U2RXIF = 0;
//uart2_timeout_counter = 0;
//unsigned char uart2_temp;
//
//// Read the receive buffer till atleast one or more character can be read
//uart2_busy_flag = 1;
//    while(DataRdyUART2())	{
//	if (Start_accumulation == 0)	{
//	uart2_temp = ReadUART2();
//		if (uart2_temp == '$')	{
//                    Rx2_DataAvailable = 0;
//                    Start_accumulation = 1;
//                    uart2_temp = 0;
//                    UART2_buf[0] = '$';
//                    num_of_bytes = 1;
//		}
//	} else 
//          {
//               UART2_buf[num_of_bytes] = ReadUART2();
//               if (num_of_bytes < 1023) {num_of_bytes ++;}
//               else Start_accumulation = 0; 
////        	   if (num_of_bytes == 1023) Start_accumulation = 0;
////        	   num_of_bytes ++;
//		  }
//    } //while( DataRdyUART1())
//
//}
//int  get_navigation_data (void) {
//
//unsigned char  *rmc_end_ptr, *rmc_start_ptr, *gga_end_ptr, *gga_start_ptr, *gsa1_end_ptr, *gsa1_start_ptr;
//unsigned char  *gsa2_end_ptr, *gsa2_start_ptr, *tmp_ptr, *tmp_ptr2, *tmp_ptr3, *tmp_ptr4, *speed_start_ptr, *speed_end_ptr, *course_start_ptr, *course_end_ptr;
//unsigned char *alt_start_ptr, *alt_end_ptr;
//unsigned int z, z1, z2, z3, z5, speed_point, course_point, alt_point, speed_len, course_len, alt_len;
////unsigned char z4, gga, gsa1, gsa2, rmc;
//int rmc_len, gga_len, gsa1_len, gsa2_len;
//unsigned char GPGL_sat_number;
//unsigned char GL_sat_number;
//
//
////_LATB6 = 1;
//
////z1 = 0; z2 = 0; z3 = 0, z5 = 0;
////gga = 0x30; gsa1 = 0x30; gsa2 = 0x30; rmc = 0x30;
//speed_point = 0;
//course_point = 0;
//
//const unsigned char str1[] = "\r\n\0";
//const unsigned char str2[] = ",\0";
//const unsigned char str3[] = ".\0";
//const unsigned char str4[] = "*\0";
//const unsigned char RMC[]  = "RMC\0";
//const unsigned char GGA[]  = "GGA\0";
//const unsigned char GSA[]  = "GSA\0";
//
//unsigned int rmc_comma_ptrs [17];
//unsigned int gga_comma_ptrs [18];
//unsigned int gsa2_comma_ptrs [21];
//
//
//if (UART2_buf[0] != '$') { restart_navdata_receiving(); return 0; }
//
////_LATB5 = 1;
//    IEC1bits.U2RXIE = 0;
//        memmove ( UART_Rx_copy_buf, UART2_buf, num_of_bytes_tmp ); //UART2_copy_buf
//        UART_Rx_copy_buf[num_of_bytes_tmp] = 0;
////        Start_accumulation = 0;
////        num_of_bytes = 0;
//    IEC1bits.U2RXIE = 1;
////_LATB5 = 0;
//
//	rmc_start_ptr = strstr(UART_Rx_copy_buf, RMC);	// start of RMC string
//	rmc_end_ptr = strstr(rmc_start_ptr + 40, str1);  // end of RMC string
//	rmc_len = (rmc_end_ptr + 2) - rmc_start_ptr;	// length of RMC string
//            if (rmc_len > 74) {  return 0; } // restart_navdata_receiving();
//	gga_start_ptr = strstr(UART_Rx_copy_buf + 1, GGA);	//start of GGA string
//	gga_end_ptr = strstr(gga_start_ptr + 40, str1);	// end of GGA string
//	gga_len = (gga_end_ptr + 2) - (gga_start_ptr - 3);//length of GGA string
//            if (gga_len > 83) {  return 0; }// restart_navdata_receiving();
//        gsa1_start_ptr = strstr(UART_Rx_copy_buf + 1 + 1, GSA); //start of GSA1 string
//        gsa1_end_ptr = strstr(gsa1_start_ptr + 15, str1); //end of GSA1 string
//        gsa1_len = (gsa1_end_ptr + 2) - (gsa1_start_ptr - 3); // length of GSA1 string
//            if (gsa1_len > 79) {  return 0; }// restart_navdata_receiving();
//	gsa2_start_ptr = strstr(gsa1_end_ptr, GSA); // start of GSA2
//	if (gsa2_start_ptr != 0) {		// if GSA2 string exists
//		gsa2_end_ptr = strstr(gsa2_start_ptr + 15, str1);// end of GSA2
//		gsa2_len = (gsa2_end_ptr + 2) - (gsa2_start_ptr - 3);//length ofGSA2
//		if (gsa2_len > 79) {  return 0; }// restart_navdata_receiving();
//	}
//
//
//unsigned char check_summ, check_summ1, check_summ2;
//int *cptr; // было int *cptr;
//check_summ = 0;
//check_summ1 = 0;
//check_summ2 = 0;
//
//
//// Check summ and comma's pointers of RMC string
//    cptr = rmc_comma_ptrs;
//    *cptr = 0;
//    cptr++;
//    tmp_ptr = rmc_start_ptr - 2;
//    tmp_ptr2 = rmc_end_ptr - 3;
//    while (tmp_ptr < tmp_ptr2) {
//            check_summ = check_summ ^ *tmp_ptr;
//            if (*tmp_ptr == ',') {*cptr = tmp_ptr; cptr++;} // здесь возникает трап аддресс
//            tmp_ptr++;
//    }
//    *cptr = 0;
//    check_summ1 = *(rmc_end_ptr - 2);
//    check_summ2 = *(rmc_end_ptr - 1);
//    if (check_summ1 > 0x40) check_summ1 = check_summ1 - 0x37;
//    else check_summ1 = check_summ1 - 0x30;
//    if (check_summ2 > 0x40) check_summ2 = check_summ2 - 0x37;
//    else check_summ2 = check_summ2 - 0x30;
//    check_summ1 = (check_summ1 << 4) + check_summ2;
//    if (check_summ != check_summ1) {  return 0; }// restart_navdata_receiving();
//
//
//// Check summ and comma's pointers of GSA2 string
//    check_summ = 0;
//    cptr = gsa2_comma_ptrs;
//    *cptr = 0;
//    cptr++;
//    tmp_ptr = gsa2_start_ptr - 2;
//    tmp_ptr2 = gsa2_end_ptr - 3;
//        while (tmp_ptr < tmp_ptr2) {
//            check_summ = check_summ ^ *tmp_ptr;
//            if (*tmp_ptr == ',') { *cptr = tmp_ptr; cptr++; }
//            tmp_ptr++;
//        }
//    if (gsa2_start_ptr != 0) { // GSA2 string exist
//        *cptr = 0;
//        check_summ1 = *(gsa2_end_ptr - 2);
//        check_summ2 = *(gsa2_end_ptr - 1);
//        if (check_summ1 > 0x40) check_summ1 = check_summ1 - 0x37;
//        else check_summ1 = check_summ1 - 0x30;
//        if (check_summ2 > 0x40) check_summ2 = check_summ2 - 0x37;
//        else check_summ2 = check_summ2 - 0x30;
//        check_summ1 = (check_summ1 << 4) + check_summ2;
//        if (check_summ != check_summ1) {  return 0; }// restart_navdata_receiving();
//    }
//
//// Check summ and comma's pointers of GGA string
//    check_summ = 0;
//    cptr = gga_comma_ptrs;
//    *cptr = 0;
//    cptr++;
//    tmp_ptr = gga_start_ptr - 2;
//    tmp_ptr2 = gga_end_ptr - 3;
//    while (tmp_ptr < tmp_ptr2) {
//            check_summ = check_summ ^ *tmp_ptr;
//            if (*tmp_ptr == ',') {*cptr = tmp_ptr; cptr++;}
//            tmp_ptr++;
//    }
//    *cptr = 0;
//    check_summ1 = *(gga_end_ptr - 2);
//    check_summ2 = *(gga_end_ptr - 1);
//    if (check_summ1 > 0x40) check_summ1 = check_summ1 - 0x37;
//    else check_summ1 = check_summ1 - 0x30;
//    if (check_summ2 > 0x40) check_summ2 = check_summ2 - 0x37;
//    else check_summ2 = check_summ2 - 0x30;
//    check_summ1 = (check_summ1 << 4) + check_summ2;
//    if (check_summ != check_summ1) {  return 0; }// restart_navdata_receiving();
//
//// Type of navigation P - GPS, L - GLONASS, N - GPS+GLONASS
//	tmp_ptr = gsa1_start_ptr;
//        Navi_str [68] = *(--tmp_ptr);
//        Navi_str [69] = ',';
//// Status of fix: V - not correct, A - correct
//	tmp_ptr = rmc_comma_ptrs[2];
////	Navigation_mode_ind = *(++tmp_ptr);
//        Navi_str [62] = *(++tmp_ptr);
//        Navi_str [63] = ',';
//// 1 - not correct fix, 2 - 2D fix, 3 - 3D fix
//       	tmp_ptr = gsa1_start_ptr;
////	Mode_of_operation = *(tmp_ptr + 6);
//        Navi_str [66] = *(tmp_ptr + 6);
//        Navi_str [67] = ',';
//// N - not correct, E - not anought satellites, A - autonomous, D - differential
//    tmp_ptr = rmc_comma_ptrs[12];
//        Navi_str [64] = *(++tmp_ptr);
//        Navi_str [65] = ',';
//
//// Time
//	tmp_ptr = rmc_comma_ptrs[1];
//        Navi_str [0] =  *(++tmp_ptr); Navi_str [1] = *(++tmp_ptr);
//        Navi_str [2] =  *(++tmp_ptr); Navi_str [3] = *(++tmp_ptr);
//        Navi_str [4] =  *(++tmp_ptr); Navi_str [5] = *(++tmp_ptr);
//        Navi_str [6] =  *(++tmp_ptr); Navi_str [7] = *(++tmp_ptr);
//        Navi_str [8] = ',';
//
///* Latitude*/
//    tmp_ptr = rmc_comma_ptrs[3];
//        Navi_str [16] = *(++tmp_ptr);	Navi_str [17] = *(++tmp_ptr);
//        Navi_str [18] = *(++tmp_ptr);	Navi_str [19] = *(++tmp_ptr);
//        Navi_str [20] = *(++tmp_ptr);	Navi_str [21] = *(++tmp_ptr);
//        Navi_str [22] = *(++tmp_ptr);	Navi_str [23] = *(++tmp_ptr);
//        Navi_str [24] = *(++tmp_ptr);   Navi_str [25] = *(++tmp_ptr);
//        Navi_str [26] = ',';
///*N/S*/        
//        tmp_ptr = rmc_comma_ptrs[4];
//        Navi_str[27] = *(++tmp_ptr);
//        Navi_str[28] = ',';
//
///* Longitude*/
//	tmp_ptr = rmc_comma_ptrs[5];
//        Navi_str [29] = *(++tmp_ptr);	Navi_str [30] = *(++tmp_ptr);
//        Navi_str [31] = *(++tmp_ptr);	Navi_str [32] = *(++tmp_ptr);
//        Navi_str [33] = *(++tmp_ptr);	Navi_str [34] = *(++tmp_ptr);
//        Navi_str [35] = *(++tmp_ptr);	Navi_str [36] = *(++tmp_ptr);
//        Navi_str [37] = *(++tmp_ptr);	Navi_str [38] = *(++tmp_ptr);
//        Navi_str [39] = *(++tmp_ptr);
//        Navi_str [40] = ',';
//            
//        tmp_ptr = rmc_comma_ptrs[6];
//        Navi_str [41] = *(++tmp_ptr);
//        Navi_str [42] = ',';
//
///* Speed*/
////	tmp_ptr = Navi_str; tmp_ptr = tmp_ptr + 48;
//    tmp_ptr  = &Navi_str[50];
//	tmp_ptr3 = &Navi_str[54];
//	tmp_ptr2 = rmc_comma_ptrs[8];
//	tmp_ptr4 = rmc_comma_ptrs[7];
//	tmp_ptr--; tmp_ptr2--; tmp_ptr4++;
//	while (tmp_ptr2 >= tmp_ptr4) {
//            if (tmp_ptr3 == tmp_ptr) break;
//            *tmp_ptr3 = *tmp_ptr2;
//            tmp_ptr2--; tmp_ptr3--;
//	}
//	while (tmp_ptr3 > tmp_ptr) {
//            *tmp_ptr3 = '0';
//            tmp_ptr3--;
//	}
//	Navi_str[55] = ',';
//
///* Course*/
//    tmp_ptr  = &Navi_str[56];
//	tmp_ptr3 = &Navi_str[60];
//	tmp_ptr2 = rmc_comma_ptrs[9];
//	tmp_ptr4 = rmc_comma_ptrs[8];
//	tmp_ptr--; tmp_ptr2--; tmp_ptr4++;
//	while (tmp_ptr2 >= tmp_ptr4) {
//            if (tmp_ptr3 == tmp_ptr) break;
//            *tmp_ptr3 = *tmp_ptr2;
//            tmp_ptr2--; tmp_ptr3--;
//	}
//	while (tmp_ptr3 > tmp_ptr) {
//            *tmp_ptr3 = '0';
//            tmp_ptr3--;
//	}
//	Navi_str[61] = ',';
//
///* Date*/
//       	tmp_ptr = rmc_comma_ptrs[9];	tmp_ptr2 = rmc_comma_ptrs[10];
//	memmove(Navi_str + 9, tmp_ptr + 1, tmp_ptr2 - tmp_ptr - 1);
//        Navi_str [15] = ',';
//
///* Altitude*/
//	tmp_ptr = &Navi_str[43];
//    tmp_ptr3 = tmp_ptr + 5;
//	tmp_ptr2 = gga_comma_ptrs[10];	tmp_ptr4 = gga_comma_ptrs[9];
//	tmp_ptr--; tmp_ptr2--; tmp_ptr4++;
//
//	while (tmp_ptr2 >= tmp_ptr4) {
//            if (tmp_ptr3 == tmp_ptr) break;
//            *tmp_ptr3 = *tmp_ptr2;
//            tmp_ptr2--; tmp_ptr3--;
//	}
//	while (tmp_ptr3 > tmp_ptr) {
//            *tmp_ptr3 = '0';
//            tmp_ptr3--;
//	}
//	Navi_str[49] = ',';
//        
// /* Full number of satellits in view */
//    tmp_ptr = gga_comma_ptrs[7];
//	Navi_str[70] = *(++tmp_ptr);
//	Navi_str[71] = *(++tmp_ptr);
//	Navi_str[72] = ',';
//    GPGL_sat_number = 0;
//    GPGL_sat_number = 10 * (Navi_str[70] - 0x30) + (Navi_str[71] - 0x30);
//    if (GPGL_sat_number > 15) GPGL_sat_number = 15;
// /* Calculation number of GPS and GLONASS satellites separately */
//        if (Navi_str[68] == 'P') { // Only GPS using
//            Navi_str[73] = '0';
//            Navi_str[74] = '0';
//        }
//        if (Navi_str[68] == 'L') { // Only GLONASS using
//            Navi_str[73] = Navi_str[70];
//            Navi_str[74] = Navi_str[71];
//        }
//
//unsigned char i;        
//        if (Navi_str[68] == 'N') { // Combyne
//            GL_sat_number = 0;
//    // If second GSA string exists then colculate number of GLONASS satellites
//            if (gsa2_start_ptr != 0) {
//                i = 3;
//                while ((gsa2_comma_ptrs[i] + 1) != gsa2_comma_ptrs[i+1] ) {
//                    i++;
//                    GL_sat_number++;
//                }
//            }
//            bin_2_bcd ((long)GL_sat_number);
//            Navi_str[73] = bin_2_bcd_buf [7];
//            Navi_str[74] = bin_2_bcd_buf [8];
//        }
//            Navi_str[75] = 0;
//    
//        nav_trigger = 1;
//        FIXFLAGSbits.ready = 1;
//        
//        load_nav_telit_buf ();
//
//
//unsigned char dig1, dig2, dig3, dig4, dig5, dig6, dig7, gig8, dig9, dig10;         
//unsigned long navi_tmp, navi_tmp1, navi_tmp2;
//int Alt;
//// Lattitude
//	navi_tmp = 0; navi_tmp1 = 0;
//    navi_tmp1 = 100000000 * (unsigned long)(Navi_str[16] - 0x30) + 10000000 * (unsigned long)(Navi_str[17] - 0x30);
//	dig1 = (Navi_str[18] - 0x30); dig2 = (Navi_str[19] - 0x30); dig3 = (Navi_str[21] - 0x30);
//	dig4 = (Navi_str[22] - 0x30); dig5 = (Navi_str[23] - 0x30); dig6 = (Navi_str[24] - 0x30);
//    dig7 = (Navi_str[25] - 0x30);
//	navi_tmp =            100000000 * (unsigned long)dig1; navi_tmp = navi_tmp + 10000000  * (unsigned long)dig2;
//    navi_tmp = navi_tmp + 1000000   * (unsigned long)dig3; navi_tmp = navi_tmp + 100000    * (unsigned long)dig4;
//    navi_tmp = navi_tmp + 10000     * (unsigned long)dig5; navi_tmp = navi_tmp + 1000      * (unsigned long)dig6;
//    navi_tmp = navi_tmp + 100       * (unsigned long)dig7;
//    navi_tmp = (navi_tmp + 30)/60;
//    navi_tmp1 = navi_tmp1 + navi_tmp;
//    Lat1 = (float) navi_tmp1 / 10000000.0;
//// Longitude    
//	navi_tmp = 0; navi_tmp2 = 0;
//    navi_tmp2 = 1000000000 * (Navi_str[29] - 0x30) + 100000000 * (Navi_str[30] - 0x30) + 10000000 * (Navi_str[31] - 0x30);
//	dig1 = (Navi_str[32] - 0x30); dig2 = (Navi_str[33] - 0x30); dig3 = (Navi_str[35] - 0x30);
//	dig4 = (Navi_str[36] - 0x30); dig5 = (Navi_str[37] - 0x30); dig6 = (Navi_str[38] - 0x30);
//    dig7 = (Navi_str[39] - 0x30);
//	navi_tmp =            100000000 * (unsigned long)dig1; navi_tmp = navi_tmp + 10000000  * (unsigned long)dig2;
//    navi_tmp = navi_tmp + 1000000   * (unsigned long)dig3; navi_tmp = navi_tmp + 100000    * (unsigned long)dig4;
//    navi_tmp = navi_tmp + 10000     * (unsigned long)dig5; navi_tmp = navi_tmp + 1000      * (unsigned long)dig6;
//    navi_tmp = navi_tmp + 100       * (unsigned long)dig7;
//    navi_tmp = (navi_tmp + 30)/60;
//    navi_tmp2 = navi_tmp2 + navi_tmp;
//    Long1 = (float)navi_tmp2 / 10000000.0;
//// Altitude
//    Alt = 0;
//    if (Navi_str[43] == '-') {
//        Alt = 10 * (Navi_str[44] - 0x30) + (Navi_str[45] - 0x30);
//        Alt = Alt * (-1);
//    }
//    else {
//        Alt = 100 * (Navi_str[43] - 0x30) + 10 * (Navi_str[44] - 0x30) + (Navi_str[45] - 0x30);
//    }
//    
//// Heading
//	course2 =           (Navi_str [56] - 0x30) * 100;
//	course2 = course2 + (Navi_str [57] - 0x30) * 10;
//	course2 = course2 + (Navi_str [58] - 0x30);
//    
//// Speed
//	navi_tmp =            (Navi_str[50] - 0x30) * 1000;
//	navi_tmp = navi_tmp + (Navi_str[51] - 0x30) * 100;
//	navi_tmp = navi_tmp + (Navi_str[52] - 0x30) * 10;
//	navi_tmp = navi_tmp + (Navi_str[54] - 0x30);
//	navi_tmp =	navi_tmp * 1852; navi_tmp =	(navi_tmp + 5000) / 10000; // From knots to km/h
//	if (navi_tmp > 255) navi_tmp = 255;
//	speed2 = (unsigned char)navi_tmp;
//
//    if (speed2 > max_speed) max_speed = speed2;
//    
//    load_navi_bin ( navi_tmp1, navi_tmp2, Alt, speed2, course2, GPGL_sat_number, GL_sat_number );
//    
///* Distance between two points*/
//float fi, lambda, sin2_fi, sin2_lambda, cos_lat1, cos_lat2;
//	Lat1  = Lat1  * 0.0174533;
//	Long1 = Long1 * 0.0174533;
//	fi = (Lat1 - Lat2) / 2.0;
//	lambda = (Long1 - Long2) / 2.0;
//	sin2_fi = sinf(fi);
//	sin2_fi = sin2_fi * sin2_fi;
//	sin2_lambda = sinf(lambda);
//	sin2_lambda = sin2_lambda * sin2_lambda;
//	cos_lat1 = cosf(Lat1);
//	cos_lat2 = cosf(Lat2);
//	distance = cos_lat1 * cos_lat2;
//	distance = distance * sin2_lambda;
//	distance = distance + sin2_fi;
//	distance = sqrtf(distance);
//	distance = asinf(distance);
//	distance = 2.0 * distance;
//	distance = 57.2957795 * distance;
//	distance = distance * 111.12;	// kilometers
//	distance = distance * 1000.0;	// meters
//
//	fix_to_fix_mileage = fix_to_fix_mileage + distance;
//
//static unsigned char odo_counter = 0;
//
//    if (ignition == 1) {
//        if ( odo_counter < 2 ) {
//            odo_counter ++;
//            GPS_odometer = GPS_odometer + distance;
//        }
//        else odo_counter = 0;
//    }
//
//
//// Time
//unsigned int c;
//	time2 = (Navi_str[0] - 0x30) * 36000; c = (Navi_str[1] - 0x30) * 3600;
//	time2 = time2 + c; c = (Navi_str[2] - 0x30) * 600;
//	time2 = time2 + c; c = (Navi_str[3] - 0x30) * 60;
//	time2 = time2 + c; c = (Navi_str[4] - 0x30) * 10;
//	time2 = time2 + c; c = (Navi_str[5] - 0x30);
//	time2 = time2 + c;
//        
//    Lat2  = Lat1;
//	Long2 = Long1;
//
////restart_navdata_receiving();
//return 1;
//}

/*
    unsigned int x;
//unsigned char temp_buf[] = "$GNGGA,175444.000,5543.1547,N,03727.3508,E,1,10,1.03,177.2,M,14.6,M,,*79\r\n$GNGLL,5543.1547,N,03727.3508,E,175444.000,A,A*4F\r\n$GPGSA,A,3,26,03,25,31,32,01,23,,,,,,1.29,1.03,0.79*07\r\n$GLGSA,A,3,77,68,67,,,,,,,,,,1.29,1.03,0.79*17\r\n$GPGSV,4,1,13,03,78,157,30,23,64,240,31,31,39,058,22,32,39,121,25*7E\r\n$GPGSV,4,2,13,06,24,316,17,01,23,188,21,09,23,248,17,26,12,104,21*7C\r\n$GPGSV,4,3,13,25,11,019,10,17,09,269,,11,02,191,,04,02,173,*78\r\n$GPGSV,4,4,13,36,,,*7E\r\n$GLGSV,3,1,10,68,60,086,24,69,59,302,,78,52,111,,77,32,035,24*6C\r\n$GLGSV,3,2,10,85,30,318,18,84,27,260,,79,22,160,,67,08,101,15*61\r\n$GLGSV,3,3,10,70,05,287,,86,05,004,*64\r\n$GNRMC,175444.000,A,5543.1547,N,03727.3508,E,0.04,67.61,260915,,,A*43\r\n$GNVTG,67.61,T,,M,0.04,N,0.07,K,A*16\r\n\0";    
//unsigned char temp_buf[] = "$GNGGA,175444.000,5543.1547,N,03727.3508,E,1,10,1.03,177.2,M,14.6,M,,*79\r\n$GNGLL,5543.1547,N,03727.3508,E,175444.000,A,A*4F\r\n$GPGSA,A,3,26,03,25,31,32,01,23,,,,,,1.29,1.03,0.79*07\r\n$GLGSA,A,3,77,68,67,,,,,,,,,,1.29,1.03,0.79*17\r\n$GNRMC,175444.000,A,5543.1547,N,03727.3508,E,0.04,67.61,260915,,,A*43\r\n$GNVTG,67.61,T,,M,0.04,N,0.07,K,A*16\r\n\0";    
unsigned char temp_buf[] = "$GNGGA,192709.016,,,,,0,0,,,M,,M,,*55\r\n$GNGLL,,,,,192709.016,V,N*67\r\n$GPGSA,A,1,,,,,,,,,,,,,,,*1E\r\n$GLGSA,A,1,,,,,,,,,,,,,,,*02\r\n$GNRMC,192709.016,V,,,,,0.00,0.00,260915,,,N*59\r\n$GNVTG,0.00,T,,M,0.00,N,0.00,K,N*2C\r\n";
while (1) {
    for (x = 0; x < 1024; x++) {
        UART2_buf[x] = temp_buf[x];
        if (temp_buf[x] == 0) break;
    }
    num_of_bytes_tmp = x;
    get_navigation_data ();
    Nop();Nop();Nop();
}
*/
////////////////////////////////////////////////////////////////////////////////
void initTruckVariables(void)
{ 
    vin.can_number                              = 0x2;
    vin.id                                      = 0x00EBFF00;
    memset(vin.Value, 0, sizeof(vin.Value)); 
    
    VEHICLEWEIGHTbits.can_number                = 0x2;
    VEHICLEWEIGHTbits.id                        = 0x00FE7000;
    VEHICLEWEIGHTbits.value1                    = 0x0;
    VEHICLEWEIGHTbits.value2                    = 0x0;
    
    VEHICLESPEEDbits.can_number                 = 0x2;
    VEHICLESPEEDbits.id                         = 0x00FEF100;
    VEHICLESPEEDbits.value1                     = 0x0;
    VEHICLESPEEDbits.value2                     = 0x0;
    
    FUELLEVELbits.can_number                    = 0x2;    
    FUELLEVELbits.id                            = 0x00FEFC00;   //0x18FEFC21;
    FUELLEVELbits.value1                        = 0x0;   
    FUELLEVELbits.value2                        = 0x0;
    
    TOTALFUELUSEDCONFbits.can_number            = 0x2;    
    TOTALFUELUSEDCONFbits.id                    = 0x00FEE900;   //0x18FEE927;
    TOTALFUELUSEDbits.value1                    = 0x0;
    TOTALFUELUSEDbits.value2                    = 0x0;
    TOTALFUELUSEDbits.value3                    = 0x0;
    TOTALFUELUSEDbits.value4                    = 0x0; 
    
    TOTALVEHICLEDISTANCECONFbits.can_number     = 0x2;    
    TOTALVEHICLEDISTANCECONFbits.id             = 0x00FEC100;   //0x18FEC1EE;
    TOTALVEHICLEDISTANCEbits.value1             = 0x0;
    TOTALVEHICLEDISTANCEbits.value2             = 0x0;
    TOTALVEHICLEDISTANCEbits.value3             = 0x0;
    TOTALVEHICLEDISTANCEbits.value4             = 0x0;
 
    ENGINETOTALHOURSCONFbits.can_number         = 0x2;    
    ENGINETOTALHOURSCONFbits.id                 = 0x00FEE500;   //0x18FEE527;
    ENGINETOTALHOURSbits.value1                 = 0x0;
    ENGINETOTALHOURSbits.value2                 = 0x0;
    ENGINETOTALHOURSbits.value3                 = 0x0;
    ENGINETOTALHOURSbits.value4                 = 0x0;

    EGINECOOLANTTEMPERATUREbits.can_number      = 0x2;    
    EGINECOOLANTTEMPERATUREbits.id              = 0x00FEEE00;   //0x18FEEE00;
    EGINECOOLANTTEMPERATUREbits.value           = 0x0;
    
    SERVICEDISTANCEbits.can_number              = 0x2;    
    SERVICEDISTANCEbits.id                      = 0x00FEC000;   //0x18FEC027;
    SERVICEDISTANCEbits.value1                  = 0x0;
    SERVICEDISTANCEbits.value2                  = 0x0;
    
    ENGINESPEEDbits.can_number                  = 0x2;    
    ENGINESPEEDbits.id                          = 0x00F00400;
    ENGINESPEEDbits.value1                      = 0x0;
    ENGINESPEEDbits.value2                      = 0x0;
    
    AXLEWEIGHTbits.can_number                   = 0x2;    
    AXLEWEIGHTbits.id                           = 0x00FEEA00;
    AXLEWEIGHTbits.value1                       = 0x0;
    AXLEWEIGHTbits.value2                       = 0x0;
    
    fmsData.vehicleWeightValue1                 = 0x0;
    fmsData.vehicleWeightValue2                 = 0x0;        
    
    fmsData.vehicleSpeedValue1                  = 0x0;
    fmsData.vehicleSpeedValue2                  = 0x0;
    
    fmsData.axleWeightValue1                    = 0x0;
    fmsData.axleWeightValue2                    = 0x0;
    
    fmsData.engineSpeedValue1                   = 0x0;
    fmsData.engineSpeedValue2                   = 0x0;
    
    fmsData.serviceDistanceValue1               = 0x0;
    fmsData.serviceDistanceValue2               = 0x0;
    
    fmsData.engineTotalHoursValue1              = 0x0;
    fmsData.engineTotalHoursValue2              = 0x0;
    fmsData.engineTotalHoursValue3              = 0x0;
    fmsData.engineTotalHoursValue4              = 0x0;
    
    fmsData.totalVehicleDistanceValue1          = 0x0;
    fmsData.totalVehicleDistanceValue2          = 0x0;
    fmsData.totalVehicleDistanceValue3          = 0x0;
    fmsData.totalVehicleDistanceValue4          = 0x0;
    
    fmsData.totalFuelUsedValue1                 = 0x0;
    fmsData.totalFuelUsedValue2                 = 0x0;
    fmsData.totalFuelUsedValue3                 = 0x0;
    fmsData.totalFuelUsedValue4                 = 0x0;
    
    fmsData.engineCoolantTemperatureValue       = 0x0;
    
    fmsData.fuelLevelValue1                     = 0x0;
    fmsData.fuelLevelValue2                     = 0x0;
}






